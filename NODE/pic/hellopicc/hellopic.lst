CCS PCM C Compiler, Version 5.015, 5967               14-Oct-21 18:09

               Filename:   E:\DATN\NODE\pic\hellopicc\hellopic.lst

               ROM used:   5318 words (65%)
                           Largest free fragment is 2048
               RAM used:   192 (52%) at main() level
                           287 (78%) worst case
               Stack used: 8 locations (4 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   284
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   44F
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   063
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  BCF    0A.0
005E:  BCF    0A.1
005F:  BCF    0A.2
0060:  ADDWF  02,F
0061:  RETLW  2A
0062:  RETLW  00
*
008B:  DATA 43,24
008C:  DATA 4F,27
008D:  DATA A0,24
008E:  DATA 44,1D
008F:  DATA 20,10
0090:  DATA 00,00
0091:  DATA 43,24
0092:  DATA 4F,27
0093:  DATA 20,22
0094:  DATA 45,2B
0095:  DATA C9,21
0096:  DATA 45,1D
0097:  DATA 20,10
0098:  DATA 00,01
0099:  DATA 20,2A
009A:  DATA 54,10
009B:  DATA 80,03
009C:  DATA C3,20
009D:  DATA D3,22
009E:  DATA 31,00
009F:  DATA C3,20
00A0:  DATA D3,22
00A1:  DATA 3A,10
00A2:  DATA 00,00
00A3:  DATA C3,27
00A4:  DATA 4E,23
00A5:  DATA C9,23
00A6:  DATA 20,22
00A7:  DATA 4F,27
00A8:  DATA 45,00
00A9:  DATA AD,16
00AA:  DATA 20,1F
00AB:  DATA A0,21
00AC:  DATA 4F,27
00AD:  DATA C6,24
00AE:  DATA 47,00
*
0218:  BSF    03.6
0219:  MOVF   61,W
021A:  ANDLW  07
021B:  MOVWF  77
021C:  RRF    61,W
021D:  MOVWF  78
021E:  RRF    78,F
021F:  RRF    78,F
0220:  MOVLW  1F
0221:  ANDWF  78,F
0222:  MOVF   78,W
0223:  ADDWF  62,W
0224:  MOVWF  04
0225:  BCF    03.7
0226:  BTFSC  63.0
0227:  BSF    03.7
0228:  MOVF   00,W
0229:  MOVWF  78
022A:  INCF   77,F
022B:  GOTO   22D
022C:  RRF    78,F
022D:  DECFSZ 77,F
022E:  GOTO   22C
022F:  BCF    03.6
0230:  RETURN
0231:  BTFSC  03.1
0232:  GOTO   236
0233:  MOVLW  A9
0234:  MOVWF  04
0235:  BSF    03.7
0236:  BSF    03.5
0237:  BSF    03.6
0238:  MOVF   24,W
0239:  XORWF  28,W
023A:  ANDLW  80
023B:  MOVWF  2E
023C:  BTFSS  24.7
023D:  GOTO   249
023E:  COMF   21,F
023F:  COMF   22,F
0240:  COMF   23,F
0241:  COMF   24,F
0242:  INCF   21,F
0243:  BTFSC  03.2
0244:  INCF   22,F
0245:  BTFSC  03.2
0246:  INCF   23,F
0247:  BTFSC  03.2
0248:  INCF   24,F
0249:  BTFSS  28.7
024A:  GOTO   256
024B:  COMF   25,F
024C:  COMF   26,F
024D:  COMF   27,F
024E:  COMF   28,F
024F:  INCF   25,F
0250:  BTFSC  03.2
0251:  INCF   26,F
0252:  BTFSC  03.2
0253:  INCF   27,F
0254:  BTFSC  03.2
0255:  INCF   28,F
0256:  CLRF   77
0257:  CLRF   78
0258:  CLRF   79
0259:  CLRF   7A
025A:  CLRF   29
025B:  CLRF   2A
025C:  CLRF   2B
025D:  CLRF   2C
025E:  MOVF   28,W
025F:  IORWF  27,W
0260:  IORWF  26,W
0261:  IORWF  25,W
0262:  BTFSC  03.2
0263:  GOTO   294
0264:  MOVLW  20
0265:  MOVWF  2D
0266:  BCF    03.0
0267:  RLF    21,F
0268:  RLF    22,F
0269:  RLF    23,F
026A:  RLF    24,F
026B:  RLF    29,F
026C:  RLF    2A,F
026D:  RLF    2B,F
026E:  RLF    2C,F
026F:  MOVF   28,W
0270:  SUBWF  2C,W
0271:  BTFSS  03.2
0272:  GOTO   27D
0273:  MOVF   27,W
0274:  SUBWF  2B,W
0275:  BTFSS  03.2
0276:  GOTO   27D
0277:  MOVF   26,W
0278:  SUBWF  2A,W
0279:  BTFSS  03.2
027A:  GOTO   27D
027B:  MOVF   25,W
027C:  SUBWF  29,W
027D:  BTFSS  03.0
027E:  GOTO   28E
027F:  MOVF   25,W
0280:  SUBWF  29,F
0281:  MOVF   26,W
0282:  BTFSS  03.0
0283:  INCFSZ 26,W
0284:  SUBWF  2A,F
0285:  MOVF   27,W
0286:  BTFSS  03.0
0287:  INCFSZ 27,W
0288:  SUBWF  2B,F
0289:  MOVF   28,W
028A:  BTFSS  03.0
028B:  INCFSZ 28,W
028C:  SUBWF  2C,F
028D:  BSF    03.0
028E:  RLF    77,F
028F:  RLF    78,F
0290:  RLF    79,F
0291:  RLF    7A,F
0292:  DECFSZ 2D,F
0293:  GOTO   266
0294:  BTFSS  2E.7
0295:  GOTO   2A1
0296:  COMF   77,F
0297:  COMF   78,F
0298:  COMF   79,F
0299:  COMF   7A,F
029A:  INCF   77,F
029B:  BTFSC  03.2
029C:  INCF   78,F
029D:  BTFSC  03.2
029E:  INCF   79,F
029F:  BTFSC  03.2
02A0:  INCF   7A,F
02A1:  MOVF   29,W
02A2:  MOVWF  00
02A3:  INCF   04,F
02A4:  MOVF   2A,W
02A5:  MOVWF  00
02A6:  INCF   04,F
02A7:  MOVF   2B,W
02A8:  MOVWF  00
02A9:  INCF   04,F
02AA:  MOVF   2C,W
02AB:  MOVWF  00
02AC:  BCF    03.5
02AD:  BCF    03.6
02AE:  RETURN
*
02CF:  MOVLW  20
02D0:  MOVWF  25
02D1:  CLRF   21
02D2:  CLRF   22
02D3:  CLRF   23
02D4:  CLRF   24
02D5:  MOVF   1C,W
02D6:  MOVWF  7A
02D7:  MOVF   1B,W
02D8:  MOVWF  79
02D9:  MOVF   1A,W
02DA:  MOVWF  78
02DB:  MOVF   19,W
02DC:  MOVWF  77
02DD:  BCF    03.0
02DE:  BTFSS  77.0
02DF:  GOTO   2EE
02E0:  MOVF   1D,W
02E1:  ADDWF  21,F
02E2:  MOVF   1E,W
02E3:  BTFSC  03.0
02E4:  INCFSZ 1E,W
02E5:  ADDWF  22,F
02E6:  MOVF   1F,W
02E7:  BTFSC  03.0
02E8:  INCFSZ 1F,W
02E9:  ADDWF  23,F
02EA:  MOVF   20,W
02EB:  BTFSC  03.0
02EC:  INCFSZ 20,W
02ED:  ADDWF  24,F
02EE:  RRF    24,F
02EF:  RRF    23,F
02F0:  RRF    22,F
02F1:  RRF    21,F
02F2:  RRF    7A,F
02F3:  RRF    79,F
02F4:  RRF    78,F
02F5:  RRF    77,F
02F6:  DECFSZ 25,F
02F7:  GOTO   2DD
*
0431:  MOVF   00,F
0432:  BTFSC  03.2
0433:  GOTO   44E
0434:  BSF    03.6
0435:  CLRF   64
0436:  MOVF   04,W
0437:  MOVWF  63
0438:  BCF    64.0
0439:  BTFSC  03.7
043A:  BSF    64.0
043B:  MOVF   00,W
043C:  BCF    03.6
043D:  BTFSS  0C.4
043E:  GOTO   43D
043F:  MOVWF  19
0440:  BSF    03.6
0441:  MOVF   63,W
0442:  MOVWF  04
0443:  BCF    03.7
0444:  BTFSC  64.0
0445:  BSF    03.7
0446:  INCF   04,F
0447:  BTFSS  03.2
0448:  GOTO   44C
0449:  BCF    03.6
044A:  INCF   05,F
044B:  BSF    03.6
044C:  BCF    03.6
044D:  GOTO   431
044E:  RETURN
*
0532:  BCF    03.6
0533:  MOVF   0B,W
0534:  BSF    03.6
0535:  MOVWF  58
0536:  BCF    03.6
0537:  BCF    0B.7
0538:  BSF    03.5
0539:  BSF    03.6
053A:  BSF    0C.7
053B:  BSF    0C.0
053C:  NOP
053D:  NOP
053E:  BCF    03.5
053F:  BTFSS  58.7
0540:  GOTO   544
0541:  BCF    03.6
0542:  BSF    0B.7
0543:  BSF    03.6
0544:  MOVF   0C,W
0545:  ANDLW  7F
0546:  BTFSC  03.2
0547:  GOTO   5EB
0548:  MOVWF  58
0549:  MOVF   0D,W
054A:  MOVWF  59
054B:  MOVF   0F,W
054C:  MOVWF  5A
054D:  MOVF   58,W
054E:  MOVWF  64
*
0587:  BSF    03.6
0588:  MOVF   59,W
0589:  MOVWF  0D
058A:  MOVF   5A,W
058B:  MOVWF  0F
058C:  BCF    03.6
058D:  MOVF   0B,W
058E:  BSF    03.6
058F:  MOVWF  5B
0590:  BCF    03.6
0591:  BCF    0B.7
0592:  BSF    03.5
0593:  BSF    03.6
0594:  BSF    0C.7
0595:  BSF    0C.0
0596:  NOP
0597:  NOP
0598:  BCF    03.5
0599:  BTFSS  5B.7
059A:  GOTO   59E
059B:  BCF    03.6
059C:  BSF    0B.7
059D:  BSF    03.6
059E:  RLF    0C,W
059F:  RLF    0E,W
05A0:  ANDLW  7F
05A1:  BTFSC  03.2
05A2:  GOTO   5EB
05A3:  MOVWF  58
05A4:  MOVF   0D,W
05A5:  MOVWF  59
05A6:  MOVF   0F,W
05A7:  MOVWF  5A
05A8:  MOVF   58,W
05A9:  MOVWF  64
*
05E2:  BSF    03.6
05E3:  MOVF   59,W
05E4:  MOVWF  0D
05E5:  MOVF   5A,W
05E6:  MOVWF  0F
05E7:  INCF   0D,F
05E8:  BTFSC  03.2
05E9:  INCF   0F,F
05EA:  GOTO   532
*
067A:  BCF    03.6
067B:  MOVF   0B,W
067C:  BSF    03.6
067D:  MOVWF  58
067E:  BCF    03.6
067F:  BCF    0B.7
0680:  BSF    03.5
0681:  BSF    03.6
0682:  BSF    0C.7
0683:  BSF    0C.0
0684:  NOP
0685:  NOP
0686:  BCF    03.5
0687:  BTFSS  58.7
0688:  GOTO   68C
0689:  BCF    03.6
068A:  BSF    0B.7
068B:  BSF    03.6
068C:  MOVF   0C,W
068D:  ANDLW  7F
068E:  BTFSC  03.2
068F:  GOTO   733
0690:  MOVWF  58
0691:  MOVF   0D,W
0692:  MOVWF  59
0693:  MOVF   0F,W
0694:  MOVWF  5A
0695:  MOVF   58,W
0696:  MOVWF  64
*
06CF:  BSF    03.6
06D0:  MOVF   59,W
06D1:  MOVWF  0D
06D2:  MOVF   5A,W
06D3:  MOVWF  0F
06D4:  BCF    03.6
06D5:  MOVF   0B,W
06D6:  BSF    03.6
06D7:  MOVWF  5B
06D8:  BCF    03.6
06D9:  BCF    0B.7
06DA:  BSF    03.5
06DB:  BSF    03.6
06DC:  BSF    0C.7
06DD:  BSF    0C.0
06DE:  NOP
06DF:  NOP
06E0:  BCF    03.5
06E1:  BTFSS  5B.7
06E2:  GOTO   6E6
06E3:  BCF    03.6
06E4:  BSF    0B.7
06E5:  BSF    03.6
06E6:  RLF    0C,W
06E7:  RLF    0E,W
06E8:  ANDLW  7F
06E9:  BTFSC  03.2
06EA:  GOTO   733
06EB:  MOVWF  58
06EC:  MOVF   0D,W
06ED:  MOVWF  59
06EE:  MOVF   0F,W
06EF:  MOVWF  5A
06F0:  MOVF   58,W
06F1:  MOVWF  64
*
072A:  BSF    03.6
072B:  MOVF   59,W
072C:  MOVWF  0D
072D:  MOVF   5A,W
072E:  MOVWF  0F
072F:  INCF   0D,F
0730:  BTFSC  03.2
0731:  INCF   0F,F
0732:  GOTO   67A
*
0741:  MOVF   00,F
0742:  BTFSC  03.2
0743:  GOTO   793
0744:  BSF    03.6
0745:  CLRF   59
0746:  MOVF   04,W
0747:  MOVWF  58
0748:  BCF    59.0
0749:  BTFSC  03.7
074A:  BSF    59.0
074B:  MOVF   00,W
074C:  MOVWF  64
*
0785:  BSF    03.6
0786:  MOVF   58,W
0787:  MOVWF  04
0788:  BCF    03.7
0789:  BTFSC  59.0
078A:  BSF    03.7
078B:  INCF   04,F
078C:  BTFSS  03.2
078D:  GOTO   791
078E:  BCF    03.6
078F:  INCF   05,F
0790:  BSF    03.6
0791:  BCF    03.6
0792:  GOTO   741
*
07A5:  BSF    03.6
07A6:  MOVF   30,W
07A7:  ANDLW  07
07A8:  MOVWF  77
07A9:  RRF    30,W
07AA:  MOVWF  78
07AB:  RRF    78,F
07AC:  RRF    78,F
07AD:  MOVLW  1F
07AE:  ANDWF  78,F
07AF:  MOVF   78,W
07B0:  ADDWF  32,W
07B1:  MOVWF  04
07B2:  BCF    03.7
07B3:  BTFSC  33.0
07B4:  BSF    03.7
07B5:  CLRF   78
07B6:  INCF   78,F
07B7:  INCF   77,F
07B8:  GOTO   7BA
07B9:  RLF    78,F
07BA:  DECFSZ 77,F
07BB:  GOTO   7B9
07BC:  MOVF   31,F
07BD:  BTFSC  03.2
07BE:  GOTO   7C2
07BF:  MOVF   78,W
07C0:  IORWF  00,F
07C1:  GOTO   7C5
07C2:  COMF   78,F
07C3:  MOVF   78,W
07C4:  ANDWF  00,F
07C5:  BCF    03.6
07C6:  BCF    0A.3
07C7:  BSF    0A.4
07C8:  GOTO   520 (RETURN)
*
08D3:  MOVLW  8E
08D4:  MOVWF  77
08D5:  MOVF   32,W
08D6:  MOVWF  78
08D7:  MOVF   31,W
08D8:  MOVWF  79
08D9:  CLRF   7A
08DA:  MOVF   78,F
08DB:  BTFSS  03.2
08DC:  GOTO   0E7
08DD:  MOVF   79,W
08DE:  MOVWF  78
08DF:  CLRF   79
08E0:  MOVLW  08
08E1:  SUBWF  77,F
08E2:  MOVF   78,F
08E3:  BTFSS  03.2
08E4:  GOTO   0E7
08E5:  CLRF   77
08E6:  GOTO   0EF
08E7:  BCF    03.0
08E8:  BTFSC  78.7
08E9:  GOTO   0EE
08EA:  RLF    79,F
08EB:  RLF    78,F
08EC:  DECF   77,F
08ED:  GOTO   0E7
08EE:  BCF    78.7
*
08FF:  MOVF   31,W
0900:  BTFSC  03.2
0901:  GOTO   1C4
0902:  MOVWF  3D
0903:  MOVF   35,W
0904:  BTFSC  03.2
0905:  GOTO   1C4
0906:  SUBWF  3D,F
0907:  BTFSS  03.0
0908:  GOTO   10E
0909:  MOVLW  7F
090A:  ADDWF  3D,F
090B:  BTFSC  03.0
090C:  GOTO   1C4
090D:  GOTO   114
090E:  MOVLW  81
090F:  SUBWF  3D,F
0910:  BTFSS  03.0
0911:  GOTO   1C4
0912:  BTFSC  03.2
0913:  GOTO   1C4
0914:  MOVF   3D,W
0915:  MOVWF  77
0916:  CLRF   78
0917:  CLRF   79
0918:  CLRF   7A
0919:  CLRF   3C
091A:  MOVF   32,W
091B:  MOVWF  3B
091C:  BSF    3B.7
091D:  MOVF   33,W
091E:  MOVWF  3A
091F:  MOVF   34,W
0920:  MOVWF  39
0921:  MOVLW  19
0922:  MOVWF  3D
0923:  MOVF   38,W
0924:  SUBWF  39,F
0925:  BTFSC  03.0
0926:  GOTO   137
0927:  MOVLW  01
0928:  SUBWF  3A,F
0929:  BTFSC  03.0
092A:  GOTO   137
092B:  SUBWF  3B,F
092C:  BTFSC  03.0
092D:  GOTO   137
092E:  SUBWF  3C,F
092F:  BTFSC  03.0
0930:  GOTO   137
0931:  INCF   3C,F
0932:  INCF   3B,F
0933:  INCF   3A,F
0934:  MOVF   38,W
0935:  ADDWF  39,F
0936:  GOTO   169
0937:  MOVF   37,W
0938:  SUBWF  3A,F
0939:  BTFSC  03.0
093A:  GOTO   152
093B:  MOVLW  01
093C:  SUBWF  3B,F
093D:  BTFSC  03.0
093E:  GOTO   152
093F:  SUBWF  3C,F
0940:  BTFSC  03.0
0941:  GOTO   152
0942:  INCF   3C,F
0943:  INCF   3B,F
0944:  MOVF   37,W
0945:  ADDWF  3A,F
0946:  MOVF   38,W
0947:  ADDWF  39,F
0948:  BTFSS  03.0
0949:  GOTO   169
094A:  INCF   3A,F
094B:  BTFSS  03.2
094C:  GOTO   169
094D:  INCF   3B,F
094E:  BTFSS  03.2
094F:  GOTO   169
0950:  INCF   3C,F
0951:  GOTO   169
0952:  MOVF   36,W
0953:  IORLW  80
0954:  SUBWF  3B,F
0955:  BTFSC  03.0
0956:  GOTO   168
0957:  MOVLW  01
0958:  SUBWF  3C,F
0959:  BTFSC  03.0
095A:  GOTO   168
095B:  INCF   3C,F
095C:  MOVF   36,W
095D:  IORLW  80
095E:  ADDWF  3B,F
095F:  MOVF   37,W
0960:  ADDWF  3A,F
0961:  BTFSS  03.0
0962:  GOTO   146
0963:  INCF   3B,F
0964:  BTFSS  03.2
0965:  GOTO   146
0966:  INCF   3C,F
0967:  GOTO   146
0968:  BSF    7A.0
0969:  DECFSZ 3D,F
096A:  GOTO   16C
096B:  GOTO   177
096C:  BCF    03.0
096D:  RLF    39,F
096E:  RLF    3A,F
096F:  RLF    3B,F
0970:  RLF    3C,F
0971:  BCF    03.0
0972:  RLF    7A,F
0973:  RLF    79,F
0974:  RLF    78,F
0975:  RLF    3E,F
0976:  GOTO   123
0977:  BTFSS  3E.0
0978:  GOTO   17F
0979:  BCF    03.0
097A:  RRF    78,F
097B:  RRF    79,F
097C:  RRF    7A,F
097D:  RRF    3E,F
097E:  GOTO   182
097F:  DECF   77,F
0980:  BTFSC  03.2
0981:  GOTO   1C4
0982:  BTFSC  3E.7
0983:  GOTO   1AB
0984:  BCF    03.0
0985:  RLF    39,F
0986:  RLF    3A,F
0987:  RLF    3B,F
0988:  RLF    3C,F
0989:  MOVF   38,W
098A:  SUBWF  39,F
098B:  BTFSC  03.0
098C:  GOTO   197
098D:  MOVLW  01
098E:  SUBWF  3A,F
098F:  BTFSC  03.0
0990:  GOTO   197
0991:  SUBWF  3B,F
0992:  BTFSC  03.0
0993:  GOTO   197
0994:  SUBWF  3C,F
0995:  BTFSS  03.0
0996:  GOTO   1BA
0997:  MOVF   37,W
0998:  SUBWF  3A,F
0999:  BTFSC  03.0
099A:  GOTO   1A2
099B:  MOVLW  01
099C:  SUBWF  3B,F
099D:  BTFSC  03.0
099E:  GOTO   1A2
099F:  SUBWF  3C,F
09A0:  BTFSS  03.0
09A1:  GOTO   1BA
09A2:  MOVF   36,W
09A3:  IORLW  80
09A4:  SUBWF  3B,F
09A5:  BTFSC  03.0
09A6:  GOTO   1AB
09A7:  MOVLW  01
09A8:  SUBWF  3C,F
09A9:  BTFSS  03.0
09AA:  GOTO   1BA
09AB:  INCF   7A,F
09AC:  BTFSS  03.2
09AD:  GOTO   1BA
09AE:  INCF   79,F
09AF:  BTFSS  03.2
09B0:  GOTO   1BA
09B1:  INCF   78,F
09B2:  BTFSS  03.2
09B3:  GOTO   1BA
09B4:  INCF   77,F
09B5:  BTFSC  03.2
09B6:  GOTO   1C4
09B7:  RRF    78,F
09B8:  RRF    79,F
09B9:  RRF    7A,F
09BA:  MOVF   32,W
09BB:  MOVWF  3D
09BC:  MOVF   36,W
09BD:  XORWF  3D,F
09BE:  BTFSS  3D.7
09BF:  GOTO   1C2
09C0:  BSF    78.7
09C1:  GOTO   1C8
09C2:  BCF    78.7
09C3:  GOTO   1C8
09C4:  CLRF   77
09C5:  CLRF   78
09C6:  CLRF   79
09C7:  CLRF   7A
*
09D0:  MOVLW  8E
09D1:  MOVWF  77
09D2:  MOVF   31,W
09D3:  SUBWF  77,F
09D4:  MOVF   32,W
09D5:  MOVWF  79
09D6:  MOVF   33,W
09D7:  MOVWF  78
09D8:  BSF    79.7
09D9:  MOVF   77,F
09DA:  BTFSC  03.2
09DB:  GOTO   1E7
09DC:  BCF    03.0
09DD:  MOVF   79,F
09DE:  BTFSS  03.2
09DF:  GOTO   1E3
09E0:  MOVF   78,F
09E1:  BTFSC  03.2
09E2:  GOTO   1E7
09E3:  RRF    79,F
09E4:  RRF    78,F
09E5:  DECFSZ 77,F
09E6:  GOTO   1DC
09E7:  BTFSS  32.7
09E8:  GOTO   1EE
09E9:  COMF   78,F
09EA:  COMF   79,F
09EB:  INCF   78,F
09EC:  BTFSC  03.2
09ED:  INCF   79,F
*
0A16:  MOVF   00,F
0A17:  BTFSC  03.2
0A18:  GOTO   274
0A19:  BSF    03.6
0A1A:  CLRF   59
0A1B:  MOVF   04,W
0A1C:  MOVWF  58
0A1D:  BCF    59.0
0A1E:  BTFSC  03.7
0A1F:  BSF    59.0
0A20:  MOVF   00,W
0A21:  MOVWF  64
*
0A66:  BSF    03.6
0A67:  MOVF   58,W
0A68:  MOVWF  04
0A69:  BCF    03.7
0A6A:  BTFSC  59.0
0A6B:  BSF    03.7
0A6C:  INCF   04,F
0A6D:  BTFSS  03.2
0A6E:  GOTO   272
0A6F:  BCF    03.6
0A70:  INCF   05,F
0A71:  BSF    03.6
0A72:  BCF    03.6
0A73:  GOTO   216
0A74:  CLRF   2B
0A75:  BTFSC  0B.7
0A76:  BSF    2B.7
0A77:  BCF    0B.7
*
0BDE:  BCF    03.6
0BDF:  MOVF   0B,W
0BE0:  BSF    03.6
0BE1:  MOVWF  58
0BE2:  BCF    03.6
0BE3:  BCF    0B.7
0BE4:  BSF    03.5
0BE5:  BSF    03.6
0BE6:  BSF    0C.7
0BE7:  BSF    0C.0
0BE8:  NOP
0BE9:  NOP
0BEA:  BCF    03.5
0BEB:  BTFSS  58.7
0BEC:  GOTO   3F0
0BED:  BCF    03.6
0BEE:  BSF    0B.7
0BEF:  BSF    03.6
0BF0:  MOVF   0C,W
0BF1:  ANDLW  7F
0BF2:  BTFSC  03.2
0BF3:  GOTO   4AF
0BF4:  MOVWF  58
0BF5:  MOVF   0D,W
0BF6:  MOVWF  59
0BF7:  MOVF   0F,W
0BF8:  MOVWF  5A
0BF9:  MOVF   58,W
0BFA:  MOVWF  64
*
0C3F:  BSF    03.6
0C40:  MOVF   59,W
0C41:  MOVWF  0D
0C42:  MOVF   5A,W
0C43:  MOVWF  0F
0C44:  BCF    03.6
0C45:  MOVF   0B,W
0C46:  BSF    03.6
0C47:  MOVWF  5B
0C48:  BCF    03.6
0C49:  BCF    0B.7
0C4A:  BSF    03.5
0C4B:  BSF    03.6
0C4C:  BSF    0C.7
0C4D:  BSF    0C.0
0C4E:  NOP
0C4F:  NOP
0C50:  BCF    03.5
0C51:  BTFSS  5B.7
0C52:  GOTO   456
0C53:  BCF    03.6
0C54:  BSF    0B.7
0C55:  BSF    03.6
0C56:  RLF    0C,W
0C57:  RLF    0E,W
0C58:  ANDLW  7F
0C59:  BTFSC  03.2
0C5A:  GOTO   4AF
0C5B:  MOVWF  58
0C5C:  MOVF   0D,W
0C5D:  MOVWF  59
0C5E:  MOVF   0F,W
0C5F:  MOVWF  5A
0C60:  MOVF   58,W
0C61:  MOVWF  64
*
0CA6:  BSF    03.6
0CA7:  MOVF   59,W
0CA8:  MOVWF  0D
0CA9:  MOVF   5A,W
0CAA:  MOVWF  0F
0CAB:  INCF   0D,F
0CAC:  BTFSC  03.2
0CAD:  INCF   0F,F
0CAE:  GOTO   3DE
*
0D07:  MOVF   00,F
0D08:  BTFSC  03.2
0D09:  GOTO   565
0D0A:  BSF    03.6
0D0B:  CLRF   59
0D0C:  MOVF   04,W
0D0D:  MOVWF  58
0D0E:  BCF    59.0
0D0F:  BTFSC  03.7
0D10:  BSF    59.0
0D11:  MOVF   00,W
0D12:  MOVWF  64
*
0D57:  BSF    03.6
0D58:  MOVF   58,W
0D59:  MOVWF  04
0D5A:  BCF    03.7
0D5B:  BTFSC  59.0
0D5C:  BSF    03.7
0D5D:  INCF   04,F
0D5E:  BTFSS  03.2
0D5F:  GOTO   563
0D60:  BCF    03.6
0D61:  INCF   05,F
0D62:  BSF    03.6
0D63:  BCF    03.6
0D64:  GOTO   507
*
1027:  BCF    03.6
1028:  MOVF   0B,W
1029:  BSF    03.6
102A:  MOVWF  58
102B:  BCF    03.6
102C:  BCF    0B.7
102D:  BSF    03.5
102E:  BSF    03.6
102F:  BSF    0C.7
1030:  BSF    0C.0
1031:  NOP
1032:  NOP
1033:  BCF    03.5
1034:  BTFSS  58.7
1035:  GOTO   039
1036:  BCF    03.6
1037:  BSF    0B.7
1038:  BSF    03.6
1039:  MOVF   0C,W
103A:  ANDLW  7F
103B:  BTFSC  03.2
103C:  GOTO   0F8
103D:  MOVWF  58
103E:  MOVF   0D,W
103F:  MOVWF  59
1040:  MOVF   0F,W
1041:  MOVWF  5A
1042:  MOVF   58,W
1043:  MOVWF  64
*
1088:  BSF    03.6
1089:  MOVF   59,W
108A:  MOVWF  0D
108B:  MOVF   5A,W
108C:  MOVWF  0F
108D:  BCF    03.6
108E:  MOVF   0B,W
108F:  BSF    03.6
1090:  MOVWF  5B
1091:  BCF    03.6
1092:  BCF    0B.7
1093:  BSF    03.5
1094:  BSF    03.6
1095:  BSF    0C.7
1096:  BSF    0C.0
1097:  NOP
1098:  NOP
1099:  BCF    03.5
109A:  BTFSS  5B.7
109B:  GOTO   09F
109C:  BCF    03.6
109D:  BSF    0B.7
109E:  BSF    03.6
109F:  RLF    0C,W
10A0:  RLF    0E,W
10A1:  ANDLW  7F
10A2:  BTFSC  03.2
10A3:  GOTO   0F8
10A4:  MOVWF  58
10A5:  MOVF   0D,W
10A6:  MOVWF  59
10A7:  MOVF   0F,W
10A8:  MOVWF  5A
10A9:  MOVF   58,W
10AA:  MOVWF  64
*
10EF:  BSF    03.6
10F0:  MOVF   59,W
10F1:  MOVWF  0D
10F2:  MOVF   5A,W
10F3:  MOVWF  0F
10F4:  INCF   0D,F
10F5:  BTFSC  03.2
10F6:  INCF   0F,F
10F7:  GOTO   027
*
1150:  MOVF   00,F
1151:  BTFSC  03.2
1152:  GOTO   1AE
1153:  BSF    03.6
1154:  CLRF   59
1155:  MOVF   04,W
1156:  MOVWF  58
1157:  BCF    59.0
1158:  BTFSC  03.7
1159:  BSF    59.0
115A:  MOVF   00,W
115B:  MOVWF  64
*
11A0:  BSF    03.6
11A1:  MOVF   58,W
11A2:  MOVWF  04
11A3:  BCF    03.7
11A4:  BTFSC  59.0
11A5:  BSF    03.7
11A6:  INCF   04,F
11A7:  BTFSS  03.2
11A8:  GOTO   1AC
11A9:  BCF    03.6
11AA:  INCF   05,F
11AB:  BSF    03.6
11AC:  BCF    03.6
11AD:  GOTO   150
11AE:  CLRF   2B
11AF:  BTFSC  0B.7
11B0:  BSF    2B.7
11B1:  BCF    0B.7
*
11E3:  BCF    03.6
11E4:  MOVF   0B,W
11E5:  BSF    03.6
11E6:  MOVWF  58
11E7:  BCF    03.6
11E8:  BCF    0B.7
11E9:  BSF    03.5
11EA:  BSF    03.6
11EB:  BSF    0C.7
11EC:  BSF    0C.0
11ED:  NOP
11EE:  NOP
11EF:  BCF    03.5
11F0:  BTFSS  58.7
11F1:  GOTO   1F5
11F2:  BCF    03.6
11F3:  BSF    0B.7
11F4:  BSF    03.6
11F5:  MOVF   0C,W
11F6:  ANDLW  7F
11F7:  BTFSC  03.2
11F8:  GOTO   2B4
11F9:  MOVWF  58
11FA:  MOVF   0D,W
11FB:  MOVWF  59
11FC:  MOVF   0F,W
11FD:  MOVWF  5A
11FE:  MOVF   58,W
11FF:  MOVWF  64
*
1244:  BSF    03.6
1245:  MOVF   59,W
1246:  MOVWF  0D
1247:  MOVF   5A,W
1248:  MOVWF  0F
1249:  BCF    03.6
124A:  MOVF   0B,W
124B:  BSF    03.6
124C:  MOVWF  5B
124D:  BCF    03.6
124E:  BCF    0B.7
124F:  BSF    03.5
1250:  BSF    03.6
1251:  BSF    0C.7
1252:  BSF    0C.0
1253:  NOP
1254:  NOP
1255:  BCF    03.5
1256:  BTFSS  5B.7
1257:  GOTO   25B
1258:  BCF    03.6
1259:  BSF    0B.7
125A:  BSF    03.6
125B:  RLF    0C,W
125C:  RLF    0E,W
125D:  ANDLW  7F
125E:  BTFSC  03.2
125F:  GOTO   2B4
1260:  MOVWF  58
1261:  MOVF   0D,W
1262:  MOVWF  59
1263:  MOVF   0F,W
1264:  MOVWF  5A
1265:  MOVF   58,W
1266:  MOVWF  64
*
12AB:  BSF    03.6
12AC:  MOVF   59,W
12AD:  MOVWF  0D
12AE:  MOVF   5A,W
12AF:  MOVWF  0F
12B0:  INCF   0D,F
12B1:  BTFSC  03.2
12B2:  INCF   0F,F
12B3:  GOTO   1E3
*
130C:  MOVF   00,F
130D:  BTFSC  03.2
130E:  GOTO   36A
130F:  BSF    03.6
1310:  CLRF   59
1311:  MOVF   04,W
1312:  MOVWF  58
1313:  BCF    59.0
1314:  BTFSC  03.7
1315:  BSF    59.0
1316:  MOVF   00,W
1317:  MOVWF  64
*
135C:  BSF    03.6
135D:  MOVF   58,W
135E:  MOVWF  04
135F:  BCF    03.7
1360:  BTFSC  59.0
1361:  BSF    03.7
1362:  INCF   04,F
1363:  BTFSS  03.2
1364:  GOTO   368
1365:  BCF    03.6
1366:  INCF   05,F
1367:  BSF    03.6
1368:  BCF    03.6
1369:  GOTO   30C
136A:  CLRF   2B
136B:  BTFSC  0B.7
136C:  BSF    2B.7
136D:  BCF    0B.7
*
137C:  BCF    03.6
137D:  MOVF   0B,W
137E:  BSF    03.6
137F:  MOVWF  58
1380:  BCF    03.6
1381:  BCF    0B.7
1382:  BSF    03.5
1383:  BSF    03.6
1384:  BSF    0C.7
1385:  BSF    0C.0
1386:  NOP
1387:  NOP
1388:  BCF    03.5
1389:  BTFSS  58.7
138A:  GOTO   38E
138B:  BCF    03.6
138C:  BSF    0B.7
138D:  BSF    03.6
138E:  MOVF   0C,W
138F:  ANDLW  7F
1390:  BTFSC  03.2
1391:  GOTO   44D
1392:  MOVWF  58
1393:  MOVF   0D,W
1394:  MOVWF  59
1395:  MOVF   0F,W
1396:  MOVWF  5A
1397:  MOVF   58,W
1398:  MOVWF  64
*
13DD:  BSF    03.6
13DE:  MOVF   59,W
13DF:  MOVWF  0D
13E0:  MOVF   5A,W
13E1:  MOVWF  0F
13E2:  BCF    03.6
13E3:  MOVF   0B,W
13E4:  BSF    03.6
13E5:  MOVWF  5B
13E6:  BCF    03.6
13E7:  BCF    0B.7
13E8:  BSF    03.5
13E9:  BSF    03.6
13EA:  BSF    0C.7
13EB:  BSF    0C.0
13EC:  NOP
13ED:  NOP
13EE:  BCF    03.5
13EF:  BTFSS  5B.7
13F0:  GOTO   3F4
13F1:  BCF    03.6
13F2:  BSF    0B.7
13F3:  BSF    03.6
13F4:  RLF    0C,W
13F5:  RLF    0E,W
13F6:  ANDLW  7F
13F7:  BTFSC  03.2
13F8:  GOTO   44D
13F9:  MOVWF  58
13FA:  MOVF   0D,W
13FB:  MOVWF  59
13FC:  MOVF   0F,W
13FD:  MOVWF  5A
13FE:  MOVF   58,W
13FF:  MOVWF  64
*
1444:  BSF    03.6
1445:  MOVF   59,W
1446:  MOVWF  0D
1447:  MOVF   5A,W
1448:  MOVWF  0F
1449:  INCF   0D,F
144A:  BTFSC  03.2
144B:  INCF   0F,F
144C:  GOTO   37C
144D:  BCF    03.6
144E:  CLRF   2B
144F:  BTFSC  0B.7
1450:  BSF    2B.7
1451:  BCF    0B.7
*
1489:  MOVF   00,F
148A:  BTFSC  03.2
148B:  GOTO   4E7
148C:  BSF    03.6
148D:  CLRF   59
148E:  MOVF   04,W
148F:  MOVWF  58
1490:  BCF    59.0
1491:  BTFSC  03.7
1492:  BSF    59.0
1493:  MOVF   00,W
1494:  MOVWF  64
*
14D9:  BSF    03.6
14DA:  MOVF   58,W
14DB:  MOVWF  04
14DC:  BCF    03.7
14DD:  BTFSC  59.0
14DE:  BSF    03.7
14DF:  INCF   04,F
14E0:  BTFSS  03.2
14E1:  GOTO   4E5
14E2:  BCF    03.6
14E3:  INCF   05,F
14E4:  BSF    03.6
14E5:  BCF    03.6
14E6:  GOTO   489
14E7:  CLRF   2B
14E8:  BTFSC  0B.7
14E9:  BSF    2B.7
14EA:  BCF    0B.7
*
1573:  MOVF   00,F
1574:  BTFSC  03.2
1575:  GOTO   5D1
1576:  BSF    03.6
1577:  CLRF   59
1578:  MOVF   04,W
1579:  MOVWF  58
157A:  BCF    59.0
157B:  BTFSC  03.7
157C:  BSF    59.0
157D:  MOVF   00,W
157E:  MOVWF  64
*
15C3:  BSF    03.6
15C4:  MOVF   58,W
15C5:  MOVWF  04
15C6:  BCF    03.7
15C7:  BTFSC  59.0
15C8:  BSF    03.7
15C9:  INCF   04,F
15CA:  BTFSS  03.2
15CB:  GOTO   5CF
15CC:  BCF    03.6
15CD:  INCF   05,F
15CE:  BSF    03.6
15CF:  BCF    03.6
15D0:  GOTO   573
*
15F4:  BCF    03.6
15F5:  MOVF   0B,W
15F6:  BSF    03.6
15F7:  MOVWF  58
15F8:  BCF    03.6
15F9:  BCF    0B.7
15FA:  BSF    03.5
15FB:  BSF    03.6
15FC:  BSF    0C.7
15FD:  BSF    0C.0
15FE:  NOP
15FF:  NOP
1600:  BCF    03.5
1601:  BTFSS  58.7
1602:  GOTO   606
1603:  BCF    03.6
1604:  BSF    0B.7
1605:  BSF    03.6
1606:  MOVF   0C,W
1607:  ANDLW  7F
1608:  BTFSC  03.2
1609:  GOTO   6C5
160A:  MOVWF  58
160B:  MOVF   0D,W
160C:  MOVWF  59
160D:  MOVF   0F,W
160E:  MOVWF  5A
160F:  MOVF   58,W
1610:  MOVWF  64
*
1655:  BSF    03.6
1656:  MOVF   59,W
1657:  MOVWF  0D
1658:  MOVF   5A,W
1659:  MOVWF  0F
165A:  BCF    03.6
165B:  MOVF   0B,W
165C:  BSF    03.6
165D:  MOVWF  5B
165E:  BCF    03.6
165F:  BCF    0B.7
1660:  BSF    03.5
1661:  BSF    03.6
1662:  BSF    0C.7
1663:  BSF    0C.0
1664:  NOP
1665:  NOP
1666:  BCF    03.5
1667:  BTFSS  5B.7
1668:  GOTO   66C
1669:  BCF    03.6
166A:  BSF    0B.7
166B:  BSF    03.6
166C:  RLF    0C,W
166D:  RLF    0E,W
166E:  ANDLW  7F
166F:  BTFSC  03.2
1670:  GOTO   6C5
1671:  MOVWF  58
1672:  MOVF   0D,W
1673:  MOVWF  59
1674:  MOVF   0F,W
1675:  MOVWF  5A
1676:  MOVF   58,W
1677:  MOVWF  64
*
16BC:  BSF    03.6
16BD:  MOVF   59,W
16BE:  MOVWF  0D
16BF:  MOVF   5A,W
16C0:  MOVWF  0F
16C1:  INCF   0D,F
16C2:  BTFSC  03.2
16C3:  INCF   0F,F
16C4:  GOTO   5F4
*
16CB:  BCF    0A.0
16CC:  BSF    0A.1
16CD:  BSF    0A.2
16CE:  ADDWF  02,F
16CF:  GOTO   006
16D0:  GOTO   1C2
16D1:  GOTO   5D3
16D2:  GOTO   6C7
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
03F3:  BSF    03.6
03F4:  MOVF   59,W
03F5:  MOVWF  5D
03F6:  MOVF   58,W
03F7:  MOVWF  5C
03F8:  MOVF   5D,W
03F9:  MOVWF  7A
03FA:  MOVF   5C,W
03FB:  MOVWF  04
03FC:  BCF    03.7
03FD:  BTFSC  7A.0
03FE:  BSF    03.7
03FF:  MOVF   00,F
0400:  BTFSC  03.2
0401:  GOTO   406
0402:  INCF   5C,F
0403:  BTFSC  03.2
0404:  INCF   5D,F
0405:  GOTO   3F8
....................    while(*s2 != '\0') 
0406:  MOVF   5B,W
0407:  MOVWF  7A
0408:  MOVF   5A,W
0409:  MOVWF  04
040A:  BCF    03.7
040B:  BTFSC  7A.0
040C:  BSF    03.7
040D:  MOVF   00,F
040E:  BTFSC  03.2
040F:  GOTO   425
....................    { 
....................       *s = *s2; 
0410:  MOVF   5A,W
0411:  MOVWF  04
0412:  BCF    03.7
0413:  BTFSC  5B.0
0414:  BSF    03.7
0415:  MOVF   00,W
0416:  MOVWF  60
0417:  MOVF   5C,W
0418:  MOVWF  04
0419:  BCF    03.7
041A:  BTFSC  5D.0
041B:  BSF    03.7
041C:  MOVF   60,W
041D:  MOVWF  00
....................       ++s; 
041E:  INCF   5C,F
041F:  BTFSC  03.2
0420:  INCF   5D,F
....................       ++s2; 
0421:  INCF   5A,F
0422:  BTFSC  03.2
0423:  INCF   5B,F
0424:  GOTO   406
....................    } 
....................  
....................    *s = '\0'; 
0425:  MOVF   5C,W
0426:  MOVWF  04
0427:  BCF    03.7
0428:  BTFSC  5D.0
0429:  BSF    03.7
042A:  CLRF   00
....................    return(s1); 
042B:  MOVF   58,W
042C:  MOVWF  78
042D:  MOVF   59,W
042E:  MOVWF  79
042F:  BCF    03.6
0430:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0AAE:  BCF    03.6
0AAF:  CLRF   2C
0AB0:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
02AF:  BSF    03.6
02B0:  CLRF   62
02B1:  CLRF   61
02B2:  CLRF   60
02B3:  MOVLW  01
02B4:  MOVWF  5F
02B5:  CLRF   64
02B6:  CLRF   65
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
02B7:  BTFSS  5B.7
02B8:  GOTO   301
....................          sign=1;        // Check for negative number 
02B9:  MOVLW  01
02BA:  MOVWF  64
....................          num*=-1; 
02BB:  MOVF   5B,W
02BC:  BSF    03.5
02BD:  MOVWF  1C
02BE:  BCF    03.5
02BF:  MOVF   5A,W
02C0:  BSF    03.5
02C1:  MOVWF  1B
02C2:  BCF    03.5
02C3:  MOVF   59,W
02C4:  BSF    03.5
02C5:  MOVWF  1A
02C6:  BCF    03.5
02C7:  MOVF   58,W
02C8:  BSF    03.5
02C9:  MOVWF  19
02CA:  MOVLW  FF
02CB:  MOVWF  20
02CC:  MOVWF  1F
02CD:  MOVWF  1E
02CE:  MOVWF  1D
*
02F8:  MOVF   7A,W
02F9:  BCF    03.5
02FA:  MOVWF  5B
02FB:  MOVF   79,W
02FC:  MOVWF  5A
02FD:  MOVF   78,W
02FE:  MOVWF  59
02FF:  MOVF   77,W
0300:  MOVWF  58
....................      } 
....................  
....................      while(temp>0) { 
0301:  MOVF   5F,F
0302:  BTFSS  03.2
0303:  GOTO   30D
0304:  MOVF   60,F
0305:  BTFSS  03.2
0306:  GOTO   30D
0307:  MOVF   61,F
0308:  BTFSS  03.2
0309:  GOTO   30D
030A:  MOVF   62,F
030B:  BTFSC  03.2
030C:  GOTO   3A1
....................          temp=(num/base); 
030D:  BCF    03.1
030E:  MOVF   5B,W
030F:  BSF    03.5
0310:  MOVWF  24
0311:  BCF    03.5
0312:  MOVF   5A,W
0313:  BSF    03.5
0314:  MOVWF  23
0315:  BCF    03.5
0316:  MOVF   59,W
0317:  BSF    03.5
0318:  MOVWF  22
0319:  BCF    03.5
031A:  MOVF   58,W
031B:  BSF    03.5
031C:  MOVWF  21
031D:  CLRF   28
031E:  CLRF   27
031F:  CLRF   26
0320:  BCF    03.5
0321:  MOVF   5C,W
0322:  BSF    03.5
0323:  MOVWF  25
0324:  BCF    03.5
0325:  BCF    03.6
0326:  CALL   231
0327:  MOVF   7A,W
0328:  BSF    03.6
0329:  MOVWF  62
032A:  MOVF   79,W
032B:  MOVWF  61
032C:  MOVF   78,W
032D:  MOVWF  60
032E:  MOVF   77,W
032F:  MOVWF  5F
....................          s[cnt]=(num%base)+'0';    // Conversion 
0330:  MOVF   65,W
0331:  ADDWF  5D,W
0332:  MOVWF  78
0333:  MOVF   5E,W
0334:  MOVWF  7A
0335:  BTFSC  03.0
0336:  INCF   7A,F
0337:  MOVF   78,W
0338:  BSF    03.5
0339:  MOVWF  10
033A:  MOVF   7A,W
033B:  MOVWF  11
033C:  CLRF   13
033D:  MOVF   04,W
033E:  MOVWF  12
033F:  BCF    13.0
0340:  BTFSC  03.7
0341:  BSF    13.0
0342:  BSF    03.1
0343:  MOVLW  94
0344:  MOVWF  04
0345:  BSF    03.7
0346:  BCF    03.5
0347:  MOVF   5B,W
0348:  BSF    03.5
0349:  MOVWF  24
034A:  BCF    03.5
034B:  MOVF   5A,W
034C:  BSF    03.5
034D:  MOVWF  23
034E:  BCF    03.5
034F:  MOVF   59,W
0350:  BSF    03.5
0351:  MOVWF  22
0352:  BCF    03.5
0353:  MOVF   58,W
0354:  BSF    03.5
0355:  MOVWF  21
0356:  CLRF   28
0357:  CLRF   27
0358:  CLRF   26
0359:  BCF    03.5
035A:  MOVF   5C,W
035B:  BSF    03.5
035C:  MOVWF  25
035D:  BCF    03.5
035E:  BCF    03.6
035F:  CALL   231
0360:  BSF    03.5
0361:  BSF    03.6
0362:  MOVF   12,W
0363:  MOVWF  04
0364:  BCF    03.7
0365:  BTFSC  13.0
0366:  BSF    03.7
0367:  MOVLW  30
0368:  ADDWF  14,W
0369:  MOVWF  77
036A:  MOVF   15,W
036B:  MOVWF  78
036C:  MOVLW  00
036D:  BTFSC  03.0
036E:  MOVLW  01
036F:  ADDWF  78,F
0370:  MOVF   16,W
0371:  MOVWF  79
0372:  MOVLW  00
0373:  BTFSC  03.0
0374:  MOVLW  01
0375:  ADDWF  79,F
0376:  MOVF   17,W
0377:  MOVWF  7A
0378:  MOVLW  00
0379:  BTFSC  03.0
037A:  MOVLW  01
037B:  ADDWF  7A,F
037C:  MOVF   10,W
037D:  MOVWF  04
037E:  BCF    03.7
037F:  BTFSC  11.0
0380:  BSF    03.7
0381:  MOVF   77,W
0382:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0383:  BCF    03.5
0384:  MOVF   65,W
0385:  ADDWF  5D,W
0386:  MOVWF  04
0387:  BCF    03.7
0388:  BTFSC  5E.0
0389:  BSF    03.7
038A:  MOVF   00,W
038B:  SUBLW  39
038C:  BTFSC  03.0
038D:  GOTO   397
....................             s[cnt]+=0x7; 
038E:  MOVF   65,W
038F:  ADDWF  5D,W
0390:  MOVWF  04
0391:  BCF    03.7
0392:  BTFSC  5E.0
0393:  BSF    03.7
0394:  MOVLW  07
0395:  ADDWF  00,W
0396:  MOVWF  00
....................  
....................          cnt++; 
0397:  INCF   65,F
....................          num=temp; 
0398:  MOVF   62,W
0399:  MOVWF  5B
039A:  MOVF   61,W
039B:  MOVWF  5A
039C:  MOVF   60,W
039D:  MOVWF  59
039E:  MOVF   5F,W
039F:  MOVWF  58
03A0:  GOTO   301
....................      } 
....................  
....................      if(sign==1) { 
03A1:  DECFSZ 64,W
03A2:  GOTO   3AC
....................          s[cnt]=0x2D;      // Negative sign 
03A3:  MOVF   65,W
03A4:  ADDWF  5D,W
03A5:  MOVWF  04
03A6:  BCF    03.7
03A7:  BTFSC  5E.0
03A8:  BSF    03.7
03A9:  MOVLW  2D
03AA:  MOVWF  00
....................          cnt++; 
03AB:  INCF   65,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
03AC:  CLRF   63
03AD:  BCF    03.0
03AE:  RRF    65,W
03AF:  SUBWF  63,W
03B0:  BTFSC  03.0
03B1:  GOTO   3E6
....................  
....................          c=s[i]; 
03B2:  MOVF   63,W
03B3:  ADDWF  5D,W
03B4:  MOVWF  04
03B5:  BCF    03.7
03B6:  BTFSC  5E.0
03B7:  BSF    03.7
03B8:  MOVF   00,W
03B9:  MOVWF  66
....................          s[i]=s[cnt-i-1];        // Reverse the number 
03BA:  MOVF   63,W
03BB:  ADDWF  5D,W
03BC:  MOVWF  78
03BD:  MOVF   5E,W
03BE:  MOVWF  7A
03BF:  BTFSC  03.0
03C0:  INCF   7A,F
03C1:  MOVF   78,W
03C2:  BSF    03.5
03C3:  MOVWF  10
03C4:  MOVF   7A,W
03C5:  MOVWF  11
03C6:  BCF    03.5
03C7:  MOVF   63,W
03C8:  SUBWF  65,W
03C9:  ADDLW  FF
03CA:  ADDWF  5D,W
03CB:  MOVWF  04
03CC:  BCF    03.7
03CD:  BTFSC  5E.0
03CE:  BSF    03.7
03CF:  MOVF   00,W
03D0:  BSF    03.5
03D1:  MOVWF  12
03D2:  MOVF   10,W
03D3:  MOVWF  04
03D4:  BCF    03.7
03D5:  BTFSC  11.0
03D6:  BSF    03.7
03D7:  MOVF   12,W
03D8:  MOVWF  00
....................          s[cnt-i-1]=c; 
03D9:  BCF    03.5
03DA:  MOVF   63,W
03DB:  SUBWF  65,W
03DC:  ADDLW  FF
03DD:  ADDWF  5D,W
03DE:  MOVWF  04
03DF:  BCF    03.7
03E0:  BTFSC  5E.0
03E1:  BSF    03.7
03E2:  MOVF   66,W
03E3:  MOVWF  00
03E4:  INCF   63,F
03E5:  GOTO   3AD
....................      } 
....................      s[cnt]='\0';     // End the string 
03E6:  MOVF   65,W
03E7:  ADDWF  5D,W
03E8:  MOVWF  04
03E9:  BCF    03.7
03EA:  BTFSC  5E.0
03EB:  BSF    03.7
03EC:  CLRF   00
....................      return s; 
03ED:  MOVF   5D,W
03EE:  MOVWF  78
03EF:  MOVF   5E,W
03F0:  MOVWF  79
03F1:  BCF    03.6
03F2:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S NGUYN 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S NGUYN DI 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0204:  MOVLW  65
0205:  MOVWF  04
0206:  BSF    03.7
0207:  MOVF   00,W
0208:  BTFSC  03.2
0209:  GOTO   217
020A:  MOVLW  06
020B:  MOVWF  78
020C:  CLRF   77
020D:  DECFSZ 77,F
020E:  GOTO   20D
020F:  DECFSZ 78,F
0210:  GOTO   20C
0211:  MOVLW  7B
0212:  MOVWF  77
0213:  DECFSZ 77,F
0214:  GOTO   213
0215:  DECFSZ 00,F
0216:  GOTO   20A
0217:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00FF:  BSF    07.0
....................    output_float(LCD_DATA5); 
0100:  BSF    07.1
....................    output_float(LCD_DATA6); 
0101:  BSF    07.2
....................    output_float(LCD_DATA7); 
0102:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0103:  BCF    03.5
0104:  BSF    09.2
0105:  BSF    03.5
0106:  BCF    09.2
....................    delay_cycles(1); 
0107:  NOP
....................    lcd_output_enable(1); 
0108:  BCF    03.5
0109:  BSF    09.0
010A:  BSF    03.5
010B:  BCF    09.0
....................    delay_cycles(1); 
010C:  NOP
....................    high = lcd_read_nibble(); 
*
014F:  MOVF   78,W
0150:  MOVWF  6C
....................        
....................    lcd_output_enable(0); 
0151:  BCF    03.6
0152:  BCF    09.0
0153:  BSF    03.5
0154:  BCF    09.0
....................    delay_cycles(1); 
0155:  NOP
....................    lcd_output_enable(1); 
0156:  BCF    03.5
0157:  BSF    09.0
0158:  BSF    03.5
0159:  BCF    09.0
....................    delay_us(1); 
015A:  GOTO   15B
015B:  GOTO   15C
015C:  NOP
....................    low = lcd_read_nibble(); 
*
019F:  MOVF   78,W
01A0:  MOVWF  6B
....................        
....................    lcd_output_enable(0); 
01A1:  BCF    03.6
01A2:  BCF    09.0
01A3:  BSF    03.5
01A4:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01A5:  BCF    03.5
01A6:  BCF    32.0
01A7:  MOVF   32,W
01A8:  BSF    03.5
01A9:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01AA:  BCF    03.5
01AB:  BCF    32.1
01AC:  MOVF   32,W
01AD:  BSF    03.5
01AE:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01AF:  BCF    03.5
01B0:  BCF    32.2
01B1:  MOVF   32,W
01B2:  BSF    03.5
01B3:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01B4:  BCF    03.5
01B5:  BCF    32.3
01B6:  MOVF   32,W
01B7:  BSF    03.5
01B8:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01B9:  BCF    03.5
01BA:  BSF    03.6
01BB:  SWAPF  6C,W
01BC:  MOVWF  77
01BD:  MOVLW  F0
01BE:  ANDWF  77,F
01BF:  MOVF   77,W
01C0:  IORWF  6B,W
01C1:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
010D:  BCF    03.5
010E:  BSF    03.6
010F:  CLRF   6D
*
015D:  BCF    03.5
015E:  BSF    03.6
015F:  CLRF   6D
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
0110:  BCF    03.6
0111:  BSF    32.0
0112:  MOVF   32,W
0113:  BSF    03.5
0114:  MOVWF  07
0115:  MOVLW  00
0116:  BCF    03.5
0117:  BTFSC  07.0
0118:  MOVLW  01
0119:  BSF    03.6
011A:  IORWF  6D,F
*
0160:  BCF    03.6
0161:  BSF    32.0
0162:  MOVF   32,W
0163:  BSF    03.5
0164:  MOVWF  07
0165:  MOVLW  00
0166:  BCF    03.5
0167:  BTFSC  07.0
0168:  MOVLW  01
0169:  BSF    03.6
016A:  IORWF  6D,F
....................    n |= input(LCD_DATA5) << 1; 
*
011B:  BCF    03.6
011C:  BSF    32.1
011D:  MOVF   32,W
011E:  BSF    03.5
011F:  MOVWF  07
0120:  MOVLW  00
0121:  BCF    03.5
0122:  BTFSC  07.1
0123:  MOVLW  01
0124:  MOVWF  77
0125:  BCF    03.0
0126:  RLF    77,F
0127:  MOVF   77,W
0128:  BSF    03.6
0129:  IORWF  6D,F
*
016B:  BCF    03.6
016C:  BSF    32.1
016D:  MOVF   32,W
016E:  BSF    03.5
016F:  MOVWF  07
0170:  MOVLW  00
0171:  BCF    03.5
0172:  BTFSC  07.1
0173:  MOVLW  01
0174:  MOVWF  77
0175:  BCF    03.0
0176:  RLF    77,F
0177:  MOVF   77,W
0178:  BSF    03.6
0179:  IORWF  6D,F
....................    n |= input(LCD_DATA6) << 2; 
*
012A:  BCF    03.6
012B:  BSF    32.2
012C:  MOVF   32,W
012D:  BSF    03.5
012E:  MOVWF  07
012F:  MOVLW  00
0130:  BCF    03.5
0131:  BTFSC  07.2
0132:  MOVLW  01
0133:  MOVWF  77
0134:  RLF    77,F
0135:  RLF    77,F
0136:  MOVLW  FC
0137:  ANDWF  77,F
0138:  MOVF   77,W
0139:  BSF    03.6
013A:  IORWF  6D,F
*
017A:  BCF    03.6
017B:  BSF    32.2
017C:  MOVF   32,W
017D:  BSF    03.5
017E:  MOVWF  07
017F:  MOVLW  00
0180:  BCF    03.5
0181:  BTFSC  07.2
0182:  MOVLW  01
0183:  MOVWF  77
0184:  RLF    77,F
0185:  RLF    77,F
0186:  MOVLW  FC
0187:  ANDWF  77,F
0188:  MOVF   77,W
0189:  BSF    03.6
018A:  IORWF  6D,F
....................    n |= input(LCD_DATA7) << 3; 
*
013B:  BCF    03.6
013C:  BSF    32.3
013D:  MOVF   32,W
013E:  BSF    03.5
013F:  MOVWF  07
0140:  MOVLW  00
0141:  BCF    03.5
0142:  BTFSC  07.3
0143:  MOVLW  01
0144:  MOVWF  77
0145:  RLF    77,F
0146:  RLF    77,F
0147:  RLF    77,F
0148:  MOVLW  F8
0149:  ANDWF  77,F
014A:  MOVF   77,W
014B:  BSF    03.6
014C:  IORWF  6D,F
*
018B:  BCF    03.6
018C:  BSF    32.3
018D:  MOVF   32,W
018E:  BSF    03.5
018F:  MOVWF  07
0190:  MOVLW  00
0191:  BCF    03.5
0192:  BTFSC  07.3
0193:  MOVLW  01
0194:  MOVWF  77
0195:  RLF    77,F
0196:  RLF    77,F
0197:  RLF    77,F
0198:  MOVLW  F8
0199:  ANDWF  77,F
019A:  MOVF   77,W
019B:  BSF    03.6
019C:  IORWF  6D,F
....................     
....................    return(n); 
*
014D:  MOVF   6D,W
014E:  MOVWF  78
*
019D:  MOVF   6D,W
019E:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00AF:  BSF    03.6
00B0:  BTFSC  6C.0
00B1:  GOTO   0B6
00B2:  BCF    03.6
00B3:  BCF    07.0
00B4:  GOTO   0B8
00B5:  BSF    03.6
00B6:  BCF    03.6
00B7:  BSF    07.0
00B8:  BCF    32.0
00B9:  MOVF   32,W
00BA:  BSF    03.5
00BB:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00BC:  BCF    03.5
00BD:  BSF    03.6
00BE:  BTFSC  6C.1
00BF:  GOTO   0C4
00C0:  BCF    03.6
00C1:  BCF    07.1
00C2:  GOTO   0C6
00C3:  BSF    03.6
00C4:  BCF    03.6
00C5:  BSF    07.1
00C6:  BCF    32.1
00C7:  MOVF   32,W
00C8:  BSF    03.5
00C9:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00CA:  BCF    03.5
00CB:  BSF    03.6
00CC:  BTFSC  6C.2
00CD:  GOTO   0D2
00CE:  BCF    03.6
00CF:  BCF    07.2
00D0:  GOTO   0D4
00D1:  BSF    03.6
00D2:  BCF    03.6
00D3:  BSF    07.2
00D4:  BCF    32.2
00D5:  MOVF   32,W
00D6:  BSF    03.5
00D7:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00D8:  BCF    03.5
00D9:  BSF    03.6
00DA:  BTFSC  6C.3
00DB:  GOTO   0E0
00DC:  BCF    03.6
00DD:  BCF    07.3
00DE:  GOTO   0E2
00DF:  BSF    03.6
00E0:  BCF    03.6
00E1:  BSF    07.3
00E2:  BCF    32.3
00E3:  MOVF   32,W
00E4:  BSF    03.5
00E5:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00E6:  NOP
....................    lcd_output_enable(1); 
00E7:  BCF    03.5
00E8:  BSF    09.0
00E9:  BSF    03.5
00EA:  BCF    09.0
....................    delay_us(2); 
00EB:  MOVLW  02
00EC:  MOVWF  77
00ED:  DECFSZ 77,F
00EE:  GOTO   0ED
00EF:  GOTO   0F0
00F0:  NOP
....................    lcd_output_enable(0); 
00F1:  BCF    03.5
00F2:  BCF    09.0
00F3:  BSF    03.5
00F4:  BCF    09.0
00F5:  BCF    03.5
00F6:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
00F7:  BSF    03.5
00F8:  BCF    09.0
....................    lcd_rs_tris(); 
00F9:  BCF    09.1
....................    lcd_rw_tris(); 
00FA:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00FB:  BCF    03.5
00FC:  BCF    09.1
00FD:  BSF    03.5
00FE:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01C2:  MOVF   78,W
01C3:  MOVWF  6B
01C4:  BTFSS  6B.7
01C5:  GOTO   1C9
01C6:  BSF    03.5
01C7:  BCF    03.6
01C8:  GOTO   0FF
....................    lcd_output_rs(address); 
01C9:  MOVF   69,F
01CA:  BTFSS  03.2
01CB:  GOTO   1D0
01CC:  BCF    03.6
01CD:  BCF    09.1
01CE:  GOTO   1D2
01CF:  BSF    03.6
01D0:  BCF    03.6
01D1:  BSF    09.1
01D2:  BSF    03.5
01D3:  BCF    09.1
....................    delay_cycles(1); 
01D4:  NOP
....................    lcd_output_rw(0); 
01D5:  BCF    03.5
01D6:  BCF    09.2
01D7:  BSF    03.5
01D8:  BCF    09.2
....................    delay_cycles(1); 
01D9:  NOP
....................    lcd_output_enable(0); 
01DA:  BCF    03.5
01DB:  BCF    09.0
01DC:  BSF    03.5
01DD:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01DE:  BCF    03.5
01DF:  BSF    03.6
01E0:  SWAPF  6A,W
01E1:  MOVWF  6B
01E2:  MOVLW  0F
01E3:  ANDWF  6B,F
01E4:  MOVF   6B,W
01E5:  MOVWF  6C
01E6:  BCF    03.6
01E7:  CALL   0AF
....................    lcd_send_nibble(n & 0xf); 
01E8:  BSF    03.6
01E9:  MOVF   6A,W
01EA:  ANDLW  0F
01EB:  MOVWF  6B
01EC:  MOVWF  6C
01ED:  BCF    03.6
01EE:  CALL   0AF
01EF:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
*
0800:  MOVLW  28
0801:  BSF    03.6
0802:  MOVWF  30
0803:  MOVLW  0C
0804:  MOVWF  31
0805:  MOVLW  01
0806:  MOVWF  32
0807:  MOVLW  06
0808:  MOVWF  33
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0809:  BCF    03.6
080A:  BCF    09.0
080B:  BSF    03.5
080C:  BCF    09.0
....................    lcd_output_rs(0); 
080D:  BCF    03.5
080E:  BCF    09.1
080F:  BSF    03.5
0810:  BCF    09.1
....................    lcd_output_rw(0); 
0811:  BCF    03.5
0812:  BCF    09.2
0813:  BSF    03.5
0814:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0815:  BCF    03.5
0816:  BCF    32.0
0817:  MOVF   32,W
0818:  BSF    03.5
0819:  MOVWF  07
....................    output_drive(LCD_DATA5); 
081A:  BCF    03.5
081B:  BCF    32.1
081C:  MOVF   32,W
081D:  BSF    03.5
081E:  MOVWF  07
....................    output_drive(LCD_DATA6); 
081F:  BCF    03.5
0820:  BCF    32.2
0821:  MOVF   32,W
0822:  BSF    03.5
0823:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0824:  BCF    03.5
0825:  BCF    32.3
0826:  MOVF   32,W
0827:  BSF    03.5
0828:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0829:  BCF    09.0
....................    lcd_rs_tris(); 
082A:  BCF    09.1
....................    lcd_rw_tris(); 
082B:  BCF    09.2
082C:  BCF    03.5
082D:  CLRF   2B
082E:  BTFSC  0B.7
082F:  BSF    2B.7
0830:  BCF    0B.7
....................  #endif 
....................      
....................    delay_ms(15); 
0831:  MOVLW  0F
0832:  BSF    03.6
0833:  MOVWF  65
0834:  BCF    0A.3
0835:  BCF    03.6
0836:  CALL   204
0837:  BSF    0A.3
0838:  BTFSC  2B.7
0839:  BSF    0B.7
....................    for(i=1;i<=3;++i) 
083A:  MOVLW  01
083B:  BSF    03.6
083C:  MOVWF  2F
083D:  MOVF   2F,W
083E:  SUBLW  03
083F:  BTFSS  03.0
0840:  GOTO   05F
0841:  BCF    03.6
0842:  CLRF   2B
0843:  BTFSC  0B.7
0844:  BSF    2B.7
0845:  BCF    0B.7
....................    { 
....................        lcd_send_nibble(3); 
0846:  MOVLW  03
0847:  BSF    03.6
0848:  MOVWF  6C
0849:  BCF    0A.3
084A:  BCF    03.6
084B:  CALL   0AF
084C:  BSF    0A.3
084D:  BTFSC  2B.7
084E:  BSF    0B.7
084F:  CLRF   2B
0850:  BTFSC  0B.7
0851:  BSF    2B.7
0852:  BCF    0B.7
....................        delay_ms(5); 
0853:  MOVLW  05
0854:  BSF    03.6
0855:  MOVWF  65
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   204
0859:  BSF    0A.3
085A:  BTFSC  2B.7
085B:  BSF    0B.7
085C:  BSF    03.6
085D:  INCF   2F,F
085E:  GOTO   03D
085F:  BCF    03.6
0860:  CLRF   2B
0861:  BTFSC  0B.7
0862:  BSF    2B.7
0863:  BCF    0B.7
....................    } 
....................     
....................    lcd_send_nibble(2); 
0864:  MOVLW  02
0865:  BSF    03.6
0866:  MOVWF  6C
0867:  BCF    0A.3
0868:  BCF    03.6
0869:  CALL   0AF
086A:  BSF    0A.3
086B:  BTFSC  2B.7
086C:  BSF    0B.7
086D:  CLRF   2B
086E:  BTFSC  0B.7
086F:  BSF    2B.7
0870:  BCF    0B.7
....................    delay_ms(5); 
0871:  MOVLW  05
0872:  BSF    03.6
0873:  MOVWF  65
0874:  BCF    0A.3
0875:  BCF    03.6
0876:  CALL   204
0877:  BSF    0A.3
0878:  BTFSC  2B.7
0879:  BSF    0B.7
....................    for(i=0;i<=3;++i) 
087A:  BSF    03.6
087B:  CLRF   2F
087C:  MOVF   2F,W
087D:  SUBLW  03
087E:  BTFSS  03.0
087F:  GOTO   098
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0880:  MOVLW  30
0881:  ADDWF  2F,W
0882:  MOVWF  04
0883:  BSF    03.7
0884:  MOVF   00,W
0885:  MOVWF  34
0886:  BCF    03.6
0887:  CLRF   2B
0888:  BTFSC  0B.7
0889:  BSF    2B.7
088A:  BCF    0B.7
088B:  BSF    03.6
088C:  CLRF   69
088D:  MOVF   34,W
088E:  MOVWF  6A
088F:  BCF    0A.3
0890:  BCF    03.6
0891:  CALL   0F7
0892:  BSF    0A.3
0893:  BTFSC  2B.7
0894:  BSF    0B.7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0895:  BSF    03.6
0896:  INCF   2F,F
0897:  GOTO   07C
0898:  BCF    03.6
0899:  BSF    0A.3
089A:  BCF    0A.4
089B:  GOTO   3AE (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01F0:  BSF    03.6
01F1:  DECFSZ 66,W
01F2:  GOTO   1F4
01F3:  GOTO   1F7
....................       address=LCD_LINE_TWO; 
01F4:  MOVLW  40
01F5:  MOVWF  67
01F6:  GOTO   1F8
....................    else 
....................       address=0; 
01F7:  CLRF   67
....................       
....................    address+=x-1; 
01F8:  MOVLW  01
01F9:  SUBWF  65,W
01FA:  ADDWF  67,F
....................    lcd_send_byte(0,0x80|address); 
01FB:  MOVF   67,W
01FC:  IORLW  80
01FD:  MOVWF  68
01FE:  CLRF   69
01FF:  MOVF   68,W
0200:  MOVWF  6A
0201:  BCF    03.6
0202:  CALL   0F7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0203:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0462:  MOVF   64,W
0463:  XORLW  07
0464:  BCF    03.6
0465:  BTFSC  03.2
0466:  GOTO   471
0467:  XORLW  0B
0468:  BTFSC  03.2
0469:  GOTO   478
046A:  XORLW  06
046B:  BTFSC  03.2
046C:  GOTO   484
046D:  XORLW  02
046E:  BTFSC  03.2
046F:  GOTO   48C
0470:  GOTO   493
*
049D:  MOVF   64,W
049E:  XORLW  07
049F:  BCF    03.6
04A0:  BTFSC  03.2
04A1:  GOTO   4AC
04A2:  XORLW  0B
04A3:  BTFSC  03.2
04A4:  GOTO   4B3
04A5:  XORLW  06
04A6:  BTFSC  03.2
04A7:  GOTO   4BF
04A8:  XORLW  02
04A9:  BTFSC  03.2
04AA:  GOTO   4C7
04AB:  GOTO   4CE
*
04D8:  MOVF   64,W
04D9:  XORLW  07
04DA:  BCF    03.6
04DB:  BTFSC  03.2
04DC:  GOTO   4E7
04DD:  XORLW  0B
04DE:  BTFSC  03.2
04DF:  GOTO   4EE
04E0:  XORLW  06
04E1:  BTFSC  03.2
04E2:  GOTO   4FA
04E3:  XORLW  02
04E4:  BTFSC  03.2
04E5:  GOTO   502
04E6:  GOTO   509
*
054F:  MOVF   64,W
0550:  XORLW  07
0551:  BCF    03.6
0552:  BTFSC  03.2
0553:  GOTO   55E
0554:  XORLW  0B
0555:  BTFSC  03.2
0556:  GOTO   565
0557:  XORLW  06
0558:  BTFSC  03.2
0559:  GOTO   571
055A:  XORLW  02
055B:  BTFSC  03.2
055C:  GOTO   579
055D:  GOTO   580
*
05AA:  MOVF   64,W
05AB:  XORLW  07
05AC:  BCF    03.6
05AD:  BTFSC  03.2
05AE:  GOTO   5B9
05AF:  XORLW  0B
05B0:  BTFSC  03.2
05B1:  GOTO   5C0
05B2:  XORLW  06
05B3:  BTFSC  03.2
05B4:  GOTO   5CC
05B5:  XORLW  02
05B6:  BTFSC  03.2
05B7:  GOTO   5D4
05B8:  GOTO   5DB
*
0697:  MOVF   64,W
0698:  XORLW  07
0699:  BCF    03.6
069A:  BTFSC  03.2
069B:  GOTO   6A6
069C:  XORLW  0B
069D:  BTFSC  03.2
069E:  GOTO   6AD
069F:  XORLW  06
06A0:  BTFSC  03.2
06A1:  GOTO   6B9
06A2:  XORLW  02
06A3:  BTFSC  03.2
06A4:  GOTO   6C1
06A5:  GOTO   6C8
*
06F2:  MOVF   64,W
06F3:  XORLW  07
06F4:  BCF    03.6
06F5:  BTFSC  03.2
06F6:  GOTO   701
06F7:  XORLW  0B
06F8:  BTFSC  03.2
06F9:  GOTO   708
06FA:  XORLW  06
06FB:  BTFSC  03.2
06FC:  GOTO   714
06FD:  XORLW  02
06FE:  BTFSC  03.2
06FF:  GOTO   71C
0700:  GOTO   723
*
074D:  MOVF   64,W
074E:  XORLW  07
074F:  BCF    03.6
0750:  BTFSC  03.2
0751:  GOTO   75C
0752:  XORLW  0B
0753:  BTFSC  03.2
0754:  GOTO   763
0755:  XORLW  06
0756:  BTFSC  03.2
0757:  GOTO   76F
0758:  XORLW  02
0759:  BTFSC  03.2
075A:  GOTO   777
075B:  GOTO   77E
*
0A22:  MOVF   64,W
0A23:  XORLW  07
0A24:  BCF    03.6
0A25:  BTFSC  03.2
0A26:  GOTO   231
0A27:  XORLW  0B
0A28:  BTFSC  03.2
0A29:  GOTO   23A
0A2A:  XORLW  06
0A2B:  BTFSC  03.2
0A2C:  GOTO   24A
0A2D:  XORLW  02
0A2E:  BTFSC  03.2
0A2F:  GOTO   254
0A30:  GOTO   25D
*
0BFB:  MOVF   64,W
0BFC:  XORLW  07
0BFD:  BCF    03.6
0BFE:  BTFSC  03.2
0BFF:  GOTO   40A
0C00:  XORLW  0B
0C01:  BTFSC  03.2
0C02:  GOTO   413
0C03:  XORLW  06
0C04:  BTFSC  03.2
0C05:  GOTO   423
0C06:  XORLW  02
0C07:  BTFSC  03.2
0C08:  GOTO   42D
0C09:  GOTO   436
*
0C62:  MOVF   64,W
0C63:  XORLW  07
0C64:  BCF    03.6
0C65:  BTFSC  03.2
0C66:  GOTO   471
0C67:  XORLW  0B
0C68:  BTFSC  03.2
0C69:  GOTO   47A
0C6A:  XORLW  06
0C6B:  BTFSC  03.2
0C6C:  GOTO   48A
0C6D:  XORLW  02
0C6E:  BTFSC  03.2
0C6F:  GOTO   494
0C70:  GOTO   49D
*
0D13:  MOVF   64,W
0D14:  XORLW  07
0D15:  BCF    03.6
0D16:  BTFSC  03.2
0D17:  GOTO   522
0D18:  XORLW  0B
0D19:  BTFSC  03.2
0D1A:  GOTO   52B
0D1B:  XORLW  06
0D1C:  BTFSC  03.2
0D1D:  GOTO   53B
0D1E:  XORLW  02
0D1F:  BTFSC  03.2
0D20:  GOTO   545
0D21:  GOTO   54E
*
1044:  MOVF   64,W
1045:  XORLW  07
1046:  BCF    03.6
1047:  BTFSC  03.2
1048:  GOTO   053
1049:  XORLW  0B
104A:  BTFSC  03.2
104B:  GOTO   05C
104C:  XORLW  06
104D:  BTFSC  03.2
104E:  GOTO   06C
104F:  XORLW  02
1050:  BTFSC  03.2
1051:  GOTO   076
1052:  GOTO   07F
*
10AB:  MOVF   64,W
10AC:  XORLW  07
10AD:  BCF    03.6
10AE:  BTFSC  03.2
10AF:  GOTO   0BA
10B0:  XORLW  0B
10B1:  BTFSC  03.2
10B2:  GOTO   0C3
10B3:  XORLW  06
10B4:  BTFSC  03.2
10B5:  GOTO   0D3
10B6:  XORLW  02
10B7:  BTFSC  03.2
10B8:  GOTO   0DD
10B9:  GOTO   0E6
*
115C:  MOVF   64,W
115D:  XORLW  07
115E:  BCF    03.6
115F:  BTFSC  03.2
1160:  GOTO   16B
1161:  XORLW  0B
1162:  BTFSC  03.2
1163:  GOTO   174
1164:  XORLW  06
1165:  BTFSC  03.2
1166:  GOTO   184
1167:  XORLW  02
1168:  BTFSC  03.2
1169:  GOTO   18E
116A:  GOTO   197
*
1200:  MOVF   64,W
1201:  XORLW  07
1202:  BCF    03.6
1203:  BTFSC  03.2
1204:  GOTO   20F
1205:  XORLW  0B
1206:  BTFSC  03.2
1207:  GOTO   218
1208:  XORLW  06
1209:  BTFSC  03.2
120A:  GOTO   228
120B:  XORLW  02
120C:  BTFSC  03.2
120D:  GOTO   232
120E:  GOTO   23B
*
1267:  MOVF   64,W
1268:  XORLW  07
1269:  BCF    03.6
126A:  BTFSC  03.2
126B:  GOTO   276
126C:  XORLW  0B
126D:  BTFSC  03.2
126E:  GOTO   27F
126F:  XORLW  06
1270:  BTFSC  03.2
1271:  GOTO   28F
1272:  XORLW  02
1273:  BTFSC  03.2
1274:  GOTO   299
1275:  GOTO   2A2
*
1318:  MOVF   64,W
1319:  XORLW  07
131A:  BCF    03.6
131B:  BTFSC  03.2
131C:  GOTO   327
131D:  XORLW  0B
131E:  BTFSC  03.2
131F:  GOTO   330
1320:  XORLW  06
1321:  BTFSC  03.2
1322:  GOTO   340
1323:  XORLW  02
1324:  BTFSC  03.2
1325:  GOTO   34A
1326:  GOTO   353
*
1399:  MOVF   64,W
139A:  XORLW  07
139B:  BCF    03.6
139C:  BTFSC  03.2
139D:  GOTO   3A8
139E:  XORLW  0B
139F:  BTFSC  03.2
13A0:  GOTO   3B1
13A1:  XORLW  06
13A2:  BTFSC  03.2
13A3:  GOTO   3C1
13A4:  XORLW  02
13A5:  BTFSC  03.2
13A6:  GOTO   3CB
13A7:  GOTO   3D4
*
1400:  MOVF   64,W
1401:  XORLW  07
1402:  BCF    03.6
1403:  BTFSC  03.2
1404:  GOTO   40F
1405:  XORLW  0B
1406:  BTFSC  03.2
1407:  GOTO   418
1408:  XORLW  06
1409:  BTFSC  03.2
140A:  GOTO   428
140B:  XORLW  02
140C:  BTFSC  03.2
140D:  GOTO   432
140E:  GOTO   43B
*
1495:  MOVF   64,W
1496:  XORLW  07
1497:  BCF    03.6
1498:  BTFSC  03.2
1499:  GOTO   4A4
149A:  XORLW  0B
149B:  BTFSC  03.2
149C:  GOTO   4AD
149D:  XORLW  06
149E:  BTFSC  03.2
149F:  GOTO   4BD
14A0:  XORLW  02
14A1:  BTFSC  03.2
14A2:  GOTO   4C7
14A3:  GOTO   4D0
*
157F:  MOVF   64,W
1580:  XORLW  07
1581:  BCF    03.6
1582:  BTFSC  03.2
1583:  GOTO   58E
1584:  XORLW  0B
1585:  BTFSC  03.2
1586:  GOTO   597
1587:  XORLW  06
1588:  BTFSC  03.2
1589:  GOTO   5A7
158A:  XORLW  02
158B:  BTFSC  03.2
158C:  GOTO   5B1
158D:  GOTO   5BA
*
1611:  MOVF   64,W
1612:  XORLW  07
1613:  BCF    03.6
1614:  BTFSC  03.2
1615:  GOTO   620
1616:  XORLW  0B
1617:  BTFSC  03.2
1618:  GOTO   629
1619:  XORLW  06
161A:  BTFSC  03.2
161B:  GOTO   639
161C:  XORLW  02
161D:  BTFSC  03.2
161E:  GOTO   643
161F:  GOTO   64C
*
1678:  MOVF   64,W
1679:  XORLW  07
167A:  BCF    03.6
167B:  BTFSC  03.2
167C:  GOTO   687
167D:  XORLW  0B
167E:  BTFSC  03.2
167F:  GOTO   690
1680:  XORLW  06
1681:  BTFSC  03.2
1682:  GOTO   6A0
1683:  XORLW  02
1684:  BTFSC  03.2
1685:  GOTO   6AA
1686:  GOTO   6B3
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
*
0471:  MOVLW  01
0472:  BSF    03.6
0473:  MOVWF  65
0474:  MOVWF  66
0475:  BCF    03.6
0476:  CALL   1F0
0477:  GOTO   49A
*
04AC:  MOVLW  01
04AD:  BSF    03.6
04AE:  MOVWF  65
04AF:  MOVWF  66
04B0:  BCF    03.6
04B1:  CALL   1F0
04B2:  GOTO   4D5
*
04E7:  MOVLW  01
04E8:  BSF    03.6
04E9:  MOVWF  65
04EA:  MOVWF  66
04EB:  BCF    03.6
04EC:  CALL   1F0
04ED:  GOTO   510
*
055E:  MOVLW  01
055F:  BSF    03.6
0560:  MOVWF  65
0561:  MOVWF  66
0562:  BCF    03.6
0563:  CALL   1F0
0564:  GOTO   587
*
05B9:  MOVLW  01
05BA:  BSF    03.6
05BB:  MOVWF  65
05BC:  MOVWF  66
05BD:  BCF    03.6
05BE:  CALL   1F0
05BF:  GOTO   5E2
*
06A6:  MOVLW  01
06A7:  BSF    03.6
06A8:  MOVWF  65
06A9:  MOVWF  66
06AA:  BCF    03.6
06AB:  CALL   1F0
06AC:  GOTO   6CF
*
0701:  MOVLW  01
0702:  BSF    03.6
0703:  MOVWF  65
0704:  MOVWF  66
0705:  BCF    03.6
0706:  CALL   1F0
0707:  GOTO   72A
*
075C:  MOVLW  01
075D:  BSF    03.6
075E:  MOVWF  65
075F:  MOVWF  66
0760:  BCF    03.6
0761:  CALL   1F0
0762:  GOTO   785
*
0A31:  MOVLW  01
0A32:  BSF    03.6
0A33:  MOVWF  65
0A34:  MOVWF  66
0A35:  BCF    0A.3
0A36:  BCF    03.6
0A37:  CALL   1F0
0A38:  BSF    0A.3
0A39:  GOTO   266
*
0C0A:  MOVLW  01
0C0B:  BSF    03.6
0C0C:  MOVWF  65
0C0D:  MOVWF  66
0C0E:  BCF    0A.3
0C0F:  BCF    03.6
0C10:  CALL   1F0
0C11:  BSF    0A.3
0C12:  GOTO   43F
*
0C71:  MOVLW  01
0C72:  BSF    03.6
0C73:  MOVWF  65
0C74:  MOVWF  66
0C75:  BCF    0A.3
0C76:  BCF    03.6
0C77:  CALL   1F0
0C78:  BSF    0A.3
0C79:  GOTO   4A6
*
0D22:  MOVLW  01
0D23:  BSF    03.6
0D24:  MOVWF  65
0D25:  MOVWF  66
0D26:  BCF    0A.3
0D27:  BCF    03.6
0D28:  CALL   1F0
0D29:  BSF    0A.3
0D2A:  GOTO   557
*
1053:  MOVLW  01
1054:  BSF    03.6
1055:  MOVWF  65
1056:  MOVWF  66
1057:  BCF    0A.4
1058:  BCF    03.6
1059:  CALL   1F0
105A:  BSF    0A.4
105B:  GOTO   088
*
10BA:  MOVLW  01
10BB:  BSF    03.6
10BC:  MOVWF  65
10BD:  MOVWF  66
10BE:  BCF    0A.4
10BF:  BCF    03.6
10C0:  CALL   1F0
10C1:  BSF    0A.4
10C2:  GOTO   0EF
*
116B:  MOVLW  01
116C:  BSF    03.6
116D:  MOVWF  65
116E:  MOVWF  66
116F:  BCF    0A.4
1170:  BCF    03.6
1171:  CALL   1F0
1172:  BSF    0A.4
1173:  GOTO   1A0
*
120F:  MOVLW  01
1210:  BSF    03.6
1211:  MOVWF  65
1212:  MOVWF  66
1213:  BCF    0A.4
1214:  BCF    03.6
1215:  CALL   1F0
1216:  BSF    0A.4
1217:  GOTO   244
*
1276:  MOVLW  01
1277:  BSF    03.6
1278:  MOVWF  65
1279:  MOVWF  66
127A:  BCF    0A.4
127B:  BCF    03.6
127C:  CALL   1F0
127D:  BSF    0A.4
127E:  GOTO   2AB
*
1327:  MOVLW  01
1328:  BSF    03.6
1329:  MOVWF  65
132A:  MOVWF  66
132B:  BCF    0A.4
132C:  BCF    03.6
132D:  CALL   1F0
132E:  BSF    0A.4
132F:  GOTO   35C
*
13A8:  MOVLW  01
13A9:  BSF    03.6
13AA:  MOVWF  65
13AB:  MOVWF  66
13AC:  BCF    0A.4
13AD:  BCF    03.6
13AE:  CALL   1F0
13AF:  BSF    0A.4
13B0:  GOTO   3DD
*
140F:  MOVLW  01
1410:  BSF    03.6
1411:  MOVWF  65
1412:  MOVWF  66
1413:  BCF    0A.4
1414:  BCF    03.6
1415:  CALL   1F0
1416:  BSF    0A.4
1417:  GOTO   444
*
14A4:  MOVLW  01
14A5:  BSF    03.6
14A6:  MOVWF  65
14A7:  MOVWF  66
14A8:  BCF    0A.4
14A9:  BCF    03.6
14AA:  CALL   1F0
14AB:  BSF    0A.4
14AC:  GOTO   4D9
*
158E:  MOVLW  01
158F:  BSF    03.6
1590:  MOVWF  65
1591:  MOVWF  66
1592:  BCF    0A.4
1593:  BCF    03.6
1594:  CALL   1F0
1595:  BSF    0A.4
1596:  GOTO   5C3
*
1620:  MOVLW  01
1621:  BSF    03.6
1622:  MOVWF  65
1623:  MOVWF  66
1624:  BCF    0A.4
1625:  BCF    03.6
1626:  CALL   1F0
1627:  BSF    0A.4
1628:  GOTO   655
*
1687:  MOVLW  01
1688:  BSF    03.6
1689:  MOVWF  65
168A:  MOVWF  66
168B:  BCF    0A.4
168C:  BCF    03.6
168D:  CALL   1F0
168E:  BSF    0A.4
168F:  GOTO   6BC
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
*
0478:  BSF    03.6
0479:  CLRF   69
047A:  MOVLW  01
047B:  MOVWF  6A
047C:  BCF    03.6
047D:  CALL   0F7
*
04B3:  BSF    03.6
04B4:  CLRF   69
04B5:  MOVLW  01
04B6:  MOVWF  6A
04B7:  BCF    03.6
04B8:  CALL   0F7
*
04EE:  BSF    03.6
04EF:  CLRF   69
04F0:  MOVLW  01
04F1:  MOVWF  6A
04F2:  BCF    03.6
04F3:  CALL   0F7
*
0565:  BSF    03.6
0566:  CLRF   69
0567:  MOVLW  01
0568:  MOVWF  6A
0569:  BCF    03.6
056A:  CALL   0F7
*
05C0:  BSF    03.6
05C1:  CLRF   69
05C2:  MOVLW  01
05C3:  MOVWF  6A
05C4:  BCF    03.6
05C5:  CALL   0F7
*
06AD:  BSF    03.6
06AE:  CLRF   69
06AF:  MOVLW  01
06B0:  MOVWF  6A
06B1:  BCF    03.6
06B2:  CALL   0F7
*
0708:  BSF    03.6
0709:  CLRF   69
070A:  MOVLW  01
070B:  MOVWF  6A
070C:  BCF    03.6
070D:  CALL   0F7
*
0763:  BSF    03.6
0764:  CLRF   69
0765:  MOVLW  01
0766:  MOVWF  6A
0767:  BCF    03.6
0768:  CALL   0F7
*
0A3A:  BSF    03.6
0A3B:  CLRF   69
0A3C:  MOVLW  01
0A3D:  MOVWF  6A
0A3E:  BCF    0A.3
0A3F:  BCF    03.6
0A40:  CALL   0F7
0A41:  BSF    0A.3
*
0C13:  BSF    03.6
0C14:  CLRF   69
0C15:  MOVLW  01
0C16:  MOVWF  6A
0C17:  BCF    0A.3
0C18:  BCF    03.6
0C19:  CALL   0F7
0C1A:  BSF    0A.3
*
0C7A:  BSF    03.6
0C7B:  CLRF   69
0C7C:  MOVLW  01
0C7D:  MOVWF  6A
0C7E:  BCF    0A.3
0C7F:  BCF    03.6
0C80:  CALL   0F7
0C81:  BSF    0A.3
*
0D2B:  BSF    03.6
0D2C:  CLRF   69
0D2D:  MOVLW  01
0D2E:  MOVWF  6A
0D2F:  BCF    0A.3
0D30:  BCF    03.6
0D31:  CALL   0F7
0D32:  BSF    0A.3
*
105C:  BSF    03.6
105D:  CLRF   69
105E:  MOVLW  01
105F:  MOVWF  6A
1060:  BCF    0A.4
1061:  BCF    03.6
1062:  CALL   0F7
1063:  BSF    0A.4
*
10C3:  BSF    03.6
10C4:  CLRF   69
10C5:  MOVLW  01
10C6:  MOVWF  6A
10C7:  BCF    0A.4
10C8:  BCF    03.6
10C9:  CALL   0F7
10CA:  BSF    0A.4
*
1174:  BSF    03.6
1175:  CLRF   69
1176:  MOVLW  01
1177:  MOVWF  6A
1178:  BCF    0A.4
1179:  BCF    03.6
117A:  CALL   0F7
117B:  BSF    0A.4
*
1218:  BSF    03.6
1219:  CLRF   69
121A:  MOVLW  01
121B:  MOVWF  6A
121C:  BCF    0A.4
121D:  BCF    03.6
121E:  CALL   0F7
121F:  BSF    0A.4
*
127F:  BSF    03.6
1280:  CLRF   69
1281:  MOVLW  01
1282:  MOVWF  6A
1283:  BCF    0A.4
1284:  BCF    03.6
1285:  CALL   0F7
1286:  BSF    0A.4
*
1330:  BSF    03.6
1331:  CLRF   69
1332:  MOVLW  01
1333:  MOVWF  6A
1334:  BCF    0A.4
1335:  BCF    03.6
1336:  CALL   0F7
1337:  BSF    0A.4
*
13B1:  BSF    03.6
13B2:  CLRF   69
13B3:  MOVLW  01
13B4:  MOVWF  6A
13B5:  BCF    0A.4
13B6:  BCF    03.6
13B7:  CALL   0F7
13B8:  BSF    0A.4
*
1418:  BSF    03.6
1419:  CLRF   69
141A:  MOVLW  01
141B:  MOVWF  6A
141C:  BCF    0A.4
141D:  BCF    03.6
141E:  CALL   0F7
141F:  BSF    0A.4
*
14AD:  BSF    03.6
14AE:  CLRF   69
14AF:  MOVLW  01
14B0:  MOVWF  6A
14B1:  BCF    0A.4
14B2:  BCF    03.6
14B3:  CALL   0F7
14B4:  BSF    0A.4
*
1597:  BSF    03.6
1598:  CLRF   69
1599:  MOVLW  01
159A:  MOVWF  6A
159B:  BCF    0A.4
159C:  BCF    03.6
159D:  CALL   0F7
159E:  BSF    0A.4
*
1629:  BSF    03.6
162A:  CLRF   69
162B:  MOVLW  01
162C:  MOVWF  6A
162D:  BCF    0A.4
162E:  BCF    03.6
162F:  CALL   0F7
1630:  BSF    0A.4
*
1690:  BSF    03.6
1691:  CLRF   69
1692:  MOVLW  01
1693:  MOVWF  6A
1694:  BCF    0A.4
1695:  BCF    03.6
1696:  CALL   0F7
1697:  BSF    0A.4
....................                      delay_ms(2); 
*
047E:  MOVLW  02
047F:  BSF    03.6
0480:  MOVWF  65
0481:  BCF    03.6
0482:  CALL   204
*
04B9:  MOVLW  02
04BA:  BSF    03.6
04BB:  MOVWF  65
04BC:  BCF    03.6
04BD:  CALL   204
*
04F4:  MOVLW  02
04F5:  BSF    03.6
04F6:  MOVWF  65
04F7:  BCF    03.6
04F8:  CALL   204
*
056B:  MOVLW  02
056C:  BSF    03.6
056D:  MOVWF  65
056E:  BCF    03.6
056F:  CALL   204
*
05C6:  MOVLW  02
05C7:  BSF    03.6
05C8:  MOVWF  65
05C9:  BCF    03.6
05CA:  CALL   204
*
06B3:  MOVLW  02
06B4:  BSF    03.6
06B5:  MOVWF  65
06B6:  BCF    03.6
06B7:  CALL   204
*
070E:  MOVLW  02
070F:  BSF    03.6
0710:  MOVWF  65
0711:  BCF    03.6
0712:  CALL   204
*
0769:  MOVLW  02
076A:  BSF    03.6
076B:  MOVWF  65
076C:  BCF    03.6
076D:  CALL   204
*
0A42:  MOVLW  02
0A43:  BSF    03.6
0A44:  MOVWF  65
0A45:  BCF    0A.3
0A46:  BCF    03.6
0A47:  CALL   204
0A48:  BSF    0A.3
*
0C1B:  MOVLW  02
0C1C:  BSF    03.6
0C1D:  MOVWF  65
0C1E:  BCF    0A.3
0C1F:  BCF    03.6
0C20:  CALL   204
0C21:  BSF    0A.3
*
0C82:  MOVLW  02
0C83:  BSF    03.6
0C84:  MOVWF  65
0C85:  BCF    0A.3
0C86:  BCF    03.6
0C87:  CALL   204
0C88:  BSF    0A.3
*
0D33:  MOVLW  02
0D34:  BSF    03.6
0D35:  MOVWF  65
0D36:  BCF    0A.3
0D37:  BCF    03.6
0D38:  CALL   204
0D39:  BSF    0A.3
*
1064:  MOVLW  02
1065:  BSF    03.6
1066:  MOVWF  65
1067:  BCF    0A.4
1068:  BCF    03.6
1069:  CALL   204
106A:  BSF    0A.4
*
10CB:  MOVLW  02
10CC:  BSF    03.6
10CD:  MOVWF  65
10CE:  BCF    0A.4
10CF:  BCF    03.6
10D0:  CALL   204
10D1:  BSF    0A.4
*
117C:  MOVLW  02
117D:  BSF    03.6
117E:  MOVWF  65
117F:  BCF    0A.4
1180:  BCF    03.6
1181:  CALL   204
1182:  BSF    0A.4
*
1220:  MOVLW  02
1221:  BSF    03.6
1222:  MOVWF  65
1223:  BCF    0A.4
1224:  BCF    03.6
1225:  CALL   204
1226:  BSF    0A.4
*
1287:  MOVLW  02
1288:  BSF    03.6
1289:  MOVWF  65
128A:  BCF    0A.4
128B:  BCF    03.6
128C:  CALL   204
128D:  BSF    0A.4
*
1338:  MOVLW  02
1339:  BSF    03.6
133A:  MOVWF  65
133B:  BCF    0A.4
133C:  BCF    03.6
133D:  CALL   204
133E:  BSF    0A.4
*
13B9:  MOVLW  02
13BA:  BSF    03.6
13BB:  MOVWF  65
13BC:  BCF    0A.4
13BD:  BCF    03.6
13BE:  CALL   204
13BF:  BSF    0A.4
*
1420:  MOVLW  02
1421:  BSF    03.6
1422:  MOVWF  65
1423:  BCF    0A.4
1424:  BCF    03.6
1425:  CALL   204
1426:  BSF    0A.4
*
14B5:  MOVLW  02
14B6:  BSF    03.6
14B7:  MOVWF  65
14B8:  BCF    0A.4
14B9:  BCF    03.6
14BA:  CALL   204
14BB:  BSF    0A.4
*
159F:  MOVLW  02
15A0:  BSF    03.6
15A1:  MOVWF  65
15A2:  BCF    0A.4
15A3:  BCF    03.6
15A4:  CALL   204
15A5:  BSF    0A.4
*
1631:  MOVLW  02
1632:  BSF    03.6
1633:  MOVWF  65
1634:  BCF    0A.4
1635:  BCF    03.6
1636:  CALL   204
1637:  BSF    0A.4
*
1698:  MOVLW  02
1699:  BSF    03.6
169A:  MOVWF  65
169B:  BCF    0A.4
169C:  BCF    03.6
169D:  CALL   204
169E:  BSF    0A.4
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
*
0483:  GOTO   49A
*
04BE:  GOTO   4D5
*
04F9:  GOTO   510
*
0570:  GOTO   587
*
05CB:  GOTO   5E2
*
06B8:  GOTO   6CF
*
0713:  GOTO   72A
*
076E:  GOTO   785
*
0A49:  GOTO   266
*
0C22:  GOTO   43F
*
0C89:  GOTO   4A6
*
0D3A:  GOTO   557
*
106B:  GOTO   088
*
10D2:  GOTO   0EF
*
1183:  GOTO   1A0
*
1227:  GOTO   244
*
128E:  GOTO   2AB
*
133F:  GOTO   35C
*
13C0:  GOTO   3DD
*
1427:  GOTO   444
*
14BC:  GOTO   4D9
*
15A6:  GOTO   5C3
*
1638:  GOTO   655
*
169F:  GOTO   6BC
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
*
0484:  MOVLW  01
0485:  BSF    03.6
0486:  MOVWF  65
0487:  MOVLW  02
0488:  MOVWF  66
0489:  BCF    03.6
048A:  CALL   1F0
048B:  GOTO   49A
*
04BF:  MOVLW  01
04C0:  BSF    03.6
04C1:  MOVWF  65
04C2:  MOVLW  02
04C3:  MOVWF  66
04C4:  BCF    03.6
04C5:  CALL   1F0
04C6:  GOTO   4D5
*
04FA:  MOVLW  01
04FB:  BSF    03.6
04FC:  MOVWF  65
04FD:  MOVLW  02
04FE:  MOVWF  66
04FF:  BCF    03.6
0500:  CALL   1F0
0501:  GOTO   510
*
0571:  MOVLW  01
0572:  BSF    03.6
0573:  MOVWF  65
0574:  MOVLW  02
0575:  MOVWF  66
0576:  BCF    03.6
0577:  CALL   1F0
0578:  GOTO   587
*
05CC:  MOVLW  01
05CD:  BSF    03.6
05CE:  MOVWF  65
05CF:  MOVLW  02
05D0:  MOVWF  66
05D1:  BCF    03.6
05D2:  CALL   1F0
05D3:  GOTO   5E2
*
06B9:  MOVLW  01
06BA:  BSF    03.6
06BB:  MOVWF  65
06BC:  MOVLW  02
06BD:  MOVWF  66
06BE:  BCF    03.6
06BF:  CALL   1F0
06C0:  GOTO   6CF
*
0714:  MOVLW  01
0715:  BSF    03.6
0716:  MOVWF  65
0717:  MOVLW  02
0718:  MOVWF  66
0719:  BCF    03.6
071A:  CALL   1F0
071B:  GOTO   72A
*
076F:  MOVLW  01
0770:  BSF    03.6
0771:  MOVWF  65
0772:  MOVLW  02
0773:  MOVWF  66
0774:  BCF    03.6
0775:  CALL   1F0
0776:  GOTO   785
*
0A4A:  MOVLW  01
0A4B:  BSF    03.6
0A4C:  MOVWF  65
0A4D:  MOVLW  02
0A4E:  MOVWF  66
0A4F:  BCF    0A.3
0A50:  BCF    03.6
0A51:  CALL   1F0
0A52:  BSF    0A.3
0A53:  GOTO   266
*
0C23:  MOVLW  01
0C24:  BSF    03.6
0C25:  MOVWF  65
0C26:  MOVLW  02
0C27:  MOVWF  66
0C28:  BCF    0A.3
0C29:  BCF    03.6
0C2A:  CALL   1F0
0C2B:  BSF    0A.3
0C2C:  GOTO   43F
*
0C8A:  MOVLW  01
0C8B:  BSF    03.6
0C8C:  MOVWF  65
0C8D:  MOVLW  02
0C8E:  MOVWF  66
0C8F:  BCF    0A.3
0C90:  BCF    03.6
0C91:  CALL   1F0
0C92:  BSF    0A.3
0C93:  GOTO   4A6
*
0D3B:  MOVLW  01
0D3C:  BSF    03.6
0D3D:  MOVWF  65
0D3E:  MOVLW  02
0D3F:  MOVWF  66
0D40:  BCF    0A.3
0D41:  BCF    03.6
0D42:  CALL   1F0
0D43:  BSF    0A.3
0D44:  GOTO   557
*
106C:  MOVLW  01
106D:  BSF    03.6
106E:  MOVWF  65
106F:  MOVLW  02
1070:  MOVWF  66
1071:  BCF    0A.4
1072:  BCF    03.6
1073:  CALL   1F0
1074:  BSF    0A.4
1075:  GOTO   088
*
10D3:  MOVLW  01
10D4:  BSF    03.6
10D5:  MOVWF  65
10D6:  MOVLW  02
10D7:  MOVWF  66
10D8:  BCF    0A.4
10D9:  BCF    03.6
10DA:  CALL   1F0
10DB:  BSF    0A.4
10DC:  GOTO   0EF
*
1184:  MOVLW  01
1185:  BSF    03.6
1186:  MOVWF  65
1187:  MOVLW  02
1188:  MOVWF  66
1189:  BCF    0A.4
118A:  BCF    03.6
118B:  CALL   1F0
118C:  BSF    0A.4
118D:  GOTO   1A0
*
1228:  MOVLW  01
1229:  BSF    03.6
122A:  MOVWF  65
122B:  MOVLW  02
122C:  MOVWF  66
122D:  BCF    0A.4
122E:  BCF    03.6
122F:  CALL   1F0
1230:  BSF    0A.4
1231:  GOTO   244
*
128F:  MOVLW  01
1290:  BSF    03.6
1291:  MOVWF  65
1292:  MOVLW  02
1293:  MOVWF  66
1294:  BCF    0A.4
1295:  BCF    03.6
1296:  CALL   1F0
1297:  BSF    0A.4
1298:  GOTO   2AB
*
1340:  MOVLW  01
1341:  BSF    03.6
1342:  MOVWF  65
1343:  MOVLW  02
1344:  MOVWF  66
1345:  BCF    0A.4
1346:  BCF    03.6
1347:  CALL   1F0
1348:  BSF    0A.4
1349:  GOTO   35C
*
13C1:  MOVLW  01
13C2:  BSF    03.6
13C3:  MOVWF  65
13C4:  MOVLW  02
13C5:  MOVWF  66
13C6:  BCF    0A.4
13C7:  BCF    03.6
13C8:  CALL   1F0
13C9:  BSF    0A.4
13CA:  GOTO   3DD
*
1428:  MOVLW  01
1429:  BSF    03.6
142A:  MOVWF  65
142B:  MOVLW  02
142C:  MOVWF  66
142D:  BCF    0A.4
142E:  BCF    03.6
142F:  CALL   1F0
1430:  BSF    0A.4
1431:  GOTO   444
*
14BD:  MOVLW  01
14BE:  BSF    03.6
14BF:  MOVWF  65
14C0:  MOVLW  02
14C1:  MOVWF  66
14C2:  BCF    0A.4
14C3:  BCF    03.6
14C4:  CALL   1F0
14C5:  BSF    0A.4
14C6:  GOTO   4D9
*
15A7:  MOVLW  01
15A8:  BSF    03.6
15A9:  MOVWF  65
15AA:  MOVLW  02
15AB:  MOVWF  66
15AC:  BCF    0A.4
15AD:  BCF    03.6
15AE:  CALL   1F0
15AF:  BSF    0A.4
15B0:  GOTO   5C3
*
1639:  MOVLW  01
163A:  BSF    03.6
163B:  MOVWF  65
163C:  MOVLW  02
163D:  MOVWF  66
163E:  BCF    0A.4
163F:  BCF    03.6
1640:  CALL   1F0
1641:  BSF    0A.4
1642:  GOTO   655
*
16A0:  MOVLW  01
16A1:  BSF    03.6
16A2:  MOVWF  65
16A3:  MOVLW  02
16A4:  MOVWF  66
16A5:  BCF    0A.4
16A6:  BCF    03.6
16A7:  CALL   1F0
16A8:  BSF    0A.4
16A9:  GOTO   6BC
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
*
048C:  BSF    03.6
048D:  CLRF   69
048E:  MOVLW  10
048F:  MOVWF  6A
0490:  BCF    03.6
0491:  CALL   0F7
0492:  GOTO   49A
*
04C7:  BSF    03.6
04C8:  CLRF   69
04C9:  MOVLW  10
04CA:  MOVWF  6A
04CB:  BCF    03.6
04CC:  CALL   0F7
04CD:  GOTO   4D5
*
0502:  BSF    03.6
0503:  CLRF   69
0504:  MOVLW  10
0505:  MOVWF  6A
0506:  BCF    03.6
0507:  CALL   0F7
0508:  GOTO   510
*
0579:  BSF    03.6
057A:  CLRF   69
057B:  MOVLW  10
057C:  MOVWF  6A
057D:  BCF    03.6
057E:  CALL   0F7
057F:  GOTO   587
*
05D4:  BSF    03.6
05D5:  CLRF   69
05D6:  MOVLW  10
05D7:  MOVWF  6A
05D8:  BCF    03.6
05D9:  CALL   0F7
05DA:  GOTO   5E2
*
06C1:  BSF    03.6
06C2:  CLRF   69
06C3:  MOVLW  10
06C4:  MOVWF  6A
06C5:  BCF    03.6
06C6:  CALL   0F7
06C7:  GOTO   6CF
*
071C:  BSF    03.6
071D:  CLRF   69
071E:  MOVLW  10
071F:  MOVWF  6A
0720:  BCF    03.6
0721:  CALL   0F7
0722:  GOTO   72A
*
0777:  BSF    03.6
0778:  CLRF   69
0779:  MOVLW  10
077A:  MOVWF  6A
077B:  BCF    03.6
077C:  CALL   0F7
077D:  GOTO   785
*
0A54:  BSF    03.6
0A55:  CLRF   69
0A56:  MOVLW  10
0A57:  MOVWF  6A
0A58:  BCF    0A.3
0A59:  BCF    03.6
0A5A:  CALL   0F7
0A5B:  BSF    0A.3
0A5C:  GOTO   266
*
0C2D:  BSF    03.6
0C2E:  CLRF   69
0C2F:  MOVLW  10
0C30:  MOVWF  6A
0C31:  BCF    0A.3
0C32:  BCF    03.6
0C33:  CALL   0F7
0C34:  BSF    0A.3
0C35:  GOTO   43F
*
0C94:  BSF    03.6
0C95:  CLRF   69
0C96:  MOVLW  10
0C97:  MOVWF  6A
0C98:  BCF    0A.3
0C99:  BCF    03.6
0C9A:  CALL   0F7
0C9B:  BSF    0A.3
0C9C:  GOTO   4A6
*
0D45:  BSF    03.6
0D46:  CLRF   69
0D47:  MOVLW  10
0D48:  MOVWF  6A
0D49:  BCF    0A.3
0D4A:  BCF    03.6
0D4B:  CALL   0F7
0D4C:  BSF    0A.3
0D4D:  GOTO   557
*
1076:  BSF    03.6
1077:  CLRF   69
1078:  MOVLW  10
1079:  MOVWF  6A
107A:  BCF    0A.4
107B:  BCF    03.6
107C:  CALL   0F7
107D:  BSF    0A.4
107E:  GOTO   088
*
10DD:  BSF    03.6
10DE:  CLRF   69
10DF:  MOVLW  10
10E0:  MOVWF  6A
10E1:  BCF    0A.4
10E2:  BCF    03.6
10E3:  CALL   0F7
10E4:  BSF    0A.4
10E5:  GOTO   0EF
*
118E:  BSF    03.6
118F:  CLRF   69
1190:  MOVLW  10
1191:  MOVWF  6A
1192:  BCF    0A.4
1193:  BCF    03.6
1194:  CALL   0F7
1195:  BSF    0A.4
1196:  GOTO   1A0
*
1232:  BSF    03.6
1233:  CLRF   69
1234:  MOVLW  10
1235:  MOVWF  6A
1236:  BCF    0A.4
1237:  BCF    03.6
1238:  CALL   0F7
1239:  BSF    0A.4
123A:  GOTO   244
*
1299:  BSF    03.6
129A:  CLRF   69
129B:  MOVLW  10
129C:  MOVWF  6A
129D:  BCF    0A.4
129E:  BCF    03.6
129F:  CALL   0F7
12A0:  BSF    0A.4
12A1:  GOTO   2AB
*
134A:  BSF    03.6
134B:  CLRF   69
134C:  MOVLW  10
134D:  MOVWF  6A
134E:  BCF    0A.4
134F:  BCF    03.6
1350:  CALL   0F7
1351:  BSF    0A.4
1352:  GOTO   35C
*
13CB:  BSF    03.6
13CC:  CLRF   69
13CD:  MOVLW  10
13CE:  MOVWF  6A
13CF:  BCF    0A.4
13D0:  BCF    03.6
13D1:  CALL   0F7
13D2:  BSF    0A.4
13D3:  GOTO   3DD
*
1432:  BSF    03.6
1433:  CLRF   69
1434:  MOVLW  10
1435:  MOVWF  6A
1436:  BCF    0A.4
1437:  BCF    03.6
1438:  CALL   0F7
1439:  BSF    0A.4
143A:  GOTO   444
*
14C7:  BSF    03.6
14C8:  CLRF   69
14C9:  MOVLW  10
14CA:  MOVWF  6A
14CB:  BCF    0A.4
14CC:  BCF    03.6
14CD:  CALL   0F7
14CE:  BSF    0A.4
14CF:  GOTO   4D9
*
15B1:  BSF    03.6
15B2:  CLRF   69
15B3:  MOVLW  10
15B4:  MOVWF  6A
15B5:  BCF    0A.4
15B6:  BCF    03.6
15B7:  CALL   0F7
15B8:  BSF    0A.4
15B9:  GOTO   5C3
*
1643:  BSF    03.6
1644:  CLRF   69
1645:  MOVLW  10
1646:  MOVWF  6A
1647:  BCF    0A.4
1648:  BCF    03.6
1649:  CALL   0F7
164A:  BSF    0A.4
164B:  GOTO   655
*
16AA:  BSF    03.6
16AB:  CLRF   69
16AC:  MOVLW  10
16AD:  MOVWF  6A
16AE:  BCF    0A.4
16AF:  BCF    03.6
16B0:  CALL   0F7
16B1:  BSF    0A.4
16B2:  GOTO   6BC
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
*
0493:  MOVLW  01
0494:  BSF    03.6
0495:  MOVWF  69
0496:  MOVF   64,W
0497:  MOVWF  6A
0498:  BCF    03.6
0499:  CALL   0F7
*
04CE:  MOVLW  01
04CF:  BSF    03.6
04D0:  MOVWF  69
04D1:  MOVF   64,W
04D2:  MOVWF  6A
04D3:  BCF    03.6
04D4:  CALL   0F7
*
0509:  MOVLW  01
050A:  BSF    03.6
050B:  MOVWF  69
050C:  MOVF   64,W
050D:  MOVWF  6A
050E:  BCF    03.6
050F:  CALL   0F7
*
0580:  MOVLW  01
0581:  BSF    03.6
0582:  MOVWF  69
0583:  MOVF   64,W
0584:  MOVWF  6A
0585:  BCF    03.6
0586:  CALL   0F7
*
05DB:  MOVLW  01
05DC:  BSF    03.6
05DD:  MOVWF  69
05DE:  MOVF   64,W
05DF:  MOVWF  6A
05E0:  BCF    03.6
05E1:  CALL   0F7
*
06C8:  MOVLW  01
06C9:  BSF    03.6
06CA:  MOVWF  69
06CB:  MOVF   64,W
06CC:  MOVWF  6A
06CD:  BCF    03.6
06CE:  CALL   0F7
*
0723:  MOVLW  01
0724:  BSF    03.6
0725:  MOVWF  69
0726:  MOVF   64,W
0727:  MOVWF  6A
0728:  BCF    03.6
0729:  CALL   0F7
*
077E:  MOVLW  01
077F:  BSF    03.6
0780:  MOVWF  69
0781:  MOVF   64,W
0782:  MOVWF  6A
0783:  BCF    03.6
0784:  CALL   0F7
*
0A5D:  MOVLW  01
0A5E:  BSF    03.6
0A5F:  MOVWF  69
0A60:  MOVF   64,W
0A61:  MOVWF  6A
0A62:  BCF    0A.3
0A63:  BCF    03.6
0A64:  CALL   0F7
0A65:  BSF    0A.3
*
0C36:  MOVLW  01
0C37:  BSF    03.6
0C38:  MOVWF  69
0C39:  MOVF   64,W
0C3A:  MOVWF  6A
0C3B:  BCF    0A.3
0C3C:  BCF    03.6
0C3D:  CALL   0F7
0C3E:  BSF    0A.3
*
0C9D:  MOVLW  01
0C9E:  BSF    03.6
0C9F:  MOVWF  69
0CA0:  MOVF   64,W
0CA1:  MOVWF  6A
0CA2:  BCF    0A.3
0CA3:  BCF    03.6
0CA4:  CALL   0F7
0CA5:  BSF    0A.3
*
0D4E:  MOVLW  01
0D4F:  BSF    03.6
0D50:  MOVWF  69
0D51:  MOVF   64,W
0D52:  MOVWF  6A
0D53:  BCF    0A.3
0D54:  BCF    03.6
0D55:  CALL   0F7
0D56:  BSF    0A.3
*
107F:  MOVLW  01
1080:  BSF    03.6
1081:  MOVWF  69
1082:  MOVF   64,W
1083:  MOVWF  6A
1084:  BCF    0A.4
1085:  BCF    03.6
1086:  CALL   0F7
1087:  BSF    0A.4
*
10E6:  MOVLW  01
10E7:  BSF    03.6
10E8:  MOVWF  69
10E9:  MOVF   64,W
10EA:  MOVWF  6A
10EB:  BCF    0A.4
10EC:  BCF    03.6
10ED:  CALL   0F7
10EE:  BSF    0A.4
*
1197:  MOVLW  01
1198:  BSF    03.6
1199:  MOVWF  69
119A:  MOVF   64,W
119B:  MOVWF  6A
119C:  BCF    0A.4
119D:  BCF    03.6
119E:  CALL   0F7
119F:  BSF    0A.4
*
123B:  MOVLW  01
123C:  BSF    03.6
123D:  MOVWF  69
123E:  MOVF   64,W
123F:  MOVWF  6A
1240:  BCF    0A.4
1241:  BCF    03.6
1242:  CALL   0F7
1243:  BSF    0A.4
*
12A2:  MOVLW  01
12A3:  BSF    03.6
12A4:  MOVWF  69
12A5:  MOVF   64,W
12A6:  MOVWF  6A
12A7:  BCF    0A.4
12A8:  BCF    03.6
12A9:  CALL   0F7
12AA:  BSF    0A.4
*
1353:  MOVLW  01
1354:  BSF    03.6
1355:  MOVWF  69
1356:  MOVF   64,W
1357:  MOVWF  6A
1358:  BCF    0A.4
1359:  BCF    03.6
135A:  CALL   0F7
135B:  BSF    0A.4
*
13D4:  MOVLW  01
13D5:  BSF    03.6
13D6:  MOVWF  69
13D7:  MOVF   64,W
13D8:  MOVWF  6A
13D9:  BCF    0A.4
13DA:  BCF    03.6
13DB:  CALL   0F7
13DC:  BSF    0A.4
*
143B:  MOVLW  01
143C:  BSF    03.6
143D:  MOVWF  69
143E:  MOVF   64,W
143F:  MOVWF  6A
1440:  BCF    0A.4
1441:  BCF    03.6
1442:  CALL   0F7
1443:  BSF    0A.4
*
14D0:  MOVLW  01
14D1:  BSF    03.6
14D2:  MOVWF  69
14D3:  MOVF   64,W
14D4:  MOVWF  6A
14D5:  BCF    0A.4
14D6:  BCF    03.6
14D7:  CALL   0F7
14D8:  BSF    0A.4
*
15BA:  MOVLW  01
15BB:  BSF    03.6
15BC:  MOVWF  69
15BD:  MOVF   64,W
15BE:  MOVWF  6A
15BF:  BCF    0A.4
15C0:  BCF    03.6
15C1:  CALL   0F7
15C2:  BSF    0A.4
*
164C:  MOVLW  01
164D:  BSF    03.6
164E:  MOVWF  69
164F:  MOVF   64,W
1650:  MOVWF  6A
1651:  BCF    0A.4
1652:  BCF    03.6
1653:  CALL   0F7
1654:  BSF    0A.4
*
16B3:  MOVLW  01
16B4:  BSF    03.6
16B5:  MOVWF  69
16B6:  MOVF   64,W
16B7:  MOVWF  6A
16B8:  BCF    0A.4
16B9:  BCF    03.6
16BA:  CALL   0F7
16BB:  BSF    0A.4
....................      #endif 
....................    } 
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0; 
.................... INT1 TT_CONFIG=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
0AB1:  CLRF   3D
.................... INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
0AB2:  CLRF   3E
.................... CHAR TT_DEVICE_CHAR[]=""; 
0AB3:  CLRF   3F
....................  
.................... //INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR *PACKAGE[]={"S","ID", "COMMAND" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
0AB4:  MOVLW  53
0AB5:  BSF    03.5
0AB6:  MOVWF  20
0AB7:  CLRF   21
0AB8:  MOVLW  49
0AB9:  MOVWF  22
0ABA:  MOVLW  44
0ABB:  MOVWF  23
0ABC:  CLRF   24
0ABD:  MOVLW  43
0ABE:  MOVWF  25
0ABF:  MOVLW  4F
0AC0:  MOVWF  26
0AC1:  MOVLW  4D
0AC2:  MOVWF  27
0AC3:  MOVWF  28
0AC4:  MOVLW  41
0AC5:  MOVWF  29
0AC6:  MOVLW  4E
0AC7:  MOVWF  2A
0AC8:  MOVLW  44
0AC9:  MOVWF  2B
0ACA:  CLRF   2C
0ACB:  MOVLW  4C
0ACC:  MOVWF  2D
0ACD:  MOVLW  45
0ACE:  MOVWF  2E
0ACF:  MOVLW  4E
0AD0:  MOVWF  2F
0AD1:  MOVLW  47
0AD2:  MOVWF  30
0AD3:  MOVLW  48
0AD4:  MOVWF  31
0AD5:  MOVLW  54
0AD6:  MOVWF  32
0AD7:  CLRF   33
0AD8:  MOVLW  44
0AD9:  MOVWF  34
0ADA:  MOVLW  41
0ADB:  MOVWF  35
0ADC:  MOVLW  54
0ADD:  MOVWF  36
0ADE:  MOVLW  41
0ADF:  MOVWF  37
0AE0:  MOVLW  31
0AE1:  MOVWF  38
0AE2:  CLRF   39
0AE3:  MOVLW  44
0AE4:  MOVWF  3A
0AE5:  MOVLW  41
0AE6:  MOVWF  3B
0AE7:  MOVLW  54
0AE8:  MOVWF  3C
0AE9:  MOVLW  41
0AEA:  MOVWF  3D
0AEB:  MOVLW  32
0AEC:  MOVWF  3E
0AED:  CLRF   3F
0AEE:  MOVLW  43
0AEF:  MOVWF  40
0AF0:  MOVLW  48
0AF1:  MOVWF  41
0AF2:  MOVLW  45
0AF3:  MOVWF  42
0AF4:  MOVLW  43
0AF5:  MOVWF  43
0AF6:  MOVLW  4B
0AF7:  MOVWF  44
0AF8:  MOVLW  53
0AF9:  MOVWF  45
0AFA:  MOVLW  55
0AFB:  MOVWF  46
0AFC:  MOVLW  4D
0AFD:  MOVWF  47
0AFE:  CLRF   48
0AFF:  MOVLW  23
0B00:  MOVWF  49
0B01:  CLRF   4A
0B02:  BCF    03.5
0B03:  CLRF   41
0B04:  MOVLW  A0
0B05:  MOVWF  40
0B06:  CLRF   43
0B07:  MOVLW  A2
0B08:  MOVWF  42
0B09:  CLRF   45
0B0A:  MOVLW  A5
0B0B:  MOVWF  44
0B0C:  CLRF   47
0B0D:  MOVLW  AD
0B0E:  MOVWF  46
0B0F:  CLRF   49
0B10:  MOVLW  B4
0B11:  MOVWF  48
0B12:  CLRF   4B
0B13:  MOVLW  BA
0B14:  MOVWF  4A
0B15:  CLRF   4D
0B16:  MOVLW  C0
0B17:  MOVWF  4C
0B18:  CLRF   4F
0B19:  MOVLW  C9
0B1A:  MOVWF  4E
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE","SENSOR","#"}; 
0B1B:  MOVLW  53
0B1C:  BSF    03.5
0B1D:  MOVWF  4B
0B1E:  CLRF   4C
0B1F:  MOVLW  49
0B20:  MOVWF  4D
0B21:  MOVLW  44
0B22:  MOVWF  4E
0B23:  CLRF   4F
0B24:  MOVLW  43
0B25:  MOVWF  50
0B26:  MOVLW  5F
0B27:  MOVWF  51
0B28:  MOVLW  46
0B29:  MOVWF  52
0B2A:  CLRF   53
0B2B:  MOVLW  4C
0B2C:  MOVWF  54
0B2D:  MOVLW  45
0B2E:  MOVWF  55
0B2F:  MOVLW  4E
0B30:  MOVWF  56
0B31:  MOVLW  47
0B32:  MOVWF  57
0B33:  MOVLW  48
0B34:  MOVWF  58
0B35:  MOVLW  54
0B36:  MOVWF  59
0B37:  CLRF   5A
0B38:  MOVLW  49
0B39:  MOVWF  5B
0B3A:  MOVLW  44
0B3B:  MOVWF  5C
0B3C:  MOVLW  5F
0B3D:  MOVWF  5D
0B3E:  CLRF   5E
0B3F:  MOVLW  44
0B40:  MOVWF  5F
0B41:  MOVLW  45
0B42:  MOVWF  60
0B43:  MOVLW  56
0B44:  MOVWF  61
0B45:  MOVLW  49
0B46:  MOVWF  62
0B47:  MOVLW  43
0B48:  MOVWF  63
0B49:  MOVLW  45
0B4A:  MOVWF  64
0B4B:  CLRF   65
0B4C:  MOVLW  53
0B4D:  MOVWF  66
0B4E:  MOVLW  45
0B4F:  MOVWF  67
0B50:  MOVLW  4E
0B51:  MOVWF  68
0B52:  MOVLW  53
0B53:  MOVWF  69
0B54:  MOVLW  4F
0B55:  MOVWF  6A
0B56:  MOVLW  52
0B57:  MOVWF  6B
0B58:  CLRF   6C
0B59:  MOVLW  23
0B5A:  MOVWF  6D
0B5B:  CLRF   6E
0B5C:  BCF    03.5
0B5D:  CLRF   51
0B5E:  MOVLW  CB
0B5F:  MOVWF  50
0B60:  CLRF   53
0B61:  MOVLW  CD
0B62:  MOVWF  52
0B63:  CLRF   55
0B64:  MOVLW  D0
0B65:  MOVWF  54
0B66:  CLRF   57
0B67:  MOVLW  D4
0B68:  MOVWF  56
0B69:  CLRF   59
0B6A:  MOVLW  DB
0B6B:  MOVWF  58
0B6C:  CLRF   5B
0B6D:  MOVLW  DF
0B6E:  MOVWF  5A
0B6F:  CLRF   5D
0B70:  MOVLW  E6
0B71:  MOVWF  5C
0B72:  CLRF   5F
0B73:  MOVLW  ED
0B74:  MOVWF  5E
.................... CHAR NHIETDO1[]="27"; 
0B75:  MOVLW  32
0B76:  MOVWF  60
0B77:  MOVLW  37
0B78:  MOVWF  61
0B79:  CLRF   62
.................... CHAR NHIETDO2[]="27"; 
0B7A:  MOVLW  32
0B7B:  MOVWF  63
0B7C:  MOVLW  37
0B7D:  MOVWF  64
0B7E:  CLRF   65
.................... CHAR ID_[]="0"; 
0B7F:  MOVLW  30
0B80:  MOVWF  66
0B81:  CLRF   67
.................... CHAR TEMP_CHAR[]="0"; 
0B82:  MOVWF  68
0B83:  CLRF   69
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;    
.................... //--------------------------------------------------------------------// 
.................... #INT_RDA 
.................... VOID NGAT() 
.................... { 
....................    KYTU[VT] = GETC (); 
*
0063:  MOVLW  10
0064:  ADDWF  6A,W
0065:  MOVWF  04
0066:  BSF    03.7
0067:  BTFSS  0C.5
0068:  GOTO   067
0069:  MOVF   1A,W
006A:  MOVWF  00
....................    IF (KYTU[VT] == ID_[0]) 
006B:  MOVLW  10
006C:  ADDWF  6A,W
006D:  MOVWF  04
006E:  BSF    03.7
006F:  MOVF   66,W
0070:  SUBWF  00,W
0071:  BTFSS  03.2
0072:  GOTO   075
....................    { 
....................       TTNHAN = 1; 
0073:  MOVLW  01
0074:  MOVWF  6B
....................    } 
....................  
....................    IF (KYTU[VT] == '.') 
0075:  MOVLW  10
0076:  ADDWF  6A,W
0077:  MOVWF  04
0078:  BSF    03.7
0079:  MOVF   00,W
007A:  SUBLW  2E
007B:  BTFSS  03.2
007C:  GOTO   086
....................    { 
....................        
....................       KYTU[VT] = '\0'; 
007D:  MOVLW  10
007E:  ADDWF  6A,W
007F:  MOVWF  04
0080:  BSF    03.7
0081:  CLRF   00
....................       VT = 0; 
0082:  CLRF   6A
....................       TTNHAN = 1; 
0083:  MOVLW  01
0084:  MOVWF  6B
....................    } 
0085:  GOTO   087
....................  
....................    ELSE 
....................    VT++; 
0086:  INCF   6A,F
0087:  BCF    0C.5
0088:  BCF    0A.3
0089:  BCF    0A.4
008A:  GOTO   031
.................... } 
....................  
.................... VOID CHON_ID() 
.................... { 
....................    TT_STT = 1; 
*
1006:  BSF    3C.2
1007:  CLRF   2B
1008:  BTFSC  0B.7
1009:  BSF    2B.7
100A:  BCF    0B.7
....................    LCD_GOTOXY (1, 1) ; 
100B:  MOVLW  01
100C:  BSF    03.6
100D:  MOVWF  65
100E:  MOVWF  66
100F:  BCF    0A.4
1010:  BCF    03.6
1011:  CALL   1F0
1012:  BSF    0A.4
1013:  BTFSC  2B.7
1014:  BSF    0B.7
1015:  CLRF   2B
1016:  BTFSC  0B.7
1017:  BSF    2B.7
1018:  BCF    0B.7
....................    DELAY_MS (10); 
1019:  MOVLW  0A
101A:  BSF    03.6
101B:  MOVWF  65
101C:  BCF    0A.4
101D:  BCF    03.6
101E:  CALL   204
101F:  BSF    0A.4
1020:  BTFSC  2B.7
1021:  BSF    0B.7
....................    PRINTF (LCD_PUTC, "CHON ID:  "); 
1022:  MOVLW  8B
1023:  BSF    03.6
1024:  MOVWF  0D
1025:  MOVLW  00
1026:  MOVWF  0F
....................    WHILE (TT_STT) 
*
10F8:  BCF    03.6
10F9:  BTFSS  3C.2
10FA:  GOTO   1C1
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
10FB:  BSF    03.5
10FC:  BSF    06.2
10FD:  BCF    03.5
10FE:  BTFSC  06.2
10FF:  GOTO   1C0
....................       { 
....................          ID_NODE ++; 
1100:  INCF   3A,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
1101:  MOVF   3A,W
1102:  SUBLW  0F
1103:  BTFSS  03.0
1104:  CLRF   3A
....................          DELAY_MS (300); 
1105:  MOVLW  02
1106:  BSF    03.6
1107:  MOVWF  2F
1108:  BCF    03.6
1109:  CLRF   2B
110A:  BTFSC  0B.7
110B:  BSF    2B.7
110C:  BCF    0B.7
110D:  MOVLW  96
110E:  BSF    03.6
110F:  MOVWF  65
1110:  BCF    0A.4
1111:  BCF    03.6
1112:  CALL   204
1113:  BSF    0A.4
1114:  BTFSC  2B.7
1115:  BSF    0B.7
1116:  BSF    03.6
1117:  DECFSZ 2F,F
1118:  GOTO   108
1119:  BCF    03.6
111A:  CLRF   2B
111B:  BTFSC  0B.7
111C:  BSF    2B.7
111D:  BCF    0B.7
....................          ITOA (ID_NODE, 10, ID_); 
111E:  BSF    03.6
111F:  CLRF   5B
1120:  CLRF   5A
1121:  CLRF   59
1122:  BCF    03.6
1123:  MOVF   3A,W
1124:  BSF    03.6
1125:  MOVWF  58
1126:  MOVLW  0A
1127:  MOVWF  5C
1128:  CLRF   5E
1129:  MOVLW  66
112A:  MOVWF  5D
112B:  BCF    0A.4
112C:  BCF    03.6
112D:  CALL   2AF
112E:  BSF    0A.4
112F:  BTFSC  2B.7
1130:  BSF    0B.7
1131:  CLRF   2B
1132:  BTFSC  0B.7
1133:  BSF    2B.7
1134:  BCF    0B.7
....................          LCD_GOTOXY (7, 2) ; 
1135:  MOVLW  07
1136:  BSF    03.6
1137:  MOVWF  65
1138:  MOVLW  02
1139:  MOVWF  66
113A:  BCF    0A.4
113B:  BCF    03.6
113C:  CALL   1F0
113D:  BSF    0A.4
113E:  BTFSC  2B.7
113F:  BSF    0B.7
1140:  CLRF   2B
1141:  BTFSC  0B.7
1142:  BSF    2B.7
1143:  BCF    0B.7
....................          DELAY_MS (10); 
1144:  MOVLW  0A
1145:  BSF    03.6
1146:  MOVWF  65
1147:  BCF    0A.4
1148:  BCF    03.6
1149:  CALL   204
114A:  BSF    0A.4
114B:  BTFSC  2B.7
114C:  BSF    0B.7
....................          PRINTF (LCD_PUTC, ID_); 
114D:  MOVLW  66
114E:  MOVWF  04
114F:  BCF    03.7
....................          DELAY_MS (1); 
*
11B2:  MOVLW  01
11B3:  BSF    03.6
11B4:  MOVWF  65
11B5:  BCF    0A.4
11B6:  BCF    03.6
11B7:  CALL   204
11B8:  BSF    0A.4
11B9:  BTFSC  2B.7
11BA:  BSF    0B.7
....................          OUTPUT_TOGGLE (PIN_D0); 
11BB:  BSF    03.5
11BC:  BCF    08.0
11BD:  MOVLW  01
11BE:  BCF    03.5
11BF:  XORWF  08,F
....................       } 
11C0:  GOTO   0F9
....................    } 
.................... } 
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_STT = 1; 
*
11C2:  BSF    3C.2
11C3:  CLRF   2B
11C4:  BTFSC  0B.7
11C5:  BSF    2B.7
11C6:  BCF    0B.7
....................    LCD_GOTOXY (1, 1) ; 
11C7:  MOVLW  01
11C8:  BSF    03.6
11C9:  MOVWF  65
11CA:  MOVWF  66
11CB:  BCF    0A.4
11CC:  BCF    03.6
11CD:  CALL   1F0
11CE:  BSF    0A.4
11CF:  BTFSC  2B.7
11D0:  BSF    0B.7
11D1:  CLRF   2B
11D2:  BTFSC  0B.7
11D3:  BSF    2B.7
11D4:  BCF    0B.7
....................    DELAY_MS (10); 
11D5:  MOVLW  0A
11D6:  BSF    03.6
11D7:  MOVWF  65
11D8:  BCF    0A.4
11D9:  BCF    03.6
11DA:  CALL   204
11DB:  BSF    0A.4
11DC:  BTFSC  2B.7
11DD:  BSF    0B.7
....................    PRINTF (LCD_PUTC, "CHON DEVICE:  "); 
11DE:  MOVLW  91
11DF:  BSF    03.6
11E0:  MOVWF  0D
11E1:  MOVLW  00
11E2:  MOVWF  0F
....................    WHILE (TT_STT) 
*
12B4:  BCF    03.6
12B5:  BTFSS  3C.2
12B6:  GOTO   5D2
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
12B7:  BSF    03.5
12B8:  BSF    06.2
12B9:  BCF    03.5
12BA:  BTFSC  06.2
12BB:  GOTO   4FA
....................       { 
....................          STT_DEVICE ++; 
12BC:  INCF   3B,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
12BD:  MOVF   3B,W
12BE:  SUBLW  07
12BF:  BTFSS  03.0
12C0:  CLRF   3B
....................          DELAY_MS (300); 
12C1:  MOVLW  02
12C2:  BSF    03.6
12C3:  MOVWF  2F
12C4:  BCF    03.6
12C5:  CLRF   2B
12C6:  BTFSC  0B.7
12C7:  BSF    2B.7
12C8:  BCF    0B.7
12C9:  MOVLW  96
12CA:  BSF    03.6
12CB:  MOVWF  65
12CC:  BCF    0A.4
12CD:  BCF    03.6
12CE:  CALL   204
12CF:  BSF    0A.4
12D0:  BTFSC  2B.7
12D1:  BSF    0B.7
12D2:  BSF    03.6
12D3:  DECFSZ 2F,F
12D4:  GOTO   2C4
12D5:  BCF    03.6
12D6:  CLRF   2B
12D7:  BTFSC  0B.7
12D8:  BSF    2B.7
12D9:  BCF    0B.7
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
12DA:  BSF    03.6
12DB:  CLRF   5B
12DC:  CLRF   5A
12DD:  CLRF   59
12DE:  BCF    03.6
12DF:  MOVF   3B,W
12E0:  BSF    03.6
12E1:  MOVWF  58
12E2:  MOVLW  0A
12E3:  MOVWF  5C
12E4:  CLRF   5E
12E5:  MOVLW  68
12E6:  MOVWF  5D
12E7:  BCF    0A.4
12E8:  BCF    03.6
12E9:  CALL   2AF
12EA:  BSF    0A.4
12EB:  BTFSC  2B.7
12EC:  BSF    0B.7
12ED:  CLRF   2B
12EE:  BTFSC  0B.7
12EF:  BSF    2B.7
12F0:  BCF    0B.7
....................          LCD_GOTOXY (7, 2) ; 
12F1:  MOVLW  07
12F2:  BSF    03.6
12F3:  MOVWF  65
12F4:  MOVLW  02
12F5:  MOVWF  66
12F6:  BCF    0A.4
12F7:  BCF    03.6
12F8:  CALL   1F0
12F9:  BSF    0A.4
12FA:  BTFSC  2B.7
12FB:  BSF    0B.7
12FC:  CLRF   2B
12FD:  BTFSC  0B.7
12FE:  BSF    2B.7
12FF:  BCF    0B.7
....................          DELAY_MS (10); 
1300:  MOVLW  0A
1301:  BSF    03.6
1302:  MOVWF  65
1303:  BCF    0A.4
1304:  BCF    03.6
1305:  CALL   204
1306:  BSF    0A.4
1307:  BTFSC  2B.7
1308:  BSF    0B.7
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
1309:  MOVLW  68
130A:  MOVWF  04
130B:  BCF    03.7
....................          DELAY_MS (1); 
*
136E:  MOVLW  01
136F:  BSF    03.6
1370:  MOVWF  65
1371:  BCF    0A.4
1372:  BCF    03.6
1373:  CALL   204
1374:  BSF    0A.4
1375:  BTFSC  2B.7
1376:  BSF    0B.7
....................          PRINTF (LCD_PUTC, " TT "); 
1377:  MOVLW  99
1378:  BSF    03.6
1379:  MOVWF  0D
137A:  MOVLW  00
137B:  MOVWF  0F
....................          DELAY_MS (1); 
*
1452:  MOVLW  01
1453:  BSF    03.6
1454:  MOVWF  65
1455:  BCF    0A.4
1456:  BCF    03.6
1457:  CALL   204
1458:  BSF    0A.4
1459:  BTFSC  2B.7
145A:  BSF    0B.7
145B:  CLRF   2B
145C:  BTFSC  0B.7
145D:  BSF    2B.7
145E:  BCF    0B.7
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
145F:  MOVF   3B,W
1460:  BSF    03.6
1461:  MOVWF  61
1462:  CLRF   63
1463:  MOVLW  3D
1464:  MOVWF  62
1465:  BCF    0A.4
1466:  BCF    03.6
1467:  CALL   218
1468:  BSF    0A.4
1469:  BTFSC  2B.7
146A:  BSF    0B.7
146B:  MOVLW  00
146C:  BTFSC  78.0
146D:  MOVLW  01
146E:  BSF    03.6
146F:  MOVWF  2F
1470:  BCF    03.6
1471:  CLRF   2B
1472:  BTFSC  0B.7
1473:  BSF    2B.7
1474:  BCF    0B.7
1475:  BSF    03.6
1476:  CLRF   5B
1477:  CLRF   5A
1478:  CLRF   59
1479:  MOVF   2F,W
147A:  MOVWF  58
147B:  MOVLW  0A
147C:  MOVWF  5C
147D:  CLRF   5E
147E:  MOVLW  68
147F:  MOVWF  5D
1480:  BCF    0A.4
1481:  BCF    03.6
1482:  CALL   2AF
1483:  BSF    0A.4
1484:  BTFSC  2B.7
1485:  BSF    0B.7
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
1486:  MOVLW  68
1487:  MOVWF  04
1488:  BCF    03.7
....................          DELAY_MS (1);          
*
14EB:  MOVLW  01
14EC:  BSF    03.6
14ED:  MOVWF  65
14EE:  BCF    0A.4
14EF:  BCF    03.6
14F0:  CALL   204
14F1:  BSF    0A.4
14F2:  BTFSC  2B.7
14F3:  BSF    0B.7
....................          OUTPUT_TOGGLE (PIN_D0); 
14F4:  BSF    03.5
14F5:  BCF    08.0
14F6:  MOVLW  01
14F7:  BCF    03.5
14F8:  XORWF  08,F
....................       } 
14F9:  GOTO   5D1
....................       ELSE IF (!INPUT (BT3_PIN)) 
14FA:  BSF    03.5
14FB:  BSF    06.3
14FC:  BCF    03.5
14FD:  BTFSC  06.3
14FE:  GOTO   5D1
14FF:  CLRF   2B
1500:  BTFSC  0B.7
1501:  BSF    2B.7
1502:  BCF    0B.7
....................       { 
....................          TT_DEVICE[STT_DEVICE] =  ~TT_DEVICE[STT_DEVICE] ; 
1503:  MOVF   3B,W
1504:  BSF    03.6
1505:  MOVWF  61
1506:  CLRF   63
1507:  MOVLW  3D
1508:  MOVWF  62
1509:  BCF    0A.4
150A:  BCF    03.6
150B:  CALL   218
150C:  BSF    0A.4
150D:  BTFSC  2B.7
150E:  BSF    0B.7
150F:  MOVLW  00
1510:  BTFSS  78.0
1511:  MOVLW  01
1512:  BSF    03.6
1513:  MOVWF  2F
1514:  BCF    03.6
1515:  MOVF   3B,W
1516:  BSF    03.6
1517:  MOVWF  30
1518:  MOVF   2F,W
1519:  MOVWF  31
151A:  CLRF   33
151B:  MOVLW  3D
151C:  MOVWF  32
151D:  BCF    0A.4
151E:  BCF    03.6
151F:  GOTO   7A5
1520:  BSF    0A.4
1521:  CLRF   2B
1522:  BTFSC  0B.7
1523:  BSF    2B.7
1524:  BCF    0B.7
....................          LCD_GOTOXY (12, 2) ;          
1525:  MOVLW  0C
1526:  BSF    03.6
1527:  MOVWF  65
1528:  MOVLW  02
1529:  MOVWF  66
152A:  BCF    0A.4
152B:  BCF    03.6
152C:  CALL   1F0
152D:  BSF    0A.4
152E:  BTFSC  2B.7
152F:  BSF    0B.7
....................          DELAY_MS (300); 
1530:  MOVLW  02
1531:  BSF    03.6
1532:  MOVWF  2F
1533:  BCF    03.6
1534:  CLRF   2B
1535:  BTFSC  0B.7
1536:  BSF    2B.7
1537:  BCF    0B.7
1538:  MOVLW  96
1539:  BSF    03.6
153A:  MOVWF  65
153B:  BCF    0A.4
153C:  BCF    03.6
153D:  CALL   204
153E:  BSF    0A.4
153F:  BTFSC  2B.7
1540:  BSF    0B.7
1541:  BSF    03.6
1542:  DECFSZ 2F,F
1543:  GOTO   533
1544:  BCF    03.6
1545:  CLRF   2B
1546:  BTFSC  0B.7
1547:  BSF    2B.7
1548:  BCF    0B.7
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
1549:  MOVF   3B,W
154A:  BSF    03.6
154B:  MOVWF  61
154C:  CLRF   63
154D:  MOVLW  3D
154E:  MOVWF  62
154F:  BCF    0A.4
1550:  BCF    03.6
1551:  CALL   218
1552:  BSF    0A.4
1553:  BTFSC  2B.7
1554:  BSF    0B.7
1555:  MOVLW  00
1556:  BTFSC  78.0
1557:  MOVLW  01
1558:  BSF    03.6
1559:  MOVWF  2F
155A:  BCF    03.6
155B:  CLRF   2B
155C:  BTFSC  0B.7
155D:  BSF    2B.7
155E:  BCF    0B.7
155F:  BSF    03.6
1560:  CLRF   5B
1561:  CLRF   5A
1562:  CLRF   59
1563:  MOVF   2F,W
1564:  MOVWF  58
1565:  MOVLW  0A
1566:  MOVWF  5C
1567:  CLRF   5E
1568:  MOVLW  68
1569:  MOVWF  5D
156A:  BCF    0A.4
156B:  BCF    03.6
156C:  CALL   2AF
156D:  BSF    0A.4
156E:  BTFSC  2B.7
156F:  BSF    0B.7
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
1570:  MOVLW  68
1571:  MOVWF  04
1572:  BCF    03.7
....................       } 
*
15D1:  GOTO   2B5
....................        
....................    }    
....................     
.................... } 
.................... VOID RESET_CONFIG() 
.................... { 
....................    ID_NODE = 0; 
*
16C7:  CLRF   3A
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_FUN = 0; 
*
0799:  BCF    3C.1
....................    TT_STT = 0; 
079A:  BCF    3C.2
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    SWITCH (CONFIG_FUN) 
*
1000:  MOVF   39,W
1001:  ADDLW  FC
1002:  BTFSC  03.0
1003:  GOTO   6C8
1004:  ADDLW  04
1005:  GOTO   6CB
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
11C1:  GOTO   6C8
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE(); 
....................  
....................       BREAK; 
*
15D2:  GOTO   6C8
....................       CASE 2: 
15D3:  CLRF   2B
15D4:  BTFSC  0B.7
15D5:  BSF    2B.7
15D6:  BCF    0B.7
....................       //CONFIG_SENSOR (); 
....................        
....................       LCD_GOTOXY (10, 2) ; 
15D7:  MOVLW  0A
15D8:  BSF    03.6
15D9:  MOVWF  65
15DA:  MOVLW  02
15DB:  MOVWF  66
15DC:  BCF    0A.4
15DD:  BCF    03.6
15DE:  CALL   1F0
15DF:  BSF    0A.4
15E0:  BTFSC  2B.7
15E1:  BSF    0B.7
15E2:  CLRF   2B
15E3:  BTFSC  0B.7
15E4:  BSF    2B.7
15E5:  BCF    0B.7
....................       DELAY_MS (10); 
15E6:  MOVLW  0A
15E7:  BSF    03.6
15E8:  MOVWF  65
15E9:  BCF    0A.4
15EA:  BCF    03.6
15EB:  CALL   204
15EC:  BSF    0A.4
15ED:  BTFSC  2B.7
15EE:  BSF    0B.7
....................       PRINTF (LCD_PUTC, "CASE1"); 
15EF:  MOVLW  9C
15F0:  BSF    03.6
15F1:  MOVWF  0D
15F2:  MOVLW  00
15F3:  MOVWF  0F
....................       BREAK; 
*
16C5:  BCF    03.6
16C6:  GOTO   6C8
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
16C8:  BSF    0A.3
16C9:  BCF    0A.4
16CA:  GOTO   569 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0BBD:  BSF    3C.1
0BBE:  CLRF   2B
0BBF:  BTFSC  0B.7
0BC0:  BSF    2B.7
0BC1:  BCF    0B.7
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 1) ; 
0BC2:  MOVLW  01
0BC3:  BSF    03.6
0BC4:  MOVWF  65
0BC5:  MOVWF  66
0BC6:  BCF    0A.3
0BC7:  BCF    03.6
0BC8:  CALL   1F0
0BC9:  BSF    0A.3
0BCA:  BTFSC  2B.7
0BCB:  BSF    0B.7
0BCC:  CLRF   2B
0BCD:  BTFSC  0B.7
0BCE:  BSF    2B.7
0BCF:  BCF    0B.7
....................    DELAY_MS (10); 
0BD0:  MOVLW  0A
0BD1:  BSF    03.6
0BD2:  MOVWF  65
0BD3:  BCF    0A.3
0BD4:  BCF    03.6
0BD5:  CALL   204
0BD6:  BSF    0A.3
0BD7:  BTFSC  2B.7
0BD8:  BSF    0B.7
....................    PRINTF (LCD_PUTC, "CASE: "); 
0BD9:  MOVLW  9F
0BDA:  BSF    03.6
0BDB:  MOVWF  0D
0BDC:  MOVLW  00
0BDD:  MOVWF  0F
....................    WHILE (TT_FUN) 
*
0CAF:  BCF    03.6
0CB0:  BTFSS  3C.1
0CB1:  GOTO   566
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0CB2:  BSF    03.5
0CB3:  BSF    06.2
0CB4:  BCF    03.5
0CB5:  BTFSC  06.2
0CB6:  GOTO   565
....................       { 
....................          CONFIG_FUN ++; 
0CB7:  INCF   39,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0CB8:  MOVF   39,W
0CB9:  SUBLW  03
0CBA:  BTFSS  03.0
0CBB:  CLRF   39
....................          DELAY_MS (300); 
0CBC:  MOVLW  02
0CBD:  BSF    03.6
0CBE:  MOVWF  2F
0CBF:  BCF    03.6
0CC0:  CLRF   2B
0CC1:  BTFSC  0B.7
0CC2:  BSF    2B.7
0CC3:  BCF    0B.7
0CC4:  MOVLW  96
0CC5:  BSF    03.6
0CC6:  MOVWF  65
0CC7:  BCF    0A.3
0CC8:  BCF    03.6
0CC9:  CALL   204
0CCA:  BSF    0A.3
0CCB:  BTFSC  2B.7
0CCC:  BSF    0B.7
0CCD:  BSF    03.6
0CCE:  DECFSZ 2F,F
0CCF:  GOTO   4BF
0CD0:  BCF    03.6
0CD1:  CLRF   2B
0CD2:  BTFSC  0B.7
0CD3:  BSF    2B.7
0CD4:  BCF    0B.7
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (7, 2) ; 
0CD5:  MOVLW  07
0CD6:  BSF    03.6
0CD7:  MOVWF  65
0CD8:  MOVLW  02
0CD9:  MOVWF  66
0CDA:  BCF    0A.3
0CDB:  BCF    03.6
0CDC:  CALL   1F0
0CDD:  BSF    0A.3
0CDE:  BTFSC  2B.7
0CDF:  BSF    0B.7
0CE0:  CLRF   2B
0CE1:  BTFSC  0B.7
0CE2:  BSF    2B.7
0CE3:  BCF    0B.7
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0CE4:  BSF    03.6
0CE5:  CLRF   5B
0CE6:  CLRF   5A
0CE7:  CLRF   59
0CE8:  BCF    03.6
0CE9:  MOVF   39,W
0CEA:  BSF    03.6
0CEB:  MOVWF  58
0CEC:  MOVLW  0A
0CED:  MOVWF  5C
0CEE:  CLRF   5E
0CEF:  MOVLW  68
0CF0:  MOVWF  5D
0CF1:  BCF    0A.3
0CF2:  BCF    03.6
0CF3:  CALL   2AF
0CF4:  BSF    0A.3
0CF5:  BTFSC  2B.7
0CF6:  BSF    0B.7
0CF7:  CLRF   2B
0CF8:  BTFSC  0B.7
0CF9:  BSF    2B.7
0CFA:  BCF    0B.7
....................          DELAY_MS (10); 
0CFB:  MOVLW  0A
0CFC:  BSF    03.6
0CFD:  MOVWF  65
0CFE:  BCF    0A.3
0CFF:  BCF    03.6
0D00:  CALL   204
0D01:  BSF    0A.3
0D02:  BTFSC  2B.7
0D03:  BSF    0B.7
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0D04:  MOVLW  68
0D05:  MOVWF  04
0D06:  BCF    03.7
....................       } 
*
0D65:  GOTO   4B0
....................    } 
....................  
....................    SELLECT_FUN (); 
0D66:  BSF    0A.4
0D67:  BCF    0A.3
0D68:  GOTO   000
0D69:  BCF    0A.4
0D6A:  BSF    0A.3
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    IF ( ! TT_CONFIG) 
*
05EB:  BCF    03.6
05EC:  BTFSC  3C.0
05ED:  GOTO   796
....................    { 
....................       TT_DEVICE_CHAR=""; 
05EE:  BSF    03.6
05EF:  CLRF   58
05F0:  CLRF   59
05F1:  MOVLW  3F
05F2:  MOVWF  04
05F3:  BCF    03.7
05F4:  MOVF   58,W
05F5:  ADDWF  04,F
05F6:  MOVF   59,W
05F7:  BCF    03.6
05F8:  CALL   058
05F9:  MOVWF  00
05FA:  IORLW  00
05FB:  BTFSC  03.2
05FC:  GOTO   602
05FD:  BSF    03.6
05FE:  INCF   59,F
05FF:  INCF   58,F
0600:  GOTO   5F1
0601:  BCF    03.6
....................       FOR (INT I = 0; I <8; I++)       
0602:  BSF    03.6
0603:  CLRF   56
0604:  MOVF   56,W
0605:  SUBLW  07
0606:  BTFSS  03.0
0607:  GOTO   62A
....................       { 
....................          IF (TT_DEVICE[I]){ 
0608:  MOVF   56,W
0609:  MOVWF  61
060A:  CLRF   63
060B:  MOVLW  3D
060C:  MOVWF  62
060D:  BCF    03.6
060E:  CALL   218
060F:  BTFSS  78.0
0610:  GOTO   627
....................             ITOA (I, 10, TEMP_CHAR); 
0611:  BSF    03.6
0612:  CLRF   5B
0613:  CLRF   5A
0614:  CLRF   59
0615:  MOVF   56,W
0616:  MOVWF  58
0617:  MOVLW  0A
0618:  MOVWF  5C
0619:  CLRF   5E
061A:  MOVLW  68
061B:  MOVWF  5D
061C:  BCF    03.6
061D:  CALL   2AF
....................             STRCAT(TT_DEVICE_CHAR, TEMP_CHAR); 
061E:  BSF    03.6
061F:  CLRF   59
0620:  MOVLW  3F
0621:  MOVWF  58
0622:  CLRF   5B
0623:  MOVLW  68
0624:  MOVWF  5A
0625:  BCF    03.6
0626:  CALL   3F3
....................          } 
0627:  BSF    03.6
0628:  INCF   56,F
0629:  GOTO   604
....................        
....................       } 
....................       TEMP_CHAR="*"; 
062A:  CLRF   58
062B:  CLRF   59
062C:  MOVLW  68
062D:  MOVWF  04
062E:  BCF    03.7
062F:  MOVF   58,W
0630:  ADDWF  04,F
0631:  MOVF   59,W
0632:  BCF    03.6
0633:  CALL   05D
0634:  MOVWF  00
0635:  IORLW  00
0636:  BTFSC  03.2
0637:  GOTO   63D
0638:  BSF    03.6
0639:  INCF   59,F
063A:  INCF   58,F
063B:  GOTO   62C
063C:  BCF    03.6
....................       STRCAT(TT_DEVICE_CHAR, TEMP_CHAR ); 
063D:  BSF    03.6
063E:  CLRF   59
063F:  MOVLW  3F
0640:  MOVWF  58
0641:  CLRF   5B
0642:  MOVLW  68
0643:  MOVWF  5A
0644:  BCF    03.6
0645:  CALL   3F3
....................       PACKAGE_CONFIG[5]=TT_DEVICE_CHAR; 
0646:  CLRF   5B
0647:  MOVLW  3F
0648:  MOVWF  5A
....................       PACKAGE_CONFIG[1]=ID_; 
0649:  CLRF   53
064A:  MOVLW  66
064B:  MOVWF  52
....................        
....................       FOR (INT J = 0; J < 8; J++) 
064C:  BSF    03.6
064D:  CLRF   57
064E:  MOVF   57,W
064F:  SUBLW  07
0650:  BTFSS  03.0
0651:  GOTO   66B
....................       { 
....................         PRINTF (PACKAGE_CONFIG[J]); 
0652:  BCF    03.0
0653:  RLF    57,W
0654:  ADDLW  50
0655:  MOVWF  04
0656:  BCF    03.7
0657:  INCF   04,F
0658:  MOVF   00,W
0659:  MOVWF  59
065A:  DECF   04,F
065B:  MOVF   00,W
065C:  MOVWF  58
065D:  MOVWF  04
065E:  BCF    03.7
065F:  BTFSC  59.0
0660:  BSF    03.7
0661:  BCF    03.6
0662:  CALL   431
....................         DELAY_MS (1); 
0663:  MOVLW  01
0664:  BSF    03.6
0665:  MOVWF  65
0666:  BCF    03.6
0667:  CALL   204
0668:  BSF    03.6
0669:  INCF   57,F
066A:  GOTO   64E
....................       } 
....................        
....................       LCD_GOTOXY (1, 1) ; 
066B:  MOVLW  01
066C:  MOVWF  65
066D:  MOVWF  66
066E:  BCF    03.6
066F:  CALL   1F0
....................       DELAY_MS (10); 
0670:  MOVLW  0A
0671:  BSF    03.6
0672:  MOVWF  65
0673:  BCF    03.6
0674:  CALL   204
....................       PRINTF (LCD_PUTC, "CONFIG DONE"); 
0675:  MOVLW  A3
0676:  BSF    03.6
0677:  MOVWF  0D
0678:  MOVLW  00
0679:  MOVWF  0F
....................       LCD_GOTOXY (1, 2) ; 
*
0733:  MOVLW  01
0734:  MOVWF  65
0735:  MOVLW  02
0736:  MOVWF  66
0737:  BCF    03.6
0738:  CALL   1F0
....................       DELAY_MS (10); 
0739:  MOVLW  0A
073A:  BSF    03.6
073B:  MOVWF  65
073C:  BCF    03.6
073D:  CALL   204
....................       PRINTF (LCD_PUTC,TT_DEVICE_CHAR );       
073E:  MOVLW  3F
073F:  MOVWF  04
0740:  BCF    03.7
....................       PACKAGE[1] = ID_; 
*
0793:  CLRF   43
0794:  MOVLW  66
0795:  MOVWF  42
0796:  BSF    03.6
....................    } 
.................... } 
....................  
.................... VOID QUET_PHIM() 
.................... { 
....................     
....................    IF (INPUT (BT1_PIN) == 0) //NEU NUT BAM DUOC BAM 
*
044F:  BSF    03.5
0450:  BSF    06.1
0451:  BCF    03.5
0452:  BTFSC  06.1
0453:  GOTO   7A1
....................    { 
....................       LCD_GOTOXY (1, 1) ; 
0454:  MOVLW  01
0455:  BSF    03.6
0456:  MOVWF  65
0457:  MOVWF  66
0458:  BCF    03.6
0459:  CALL   1F0
....................       DELAY_MS (10); 
045A:  MOVLW  0A
045B:  BSF    03.6
045C:  MOVWF  65
045D:  BCF    03.6
045E:  CALL   204
....................       PRINTF (LCD_PUTC, "BT1"); 
045F:  MOVLW  42
0460:  BSF    03.6
0461:  MOVWF  64
*
049A:  MOVLW  54
049B:  BSF    03.6
049C:  MOVWF  64
*
04D5:  MOVLW  31
04D6:  BSF    03.6
04D7:  MOVWF  64
....................       FOR (INT I = 0; I < 5; I++) // SAU 10S VAN CON NHAN NUT 
*
0510:  BSF    03.6
0511:  CLRF   55
0512:  MOVF   55,W
0513:  SUBLW  04
0514:  BTFSS  03.0
0515:  GOTO   7A0
....................       { 
....................          IF (INPUT (BT1_PIN) == 0) 
0516:  BSF    03.5
0517:  BCF    03.6
0518:  BSF    06.1
0519:  BCF    03.5
051A:  BTFSC  06.1
051B:  GOTO   799
....................          { 
....................             DELAY_MS (1000); 
051C:  MOVLW  04
051D:  BSF    03.6
051E:  MOVWF  56
051F:  MOVLW  FA
0520:  MOVWF  65
0521:  BCF    03.6
0522:  CALL   204
0523:  BSF    03.6
0524:  DECFSZ 56,F
0525:  GOTO   51F
....................             IF (I == 4) 
0526:  MOVF   55,W
0527:  SUBLW  04
0528:  BTFSS  03.2
0529:  GOTO   797
....................             { 
....................                //CONFIG NODE 
....................                TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
052A:  MOVLW  01
052B:  BCF    03.6
052C:  XORWF  3C,F
....................                PRINTF (LCD_PUTC, "-- > CONFIG"); 
052D:  MOVLW  A9
052E:  BSF    03.6
052F:  MOVWF  0D
0530:  MOVLW  00
0531:  MOVWF  0F
....................                CONFIG_DONE () ; 
....................             } 
....................          } 
*
0797:  GOTO   79E
0798:  BCF    03.6
....................  
....................          ELSE // NHAN NUT < 10S 
....................          { 
....................             BUTT_OKE (); //OKE 
....................             I = 10; // THOAT FOR 
*
079B:  MOVLW  0A
079C:  BSF    03.6
079D:  MOVWF  55
....................          } 
079E:  INCF   55,F
079F:  GOTO   512
07A0:  BCF    03.6
....................       } 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
07A1:  BCF    0B.1
07A2:  BCF    0A.3
07A3:  BCF    0A.4
07A4:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD  () 
*
09F8:  CLRF   2B
09F9:  BTFSC  0B.7
09FA:  BSF    2B.7
09FB:  BCF    0B.7
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
09FC:  MOVLW  01
09FD:  BSF    03.6
09FE:  MOVWF  65
09FF:  MOVWF  66
0A00:  BCF    0A.3
0A01:  BCF    03.6
0A02:  CALL   1F0
0A03:  BSF    0A.3
0A04:  BTFSC  2B.7
0A05:  BSF    0B.7
0A06:  CLRF   2B
0A07:  BTFSC  0B.7
0A08:  BSF    2B.7
0A09:  BCF    0B.7
....................     DELAY_MS (10); 
0A0A:  MOVLW  0A
0A0B:  BSF    03.6
0A0C:  MOVWF  65
0A0D:  BCF    0A.3
0A0E:  BCF    03.6
0A0F:  CALL   204
0A10:  BSF    0A.3
0A11:  BTFSC  2B.7
0A12:  BSF    0B.7
....................     PRINTF (LCD_PUTC, KYTU); 
0A13:  MOVLW  10
0A14:  MOVWF  04
0A15:  BSF    03.7
....................     DELAY_MS (1); 
*
0A78:  MOVLW  01
0A79:  BSF    03.6
0A7A:  MOVWF  65
0A7B:  BCF    0A.3
0A7C:  BCF    03.6
0A7D:  CALL   204
0A7E:  BSF    0A.3
0A7F:  BTFSC  2B.7
0A80:  BSF    0B.7
0A81:  BSF    0A.3
0A82:  BCF    0A.4
0A83:  GOTO   5F6 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
089C:  BSF    03.6
089D:  RLF    2F,W
089E:  MOVWF  77
089F:  RLF    77,F
08A0:  MOVLW  FC
08A1:  ANDWF  77,F
08A2:  BCF    03.6
08A3:  MOVF   1F,W
08A4:  ANDLW  C3
08A5:  IORWF  77,W
08A6:  MOVWF  1F
....................     KQADC = 0; 
08A7:  CLRF   34
08A8:  CLRF   33
....................     FOR (INT I = 0; I < 100; I++) 
08A9:  BSF    03.6
08AA:  CLRF   30
08AB:  MOVF   30,W
08AC:  SUBLW  63
08AD:  BTFSS  03.0
08AE:  GOTO   0CB
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
08AF:  BCF    03.6
08B0:  BSF    1F.1
08B1:  BTFSC  1F.1
08B2:  GOTO   0B1
08B3:  BSF    03.5
08B4:  MOVF   1E,W
08B5:  BCF    03.5
08B6:  ADDWF  33,F
08B7:  MOVF   1E,W
08B8:  BTFSC  03.0
08B9:  INCFSZ 1E,W
08BA:  ADDWF  34,F
08BB:  CLRF   2B
08BC:  BTFSC  0B.7
08BD:  BSF    2B.7
08BE:  BCF    0B.7
....................        DELAY_MS (1); 
08BF:  MOVLW  01
08C0:  BSF    03.6
08C1:  MOVWF  65
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   204
08C5:  BSF    0A.3
08C6:  BTFSC  2B.7
08C7:  BSF    0B.7
08C8:  BSF    03.6
08C9:  INCF   30,F
08CA:  GOTO   0AB
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
08CB:  BCF    03.6
08CC:  MOVF   34,W
08CD:  BSF    03.6
08CE:  MOVWF  32
08CF:  BCF    03.6
08D0:  MOVF   33,W
08D1:  BSF    03.6
08D2:  MOVWF  31
*
08EF:  MOVF   7A,W
08F0:  MOVWF  34
08F1:  MOVF   79,W
08F2:  MOVWF  33
08F3:  MOVF   78,W
08F4:  MOVWF  32
08F5:  MOVF   77,W
08F6:  MOVWF  31
08F7:  MOVLW  9A
08F8:  MOVWF  38
08F9:  MOVLW  99
08FA:  MOVWF  37
08FB:  MOVLW  4C
08FC:  MOVWF  36
08FD:  MOVLW  86
08FE:  MOVWF  35
*
09C8:  MOVF   7A,W
09C9:  MOVWF  34
09CA:  MOVF   79,W
09CB:  MOVWF  33
09CC:  MOVF   78,W
09CD:  MOVWF  32
09CE:  MOVF   77,W
09CF:  MOVWF  31
*
09EE:  MOVF   79,W
09EF:  BCF    03.6
09F0:  MOVWF  34
09F1:  MOVF   78,W
09F2:  MOVWF  33
....................     RETURN KQADC; 
09F3:  MOVF   33,W
09F4:  MOVWF  78
09F5:  BSF    0A.3
09F6:  BCF    0A.4
09F7:  GOTO   3B8 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07C9:  BSF    03.6
07CA:  CLRF   2F
07CB:  MOVF   2F,W
07CC:  SUBLW  1E
07CD:  BTFSS  03.0
07CE:  GOTO   7E3
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07CF:  BSF    03.5
07D0:  BCF    03.6
07D1:  BCF    08.1
07D2:  MOVLW  02
07D3:  BCF    03.5
07D4:  XORWF  08,F
07D5:  CLRF   2B
07D6:  BTFSC  0B.7
07D7:  BSF    2B.7
07D8:  BCF    0B.7
....................        DELAY_MS (100); 
07D9:  MOVLW  64
07DA:  BSF    03.6
07DB:  MOVWF  65
07DC:  BCF    03.6
07DD:  CALL   204
07DE:  BTFSC  2B.7
07DF:  BSF    0B.7
07E0:  BSF    03.6
07E1:  INCF   2F,F
07E2:  GOTO   7CB
....................     } 
07E3:  BCF    03.6
07E4:  BSF    0A.3
07E5:  BCF    0A.4
07E6:  GOTO   56D (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0A84:  MOVF   03,W
0A85:  ANDLW  1F
0A86:  MOVWF  03
0A87:  BSF    03.5
0A88:  BSF    03.6
0A89:  BSF    07.3
0A8A:  MOVLW  08
0A8B:  BCF    03.6
0A8C:  MOVWF  19
0A8D:  MOVLW  02
0A8E:  MOVWF  1A
0A8F:  MOVLW  A6
0A90:  MOVWF  18
0A91:  MOVLW  90
0A92:  BCF    03.5
0A93:  MOVWF  18
0A94:  MOVLW  FF
0A95:  MOVWF  32
0A96:  CLRF   39
0A97:  CLRF   3A
0A98:  CLRF   3B
0A99:  BCF    3C.0
0A9A:  BCF    3C.1
0A9B:  BCF    3C.2
0A9C:  CLRF   6A
0A9D:  CLRF   6B
0A9E:  BSF    03.5
0A9F:  BSF    03.6
0AA0:  MOVF   09,W
0AA1:  ANDLW  C0
0AA2:  MOVWF  09
0AA3:  BCF    03.6
0AA4:  BCF    1F.4
0AA5:  BCF    1F.5
0AA6:  MOVLW  00
0AA7:  BSF    03.6
0AA8:  MOVWF  08
0AA9:  BCF    03.5
0AAA:  CLRF   07
0AAB:  CLRF   08
0AAC:  CLRF   09
0AAD:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0B84:  MOVLW  00
0B85:  BSF    03.5
0B86:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0B87:  MOVLW  FF
0B88:  MOVWF  06
....................     SET_TRIS_E (0); 
0B89:  BCF    09.0
0B8A:  BCF    09.1
0B8B:  BCF    09.2
0B8C:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0B8D:  MOVLW  80
0B8E:  MOVWF  07
0B8F:  BCF    03.5
0B90:  MOVWF  32
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0B91:  BSF    1F.6
0B92:  BCF    1F.7
0B93:  BSF    03.5
0B94:  BSF    1F.7
0B95:  BCF    03.5
0B96:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0B97:  BSF    03.5
0B98:  BSF    03.6
0B99:  MOVF   09,W
0B9A:  ANDLW  C0
0B9B:  MOVWF  09
0B9C:  BCF    03.6
0B9D:  BCF    1F.4
0B9E:  BCF    1F.5
0B9F:  MOVLW  01
0BA0:  BSF    03.6
0BA1:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_RDA); 
0BA2:  BCF    03.6
0BA3:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0BA4:  MOVLW  C0
0BA5:  BCF    03.5
0BA6:  IORWF  0B,F
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0BA7:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0BA8:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0BA9:  BSF    0B.4
0BAA:  BSF    03.5
0BAB:  BCF    01.6
....................     LCD_INIT (); // KHOI TAO LCD 
0BAC:  BCF    03.5
0BAD:  GOTO   000
....................     ID_NODE = 0; 
0BAE:  CLRF   3A
....................     TT_CONFIG = 0; 
0BAF:  BCF    3C.0
....................     OUTPUT_D(0X00); 
0BB0:  BSF    03.5
0BB1:  CLRF   08
0BB2:  BCF    03.5
0BB3:  CLRF   08
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0BB4:  BSF    03.6
0BB5:  CLRF   2F
0BB6:  BCF    03.6
0BB7:  GOTO   09C
0BB8:  CLRF   36
0BB9:  MOVF   78,W
0BBA:  MOVWF  35
....................        IF (TT_CONFIG) 
0BBB:  BTFSS  3C.0
0BBC:  GOTO   56B
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
....................        } 
....................  
....................        CHUONG_TRINH_CON (); 
*
0D6B:  BCF    0A.3
0D6C:  GOTO   7C9
0D6D:  BSF    0A.3
....................        IF (AN0 > 26) 
0D6E:  MOVF   36,F
0D6F:  BTFSS  03.2
0D70:  GOTO   575
0D71:  MOVF   35,W
0D72:  SUBLW  1A
0D73:  BTFSC  03.0
0D74:  GOTO   5F2
0D75:  CLRF   2B
0D76:  BTFSC  0B.7
0D77:  BSF    2B.7
0D78:  BCF    0B.7
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0D79:  BSF    03.6
0D7A:  CLRF   5B
0D7B:  CLRF   5A
0D7C:  BCF    03.6
0D7D:  MOVF   36,W
0D7E:  BSF    03.6
0D7F:  MOVWF  59
0D80:  BCF    03.6
0D81:  MOVF   35,W
0D82:  BSF    03.6
0D83:  MOVWF  58
0D84:  MOVLW  0A
0D85:  MOVWF  5C
0D86:  CLRF   5E
0D87:  MOVLW  60
0D88:  MOVWF  5D
0D89:  BCF    0A.3
0D8A:  BCF    03.6
0D8B:  CALL   2AF
0D8C:  BSF    0A.3
0D8D:  BTFSC  2B.7
0D8E:  BSF    0B.7
....................           PACKAGE[4] = NHIETDO1; 
0D8F:  CLRF   49
0D90:  MOVLW  60
0D91:  MOVWF  48
0D92:  CLRF   2B
0D93:  BTFSC  0B.7
0D94:  BSF    2B.7
0D95:  BCF    0B.7
....................           ITOA (AN1, 10, NHIETDO2); 
0D96:  BSF    03.6
0D97:  CLRF   5B
0D98:  CLRF   5A
0D99:  BCF    03.6
0D9A:  MOVF   38,W
0D9B:  BSF    03.6
0D9C:  MOVWF  59
0D9D:  BCF    03.6
0D9E:  MOVF   37,W
0D9F:  BSF    03.6
0DA0:  MOVWF  58
0DA1:  MOVLW  0A
0DA2:  MOVWF  5C
0DA3:  CLRF   5E
0DA4:  MOVLW  63
0DA5:  MOVWF  5D
0DA6:  BCF    0A.3
0DA7:  BCF    03.6
0DA8:  CALL   2AF
0DA9:  BSF    0A.3
0DAA:  BTFSC  2B.7
0DAB:  BSF    0B.7
....................           PACKAGE[5] = NHIETDO2; 
0DAC:  CLRF   4B
0DAD:  MOVLW  63
0DAE:  MOVWF  4A
....................            
....................           FOR (INT I = 0; I < 8; I++) 
0DAF:  BSF    03.6
0DB0:  CLRF   2E
0DB1:  MOVF   2E,W
0DB2:  SUBLW  07
0DB3:  BTFSS  03.0
0DB4:  GOTO   5DE
....................           { 
....................              PRINTF (PACKAGE[I]); 
0DB5:  BCF    03.0
0DB6:  RLF    2E,W
0DB7:  ADDLW  40
0DB8:  MOVWF  04
0DB9:  BCF    03.7
0DBA:  INCF   04,F
0DBB:  MOVF   00,W
0DBC:  MOVWF  30
0DBD:  DECF   04,F
0DBE:  MOVF   00,W
0DBF:  MOVWF  2F
0DC0:  MOVWF  04
0DC1:  BCF    03.7
0DC2:  BTFSC  30.0
0DC3:  BSF    03.7
0DC4:  BCF    03.6
0DC5:  CLRF   2B
0DC6:  BTFSC  0B.7
0DC7:  BSF    2B.7
0DC8:  BCF    0B.7
0DC9:  BCF    0A.3
0DCA:  CALL   431
0DCB:  BSF    0A.3
0DCC:  BTFSC  2B.7
0DCD:  BSF    0B.7
0DCE:  CLRF   2B
0DCF:  BTFSC  0B.7
0DD0:  BSF    2B.7
0DD1:  BCF    0B.7
....................              DELAY_MS (1); 
0DD2:  MOVLW  01
0DD3:  BSF    03.6
0DD4:  MOVWF  65
0DD5:  BCF    0A.3
0DD6:  BCF    03.6
0DD7:  CALL   204
0DD8:  BSF    0A.3
0DD9:  BTFSC  2B.7
0DDA:  BSF    0B.7
0DDB:  BSF    03.6
0DDC:  INCF   2E,F
0DDD:  GOTO   5B1
....................           } 
....................  
....................            
....................           DELAY_MS (1000); 
0DDE:  MOVLW  04
0DDF:  MOVWF  2F
0DE0:  BCF    03.6
0DE1:  CLRF   2B
0DE2:  BTFSC  0B.7
0DE3:  BSF    2B.7
0DE4:  BCF    0B.7
0DE5:  MOVLW  FA
0DE6:  BSF    03.6
0DE7:  MOVWF  65
0DE8:  BCF    0A.3
0DE9:  BCF    03.6
0DEA:  CALL   204
0DEB:  BSF    0A.3
0DEC:  BTFSC  2B.7
0DED:  BSF    0B.7
0DEE:  BSF    03.6
0DEF:  DECFSZ 2F,F
0DF0:  GOTO   5E0
0DF1:  BCF    03.6
....................        } 
....................  
....................        IF (TTNHAN == 1) 
0DF2:  DECFSZ 6B,W
0DF3:  GOTO   60A
....................        { 
....................            
....................           TTNHAN = 0; 
0DF4:  CLRF   6B
....................           XUATLCD (); 
0DF5:  GOTO   1F8
....................            
....................           OUTPUT_TOGGLE (PIN_D0); 
0DF6:  BSF    03.5
0DF7:  BCF    08.0
0DF8:  MOVLW  01
0DF9:  BCF    03.5
0DFA:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D1); 
0DFB:  BSF    03.5
0DFC:  BCF    08.1
0DFD:  MOVLW  02
0DFE:  BCF    03.5
0DFF:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D2); 
0E00:  BSF    03.5
0E01:  BCF    08.2
0E02:  MOVLW  04
0E03:  BCF    03.5
0E04:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D3); 
0E05:  BSF    03.5
0E06:  BCF    08.3
0E07:  MOVLW  08
0E08:  BCF    03.5
0E09:  XORWF  08,F
....................        } 
0E0A:  GOTO   3B4
....................     } 
....................  } 
....................  
0E0B:  SLEEP
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
