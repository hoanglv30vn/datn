CCS PCM C Compiler, Version 5.015, 5967               16-Oct-21 12:56

               Filename:   E:\DATN\NODE\pic\hellopicc\hellopic.lst

               ROM used:   2841 words (35%)
                           Largest free fragment is 2048
               RAM used:   191 (52%) at main() level
                           231 (63%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   13C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   07E
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0AC
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  BCF    0A.0
005E:  BCF    0A.1
005F:  BCF    0A.2
0060:  ADDWF  02,F
0061:  RETLW  20
0062:  RETLW  2A
0063:  RETLW  20
0064:  RETLW  00
0065:  DATA 49,22
0066:  DATA 3A,10
0067:  DATA 00,00
0068:  DATA C4,22
0069:  DATA D6,24
006A:  DATA C3,22
006B:  DATA 3A,10
006C:  DATA 00,01
006D:  DATA C3,20
006E:  DATA D3,22
006F:  DATA 31,00
0070:  DATA C3,27
0071:  DATA 4E,23
0072:  DATA C9,23
0073:  DATA 00,01
0074:  DATA C3,20
0075:  DATA D3,22
0076:  DATA 3A,10
0077:  DATA 00,00
0078:  DATA C3,27
0079:  DATA 4E,23
007A:  DATA C9,23
007B:  DATA 20,22
007C:  DATA 4F,27
007D:  DATA 45,00
*
0279:  MOVLW  8E
027A:  MOVWF  77
027B:  MOVF   38,W
027C:  MOVWF  78
027D:  MOVF   37,W
027E:  MOVWF  79
027F:  CLRF   7A
0280:  MOVF   78,F
0281:  BTFSS  03.2
0282:  GOTO   28D
0283:  MOVF   79,W
0284:  MOVWF  78
0285:  CLRF   79
0286:  MOVLW  08
0287:  SUBWF  77,F
0288:  MOVF   78,F
0289:  BTFSS  03.2
028A:  GOTO   28D
028B:  CLRF   77
028C:  GOTO   295
028D:  BCF    03.0
028E:  BTFSC  78.7
028F:  GOTO   294
0290:  RLF    79,F
0291:  RLF    78,F
0292:  DECF   77,F
0293:  GOTO   28D
0294:  BCF    78.7
*
02A5:  MOVF   37,W
02A6:  BTFSC  03.2
02A7:  GOTO   36A
02A8:  MOVWF  43
02A9:  MOVF   3B,W
02AA:  BTFSC  03.2
02AB:  GOTO   36A
02AC:  SUBWF  43,F
02AD:  BTFSS  03.0
02AE:  GOTO   2B4
02AF:  MOVLW  7F
02B0:  ADDWF  43,F
02B1:  BTFSC  03.0
02B2:  GOTO   36A
02B3:  GOTO   2BA
02B4:  MOVLW  81
02B5:  SUBWF  43,F
02B6:  BTFSS  03.0
02B7:  GOTO   36A
02B8:  BTFSC  03.2
02B9:  GOTO   36A
02BA:  MOVF   43,W
02BB:  MOVWF  77
02BC:  CLRF   78
02BD:  CLRF   79
02BE:  CLRF   7A
02BF:  CLRF   42
02C0:  MOVF   38,W
02C1:  MOVWF  41
02C2:  BSF    41.7
02C3:  MOVF   39,W
02C4:  MOVWF  40
02C5:  MOVF   3A,W
02C6:  MOVWF  3F
02C7:  MOVLW  19
02C8:  MOVWF  43
02C9:  MOVF   3E,W
02CA:  SUBWF  3F,F
02CB:  BTFSC  03.0
02CC:  GOTO   2DD
02CD:  MOVLW  01
02CE:  SUBWF  40,F
02CF:  BTFSC  03.0
02D0:  GOTO   2DD
02D1:  SUBWF  41,F
02D2:  BTFSC  03.0
02D3:  GOTO   2DD
02D4:  SUBWF  42,F
02D5:  BTFSC  03.0
02D6:  GOTO   2DD
02D7:  INCF   42,F
02D8:  INCF   41,F
02D9:  INCF   40,F
02DA:  MOVF   3E,W
02DB:  ADDWF  3F,F
02DC:  GOTO   30F
02DD:  MOVF   3D,W
02DE:  SUBWF  40,F
02DF:  BTFSC  03.0
02E0:  GOTO   2F8
02E1:  MOVLW  01
02E2:  SUBWF  41,F
02E3:  BTFSC  03.0
02E4:  GOTO   2F8
02E5:  SUBWF  42,F
02E6:  BTFSC  03.0
02E7:  GOTO   2F8
02E8:  INCF   42,F
02E9:  INCF   41,F
02EA:  MOVF   3D,W
02EB:  ADDWF  40,F
02EC:  MOVF   3E,W
02ED:  ADDWF  3F,F
02EE:  BTFSS  03.0
02EF:  GOTO   30F
02F0:  INCF   40,F
02F1:  BTFSS  03.2
02F2:  GOTO   30F
02F3:  INCF   41,F
02F4:  BTFSS  03.2
02F5:  GOTO   30F
02F6:  INCF   42,F
02F7:  GOTO   30F
02F8:  MOVF   3C,W
02F9:  IORLW  80
02FA:  SUBWF  41,F
02FB:  BTFSC  03.0
02FC:  GOTO   30E
02FD:  MOVLW  01
02FE:  SUBWF  42,F
02FF:  BTFSC  03.0
0300:  GOTO   30E
0301:  INCF   42,F
0302:  MOVF   3C,W
0303:  IORLW  80
0304:  ADDWF  41,F
0305:  MOVF   3D,W
0306:  ADDWF  40,F
0307:  BTFSS  03.0
0308:  GOTO   2EC
0309:  INCF   41,F
030A:  BTFSS  03.2
030B:  GOTO   2EC
030C:  INCF   42,F
030D:  GOTO   2EC
030E:  BSF    7A.0
030F:  DECFSZ 43,F
0310:  GOTO   312
0311:  GOTO   31D
0312:  BCF    03.0
0313:  RLF    3F,F
0314:  RLF    40,F
0315:  RLF    41,F
0316:  RLF    42,F
0317:  BCF    03.0
0318:  RLF    7A,F
0319:  RLF    79,F
031A:  RLF    78,F
031B:  RLF    44,F
031C:  GOTO   2C9
031D:  BTFSS  44.0
031E:  GOTO   325
031F:  BCF    03.0
0320:  RRF    78,F
0321:  RRF    79,F
0322:  RRF    7A,F
0323:  RRF    44,F
0324:  GOTO   328
0325:  DECF   77,F
0326:  BTFSC  03.2
0327:  GOTO   36A
0328:  BTFSC  44.7
0329:  GOTO   351
032A:  BCF    03.0
032B:  RLF    3F,F
032C:  RLF    40,F
032D:  RLF    41,F
032E:  RLF    42,F
032F:  MOVF   3E,W
0330:  SUBWF  3F,F
0331:  BTFSC  03.0
0332:  GOTO   33D
0333:  MOVLW  01
0334:  SUBWF  40,F
0335:  BTFSC  03.0
0336:  GOTO   33D
0337:  SUBWF  41,F
0338:  BTFSC  03.0
0339:  GOTO   33D
033A:  SUBWF  42,F
033B:  BTFSS  03.0
033C:  GOTO   360
033D:  MOVF   3D,W
033E:  SUBWF  40,F
033F:  BTFSC  03.0
0340:  GOTO   348
0341:  MOVLW  01
0342:  SUBWF  41,F
0343:  BTFSC  03.0
0344:  GOTO   348
0345:  SUBWF  42,F
0346:  BTFSS  03.0
0347:  GOTO   360
0348:  MOVF   3C,W
0349:  IORLW  80
034A:  SUBWF  41,F
034B:  BTFSC  03.0
034C:  GOTO   351
034D:  MOVLW  01
034E:  SUBWF  42,F
034F:  BTFSS  03.0
0350:  GOTO   360
0351:  INCF   7A,F
0352:  BTFSS  03.2
0353:  GOTO   360
0354:  INCF   79,F
0355:  BTFSS  03.2
0356:  GOTO   360
0357:  INCF   78,F
0358:  BTFSS  03.2
0359:  GOTO   360
035A:  INCF   77,F
035B:  BTFSC  03.2
035C:  GOTO   36A
035D:  RRF    78,F
035E:  RRF    79,F
035F:  RRF    7A,F
0360:  MOVF   38,W
0361:  MOVWF  43
0362:  MOVF   3C,W
0363:  XORWF  43,F
0364:  BTFSS  43.7
0365:  GOTO   368
0366:  BSF    78.7
0367:  GOTO   36E
0368:  BCF    78.7
0369:  GOTO   36E
036A:  CLRF   77
036B:  CLRF   78
036C:  CLRF   79
036D:  CLRF   7A
*
0376:  MOVLW  8E
0377:  MOVWF  77
0378:  MOVF   37,W
0379:  SUBWF  77,F
037A:  MOVF   38,W
037B:  MOVWF  79
037C:  MOVF   39,W
037D:  MOVWF  78
037E:  BSF    79.7
037F:  MOVF   77,F
0380:  BTFSC  03.2
0381:  GOTO   38D
0382:  BCF    03.0
0383:  MOVF   79,F
0384:  BTFSS  03.2
0385:  GOTO   389
0386:  MOVF   78,F
0387:  BTFSC  03.2
0388:  GOTO   38D
0389:  RRF    79,F
038A:  RRF    78,F
038B:  DECFSZ 77,F
038C:  GOTO   382
038D:  BTFSS  38.7
038E:  GOTO   394
038F:  COMF   78,F
0390:  COMF   79,F
0391:  INCF   78,F
0392:  BTFSC  03.2
0393:  INCF   79,F
*
03EC:  MOVF   0B,W
03ED:  BSF    03.6
03EE:  MOVWF  37
03EF:  BCF    03.6
03F0:  BCF    0B.7
03F1:  BSF    03.5
03F2:  BSF    03.6
03F3:  BSF    0C.7
03F4:  BSF    0C.0
03F5:  NOP
03F6:  NOP
03F7:  BCF    03.5
03F8:  BTFSS  37.7
03F9:  GOTO   3FD
03FA:  BCF    03.6
03FB:  BSF    0B.7
03FC:  BSF    03.6
03FD:  MOVF   0C,W
03FE:  ANDLW  7F
03FF:  BTFSC  03.2
0400:  GOTO   43A
0401:  MOVWF  37
0402:  MOVF   0D,W
0403:  MOVWF  38
0404:  MOVF   0F,W
0405:  MOVWF  39
0406:  MOVF   37,W
0407:  MOVWF  3A
0408:  BCF    03.6
0409:  CALL   3B2
040A:  BSF    03.6
040B:  MOVF   38,W
040C:  MOVWF  0D
040D:  MOVF   39,W
040E:  MOVWF  0F
040F:  BCF    03.6
0410:  MOVF   0B,W
0411:  BSF    03.6
0412:  MOVWF  3A
0413:  BCF    03.6
0414:  BCF    0B.7
0415:  BSF    03.5
0416:  BSF    03.6
0417:  BSF    0C.7
0418:  BSF    0C.0
0419:  NOP
041A:  NOP
041B:  BCF    03.5
041C:  BTFSS  3A.7
041D:  GOTO   421
041E:  BCF    03.6
041F:  BSF    0B.7
0420:  BSF    03.6
0421:  RLF    0C,W
0422:  RLF    0E,W
0423:  ANDLW  7F
0424:  BTFSC  03.2
0425:  GOTO   43A
0426:  MOVWF  37
0427:  MOVF   0D,W
0428:  MOVWF  38
0429:  MOVF   0F,W
042A:  MOVWF  39
042B:  MOVF   37,W
042C:  MOVWF  3A
042D:  BCF    03.6
042E:  CALL   3B2
042F:  BSF    03.6
0430:  MOVF   38,W
0431:  MOVWF  0D
0432:  MOVF   39,W
0433:  MOVWF  0F
0434:  INCF   0D,F
0435:  BTFSC  03.2
0436:  INCF   0F,F
0437:  BCF    03.6
0438:  GOTO   3EC
0439:  BSF    03.6
043A:  BCF    03.6
043B:  RETURN
043C:  BTFSC  03.1
043D:  GOTO   441
043E:  MOVLW  56
043F:  MOVWF  04
0440:  BSF    03.7
0441:  BSF    03.6
0442:  MOVF   51,W
0443:  XORWF  55,W
0444:  ANDLW  80
0445:  MOVWF  5B
0446:  BTFSS  51.7
0447:  GOTO   453
0448:  COMF   4E,F
0449:  COMF   4F,F
044A:  COMF   50,F
044B:  COMF   51,F
044C:  INCF   4E,F
044D:  BTFSC  03.2
044E:  INCF   4F,F
044F:  BTFSC  03.2
0450:  INCF   50,F
0451:  BTFSC  03.2
0452:  INCF   51,F
0453:  BTFSS  55.7
0454:  GOTO   460
0455:  COMF   52,F
0456:  COMF   53,F
0457:  COMF   54,F
0458:  COMF   55,F
0459:  INCF   52,F
045A:  BTFSC  03.2
045B:  INCF   53,F
045C:  BTFSC  03.2
045D:  INCF   54,F
045E:  BTFSC  03.2
045F:  INCF   55,F
0460:  CLRF   77
0461:  CLRF   78
0462:  CLRF   79
0463:  CLRF   7A
0464:  CLRF   56
0465:  CLRF   57
0466:  CLRF   58
0467:  CLRF   59
0468:  MOVF   55,W
0469:  IORWF  54,W
046A:  IORWF  53,W
046B:  IORWF  52,W
046C:  BTFSC  03.2
046D:  GOTO   49E
046E:  MOVLW  20
046F:  MOVWF  5A
0470:  BCF    03.0
0471:  RLF    4E,F
0472:  RLF    4F,F
0473:  RLF    50,F
0474:  RLF    51,F
0475:  RLF    56,F
0476:  RLF    57,F
0477:  RLF    58,F
0478:  RLF    59,F
0479:  MOVF   55,W
047A:  SUBWF  59,W
047B:  BTFSS  03.2
047C:  GOTO   487
047D:  MOVF   54,W
047E:  SUBWF  58,W
047F:  BTFSS  03.2
0480:  GOTO   487
0481:  MOVF   53,W
0482:  SUBWF  57,W
0483:  BTFSS  03.2
0484:  GOTO   487
0485:  MOVF   52,W
0486:  SUBWF  56,W
0487:  BTFSS  03.0
0488:  GOTO   498
0489:  MOVF   52,W
048A:  SUBWF  56,F
048B:  MOVF   53,W
048C:  BTFSS  03.0
048D:  INCFSZ 53,W
048E:  SUBWF  57,F
048F:  MOVF   54,W
0490:  BTFSS  03.0
0491:  INCFSZ 54,W
0492:  SUBWF  58,F
0493:  MOVF   55,W
0494:  BTFSS  03.0
0495:  INCFSZ 55,W
0496:  SUBWF  59,F
0497:  BSF    03.0
0498:  RLF    77,F
0499:  RLF    78,F
049A:  RLF    79,F
049B:  RLF    7A,F
049C:  DECFSZ 5A,F
049D:  GOTO   470
049E:  BTFSS  5B.7
049F:  GOTO   4AB
04A0:  COMF   77,F
04A1:  COMF   78,F
04A2:  COMF   79,F
04A3:  COMF   7A,F
04A4:  INCF   77,F
04A5:  BTFSC  03.2
04A6:  INCF   78,F
04A7:  BTFSC  03.2
04A8:  INCF   79,F
04A9:  BTFSC  03.2
04AA:  INCF   7A,F
04AB:  MOVF   56,W
04AC:  MOVWF  00
04AD:  INCF   04,F
04AE:  MOVF   57,W
04AF:  MOVWF  00
04B0:  INCF   04,F
04B1:  MOVF   58,W
04B2:  MOVWF  00
04B3:  INCF   04,F
04B4:  MOVF   59,W
04B5:  MOVWF  00
04B6:  BCF    03.6
04B7:  RETURN
*
04D1:  MOVLW  20
04D2:  MOVWF  52
04D3:  CLRF   4E
04D4:  CLRF   4F
04D5:  CLRF   50
04D6:  CLRF   51
04D7:  MOVF   49,W
04D8:  MOVWF  7A
04D9:  MOVF   48,W
04DA:  MOVWF  79
04DB:  MOVF   47,W
04DC:  MOVWF  78
04DD:  MOVF   46,W
04DE:  MOVWF  77
04DF:  BCF    03.0
04E0:  BTFSS  77.0
04E1:  GOTO   4F0
04E2:  MOVF   4A,W
04E3:  ADDWF  4E,F
04E4:  MOVF   4B,W
04E5:  BTFSC  03.0
04E6:  INCFSZ 4B,W
04E7:  ADDWF  4F,F
04E8:  MOVF   4C,W
04E9:  BTFSC  03.0
04EA:  INCFSZ 4C,W
04EB:  ADDWF  50,F
04EC:  MOVF   4D,W
04ED:  BTFSC  03.0
04EE:  INCFSZ 4D,W
04EF:  ADDWF  51,F
04F0:  RRF    51,F
04F1:  RRF    50,F
04F2:  RRF    4F,F
04F3:  RRF    4E,F
04F4:  RRF    7A,F
04F5:  RRF    79,F
04F6:  RRF    78,F
04F7:  RRF    77,F
04F8:  DECFSZ 52,F
04F9:  GOTO   4DF
*
05D8:  MOVF   00,F
05D9:  BTFSC  03.2
05DA:  GOTO   5F4
05DB:  BSF    03.6
05DC:  CLRF   38
05DD:  MOVF   04,W
05DE:  MOVWF  37
05DF:  BCF    38.0
05E0:  BTFSC  03.7
05E1:  BSF    38.0
05E2:  MOVF   00,W
05E3:  MOVWF  3A
05E4:  BCF    03.6
05E5:  CALL   3B2
05E6:  BSF    03.6
05E7:  MOVF   37,W
05E8:  MOVWF  04
05E9:  BCF    03.7
05EA:  BTFSC  38.0
05EB:  BSF    03.7
05EC:  INCF   04,F
05ED:  BTFSS  03.2
05EE:  GOTO   5F2
05EF:  BCF    03.6
05F0:  INCF   05,F
05F1:  BSF    03.6
05F2:  BCF    03.6
05F3:  GOTO   5D8
05F4:  RETURN
05F5:  BSF    03.6
05F6:  MOVF   37,W
05F7:  ANDLW  07
05F8:  MOVWF  77
05F9:  RRF    37,W
05FA:  MOVWF  78
05FB:  RRF    78,F
05FC:  RRF    78,F
05FD:  MOVLW  1F
05FE:  ANDWF  78,F
05FF:  MOVF   78,W
0600:  ADDWF  38,W
0601:  MOVWF  04
0602:  BCF    03.7
0603:  BTFSC  39.0
0604:  BSF    03.7
0605:  MOVF   00,W
0606:  MOVWF  78
0607:  INCF   77,F
0608:  GOTO   60A
0609:  RRF    78,F
060A:  DECFSZ 77,F
060B:  GOTO   609
060C:  BCF    03.6
060D:  RETURN
060E:  BSF    03.6
060F:  MOVF   36,W
0610:  ANDLW  07
0611:  MOVWF  77
0612:  RRF    36,W
0613:  MOVWF  78
0614:  RRF    78,F
0615:  RRF    78,F
0616:  MOVLW  1F
0617:  ANDWF  78,F
0618:  MOVF   78,W
0619:  ADDWF  38,W
061A:  MOVWF  04
061B:  BCF    03.7
061C:  BTFSC  39.0
061D:  BSF    03.7
061E:  CLRF   78
061F:  INCF   78,F
0620:  INCF   77,F
0621:  GOTO   623
0622:  RLF    78,F
0623:  DECFSZ 77,F
0624:  GOTO   622
0625:  MOVF   37,F
0626:  BTFSC  03.2
0627:  GOTO   62B
0628:  MOVF   78,W
0629:  IORWF  00,F
062A:  GOTO   62E
062B:  COMF   78,F
062C:  MOVF   78,W
062D:  ANDWF  00,F
062E:  BCF    03.6
062F:  RETURN
*
0773:  BSF    0A.0
0774:  BSF    0A.1
0775:  BSF    0A.2
0776:  ADDWF  02,F
0777:  GOTO   637
0778:  GOTO   68C
0779:  GOTO   75A
077A:  GOTO   76E
*
07DA:  MOVF   00,F
07DB:  BTFSC  03.2
07DC:  GOTO   7F7
07DD:  BSF    03.6
07DE:  CLRF   3A
07DF:  MOVF   04,W
07E0:  MOVWF  39
07E1:  BCF    3A.0
07E2:  BTFSC  03.7
07E3:  BSF    3A.0
07E4:  MOVF   00,W
07E5:  BCF    03.6
07E6:  BTFSS  0C.4
07E7:  GOTO   7E6
07E8:  MOVWF  19
07E9:  BSF    03.6
07EA:  MOVF   39,W
07EB:  MOVWF  04
07EC:  BCF    03.7
07ED:  BTFSC  3A.0
07EE:  BSF    03.7
07EF:  INCF   04,F
07F0:  BTFSS  03.2
07F1:  GOTO   7F5
07F2:  BCF    03.6
07F3:  INCF   05,F
07F4:  BSF    03.6
07F5:  BCF    03.6
07F6:  GOTO   7DA
07F7:  RETURN
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0800:  BSF    03.6
0801:  MOVF   38,W
0802:  MOVWF  3C
0803:  MOVF   37,W
0804:  MOVWF  3B
0805:  MOVF   3C,W
0806:  MOVWF  7A
0807:  MOVF   3B,W
0808:  MOVWF  04
0809:  BCF    03.7
080A:  BTFSC  7A.0
080B:  BSF    03.7
080C:  MOVF   00,F
080D:  BTFSC  03.2
080E:  GOTO   013
080F:  INCF   3B,F
0810:  BTFSC  03.2
0811:  INCF   3C,F
0812:  GOTO   005
....................    while(*s2 != '\0') 
0813:  MOVF   3A,W
0814:  MOVWF  7A
0815:  MOVF   39,W
0816:  MOVWF  04
0817:  BCF    03.7
0818:  BTFSC  7A.0
0819:  BSF    03.7
081A:  MOVF   00,F
081B:  BTFSC  03.2
081C:  GOTO   036
....................    { 
....................       *s = *s2; 
081D:  MOVF   3B,W
081E:  MOVWF  3D
081F:  MOVF   3C,W
0820:  MOVWF  3E
0821:  MOVF   39,W
0822:  MOVWF  04
0823:  BCF    03.7
0824:  BTFSC  3A.0
0825:  BSF    03.7
0826:  MOVF   00,W
0827:  MOVWF  3F
0828:  MOVF   3D,W
0829:  MOVWF  04
082A:  BCF    03.7
082B:  BTFSC  3E.0
082C:  BSF    03.7
082D:  MOVF   3F,W
082E:  MOVWF  00
....................       ++s; 
082F:  INCF   3B,F
0830:  BTFSC  03.2
0831:  INCF   3C,F
....................       ++s2; 
0832:  INCF   39,F
0833:  BTFSC  03.2
0834:  INCF   3A,F
0835:  GOTO   013
....................    } 
....................  
....................    *s = '\0'; 
0836:  MOVF   3B,W
0837:  MOVWF  04
0838:  BCF    03.7
0839:  BTFSC  3C.0
083A:  BSF    03.7
083B:  CLRF   00
....................    return(s1); 
083C:  MOVF   37,W
083D:  MOVWF  78
083E:  MOVF   38,W
083F:  MOVWF  79
0840:  BCF    03.6
0841:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0967:  BCF    03.6
0968:  CLRF   2B
0969:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04B8:  BSF    03.6
04B9:  CLRF   41
04BA:  CLRF   40
04BB:  CLRF   3F
04BC:  MOVLW  01
04BD:  MOVWF  3E
04BE:  CLRF   43
04BF:  CLRF   44
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04C0:  BTFSS  3A.7
04C1:  GOTO   502
....................          sign=1;        // Check for negative number 
04C2:  MOVLW  01
04C3:  MOVWF  43
....................          num*=-1; 
04C4:  MOVF   3A,W
04C5:  MOVWF  49
04C6:  MOVF   39,W
04C7:  MOVWF  48
04C8:  MOVF   38,W
04C9:  MOVWF  47
04CA:  MOVF   37,W
04CB:  MOVWF  46
04CC:  MOVLW  FF
04CD:  MOVWF  4D
04CE:  MOVWF  4C
04CF:  MOVWF  4B
04D0:  MOVWF  4A
*
04FA:  MOVF   7A,W
04FB:  MOVWF  3A
04FC:  MOVF   79,W
04FD:  MOVWF  39
04FE:  MOVF   78,W
04FF:  MOVWF  38
0500:  MOVF   77,W
0501:  MOVWF  37
....................      } 
....................  
....................      while(temp>0) { 
0502:  MOVF   3E,F
0503:  BTFSS  03.2
0504:  GOTO   50E
0505:  MOVF   3F,F
0506:  BTFSS  03.2
0507:  GOTO   50E
0508:  MOVF   40,F
0509:  BTFSS  03.2
050A:  GOTO   50E
050B:  MOVF   41,F
050C:  BTFSC  03.2
050D:  GOTO   58A
....................          temp=(num/base); 
050E:  BCF    03.1
050F:  MOVF   3A,W
0510:  MOVWF  51
0511:  MOVF   39,W
0512:  MOVWF  50
0513:  MOVF   38,W
0514:  MOVWF  4F
0515:  MOVF   37,W
0516:  MOVWF  4E
0517:  CLRF   55
0518:  CLRF   54
0519:  CLRF   53
051A:  MOVF   3B,W
051B:  MOVWF  52
051C:  BCF    03.6
051D:  CALL   43C
051E:  MOVF   7A,W
051F:  BSF    03.6
0520:  MOVWF  41
0521:  MOVF   79,W
0522:  MOVWF  40
0523:  MOVF   78,W
0524:  MOVWF  3F
0525:  MOVF   77,W
0526:  MOVWF  3E
....................          s[cnt]=(num%base)+'0';    // Conversion 
0527:  MOVF   44,W
0528:  ADDWF  3C,W
0529:  MOVWF  78
052A:  MOVF   3D,W
052B:  MOVWF  7A
052C:  BTFSC  03.0
052D:  INCF   7A,F
052E:  MOVF   78,W
052F:  MOVWF  46
0530:  MOVF   7A,W
0531:  MOVWF  47
0532:  CLRF   49
0533:  MOVF   04,W
0534:  MOVWF  48
0535:  BCF    49.0
0536:  BTFSC  03.7
0537:  BSF    49.0
0538:  BSF    03.1
0539:  MOVLW  4A
053A:  MOVWF  04
053B:  BSF    03.7
053C:  MOVF   3A,W
053D:  MOVWF  51
053E:  MOVF   39,W
053F:  MOVWF  50
0540:  MOVF   38,W
0541:  MOVWF  4F
0542:  MOVF   37,W
0543:  MOVWF  4E
0544:  CLRF   55
0545:  CLRF   54
0546:  CLRF   53
0547:  MOVF   3B,W
0548:  MOVWF  52
0549:  BCF    03.6
054A:  CALL   43C
054B:  BSF    03.6
054C:  MOVF   48,W
054D:  MOVWF  04
054E:  BCF    03.7
054F:  BTFSC  49.0
0550:  BSF    03.7
0551:  MOVLW  30
0552:  ADDWF  4A,W
0553:  MOVWF  77
0554:  MOVF   4B,W
0555:  MOVWF  78
0556:  MOVLW  00
0557:  BTFSC  03.0
0558:  MOVLW  01
0559:  ADDWF  78,F
055A:  MOVF   4C,W
055B:  MOVWF  79
055C:  MOVLW  00
055D:  BTFSC  03.0
055E:  MOVLW  01
055F:  ADDWF  79,F
0560:  MOVF   4D,W
0561:  MOVWF  7A
0562:  MOVLW  00
0563:  BTFSC  03.0
0564:  MOVLW  01
0565:  ADDWF  7A,F
0566:  MOVF   46,W
0567:  MOVWF  04
0568:  BCF    03.7
0569:  BTFSC  47.0
056A:  BSF    03.7
056B:  MOVF   77,W
056C:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
056D:  MOVF   44,W
056E:  ADDWF  3C,W
056F:  MOVWF  04
0570:  BCF    03.7
0571:  BTFSC  3D.0
0572:  BSF    03.7
0573:  MOVF   00,W
0574:  SUBLW  39
0575:  BTFSC  03.0
0576:  GOTO   580
....................             s[cnt]+=0x7; 
0577:  MOVF   44,W
0578:  ADDWF  3C,W
0579:  MOVWF  04
057A:  BCF    03.7
057B:  BTFSC  3D.0
057C:  BSF    03.7
057D:  MOVLW  07
057E:  ADDWF  00,W
057F:  MOVWF  00
....................  
....................          cnt++; 
0580:  INCF   44,F
....................          num=temp; 
0581:  MOVF   41,W
0582:  MOVWF  3A
0583:  MOVF   40,W
0584:  MOVWF  39
0585:  MOVF   3F,W
0586:  MOVWF  38
0587:  MOVF   3E,W
0588:  MOVWF  37
0589:  GOTO   502
....................      } 
....................  
....................      if(sign==1) { 
058A:  DECFSZ 43,W
058B:  GOTO   595
....................          s[cnt]=0x2D;      // Negative sign 
058C:  MOVF   44,W
058D:  ADDWF  3C,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  3D.0
0591:  BSF    03.7
0592:  MOVLW  2D
0593:  MOVWF  00
....................          cnt++; 
0594:  INCF   44,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0595:  CLRF   42
0596:  BCF    03.0
0597:  RRF    44,W
0598:  SUBWF  42,W
0599:  BTFSC  03.0
059A:  GOTO   5CB
....................  
....................          c=s[i]; 
059B:  MOVF   42,W
059C:  ADDWF  3C,W
059D:  MOVWF  04
059E:  BCF    03.7
059F:  BTFSC  3D.0
05A0:  BSF    03.7
05A1:  MOVF   00,W
05A2:  MOVWF  45
....................          s[i]=s[cnt-i-1];        // Reverse the number 
05A3:  MOVF   42,W
05A4:  ADDWF  3C,W
05A5:  MOVWF  78
05A6:  MOVF   3D,W
05A7:  MOVWF  7A
05A8:  BTFSC  03.0
05A9:  INCF   7A,F
05AA:  MOVF   78,W
05AB:  MOVWF  46
05AC:  MOVF   7A,W
05AD:  MOVWF  47
05AE:  MOVF   42,W
05AF:  SUBWF  44,W
05B0:  ADDLW  FF
05B1:  ADDWF  3C,W
05B2:  MOVWF  04
05B3:  BCF    03.7
05B4:  BTFSC  3D.0
05B5:  BSF    03.7
05B6:  MOVF   00,W
05B7:  MOVWF  48
05B8:  MOVF   46,W
05B9:  MOVWF  04
05BA:  BCF    03.7
05BB:  BTFSC  47.0
05BC:  BSF    03.7
05BD:  MOVF   48,W
05BE:  MOVWF  00
....................          s[cnt-i-1]=c; 
05BF:  MOVF   42,W
05C0:  SUBWF  44,W
05C1:  ADDLW  FF
05C2:  ADDWF  3C,W
05C3:  MOVWF  04
05C4:  BCF    03.7
05C5:  BTFSC  3D.0
05C6:  BSF    03.7
05C7:  MOVF   45,W
05C8:  MOVWF  00
05C9:  INCF   42,F
05CA:  GOTO   596
....................      } 
....................      s[cnt]='\0';     // End the string 
05CB:  MOVF   44,W
05CC:  ADDWF  3C,W
05CD:  MOVWF  04
05CE:  BCF    03.7
05CF:  BTFSC  3D.0
05D0:  BSF    03.7
05D1:  CLRF   00
....................      return s; 
05D2:  MOVF   3C,W
05D3:  MOVWF  78
05D4:  MOVF   3D,W
05D5:  MOVWF  79
05D6:  BCF    03.6
05D7:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S NGUYN 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S NGUYN DI 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
00CA:  MOVLW  3B
00CB:  MOVWF  04
00CC:  BSF    03.7
00CD:  MOVF   00,W
00CE:  BTFSC  03.2
00CF:  GOTO   0DD
00D0:  MOVLW  06
00D1:  MOVWF  78
00D2:  CLRF   77
00D3:  DECFSZ 77,F
00D4:  GOTO   0D3
00D5:  DECFSZ 78,F
00D6:  GOTO   0D2
00D7:  MOVLW  7B
00D8:  MOVWF  77
00D9:  DECFSZ 77,F
00DA:  GOTO   0D9
00DB:  DECFSZ 00,F
00DC:  GOTO   0D0
00DD:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0171:  BSF    07.0
....................    output_float(LCD_DATA5); 
0172:  BSF    07.1
....................    output_float(LCD_DATA6); 
0173:  BSF    07.2
....................    output_float(LCD_DATA7); 
0174:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0175:  BCF    03.5
0176:  BSF    09.2
0177:  BSF    03.5
0178:  BCF    09.2
....................    delay_cycles(1); 
0179:  NOP
....................    lcd_output_enable(1); 
017A:  BCF    03.5
017B:  BSF    09.0
017C:  BSF    03.5
017D:  BCF    09.0
....................    delay_cycles(1); 
017E:  NOP
....................    high = lcd_read_nibble(); 
017F:  BCF    03.5
0180:  CALL   126
0181:  MOVF   78,W
0182:  BSF    03.6
0183:  MOVWF  42
....................        
....................    lcd_output_enable(0); 
0184:  BCF    03.6
0185:  BCF    09.0
0186:  BSF    03.5
0187:  BCF    09.0
....................    delay_cycles(1); 
0188:  NOP
....................    lcd_output_enable(1); 
0189:  BCF    03.5
018A:  BSF    09.0
018B:  BSF    03.5
018C:  BCF    09.0
....................    delay_us(1); 
018D:  GOTO   18E
018E:  GOTO   18F
018F:  NOP
....................    low = lcd_read_nibble(); 
0190:  BCF    03.5
0191:  CALL   126
0192:  MOVF   78,W
0193:  BSF    03.6
0194:  MOVWF  41
....................        
....................    lcd_output_enable(0); 
0195:  BCF    03.6
0196:  BCF    09.0
0197:  BSF    03.5
0198:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0199:  BCF    03.5
019A:  BCF    31.0
019B:  MOVF   31,W
019C:  BSF    03.5
019D:  MOVWF  07
....................    output_drive(LCD_DATA5); 
019E:  BCF    03.5
019F:  BCF    31.1
01A0:  MOVF   31,W
01A1:  BSF    03.5
01A2:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01A3:  BCF    03.5
01A4:  BCF    31.2
01A5:  MOVF   31,W
01A6:  BSF    03.5
01A7:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01A8:  BCF    03.5
01A9:  BCF    31.3
01AA:  MOVF   31,W
01AB:  BSF    03.5
01AC:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01AD:  BCF    03.5
01AE:  BSF    03.6
01AF:  SWAPF  42,W
01B0:  MOVWF  77
01B1:  MOVLW  F0
01B2:  ANDWF  77,F
01B3:  MOVF   77,W
01B4:  IORWF  41,W
01B5:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0126:  BSF    03.6
0127:  CLRF   43
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0128:  BCF    03.6
0129:  BSF    31.0
012A:  MOVF   31,W
012B:  BSF    03.5
012C:  MOVWF  07
012D:  MOVLW  00
012E:  BCF    03.5
012F:  BTFSC  07.0
0130:  MOVLW  01
0131:  BSF    03.6
0132:  IORWF  43,F
....................    n |= input(LCD_DATA5) << 1; 
0133:  BCF    03.6
0134:  BSF    31.1
0135:  MOVF   31,W
0136:  BSF    03.5
0137:  MOVWF  07
0138:  MOVLW  00
0139:  BCF    03.5
013A:  BTFSC  07.1
013B:  MOVLW  01
013C:  MOVWF  77
013D:  BCF    03.0
013E:  RLF    77,F
013F:  MOVF   77,W
0140:  BSF    03.6
0141:  IORWF  43,F
....................    n |= input(LCD_DATA6) << 2; 
0142:  BCF    03.6
0143:  BSF    31.2
0144:  MOVF   31,W
0145:  BSF    03.5
0146:  MOVWF  07
0147:  MOVLW  00
0148:  BCF    03.5
0149:  BTFSC  07.2
014A:  MOVLW  01
014B:  MOVWF  77
014C:  RLF    77,F
014D:  RLF    77,F
014E:  MOVLW  FC
014F:  ANDWF  77,F
0150:  MOVF   77,W
0151:  BSF    03.6
0152:  IORWF  43,F
....................    n |= input(LCD_DATA7) << 3; 
0153:  BCF    03.6
0154:  BSF    31.3
0155:  MOVF   31,W
0156:  BSF    03.5
0157:  MOVWF  07
0158:  MOVLW  00
0159:  BCF    03.5
015A:  BTFSC  07.3
015B:  MOVLW  01
015C:  MOVWF  77
015D:  RLF    77,F
015E:  RLF    77,F
015F:  RLF    77,F
0160:  MOVLW  F8
0161:  ANDWF  77,F
0162:  MOVF   77,W
0163:  BSF    03.6
0164:  IORWF  43,F
....................     
....................    return(n); 
0165:  MOVF   43,W
0166:  MOVWF  78
....................   #else 
0167:  BCF    03.6
0168:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00DE:  BSF    03.6
00DF:  BTFSC  42.0
00E0:  GOTO   0E5
00E1:  BCF    03.6
00E2:  BCF    07.0
00E3:  GOTO   0E7
00E4:  BSF    03.6
00E5:  BCF    03.6
00E6:  BSF    07.0
00E7:  BCF    31.0
00E8:  MOVF   31,W
00E9:  BSF    03.5
00EA:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00EB:  BCF    03.5
00EC:  BSF    03.6
00ED:  BTFSC  42.1
00EE:  GOTO   0F3
00EF:  BCF    03.6
00F0:  BCF    07.1
00F1:  GOTO   0F5
00F2:  BSF    03.6
00F3:  BCF    03.6
00F4:  BSF    07.1
00F5:  BCF    31.1
00F6:  MOVF   31,W
00F7:  BSF    03.5
00F8:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00F9:  BCF    03.5
00FA:  BSF    03.6
00FB:  BTFSC  42.2
00FC:  GOTO   101
00FD:  BCF    03.6
00FE:  BCF    07.2
00FF:  GOTO   103
0100:  BSF    03.6
0101:  BCF    03.6
0102:  BSF    07.2
0103:  BCF    31.2
0104:  MOVF   31,W
0105:  BSF    03.5
0106:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0107:  BCF    03.5
0108:  BSF    03.6
0109:  BTFSC  42.3
010A:  GOTO   10F
010B:  BCF    03.6
010C:  BCF    07.3
010D:  GOTO   111
010E:  BSF    03.6
010F:  BCF    03.6
0110:  BSF    07.3
0111:  BCF    31.3
0112:  MOVF   31,W
0113:  BSF    03.5
0114:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0115:  NOP
....................    lcd_output_enable(1); 
0116:  BCF    03.5
0117:  BSF    09.0
0118:  BSF    03.5
0119:  BCF    09.0
....................    delay_us(2); 
011A:  MOVLW  02
011B:  MOVWF  77
011C:  DECFSZ 77,F
011D:  GOTO   11C
011E:  GOTO   11F
011F:  NOP
....................    lcd_output_enable(0); 
0120:  BCF    03.5
0121:  BCF    09.0
0122:  BSF    03.5
0123:  BCF    09.0
0124:  BCF    03.5
0125:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0169:  BSF    03.5
016A:  BCF    09.0
....................    lcd_rs_tris(); 
016B:  BCF    09.1
....................    lcd_rw_tris(); 
016C:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
016D:  BCF    03.5
016E:  BCF    09.1
016F:  BSF    03.5
0170:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01B6:  MOVF   78,W
01B7:  MOVWF  41
01B8:  BTFSS  41.7
01B9:  GOTO   1BD
01BA:  BSF    03.5
01BB:  BCF    03.6
01BC:  GOTO   171
....................    lcd_output_rs(address); 
01BD:  MOVF   3F,F
01BE:  BTFSS  03.2
01BF:  GOTO   1C4
01C0:  BCF    03.6
01C1:  BCF    09.1
01C2:  GOTO   1C6
01C3:  BSF    03.6
01C4:  BCF    03.6
01C5:  BSF    09.1
01C6:  BSF    03.5
01C7:  BCF    09.1
....................    delay_cycles(1); 
01C8:  NOP
....................    lcd_output_rw(0); 
01C9:  BCF    03.5
01CA:  BCF    09.2
01CB:  BSF    03.5
01CC:  BCF    09.2
....................    delay_cycles(1); 
01CD:  NOP
....................    lcd_output_enable(0); 
01CE:  BCF    03.5
01CF:  BCF    09.0
01D0:  BSF    03.5
01D1:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01D2:  BCF    03.5
01D3:  BSF    03.6
01D4:  SWAPF  40,W
01D5:  MOVWF  41
01D6:  MOVLW  0F
01D7:  ANDWF  41,F
01D8:  MOVF   41,W
01D9:  MOVWF  42
01DA:  BCF    03.6
01DB:  CALL   0DE
....................    lcd_send_nibble(n & 0xf); 
01DC:  BSF    03.6
01DD:  MOVF   40,W
01DE:  ANDLW  0F
01DF:  MOVWF  41
01E0:  MOVWF  42
01E1:  BCF    03.6
01E2:  CALL   0DE
01E3:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01E4:  MOVLW  28
01E5:  BSF    03.6
01E6:  MOVWF  36
01E7:  MOVLW  0C
01E8:  MOVWF  37
01E9:  MOVLW  01
01EA:  MOVWF  38
01EB:  MOVLW  06
01EC:  MOVWF  39
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01ED:  BCF    03.6
01EE:  BCF    09.0
01EF:  BSF    03.5
01F0:  BCF    09.0
....................    lcd_output_rs(0); 
01F1:  BCF    03.5
01F2:  BCF    09.1
01F3:  BSF    03.5
01F4:  BCF    09.1
....................    lcd_output_rw(0); 
01F5:  BCF    03.5
01F6:  BCF    09.2
01F7:  BSF    03.5
01F8:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01F9:  BCF    03.5
01FA:  BCF    31.0
01FB:  MOVF   31,W
01FC:  BSF    03.5
01FD:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01FE:  BCF    03.5
01FF:  BCF    31.1
0200:  MOVF   31,W
0201:  BSF    03.5
0202:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0203:  BCF    03.5
0204:  BCF    31.2
0205:  MOVF   31,W
0206:  BSF    03.5
0207:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0208:  BCF    03.5
0209:  BCF    31.3
020A:  MOVF   31,W
020B:  BSF    03.5
020C:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
020D:  BCF    09.0
....................    lcd_rs_tris(); 
020E:  BCF    09.1
....................    lcd_rw_tris(); 
020F:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0210:  MOVLW  0F
0211:  BCF    03.5
0212:  BSF    03.6
0213:  MOVWF  3B
0214:  BCF    03.6
0215:  CALL   0CA
....................    for(i=1;i<=3;++i) 
0216:  MOVLW  01
0217:  BSF    03.6
0218:  MOVWF  35
0219:  MOVF   35,W
021A:  SUBLW  03
021B:  BTFSS  03.0
021C:  GOTO   229
....................    { 
....................        lcd_send_nibble(3); 
021D:  MOVLW  03
021E:  MOVWF  42
021F:  BCF    03.6
0220:  CALL   0DE
....................        delay_ms(5); 
0221:  MOVLW  05
0222:  BSF    03.6
0223:  MOVWF  3B
0224:  BCF    03.6
0225:  CALL   0CA
0226:  BSF    03.6
0227:  INCF   35,F
0228:  GOTO   219
....................    } 
....................     
....................    lcd_send_nibble(2); 
0229:  MOVLW  02
022A:  MOVWF  42
022B:  BCF    03.6
022C:  CALL   0DE
....................    delay_ms(5); 
022D:  MOVLW  05
022E:  BSF    03.6
022F:  MOVWF  3B
0230:  BCF    03.6
0231:  CALL   0CA
....................    for(i=0;i<=3;++i) 
0232:  BSF    03.6
0233:  CLRF   35
0234:  MOVF   35,W
0235:  SUBLW  03
0236:  BTFSS  03.0
0237:  GOTO   246
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0238:  MOVLW  36
0239:  ADDWF  35,W
023A:  MOVWF  04
023B:  BSF    03.7
023C:  MOVF   00,W
023D:  MOVWF  3A
023E:  CLRF   3F
023F:  MOVF   3A,W
0240:  MOVWF  40
0241:  BCF    03.6
0242:  CALL   169
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0243:  BSF    03.6
0244:  INCF   35,F
0245:  GOTO   234
0246:  BCF    03.6
0247:  BSF    0A.3
0248:  BCF    0A.4
0249:  GOTO   271 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
039E:  BSF    03.6
039F:  DECFSZ 3C,W
03A0:  GOTO   3A2
03A1:  GOTO   3A5
....................       address=LCD_LINE_TWO; 
03A2:  MOVLW  40
03A3:  MOVWF  3D
03A4:  GOTO   3A6
....................    else 
....................       address=0; 
03A5:  CLRF   3D
....................       
....................    address+=x-1; 
03A6:  MOVLW  01
03A7:  SUBWF  3B,W
03A8:  ADDWF  3D,F
....................    lcd_send_byte(0,0x80|address); 
03A9:  MOVF   3D,W
03AA:  IORLW  80
03AB:  MOVWF  3E
03AC:  CLRF   3F
03AD:  MOVF   3E,W
03AE:  MOVWF  40
03AF:  BCF    03.6
03B0:  CALL   169
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03B1:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03B2:  BSF    03.6
03B3:  MOVF   3A,W
03B4:  XORLW  07
03B5:  BCF    03.6
03B6:  BTFSC  03.2
03B7:  GOTO   3C2
03B8:  XORLW  0B
03B9:  BTFSC  03.2
03BA:  GOTO   3C9
03BB:  XORLW  06
03BC:  BTFSC  03.2
03BD:  GOTO   3D5
03BE:  XORLW  02
03BF:  BTFSC  03.2
03C0:  GOTO   3DD
03C1:  GOTO   3E4
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03C2:  MOVLW  01
03C3:  BSF    03.6
03C4:  MOVWF  3B
03C5:  MOVWF  3C
03C6:  BCF    03.6
03C7:  CALL   39E
03C8:  GOTO   3EB
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03C9:  BSF    03.6
03CA:  CLRF   3F
03CB:  MOVLW  01
03CC:  MOVWF  40
03CD:  BCF    03.6
03CE:  CALL   169
....................                      delay_ms(2); 
03CF:  MOVLW  02
03D0:  BSF    03.6
03D1:  MOVWF  3B
03D2:  BCF    03.6
03D3:  CALL   0CA
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03D4:  GOTO   3EB
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03D5:  MOVLW  01
03D6:  BSF    03.6
03D7:  MOVWF  3B
03D8:  MOVLW  02
03D9:  MOVWF  3C
03DA:  BCF    03.6
03DB:  CALL   39E
03DC:  GOTO   3EB
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03DD:  BSF    03.6
03DE:  CLRF   3F
03DF:  MOVLW  10
03E0:  MOVWF  40
03E1:  BCF    03.6
03E2:  CALL   169
03E3:  GOTO   3EB
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03E4:  MOVLW  01
03E5:  BSF    03.6
03E6:  MOVWF  3F
03E7:  MOVF   3A,W
03E8:  MOVWF  40
03E9:  BCF    03.6
03EA:  CALL   169
....................      #endif 
....................    } 
03EB:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 VT_DK; 
....................  
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
096A:  CLRF   60
....................  
....................  
.................... //INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR TT_DEVICE_CHAR[]=" "; 
096B:  MOVLW  20
096C:  MOVWF  61
096D:  CLRF   62
.................... //INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR *PACKAGE[]={"S","ID", "S_S" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
096E:  MOVLW  53
096F:  BSF    03.5
0970:  MOVWF  20
0971:  CLRF   21
0972:  MOVLW  49
0973:  MOVWF  22
0974:  MOVLW  44
0975:  MOVWF  23
0976:  CLRF   24
0977:  MOVLW  53
0978:  MOVWF  25
0979:  MOVLW  5F
097A:  MOVWF  26
097B:  MOVLW  53
097C:  MOVWF  27
097D:  CLRF   28
097E:  MOVLW  4C
097F:  MOVWF  29
0980:  MOVLW  45
0981:  MOVWF  2A
0982:  MOVLW  4E
0983:  MOVWF  2B
0984:  MOVLW  47
0985:  MOVWF  2C
0986:  MOVLW  48
0987:  MOVWF  2D
0988:  MOVLW  54
0989:  MOVWF  2E
098A:  CLRF   2F
098B:  MOVLW  44
098C:  MOVWF  30
098D:  MOVLW  41
098E:  MOVWF  31
098F:  MOVLW  54
0990:  MOVWF  32
0991:  MOVLW  41
0992:  MOVWF  33
0993:  MOVLW  31
0994:  MOVWF  34
0995:  CLRF   35
0996:  MOVLW  44
0997:  MOVWF  36
0998:  MOVLW  41
0999:  MOVWF  37
099A:  MOVLW  54
099B:  MOVWF  38
099C:  MOVLW  41
099D:  MOVWF  39
099E:  MOVLW  32
099F:  MOVWF  3A
09A0:  CLRF   3B
09A1:  MOVLW  43
09A2:  MOVWF  3C
09A3:  MOVLW  48
09A4:  MOVWF  3D
09A5:  MOVLW  45
09A6:  MOVWF  3E
09A7:  MOVLW  43
09A8:  MOVWF  3F
09A9:  MOVLW  4B
09AA:  MOVWF  40
09AB:  MOVLW  53
09AC:  MOVWF  41
09AD:  MOVLW  55
09AE:  MOVWF  42
09AF:  MOVLW  4D
09B0:  MOVWF  43
09B1:  CLRF   44
09B2:  MOVLW  23
09B3:  MOVWF  45
09B4:  CLRF   46
09B5:  BCF    03.5
09B6:  CLRF   64
09B7:  MOVLW  A0
09B8:  MOVWF  63
09B9:  CLRF   66
09BA:  MOVLW  A2
09BB:  MOVWF  65
09BC:  CLRF   68
09BD:  MOVLW  A5
09BE:  MOVWF  67
09BF:  CLRF   6A
09C0:  MOVLW  A9
09C1:  MOVWF  69
09C2:  CLRF   6C
09C3:  MOVLW  B0
09C4:  MOVWF  6B
09C5:  CLRF   6E
09C6:  MOVLW  B6
09C7:  MOVWF  6D
09C8:  CLRF   70
09C9:  MOVLW  BC
09CA:  MOVWF  6F
09CB:  CLRF   72
09CC:  MOVLW  C5
09CD:  MOVWF  71
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE","SENSOR","#"}; 
09CE:  MOVLW  53
09CF:  BSF    03.6
09D0:  MOVWF  10
09D1:  CLRF   11
09D2:  MOVLW  49
09D3:  MOVWF  12
09D4:  MOVLW  44
09D5:  MOVWF  13
09D6:  CLRF   14
09D7:  MOVLW  43
09D8:  MOVWF  15
09D9:  MOVLW  5F
09DA:  MOVWF  16
09DB:  MOVLW  46
09DC:  MOVWF  17
09DD:  CLRF   18
09DE:  MOVLW  4C
09DF:  MOVWF  19
09E0:  MOVLW  45
09E1:  MOVWF  1A
09E2:  MOVLW  4E
09E3:  MOVWF  1B
09E4:  MOVLW  47
09E5:  MOVWF  1C
09E6:  MOVLW  48
09E7:  MOVWF  1D
09E8:  MOVLW  54
09E9:  MOVWF  1E
09EA:  CLRF   1F
09EB:  MOVLW  49
09EC:  MOVWF  20
09ED:  MOVLW  44
09EE:  MOVWF  21
09EF:  MOVLW  5F
09F0:  MOVWF  22
09F1:  CLRF   23
09F2:  MOVLW  44
09F3:  MOVWF  24
09F4:  MOVLW  45
09F5:  MOVWF  25
09F6:  MOVLW  56
09F7:  MOVWF  26
09F8:  MOVLW  49
09F9:  MOVWF  27
09FA:  MOVLW  43
09FB:  MOVWF  28
09FC:  MOVLW  45
09FD:  MOVWF  29
09FE:  CLRF   2A
09FF:  MOVLW  53
0A00:  MOVWF  2B
0A01:  MOVLW  45
0A02:  MOVWF  2C
0A03:  MOVLW  4E
0A04:  MOVWF  2D
0A05:  MOVLW  53
0A06:  MOVWF  2E
0A07:  MOVLW  4F
0A08:  MOVWF  2F
0A09:  MOVLW  52
0A0A:  MOVWF  30
0A0B:  CLRF   31
0A0C:  MOVLW  23
0A0D:  MOVWF  32
0A0E:  CLRF   33
0A0F:  MOVLW  01
0A10:  BSF    03.5
0A11:  BCF    03.6
0A12:  MOVWF  48
0A13:  MOVLW  10
0A14:  MOVWF  47
0A15:  MOVLW  01
0A16:  MOVWF  4A
0A17:  MOVLW  12
0A18:  MOVWF  49
0A19:  MOVLW  01
0A1A:  MOVWF  4C
0A1B:  MOVLW  15
0A1C:  MOVWF  4B
0A1D:  MOVLW  01
0A1E:  MOVWF  4E
0A1F:  MOVLW  19
0A20:  MOVWF  4D
0A21:  MOVLW  01
0A22:  MOVWF  50
0A23:  MOVLW  20
0A24:  MOVWF  4F
0A25:  MOVLW  01
0A26:  MOVWF  52
0A27:  MOVLW  24
0A28:  MOVWF  51
0A29:  MOVLW  01
0A2A:  MOVWF  54
0A2B:  MOVLW  2B
0A2C:  MOVWF  53
0A2D:  MOVLW  01
0A2E:  MOVWF  56
0A2F:  MOVLW  32
0A30:  MOVWF  55
.................... CHAR NHIETDO1[]="27"; 
0A31:  MOVWF  73
0A32:  MOVLW  37
0A33:  MOVWF  74
0A34:  CLRF   75
.................... CHAR NHIETDO2[]="27"; 
0A35:  MOVLW  32
0A36:  MOVWF  7B
0A37:  MOVLW  37
0A38:  MOVWF  7C
0A39:  CLRF   7D
.................... CHAR ID_[]="0"; 
0A3A:  MOVLW  30
0A3B:  MOVWF  57
0A3C:  CLRF   58
.................... CHAR TEMP_CHAR[]="0"; 
0A3D:  MOVWF  59
0A3E:  CLRF   5A
....................    
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0637:  BCF    5F.1
....................    TT_STT = 1; 
0638:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0639:  MOVLW  01
063A:  BSF    03.6
063B:  MOVWF  3B
063C:  MOVLW  02
063D:  MOVWF  3C
063E:  BCF    03.6
063F:  CALL   39E
....................    DELAY_MS (10); 
0640:  MOVLW  0A
0641:  BSF    03.6
0642:  MOVWF  3B
0643:  BCF    03.6
0644:  CALL   0CA
....................    PRINTF (LCD_PUTC, "ID: "); 
0645:  MOVLW  65
0646:  BSF    03.6
0647:  MOVWF  0D
0648:  MOVLW  00
0649:  MOVWF  0F
064A:  BCF    03.6
064B:  CALL   3EC
....................  
....................    WHILE (TT_STT) 
064C:  BTFSS  5F.3
064D:  GOTO   68B
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
064E:  BSF    03.5
064F:  BSF    06.2
0650:  BCF    03.5
0651:  BTFSC  06.2
0652:  GOTO   68A
....................       { 
....................          ID_NODE ++; 
0653:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
0654:  MOVF   39,W
0655:  SUBLW  0F
0656:  BTFSS  03.0
0657:  CLRF   39
....................          DELAY_MS (300); 
0658:  MOVLW  02
0659:  BSF    03.6
065A:  MOVWF  35
065B:  MOVLW  96
065C:  MOVWF  3B
065D:  BCF    03.6
065E:  CALL   0CA
065F:  BSF    03.6
0660:  DECFSZ 35,F
0661:  GOTO   65B
....................          ITOA (ID_NODE, 10, ID_); 
0662:  CLRF   3A
0663:  CLRF   39
0664:  CLRF   38
0665:  BCF    03.6
0666:  MOVF   39,W
0667:  BSF    03.6
0668:  MOVWF  37
0669:  MOVLW  0A
066A:  MOVWF  3B
066B:  CLRF   3D
066C:  MOVLW  D7
066D:  MOVWF  3C
066E:  BCF    03.6
066F:  CALL   4B8
....................          LCD_GOTOXY (9, 2) ; 
0670:  MOVLW  09
0671:  BSF    03.6
0672:  MOVWF  3B
0673:  MOVLW  02
0674:  MOVWF  3C
0675:  BCF    03.6
0676:  CALL   39E
....................          DELAY_MS (10); 
0677:  MOVLW  0A
0678:  BSF    03.6
0679:  MOVWF  3B
067A:  BCF    03.6
067B:  CALL   0CA
....................          PRINTF (LCD_PUTC, ID_); 
067C:  MOVLW  D7
067D:  MOVWF  04
067E:  BCF    03.7
067F:  CALL   5D8
....................          DELAY_MS (1); 
0680:  MOVLW  01
0681:  BSF    03.6
0682:  MOVWF  3B
0683:  BCF    03.6
0684:  CALL   0CA
....................          OUTPUT_TOGGLE (PIN_D0); 
0685:  BSF    03.5
0686:  BCF    08.0
0687:  MOVLW  01
0688:  BCF    03.5
0689:  XORWF  08,F
....................       } 
068A:  GOTO   64C
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
068C:  BCF    5F.1
....................    TT_STT = 1; 
068D:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
068E:  MOVLW  01
068F:  BSF    03.6
0690:  MOVWF  3B
0691:  MOVLW  02
0692:  MOVWF  3C
0693:  BCF    03.6
0694:  CALL   39E
....................    DELAY_MS (10); 
0695:  MOVLW  0A
0696:  BSF    03.6
0697:  MOVWF  3B
0698:  BCF    03.6
0699:  CALL   0CA
....................    PRINTF (LCD_PUTC, "DEVICE: "); 
069A:  MOVLW  68
069B:  BSF    03.6
069C:  MOVWF  0D
069D:  MOVLW  00
069E:  MOVWF  0F
069F:  BCF    03.6
06A0:  CALL   3EC
....................  
....................    WHILE (TT_STT) 
06A1:  BTFSS  5F.3
06A2:  GOTO   759
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06A3:  BSF    03.5
06A4:  BSF    06.2
06A5:  BCF    03.5
06A6:  BTFSC  06.2
06A7:  GOTO   70C
....................       { 
....................          STT_DEVICE ++; 
06A8:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
06A9:  MOVF   3A,W
06AA:  SUBLW  07
06AB:  BTFSS  03.0
06AC:  CLRF   3A
....................          DELAY_MS (300); 
06AD:  MOVLW  02
06AE:  BSF    03.6
06AF:  MOVWF  35
06B0:  MOVLW  96
06B1:  MOVWF  3B
06B2:  BCF    03.6
06B3:  CALL   0CA
06B4:  BSF    03.6
06B5:  DECFSZ 35,F
06B6:  GOTO   6B0
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
06B7:  CLRF   3A
06B8:  CLRF   39
06B9:  CLRF   38
06BA:  BCF    03.6
06BB:  MOVF   3A,W
06BC:  BSF    03.6
06BD:  MOVWF  37
06BE:  MOVLW  0A
06BF:  MOVWF  3B
06C0:  CLRF   3D
06C1:  MOVLW  D9
06C2:  MOVWF  3C
06C3:  BCF    03.6
06C4:  CALL   4B8
....................          LCD_GOTOXY (9, 2) ; 
06C5:  MOVLW  09
06C6:  BSF    03.6
06C7:  MOVWF  3B
06C8:  MOVLW  02
06C9:  MOVWF  3C
06CA:  BCF    03.6
06CB:  CALL   39E
....................          DELAY_MS (10); 
06CC:  MOVLW  0A
06CD:  BSF    03.6
06CE:  MOVWF  3B
06CF:  BCF    03.6
06D0:  CALL   0CA
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06D1:  MOVLW  D9
06D2:  MOVWF  04
06D3:  BCF    03.7
06D4:  CALL   5D8
....................          DELAY_MS (1); 
06D5:  MOVLW  01
06D6:  BSF    03.6
06D7:  MOVWF  3B
06D8:  BCF    03.6
06D9:  CALL   0CA
....................          PRINTF (LCD_PUTC, ":"); 
06DA:  MOVLW  3A
06DB:  BSF    03.6
06DC:  MOVWF  3A
06DD:  BCF    03.6
06DE:  CALL   3B2
....................          DELAY_MS (1); 
06DF:  MOVLW  01
06E0:  BSF    03.6
06E1:  MOVWF  3B
06E2:  BCF    03.6
06E3:  CALL   0CA
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
06E4:  MOVF   3A,W
06E5:  BSF    03.6
06E6:  MOVWF  37
06E7:  CLRF   39
06E8:  MOVLW  60
06E9:  MOVWF  38
06EA:  BCF    03.6
06EB:  CALL   5F5
06EC:  MOVLW  00
06ED:  BTFSC  78.0
06EE:  MOVLW  01
06EF:  BSF    03.6
06F0:  MOVWF  35
06F1:  CLRF   3A
06F2:  CLRF   39
06F3:  CLRF   38
06F4:  MOVF   35,W
06F5:  MOVWF  37
06F6:  MOVLW  0A
06F7:  MOVWF  3B
06F8:  CLRF   3D
06F9:  MOVLW  D9
06FA:  MOVWF  3C
06FB:  BCF    03.6
06FC:  CALL   4B8
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06FD:  MOVLW  D9
06FE:  MOVWF  04
06FF:  BCF    03.7
0700:  CALL   5D8
....................          DELAY_MS (1); 
0701:  MOVLW  01
0702:  BSF    03.6
0703:  MOVWF  3B
0704:  BCF    03.6
0705:  CALL   0CA
....................          OUTPUT_TOGGLE (PIN_D0); 
0706:  BSF    03.5
0707:  BCF    08.0
0708:  MOVLW  01
0709:  BCF    03.5
070A:  XORWF  08,F
....................       } 
070B:  GOTO   758
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
070C:  BSF    03.5
070D:  BSF    06.3
070E:  BCF    03.5
070F:  BTFSC  06.3
0710:  GOTO   758
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
0711:  MOVF   3A,W
0712:  BSF    03.6
0713:  MOVWF  37
0714:  CLRF   39
0715:  MOVLW  60
0716:  MOVWF  38
0717:  BCF    03.6
0718:  CALL   5F5
0719:  MOVLW  00
071A:  BTFSS  78.0
071B:  MOVLW  01
071C:  BSF    03.6
071D:  MOVWF  35
071E:  BCF    03.6
071F:  MOVF   3A,W
0720:  BSF    03.6
0721:  MOVWF  36
0722:  MOVF   35,W
0723:  MOVWF  37
0724:  CLRF   39
0725:  MOVLW  60
0726:  MOVWF  38
0727:  BCF    03.6
0728:  CALL   60E
....................          LCD_GOTOXY (12, 2) ; 
0729:  MOVLW  0C
072A:  BSF    03.6
072B:  MOVWF  3B
072C:  MOVLW  02
072D:  MOVWF  3C
072E:  BCF    03.6
072F:  CALL   39E
....................          DELAY_MS (300); 
0730:  MOVLW  02
0731:  BSF    03.6
0732:  MOVWF  35
0733:  MOVLW  96
0734:  MOVWF  3B
0735:  BCF    03.6
0736:  CALL   0CA
0737:  BSF    03.6
0738:  DECFSZ 35,F
0739:  GOTO   733
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
073A:  BCF    03.6
073B:  MOVF   3A,W
073C:  BSF    03.6
073D:  MOVWF  37
073E:  CLRF   39
073F:  MOVLW  60
0740:  MOVWF  38
0741:  BCF    03.6
0742:  CALL   5F5
0743:  MOVLW  00
0744:  BTFSC  78.0
0745:  MOVLW  01
0746:  BSF    03.6
0747:  MOVWF  35
0748:  CLRF   3A
0749:  CLRF   39
074A:  CLRF   38
074B:  MOVF   35,W
074C:  MOVWF  37
074D:  MOVLW  0A
074E:  MOVWF  3B
074F:  CLRF   3D
0750:  MOVLW  D9
0751:  MOVWF  3C
0752:  BCF    03.6
0753:  CALL   4B8
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0754:  MOVLW  D9
0755:  MOVWF  04
0756:  BCF    03.7
0757:  CALL   5D8
....................       } 
0758:  GOTO   6A1
....................    } 
.................... } 
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
076E:  BCF    5F.1
....................    ID_NODE = 0; 
076F:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00A4:  BCF    03.6
00A5:  BCF    5F.1
....................    TT_FUN = 0; 
00A6:  BCF    5F.2
....................    TT_STT = 0; 
00A7:  BCF    5F.3
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0630:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0631:  MOVF   38,W
0632:  ADDLW  FC
0633:  BTFSC  03.0
0634:  GOTO   770
0635:  ADDLW  04
0636:  GOTO   773
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
068B:  GOTO   770
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0759:  GOTO   770
....................  
....................       CASE 2: 
....................       //CONFIG_SENSOR (); 
....................        
....................       LCD_GOTOXY (10, 2) ; 
075A:  MOVLW  0A
075B:  BSF    03.6
075C:  MOVWF  3B
075D:  MOVLW  02
075E:  MOVWF  3C
075F:  BCF    03.6
0760:  CALL   39E
....................       DELAY_MS (10); 
0761:  MOVLW  0A
0762:  BSF    03.6
0763:  MOVWF  3B
0764:  BCF    03.6
0765:  CALL   0CA
....................       PRINTF (LCD_PUTC, "CASE1"); 
0766:  MOVLW  6D
0767:  BSF    03.6
0768:  MOVWF  0D
0769:  MOVLW  00
076A:  MOVWF  0F
076B:  BCF    03.6
076C:  CALL   3EC
....................       BREAK; 
076D:  GOTO   770
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
0770:  BCF    0A.3
0771:  BCF    0A.4
0772:  GOTO   7D7 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
077B:  BSF    5F.2
....................    LCD_GOTOXY (1, 1) ; 
077C:  MOVLW  01
077D:  BSF    03.6
077E:  MOVWF  3B
077F:  MOVWF  3C
0780:  BCF    03.6
0781:  CALL   39E
....................    DELAY_MS (10); 
0782:  MOVLW  0A
0783:  BSF    03.6
0784:  MOVWF  3B
0785:  BCF    03.6
0786:  CALL   0CA
....................    PRINTF (LCD_PUTC, "CONFIG"); 
0787:  MOVLW  70
0788:  BSF    03.6
0789:  MOVWF  0D
078A:  MOVLW  00
078B:  MOVWF  0F
078C:  BCF    03.6
078D:  CALL   3EC
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
078E:  MOVLW  01
078F:  BSF    03.6
0790:  MOVWF  3B
0791:  MOVLW  02
0792:  MOVWF  3C
0793:  BCF    03.6
0794:  CALL   39E
....................    DELAY_MS (10); 
0795:  MOVLW  0A
0796:  BSF    03.6
0797:  MOVWF  3B
0798:  BCF    03.6
0799:  CALL   0CA
....................    PRINTF (LCD_PUTC, "CASE: "); 
079A:  MOVLW  74
079B:  BSF    03.6
079C:  MOVWF  0D
079D:  MOVLW  00
079E:  MOVWF  0F
079F:  BCF    03.6
07A0:  CALL   3EC
....................  
....................    WHILE (TT_FUN) 
07A1:  BTFSS  5F.2
07A2:  GOTO   7D6
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
07A3:  BSF    03.5
07A4:  BSF    06.2
07A5:  BCF    03.5
07A6:  BTFSC  06.2
07A7:  GOTO   7D5
....................       { 
....................          CONFIG_FUN ++; 
07A8:  INCF   38,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
07A9:  MOVF   38,W
07AA:  SUBLW  03
07AB:  BTFSS  03.0
07AC:  CLRF   38
....................          DELAY_MS (300); 
07AD:  MOVLW  02
07AE:  BSF    03.6
07AF:  MOVWF  35
07B0:  MOVLW  96
07B1:  MOVWF  3B
07B2:  BCF    03.6
07B3:  CALL   0CA
07B4:  BSF    03.6
07B5:  DECFSZ 35,F
07B6:  GOTO   7B0
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (9, 2) ; 
07B7:  MOVLW  09
07B8:  MOVWF  3B
07B9:  MOVLW  02
07BA:  MOVWF  3C
07BB:  BCF    03.6
07BC:  CALL   39E
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
07BD:  BSF    03.6
07BE:  CLRF   3A
07BF:  CLRF   39
07C0:  CLRF   38
07C1:  BCF    03.6
07C2:  MOVF   38,W
07C3:  BSF    03.6
07C4:  MOVWF  37
07C5:  MOVLW  0A
07C6:  MOVWF  3B
07C7:  CLRF   3D
07C8:  MOVLW  D9
07C9:  MOVWF  3C
07CA:  BCF    03.6
07CB:  CALL   4B8
....................          DELAY_MS (10); 
07CC:  MOVLW  0A
07CD:  BSF    03.6
07CE:  MOVWF  3B
07CF:  BCF    03.6
07D0:  CALL   0CA
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
07D1:  MOVLW  D9
07D2:  MOVWF  04
07D3:  BCF    03.7
07D4:  CALL   5D8
....................       } 
07D5:  GOTO   7A1
....................    } 
....................  
....................    SELLECT_FUN (); 
07D6:  GOTO   630
07D7:  BSF    0A.3
07D8:  BCF    0A.4
07D9:  GOTO   287 (RETURN)
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0842:  BCF    5F.2
....................    TT_STT = 0; 
0843:  BCF    5F.3
....................    TT_DEVICE_CHAR = ""; 
0844:  BSF    03.6
0845:  CLRF   37
0846:  CLRF   38
0847:  MOVLW  61
0848:  MOVWF  04
0849:  BCF    03.7
084A:  MOVF   37,W
084B:  ADDWF  04,F
084C:  MOVF   38,W
084D:  BCF    0A.3
084E:  BCF    03.6
084F:  CALL   058
0850:  BSF    0A.3
0851:  MOVWF  00
0852:  IORLW  00
0853:  BTFSC  03.2
0854:  GOTO   05A
0855:  BSF    03.6
0856:  INCF   38,F
0857:  INCF   37,F
0858:  GOTO   047
0859:  BCF    03.6
....................    FOR (INT I = 0; I < 8; I++) 
085A:  BSF    03.6
085B:  CLRF   35
085C:  MOVF   35,W
085D:  SUBLW  07
085E:  BTFSS  03.0
085F:  GOTO   086
....................    { 
....................       IF (TT_DEVICE[I]) 
0860:  MOVF   35,W
0861:  MOVWF  37
0862:  CLRF   39
0863:  MOVLW  60
0864:  MOVWF  38
0865:  BCF    0A.3
0866:  BCF    03.6
0867:  CALL   5F5
0868:  BSF    0A.3
0869:  BTFSS  78.0
086A:  GOTO   083
....................       { 
....................          ITOA (I, 10, TEMP_CHAR); 
086B:  BSF    03.6
086C:  CLRF   3A
086D:  CLRF   39
086E:  CLRF   38
086F:  MOVF   35,W
0870:  MOVWF  37
0871:  MOVLW  0A
0872:  MOVWF  3B
0873:  CLRF   3D
0874:  MOVLW  D9
0875:  MOVWF  3C
0876:  BCF    0A.3
0877:  BCF    03.6
0878:  CALL   4B8
0879:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
087A:  BSF    03.6
087B:  CLRF   38
087C:  MOVLW  61
087D:  MOVWF  37
087E:  CLRF   3A
087F:  MOVLW  D9
0880:  MOVWF  39
0881:  BCF    03.6
0882:  CALL   000
....................       } 
0883:  BSF    03.6
0884:  INCF   35,F
0885:  GOTO   05C
....................    } 
....................  
....................    TEMP_CHAR = " * "; 
0886:  CLRF   37
0887:  CLRF   38
0888:  MOVLW  D9
0889:  MOVWF  04
088A:  BCF    03.7
088B:  MOVF   37,W
088C:  ADDWF  04,F
088D:  MOVF   38,W
088E:  BCF    0A.3
088F:  BCF    03.6
0890:  CALL   05D
0891:  BSF    0A.3
0892:  MOVWF  00
0893:  IORLW  00
0894:  BTFSC  03.2
0895:  GOTO   09B
0896:  BSF    03.6
0897:  INCF   38,F
0898:  INCF   37,F
0899:  GOTO   088
089A:  BCF    03.6
....................    STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
089B:  BSF    03.6
089C:  CLRF   38
089D:  MOVLW  61
089E:  MOVWF  37
089F:  CLRF   3A
08A0:  MOVLW  D9
08A1:  MOVWF  39
08A2:  BCF    03.6
08A3:  CALL   000
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
08A4:  BSF    03.5
08A5:  CLRF   52
08A6:  MOVLW  61
08A7:  MOVWF  51
....................    PACKAGE_CONFIG[1] = ID_; 
08A8:  CLRF   4A
08A9:  MOVLW  D7
08AA:  MOVWF  49
....................     
....................    FOR (INT J = 0; J < 8; J++) 
08AB:  BCF    03.5
08AC:  BSF    03.6
08AD:  CLRF   36
08AE:  MOVF   36,W
08AF:  SUBLW  07
08B0:  BTFSS  03.0
08B1:  GOTO   0CF
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08B2:  BCF    03.0
08B3:  RLF    36,W
08B4:  ADDLW  C7
08B5:  MOVWF  04
08B6:  BCF    03.7
08B7:  INCF   04,F
08B8:  MOVF   00,W
08B9:  MOVWF  38
08BA:  DECF   04,F
08BB:  MOVF   00,W
08BC:  MOVWF  37
08BD:  MOVWF  04
08BE:  BCF    03.7
08BF:  BTFSC  38.0
08C0:  BSF    03.7
08C1:  BCF    0A.3
08C2:  BCF    03.6
08C3:  CALL   7DA
08C4:  BSF    0A.3
....................       DELAY_MS (1); 
08C5:  MOVLW  01
08C6:  BSF    03.6
08C7:  MOVWF  3B
08C8:  BCF    0A.3
08C9:  BCF    03.6
08CA:  CALL   0CA
08CB:  BSF    0A.3
08CC:  BSF    03.6
08CD:  INCF   36,F
08CE:  GOTO   0AE
....................    } 
....................  
....................     
....................    LCD_GOTOXY (1, 1) ; 
08CF:  MOVLW  01
08D0:  MOVWF  3B
08D1:  MOVWF  3C
08D2:  BCF    0A.3
08D3:  BCF    03.6
08D4:  CALL   39E
08D5:  BSF    0A.3
....................    DELAY_MS (10); 
08D6:  MOVLW  0A
08D7:  BSF    03.6
08D8:  MOVWF  3B
08D9:  BCF    0A.3
08DA:  BCF    03.6
08DB:  CALL   0CA
08DC:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE"); 
08DD:  MOVLW  78
08DE:  BSF    03.6
08DF:  MOVWF  0D
08E0:  MOVLW  00
08E1:  MOVWF  0F
08E2:  BCF    0A.3
08E3:  BCF    03.6
08E4:  CALL   3EC
08E5:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
08E6:  MOVLW  01
08E7:  BSF    03.6
08E8:  MOVWF  3B
08E9:  MOVLW  02
08EA:  MOVWF  3C
08EB:  BCF    0A.3
08EC:  BCF    03.6
08ED:  CALL   39E
08EE:  BSF    0A.3
....................    DELAY_MS (10); 
08EF:  MOVLW  0A
08F0:  BSF    03.6
08F1:  MOVWF  3B
08F2:  BCF    0A.3
08F3:  BCF    03.6
08F4:  CALL   0CA
08F5:  BSF    0A.3
....................    PRINTF (LCD_PUTC, TT_DEVICE_CHAR); 
08F6:  MOVLW  61
08F7:  MOVWF  04
08F8:  BCF    03.7
08F9:  BCF    0A.3
08FA:  CALL   5D8
08FB:  BSF    0A.3
....................    PACKAGE[1] = ID_; 
08FC:  CLRF   66
08FD:  MOVLW  D7
08FE:  MOVWF  65
....................    TT_CONFIG_DONE = 0; 
08FF:  BCF    5F.1
0900:  BSF    0A.3
0901:  BCF    0A.4
0902:  GOTO   28B (RETURN)
.................... } 
....................  
.................... VOID QUET_PHIM() 
*
007E:  BSF    03.6
007F:  CLRF   5C
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
0080:  BSF    03.5
0081:  BCF    03.6
0082:  BSF    06.1
0083:  BCF    03.5
0084:  BTFSC  06.1
0085:  GOTO   099
....................    { 
....................       IF (TMR1IF)       
0086:  BTFSS  0C.0
0087:  GOTO   096
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
0088:  BSF    03.5
0089:  BCF    08.2
008A:  MOVLW  04
008B:  BCF    03.5
008C:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
008D:  BCF    0C.0
008E:  CLRF   0E
008F:  MOVLW  0B
0090:  MOVWF  0F
0091:  MOVLW  DC
0092:  MOVWF  0E
0093:  BSF    03.6
0094:  INCF   5C,F
0095:  BCF    03.6
....................       } 
0096:  BSF    03.6
0097:  GOTO   080
0098:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 40) 
0099:  BSF    03.6
009A:  MOVF   5C,W
009B:  SUBLW  28
009C:  BTFSC  03.0
009D:  GOTO   0A4
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
009E:  MOVLW  01
009F:  BCF    03.6
00A0:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00A1:  BSF    5F.1
....................    } 
00A2:  GOTO   0A8
00A3:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    }   
.................... } 
....................  
.................... #INT_EXT 
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
....................  
*
00A8:  BCF    0B.1
00A9:  BCF    0A.3
00AA:  BCF    0A.4
00AB:  GOTO   031
.................... #INT_RDA 
.................... VOID NGAT() 
.................... {    
....................    KYTU[VT] = GETCH (); 
00AC:  MOVLW  3B
00AD:  ADDWF  59,W
00AE:  MOVWF  04
00AF:  BCF    03.7
00B0:  BTFSS  0C.5
00B1:  GOTO   0B0
00B2:  MOVF   1A,W
00B3:  MOVWF  00
....................    IF (KYTU[VT] == '.') 
00B4:  MOVLW  3B
00B5:  ADDWF  59,W
00B6:  MOVWF  04
00B7:  BCF    03.7
00B8:  MOVF   00,W
00B9:  SUBLW  2E
00BA:  BTFSS  03.2
00BB:  GOTO   0C5
....................    { 
....................       KYTU[VT] = '\0'; 
00BC:  MOVLW  3B
00BD:  ADDWF  59,W
00BE:  MOVWF  04
00BF:  BCF    03.7
00C0:  CLRF   00
....................       VT = 0; 
00C1:  CLRF   59
....................       TTNHAN = 1; 
00C2:  MOVLW  01
00C3:  MOVWF  5A
....................    } 
00C4:  GOTO   0C6
....................    ELSE 
....................    VT++; 
00C5:  INCF   59,F
00C6:  BCF    0C.5
00C7:  BCF    0A.3
00C8:  BCF    0A.4
00C9:  GOTO   031
.................... } 
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
091D:  MOVLW  01
091E:  BSF    03.6
091F:  MOVWF  3B
0920:  MOVWF  3C
0921:  BCF    0A.3
0922:  BCF    03.6
0923:  CALL   39E
0924:  BSF    0A.3
....................     DELAY_MS (10); 
0925:  MOVLW  0A
0926:  BSF    03.6
0927:  MOVWF  3B
0928:  BCF    0A.3
0929:  BCF    03.6
092A:  CALL   0CA
092B:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTU); 
092C:  MOVLW  3B
092D:  MOVWF  04
092E:  BCF    03.7
092F:  BCF    0A.3
0930:  CALL   5D8
0931:  BSF    0A.3
....................     DELAY_MS (1); 
0932:  MOVLW  01
0933:  BSF    03.6
0934:  MOVWF  3B
0935:  BCF    0A.3
0936:  BCF    03.6
0937:  CALL   0CA
0938:  BSF    0A.3
0939:  BSF    0A.3
093A:  BCF    0A.4
093B:  GOTO   2FE (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
024A:  BSF    03.6
024B:  RLF    35,W
024C:  MOVWF  77
024D:  RLF    77,F
024E:  MOVLW  FC
024F:  ANDWF  77,F
0250:  BCF    03.6
0251:  MOVF   1F,W
0252:  ANDLW  C3
0253:  IORWF  77,W
0254:  MOVWF  1F
....................     KQADC = 0; 
0255:  CLRF   33
0256:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0257:  BSF    03.6
0258:  CLRF   36
0259:  MOVF   36,W
025A:  SUBLW  63
025B:  BTFSS  03.0
025C:  GOTO   271
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
025D:  BCF    03.6
025E:  BSF    1F.1
025F:  BTFSC  1F.1
0260:  GOTO   25F
0261:  BSF    03.5
0262:  MOVF   1E,W
0263:  BCF    03.5
0264:  ADDWF  32,F
0265:  MOVF   1E,W
0266:  BTFSC  03.0
0267:  INCFSZ 1E,W
0268:  ADDWF  33,F
....................        DELAY_MS (1); 
0269:  MOVLW  01
026A:  BSF    03.6
026B:  MOVWF  3B
026C:  BCF    03.6
026D:  CALL   0CA
026E:  BSF    03.6
026F:  INCF   36,F
0270:  GOTO   259
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0271:  BCF    03.6
0272:  MOVF   33,W
0273:  BSF    03.6
0274:  MOVWF  38
0275:  BCF    03.6
0276:  MOVF   32,W
0277:  BSF    03.6
0278:  MOVWF  37
*
0295:  MOVF   7A,W
0296:  MOVWF  3A
0297:  MOVF   79,W
0298:  MOVWF  39
0299:  MOVF   78,W
029A:  MOVWF  38
029B:  MOVF   77,W
029C:  MOVWF  37
029D:  MOVLW  9A
029E:  MOVWF  3E
029F:  MOVLW  99
02A0:  MOVWF  3D
02A1:  MOVLW  4C
02A2:  MOVWF  3C
02A3:  MOVLW  86
02A4:  MOVWF  3B
*
036E:  MOVF   7A,W
036F:  MOVWF  3A
0370:  MOVF   79,W
0371:  MOVWF  39
0372:  MOVF   78,W
0373:  MOVWF  38
0374:  MOVF   77,W
0375:  MOVWF  37
*
0394:  MOVF   79,W
0395:  BCF    03.6
0396:  MOVWF  33
0397:  MOVF   78,W
0398:  MOVWF  32
....................     RETURN KQADC; 
0399:  MOVF   32,W
039A:  MOVWF  78
039B:  BSF    0A.3
039C:  BCF    0A.4
039D:  GOTO   27F (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0903:  BSF    03.6
0904:  CLRF   35
0905:  MOVF   35,W
0906:  SUBLW  1E
0907:  BTFSS  03.0
0908:  GOTO   119
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
0909:  BSF    03.5
090A:  BCF    03.6
090B:  BCF    08.1
090C:  MOVLW  02
090D:  BCF    03.5
090E:  XORWF  08,F
....................        DELAY_MS (100); 
090F:  MOVLW  64
0910:  BSF    03.6
0911:  MOVWF  3B
0912:  BCF    0A.3
0913:  BCF    03.6
0914:  CALL   0CA
0915:  BSF    0A.3
0916:  BSF    03.6
0917:  INCF   35,F
0918:  GOTO   105
....................     } 
0919:  BCF    03.6
091A:  BSF    0A.3
091B:  BCF    0A.4
091C:  GOTO   28C (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
093C:  MOVF   03,W
093D:  ANDLW  1F
093E:  MOVWF  03
093F:  BSF    03.5
0940:  BSF    03.6
0941:  BSF    07.3
0942:  MOVLW  08
0943:  BCF    03.6
0944:  MOVWF  19
0945:  MOVLW  02
0946:  MOVWF  1A
0947:  MOVLW  A6
0948:  MOVWF  18
0949:  MOVLW  90
094A:  BCF    03.5
094B:  MOVWF  18
094C:  MOVLW  FF
094D:  MOVWF  31
094E:  CLRF   38
094F:  CLRF   39
0950:  CLRF   3A
0951:  CLRF   59
0952:  CLRF   5A
0953:  BCF    5F.0
0954:  BCF    5F.1
0955:  BCF    5F.2
0956:  BCF    5F.3
0957:  BSF    03.5
0958:  BSF    03.6
0959:  MOVF   09,W
095A:  ANDLW  C0
095B:  MOVWF  09
095C:  BCF    03.6
095D:  BCF    1F.4
095E:  BCF    1F.5
095F:  MOVLW  00
0960:  BSF    03.6
0961:  MOVWF  08
0962:  BCF    03.5
0963:  CLRF   07
0964:  CLRF   08
0965:  CLRF   09
0966:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0A3F:  MOVLW  00
0A40:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0A41:  MOVLW  FF
0A42:  MOVWF  06
....................     SET_TRIS_E (0); 
0A43:  BCF    09.0
0A44:  BCF    09.1
0A45:  BCF    09.2
0A46:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0A47:  MOVLW  80
0A48:  MOVWF  07
0A49:  BCF    03.5
0A4A:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0A4B:  BSF    1F.6
0A4C:  BCF    1F.7
0A4D:  BSF    03.5
0A4E:  BSF    1F.7
0A4F:  BCF    03.5
0A50:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0A51:  BSF    03.5
0A52:  BSF    03.6
0A53:  MOVF   09,W
0A54:  ANDLW  C0
0A55:  MOVWF  09
0A56:  BCF    03.6
0A57:  BCF    1F.4
0A58:  BCF    1F.5
0A59:  MOVLW  01
0A5A:  BSF    03.6
0A5B:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0A5C:  BCF    03.5
0A5D:  BCF    03.6
0A5E:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0A5F:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0A60:  BSF    0B.4
0A61:  BSF    03.5
0A62:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0A63:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0A64:  MOVLW  C0
0A65:  BCF    03.5
0A66:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8) ; 
0A67:  MOVLW  35
0A68:  MOVWF  10
....................     //SET_TIMER1 (0) ; 
....................     SET_TIMER1 (3036) ; 
0A69:  CLRF   0E
0A6A:  MOVLW  0B
0A6B:  MOVWF  0F
0A6C:  MOVLW  DC
0A6D:  MOVWF  0E
....................     TMR1IF = 0; 
0A6E:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0A6F:  BCF    0A.3
0A70:  GOTO   1E4
0A71:  BSF    0A.3
....................     ID_NODE = 0; 
0A72:  CLRF   39
....................     TT_CONFIG = 0; 
0A73:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0A74:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0A75:  BSF    03.5
0A76:  CLRF   08
0A77:  BCF    03.5
0A78:  CLRF   08
....................     TTNHAN = 0; 
0A79:  CLRF   5A
....................               
....................                 
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0A7A:  BSF    03.6
0A7B:  CLRF   35
0A7C:  BCF    0A.3
0A7D:  BCF    03.6
0A7E:  GOTO   24A
0A7F:  BSF    0A.3
0A80:  CLRF   35
0A81:  MOVF   78,W
0A82:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0A83:  BTFSS  5F.0
0A84:  GOTO   289
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0A85:  BCF    0A.3
0A86:  GOTO   77B
0A87:  BSF    0A.3
....................        } 
0A88:  GOTO   28B
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0A89:  BTFSC  5F.1
....................        { 
....................           CONFIG_DONE () ; 
0A8A:  GOTO   042
....................        } 
....................  
....................        CHUONG_TRINH_CON (); 
0A8B:  GOTO   103
....................  
....................        IF (AN0 > 26) 
0A8C:  MOVF   35,F
0A8D:  BTFSS  03.2
0A8E:  GOTO   293
0A8F:  MOVF   34,W
0A90:  SUBLW  1A
0A91:  BTFSC  03.0
0A92:  GOTO   2F0
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0A93:  BSF    03.6
0A94:  CLRF   3A
0A95:  CLRF   39
0A96:  BCF    03.6
0A97:  MOVF   35,W
0A98:  BSF    03.6
0A99:  MOVWF  38
0A9A:  BCF    03.6
0A9B:  MOVF   34,W
0A9C:  BSF    03.6
0A9D:  MOVWF  37
0A9E:  MOVLW  0A
0A9F:  MOVWF  3B
0AA0:  CLRF   3D
0AA1:  MOVLW  73
0AA2:  MOVWF  3C
0AA3:  BCF    0A.3
0AA4:  BCF    03.6
0AA5:  CALL   4B8
0AA6:  BSF    0A.3
....................           PACKAGE[4] = NHIETDO1; 
0AA7:  CLRF   6C
0AA8:  MOVLW  73
0AA9:  MOVWF  6B
....................           ITOA (AN1, 10, NHIETDO2); 
0AAA:  BSF    03.6
0AAB:  CLRF   3A
0AAC:  CLRF   39
0AAD:  BCF    03.6
0AAE:  MOVF   37,W
0AAF:  BSF    03.6
0AB0:  MOVWF  38
0AB1:  BCF    03.6
0AB2:  MOVF   36,W
0AB3:  BSF    03.6
0AB4:  MOVWF  37
0AB5:  MOVLW  0A
0AB6:  MOVWF  3B
0AB7:  CLRF   3D
0AB8:  MOVLW  7B
0AB9:  MOVWF  3C
0ABA:  BCF    0A.3
0ABB:  BCF    03.6
0ABC:  CALL   4B8
0ABD:  BSF    0A.3
....................           PACKAGE[5] = NHIETDO2; 
0ABE:  CLRF   6E
0ABF:  MOVLW  7B
0AC0:  MOVWF  6D
....................            
....................           FOR (INT I = 0; I < 8; I++) 
0AC1:  BSF    03.6
0AC2:  CLRF   34
0AC3:  MOVF   34,W
0AC4:  SUBLW  07
0AC5:  BTFSS  03.0
0AC6:  GOTO   2E4
....................           { 
....................              PRINTF (PACKAGE[I]); 
0AC7:  BCF    03.0
0AC8:  RLF    34,W
0AC9:  ADDLW  63
0ACA:  MOVWF  04
0ACB:  BCF    03.7
0ACC:  INCF   04,F
0ACD:  MOVF   00,W
0ACE:  MOVWF  36
0ACF:  DECF   04,F
0AD0:  MOVF   00,W
0AD1:  MOVWF  35
0AD2:  MOVWF  04
0AD3:  BCF    03.7
0AD4:  BTFSC  36.0
0AD5:  BSF    03.7
0AD6:  BCF    0A.3
0AD7:  BCF    03.6
0AD8:  CALL   7DA
0AD9:  BSF    0A.3
....................              DELAY_MS (1); 
0ADA:  MOVLW  01
0ADB:  BSF    03.6
0ADC:  MOVWF  3B
0ADD:  BCF    0A.3
0ADE:  BCF    03.6
0ADF:  CALL   0CA
0AE0:  BSF    0A.3
0AE1:  BSF    03.6
0AE2:  INCF   34,F
0AE3:  GOTO   2C3
....................           } 
....................  
....................           DELAY_MS (1000); 
0AE4:  MOVLW  04
0AE5:  MOVWF  35
0AE6:  MOVLW  FA
0AE7:  MOVWF  3B
0AE8:  BCF    0A.3
0AE9:  BCF    03.6
0AEA:  CALL   0CA
0AEB:  BSF    0A.3
0AEC:  BSF    03.6
0AED:  DECFSZ 35,F
0AEE:  GOTO   2E6
0AEF:  BCF    03.6
....................        } 
....................  
....................        IF (TTNHAN == 1) 
0AF0:  DECFSZ 5A,W
0AF1:  GOTO   31F
....................        { 
....................            
....................           TTNHAN = 0; 
0AF2:  CLRF   5A
....................           //TEMP_CHAR = 'K'; 
....................           ID_NODE_NHAN = KYTU[1]-48; 
0AF3:  MOVLW  30
0AF4:  SUBWF  3C,W
0AF5:  MOVWF  5B
....................           ID_DEVICE_NHAN =KYTU[2]-48 + 64; 
0AF6:  MOVLW  30
0AF7:  SUBWF  3D,W
0AF8:  ADDLW  40
0AF9:  MOVWF  5C
....................           TT_DEVICE_NHAN = KYTU[3]-48;// -48 ASCII --> S. +64 -->PORT_D (D0=64) 
0AFA:  MOVLW  30
0AFB:  SUBWF  3E,W
0AFC:  MOVWF  5D
....................           XUATLCD ();                 
0AFD:  GOTO   11D
....................           IF(ID_NODE_NHAN == ID_NODE) 
0AFE:  MOVF   39,W
0AFF:  SUBWF  5B,W
0B00:  BTFSS  03.2
0B01:  GOTO   31F
....................           { 
....................                OUTPUT_BIT (ID_DEVICE_NHAN,TT_DEVICE_NHAN);  
0B02:  MOVF   5D,F
0B03:  BTFSS  03.2
0B04:  GOTO   307
0B05:  MOVLW  00
0B06:  GOTO   308
0B07:  MOVLW  01
0B08:  MOVWF  77
0B09:  MOVF   5C,W
0B0A:  BSF    03.6
0B0B:  MOVWF  36
0B0C:  MOVF   77,W
0B0D:  MOVWF  37
0B0E:  CLRF   39
0B0F:  CLRF   38
0B10:  BCF    0A.3
0B11:  BCF    03.6
0B12:  CALL   60E
0B13:  BSF    0A.3
0B14:  MOVF   5C,W
0B15:  BSF    03.6
0B16:  MOVWF  36
0B17:  CLRF   37
0B18:  CLRF   39
0B19:  MOVLW  80
0B1A:  MOVWF  38
0B1B:  BCF    0A.3
0B1C:  BCF    03.6
0B1D:  CALL   60E
0B1E:  BSF    0A.3
....................           } 
....................  
....................        } 
0B1F:  GOTO   27A
....................     } 
....................  } 
....................  
0B20:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
