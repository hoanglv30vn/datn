CCS PCM C Compiler, Version 5.015, 5967               15-Oct-21 01:46

               Filename:   E:\DATN\NODE\pic\hellopicc\hellopic.lst

               ROM used:   2467 words (30%)
                           Largest free fragment is 2048
               RAM used:   187 (51%) at main() level
                           226 (61%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   098
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   058
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
*
0076:  DATA 43,24
0077:  DATA 4F,27
0078:  DATA A0,24
0079:  DATA 44,1D
007A:  DATA 20,00
007B:  DATA 43,24
007C:  DATA 4F,27
007D:  DATA 20,22
007E:  DATA 45,2B
007F:  DATA C9,21
0080:  DATA 45,1D
0081:  DATA 20,00
0082:  DATA 20,2A
0083:  DATA 54,10
0084:  DATA 80,03
0085:  DATA C3,20
0086:  DATA D3,22
0087:  DATA 31,00
0088:  DATA C3,20
0089:  DATA D3,22
008A:  DATA 3A,10
008B:  DATA 00,00
008C:  DATA C3,27
008D:  DATA 4E,23
008E:  DATA C9,23
008F:  DATA 20,22
0090:  DATA 4F,27
0091:  DATA 45,00
0092:  DATA AD,16
0093:  DATA 20,1F
0094:  DATA A0,21
0095:  DATA 4F,27
0096:  DATA C6,24
0097:  DATA 47,00
*
024E:  MOVLW  8E
024F:  MOVWF  77
0250:  MOVF   32,W
0251:  MOVWF  78
0252:  MOVF   31,W
0253:  MOVWF  79
0254:  CLRF   7A
0255:  MOVF   78,F
0256:  BTFSS  03.2
0257:  GOTO   262
0258:  MOVF   79,W
0259:  MOVWF  78
025A:  CLRF   79
025B:  MOVLW  08
025C:  SUBWF  77,F
025D:  MOVF   78,F
025E:  BTFSS  03.2
025F:  GOTO   262
0260:  CLRF   77
0261:  GOTO   26A
0262:  BCF    03.0
0263:  BTFSC  78.7
0264:  GOTO   269
0265:  RLF    79,F
0266:  RLF    78,F
0267:  DECF   77,F
0268:  GOTO   262
0269:  BCF    78.7
*
027A:  MOVF   31,W
027B:  BTFSC  03.2
027C:  GOTO   33F
027D:  MOVWF  3D
027E:  MOVF   35,W
027F:  BTFSC  03.2
0280:  GOTO   33F
0281:  SUBWF  3D,F
0282:  BTFSS  03.0
0283:  GOTO   289
0284:  MOVLW  7F
0285:  ADDWF  3D,F
0286:  BTFSC  03.0
0287:  GOTO   33F
0288:  GOTO   28F
0289:  MOVLW  81
028A:  SUBWF  3D,F
028B:  BTFSS  03.0
028C:  GOTO   33F
028D:  BTFSC  03.2
028E:  GOTO   33F
028F:  MOVF   3D,W
0290:  MOVWF  77
0291:  CLRF   78
0292:  CLRF   79
0293:  CLRF   7A
0294:  CLRF   3C
0295:  MOVF   32,W
0296:  MOVWF  3B
0297:  BSF    3B.7
0298:  MOVF   33,W
0299:  MOVWF  3A
029A:  MOVF   34,W
029B:  MOVWF  39
029C:  MOVLW  19
029D:  MOVWF  3D
029E:  MOVF   38,W
029F:  SUBWF  39,F
02A0:  BTFSC  03.0
02A1:  GOTO   2B2
02A2:  MOVLW  01
02A3:  SUBWF  3A,F
02A4:  BTFSC  03.0
02A5:  GOTO   2B2
02A6:  SUBWF  3B,F
02A7:  BTFSC  03.0
02A8:  GOTO   2B2
02A9:  SUBWF  3C,F
02AA:  BTFSC  03.0
02AB:  GOTO   2B2
02AC:  INCF   3C,F
02AD:  INCF   3B,F
02AE:  INCF   3A,F
02AF:  MOVF   38,W
02B0:  ADDWF  39,F
02B1:  GOTO   2E4
02B2:  MOVF   37,W
02B3:  SUBWF  3A,F
02B4:  BTFSC  03.0
02B5:  GOTO   2CD
02B6:  MOVLW  01
02B7:  SUBWF  3B,F
02B8:  BTFSC  03.0
02B9:  GOTO   2CD
02BA:  SUBWF  3C,F
02BB:  BTFSC  03.0
02BC:  GOTO   2CD
02BD:  INCF   3C,F
02BE:  INCF   3B,F
02BF:  MOVF   37,W
02C0:  ADDWF  3A,F
02C1:  MOVF   38,W
02C2:  ADDWF  39,F
02C3:  BTFSS  03.0
02C4:  GOTO   2E4
02C5:  INCF   3A,F
02C6:  BTFSS  03.2
02C7:  GOTO   2E4
02C8:  INCF   3B,F
02C9:  BTFSS  03.2
02CA:  GOTO   2E4
02CB:  INCF   3C,F
02CC:  GOTO   2E4
02CD:  MOVF   36,W
02CE:  IORLW  80
02CF:  SUBWF  3B,F
02D0:  BTFSC  03.0
02D1:  GOTO   2E3
02D2:  MOVLW  01
02D3:  SUBWF  3C,F
02D4:  BTFSC  03.0
02D5:  GOTO   2E3
02D6:  INCF   3C,F
02D7:  MOVF   36,W
02D8:  IORLW  80
02D9:  ADDWF  3B,F
02DA:  MOVF   37,W
02DB:  ADDWF  3A,F
02DC:  BTFSS  03.0
02DD:  GOTO   2C1
02DE:  INCF   3B,F
02DF:  BTFSS  03.2
02E0:  GOTO   2C1
02E1:  INCF   3C,F
02E2:  GOTO   2C1
02E3:  BSF    7A.0
02E4:  DECFSZ 3D,F
02E5:  GOTO   2E7
02E6:  GOTO   2F2
02E7:  BCF    03.0
02E8:  RLF    39,F
02E9:  RLF    3A,F
02EA:  RLF    3B,F
02EB:  RLF    3C,F
02EC:  BCF    03.0
02ED:  RLF    7A,F
02EE:  RLF    79,F
02EF:  RLF    78,F
02F0:  RLF    3E,F
02F1:  GOTO   29E
02F2:  BTFSS  3E.0
02F3:  GOTO   2FA
02F4:  BCF    03.0
02F5:  RRF    78,F
02F6:  RRF    79,F
02F7:  RRF    7A,F
02F8:  RRF    3E,F
02F9:  GOTO   2FD
02FA:  DECF   77,F
02FB:  BTFSC  03.2
02FC:  GOTO   33F
02FD:  BTFSC  3E.7
02FE:  GOTO   326
02FF:  BCF    03.0
0300:  RLF    39,F
0301:  RLF    3A,F
0302:  RLF    3B,F
0303:  RLF    3C,F
0304:  MOVF   38,W
0305:  SUBWF  39,F
0306:  BTFSC  03.0
0307:  GOTO   312
0308:  MOVLW  01
0309:  SUBWF  3A,F
030A:  BTFSC  03.0
030B:  GOTO   312
030C:  SUBWF  3B,F
030D:  BTFSC  03.0
030E:  GOTO   312
030F:  SUBWF  3C,F
0310:  BTFSS  03.0
0311:  GOTO   335
0312:  MOVF   37,W
0313:  SUBWF  3A,F
0314:  BTFSC  03.0
0315:  GOTO   31D
0316:  MOVLW  01
0317:  SUBWF  3B,F
0318:  BTFSC  03.0
0319:  GOTO   31D
031A:  SUBWF  3C,F
031B:  BTFSS  03.0
031C:  GOTO   335
031D:  MOVF   36,W
031E:  IORLW  80
031F:  SUBWF  3B,F
0320:  BTFSC  03.0
0321:  GOTO   326
0322:  MOVLW  01
0323:  SUBWF  3C,F
0324:  BTFSS  03.0
0325:  GOTO   335
0326:  INCF   7A,F
0327:  BTFSS  03.2
0328:  GOTO   335
0329:  INCF   79,F
032A:  BTFSS  03.2
032B:  GOTO   335
032C:  INCF   78,F
032D:  BTFSS  03.2
032E:  GOTO   335
032F:  INCF   77,F
0330:  BTFSC  03.2
0331:  GOTO   33F
0332:  RRF    78,F
0333:  RRF    79,F
0334:  RRF    7A,F
0335:  MOVF   32,W
0336:  MOVWF  3D
0337:  MOVF   36,W
0338:  XORWF  3D,F
0339:  BTFSS  3D.7
033A:  GOTO   33D
033B:  BSF    78.7
033C:  GOTO   343
033D:  BCF    78.7
033E:  GOTO   343
033F:  CLRF   77
0340:  CLRF   78
0341:  CLRF   79
0342:  CLRF   7A
*
034B:  MOVLW  8E
034C:  MOVWF  77
034D:  MOVF   31,W
034E:  SUBWF  77,F
034F:  MOVF   32,W
0350:  MOVWF  79
0351:  MOVF   33,W
0352:  MOVWF  78
0353:  BSF    79.7
0354:  MOVF   77,F
0355:  BTFSC  03.2
0356:  GOTO   362
0357:  BCF    03.0
0358:  MOVF   79,F
0359:  BTFSS  03.2
035A:  GOTO   35E
035B:  MOVF   78,F
035C:  BTFSC  03.2
035D:  GOTO   362
035E:  RRF    79,F
035F:  RRF    78,F
0360:  DECFSZ 77,F
0361:  GOTO   357
0362:  BTFSS  32.7
0363:  GOTO   369
0364:  COMF   78,F
0365:  COMF   79,F
0366:  INCF   78,F
0367:  BTFSC  03.2
0368:  INCF   79,F
*
03C1:  MOVF   0B,W
03C2:  BSF    03.6
03C3:  MOVWF  2F
03C4:  BCF    03.6
03C5:  BCF    0B.7
03C6:  BSF    03.5
03C7:  BSF    03.6
03C8:  BSF    0C.7
03C9:  BSF    0C.0
03CA:  NOP
03CB:  NOP
03CC:  BCF    03.5
03CD:  BTFSS  2F.7
03CE:  GOTO   3D2
03CF:  BCF    03.6
03D0:  BSF    0B.7
03D1:  BSF    03.6
03D2:  MOVF   0C,W
03D3:  ANDLW  7F
03D4:  BTFSC  03.2
03D5:  GOTO   40F
03D6:  MOVWF  2F
03D7:  MOVF   0D,W
03D8:  MOVWF  30
03D9:  MOVF   0F,W
03DA:  MOVWF  31
03DB:  MOVF   2F,W
03DC:  MOVWF  32
03DD:  BCF    03.6
03DE:  CALL   387
03DF:  BSF    03.6
03E0:  MOVF   30,W
03E1:  MOVWF  0D
03E2:  MOVF   31,W
03E3:  MOVWF  0F
03E4:  BCF    03.6
03E5:  MOVF   0B,W
03E6:  BSF    03.6
03E7:  MOVWF  32
03E8:  BCF    03.6
03E9:  BCF    0B.7
03EA:  BSF    03.5
03EB:  BSF    03.6
03EC:  BSF    0C.7
03ED:  BSF    0C.0
03EE:  NOP
03EF:  NOP
03F0:  BCF    03.5
03F1:  BTFSS  32.7
03F2:  GOTO   3F6
03F3:  BCF    03.6
03F4:  BSF    0B.7
03F5:  BSF    03.6
03F6:  RLF    0C,W
03F7:  RLF    0E,W
03F8:  ANDLW  7F
03F9:  BTFSC  03.2
03FA:  GOTO   40F
03FB:  MOVWF  2F
03FC:  MOVF   0D,W
03FD:  MOVWF  30
03FE:  MOVF   0F,W
03FF:  MOVWF  31
0400:  MOVF   2F,W
0401:  MOVWF  32
0402:  BCF    03.6
0403:  CALL   387
0404:  BSF    03.6
0405:  MOVF   30,W
0406:  MOVWF  0D
0407:  MOVF   31,W
0408:  MOVWF  0F
0409:  INCF   0D,F
040A:  BTFSC  03.2
040B:  INCF   0F,F
040C:  BCF    03.6
040D:  GOTO   3C1
040E:  BSF    03.6
040F:  BCF    03.6
0410:  RETURN
0411:  BTFSC  03.1
0412:  GOTO   416
0413:  MOVLW  4F
0414:  MOVWF  04
0415:  BSF    03.7
0416:  BSF    03.6
0417:  MOVF   4A,W
0418:  XORWF  4E,W
0419:  ANDLW  80
041A:  MOVWF  54
041B:  BTFSS  4A.7
041C:  GOTO   428
041D:  COMF   47,F
041E:  COMF   48,F
041F:  COMF   49,F
0420:  COMF   4A,F
0421:  INCF   47,F
0422:  BTFSC  03.2
0423:  INCF   48,F
0424:  BTFSC  03.2
0425:  INCF   49,F
0426:  BTFSC  03.2
0427:  INCF   4A,F
0428:  BTFSS  4E.7
0429:  GOTO   435
042A:  COMF   4B,F
042B:  COMF   4C,F
042C:  COMF   4D,F
042D:  COMF   4E,F
042E:  INCF   4B,F
042F:  BTFSC  03.2
0430:  INCF   4C,F
0431:  BTFSC  03.2
0432:  INCF   4D,F
0433:  BTFSC  03.2
0434:  INCF   4E,F
0435:  CLRF   77
0436:  CLRF   78
0437:  CLRF   79
0438:  CLRF   7A
0439:  CLRF   4F
043A:  CLRF   50
043B:  CLRF   51
043C:  CLRF   52
043D:  MOVF   4E,W
043E:  IORWF  4D,W
043F:  IORWF  4C,W
0440:  IORWF  4B,W
0441:  BTFSC  03.2
0442:  GOTO   473
0443:  MOVLW  20
0444:  MOVWF  53
0445:  BCF    03.0
0446:  RLF    47,F
0447:  RLF    48,F
0448:  RLF    49,F
0449:  RLF    4A,F
044A:  RLF    4F,F
044B:  RLF    50,F
044C:  RLF    51,F
044D:  RLF    52,F
044E:  MOVF   4E,W
044F:  SUBWF  52,W
0450:  BTFSS  03.2
0451:  GOTO   45C
0452:  MOVF   4D,W
0453:  SUBWF  51,W
0454:  BTFSS  03.2
0455:  GOTO   45C
0456:  MOVF   4C,W
0457:  SUBWF  50,W
0458:  BTFSS  03.2
0459:  GOTO   45C
045A:  MOVF   4B,W
045B:  SUBWF  4F,W
045C:  BTFSS  03.0
045D:  GOTO   46D
045E:  MOVF   4B,W
045F:  SUBWF  4F,F
0460:  MOVF   4C,W
0461:  BTFSS  03.0
0462:  INCFSZ 4C,W
0463:  SUBWF  50,F
0464:  MOVF   4D,W
0465:  BTFSS  03.0
0466:  INCFSZ 4D,W
0467:  SUBWF  51,F
0468:  MOVF   4E,W
0469:  BTFSS  03.0
046A:  INCFSZ 4E,W
046B:  SUBWF  52,F
046C:  BSF    03.0
046D:  RLF    77,F
046E:  RLF    78,F
046F:  RLF    79,F
0470:  RLF    7A,F
0471:  DECFSZ 53,F
0472:  GOTO   445
0473:  BTFSS  54.7
0474:  GOTO   480
0475:  COMF   77,F
0476:  COMF   78,F
0477:  COMF   79,F
0478:  COMF   7A,F
0479:  INCF   77,F
047A:  BTFSC  03.2
047B:  INCF   78,F
047C:  BTFSC  03.2
047D:  INCF   79,F
047E:  BTFSC  03.2
047F:  INCF   7A,F
0480:  MOVF   4F,W
0481:  MOVWF  00
0482:  INCF   04,F
0483:  MOVF   50,W
0484:  MOVWF  00
0485:  INCF   04,F
0486:  MOVF   51,W
0487:  MOVWF  00
0488:  INCF   04,F
0489:  MOVF   52,W
048A:  MOVWF  00
048B:  BCF    03.6
048C:  RETURN
*
04A6:  MOVLW  20
04A7:  MOVWF  4B
04A8:  CLRF   47
04A9:  CLRF   48
04AA:  CLRF   49
04AB:  CLRF   4A
04AC:  MOVF   42,W
04AD:  MOVWF  7A
04AE:  MOVF   41,W
04AF:  MOVWF  79
04B0:  MOVF   40,W
04B1:  MOVWF  78
04B2:  MOVF   3F,W
04B3:  MOVWF  77
04B4:  BCF    03.0
04B5:  BTFSS  77.0
04B6:  GOTO   4C5
04B7:  MOVF   43,W
04B8:  ADDWF  47,F
04B9:  MOVF   44,W
04BA:  BTFSC  03.0
04BB:  INCFSZ 44,W
04BC:  ADDWF  48,F
04BD:  MOVF   45,W
04BE:  BTFSC  03.0
04BF:  INCFSZ 45,W
04C0:  ADDWF  49,F
04C1:  MOVF   46,W
04C2:  BTFSC  03.0
04C3:  INCFSZ 46,W
04C4:  ADDWF  4A,F
04C5:  RRF    4A,F
04C6:  RRF    49,F
04C7:  RRF    48,F
04C8:  RRF    47,F
04C9:  RRF    7A,F
04CA:  RRF    79,F
04CB:  RRF    78,F
04CC:  RRF    77,F
04CD:  DECFSZ 4B,F
04CE:  GOTO   4B4
*
05AD:  MOVF   00,F
05AE:  BTFSC  03.2
05AF:  GOTO   5C9
05B0:  BSF    03.6
05B1:  CLRF   30
05B2:  MOVF   04,W
05B3:  MOVWF  2F
05B4:  BCF    30.0
05B5:  BTFSC  03.7
05B6:  BSF    30.0
05B7:  MOVF   00,W
05B8:  MOVWF  32
05B9:  BCF    03.6
05BA:  CALL   387
05BB:  BSF    03.6
05BC:  MOVF   2F,W
05BD:  MOVWF  04
05BE:  BCF    03.7
05BF:  BTFSC  30.0
05C0:  BSF    03.7
05C1:  INCF   04,F
05C2:  BTFSS  03.2
05C3:  GOTO   5C7
05C4:  BCF    03.6
05C5:  INCF   05,F
05C6:  BSF    03.6
05C7:  BCF    03.6
05C8:  GOTO   5AD
05C9:  RETURN
05CA:  BSF    03.6
05CB:  MOVF   2F,W
05CC:  ANDLW  07
05CD:  MOVWF  77
05CE:  RRF    2F,W
05CF:  MOVWF  78
05D0:  RRF    78,F
05D1:  RRF    78,F
05D2:  MOVLW  1F
05D3:  ANDWF  78,F
05D4:  MOVF   78,W
05D5:  ADDWF  30,W
05D6:  MOVWF  04
05D7:  BCF    03.7
05D8:  BTFSC  31.0
05D9:  BSF    03.7
05DA:  MOVF   00,W
05DB:  MOVWF  78
05DC:  INCF   77,F
05DD:  GOTO   5DF
05DE:  RRF    78,F
05DF:  DECFSZ 77,F
05E0:  GOTO   5DE
05E1:  BCF    03.6
05E2:  RETURN
05E3:  BSF    03.6
05E4:  MOVF   30,W
05E5:  ANDLW  07
05E6:  MOVWF  77
05E7:  RRF    30,W
05E8:  MOVWF  78
05E9:  RRF    78,F
05EA:  RRF    78,F
05EB:  MOVLW  1F
05EC:  ANDWF  78,F
05ED:  MOVF   78,W
05EE:  ADDWF  32,W
05EF:  MOVWF  04
05F0:  BCF    03.7
05F1:  BTFSC  33.0
05F2:  BSF    03.7
05F3:  CLRF   78
05F4:  INCF   78,F
05F5:  INCF   77,F
05F6:  GOTO   5F8
05F7:  RLF    78,F
05F8:  DECFSZ 77,F
05F9:  GOTO   5F7
05FA:  MOVF   31,F
05FB:  BTFSC  03.2
05FC:  GOTO   600
05FD:  MOVF   78,W
05FE:  IORWF  00,F
05FF:  GOTO   603
0600:  COMF   78,F
0601:  MOVF   78,W
0602:  ANDWF  00,F
0603:  BCF    03.6
0604:  BCF    0A.3
0605:  BCF    0A.4
0606:  GOTO   6FD (RETURN)
*
0746:  BSF    0A.0
0747:  BSF    0A.1
0748:  BSF    0A.2
0749:  ADDWF  02,F
074A:  GOTO   60D
074B:  GOTO   660
074C:  GOTO   72E
074D:  GOTO   742
*
07B2:  MOVF   00,F
07B3:  BTFSC  03.2
07B4:  GOTO   7CF
07B5:  BSF    03.6
07B6:  CLRF   32
07B7:  MOVF   04,W
07B8:  MOVWF  31
07B9:  BCF    32.0
07BA:  BTFSC  03.7
07BB:  BSF    32.0
07BC:  MOVF   00,W
07BD:  BCF    03.6
07BE:  BTFSS  0C.4
07BF:  GOTO   7BE
07C0:  MOVWF  19
07C1:  BSF    03.6
07C2:  MOVF   31,W
07C3:  MOVWF  04
07C4:  BCF    03.7
07C5:  BTFSC  32.0
07C6:  BSF    03.7
07C7:  INCF   04,F
07C8:  BTFSS  03.2
07C9:  GOTO   7CD
07CA:  BCF    03.6
07CB:  INCF   05,F
07CC:  BSF    03.6
07CD:  BCF    03.6
07CE:  GOTO   7B2
07CF:  BSF    0A.3
07D0:  BCF    0A.4
07D1:  GOTO   187 (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
082A:  BCF    03.6
082B:  CLRF   2B
082C:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
048D:  BSF    03.6
048E:  CLRF   3A
048F:  CLRF   39
0490:  CLRF   38
0491:  MOVLW  01
0492:  MOVWF  37
0493:  CLRF   3C
0494:  CLRF   3D
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0495:  BTFSS  33.7
0496:  GOTO   4D7
....................          sign=1;        // Check for negative number 
0497:  MOVLW  01
0498:  MOVWF  3C
....................          num*=-1; 
0499:  MOVF   33,W
049A:  MOVWF  42
049B:  MOVF   32,W
049C:  MOVWF  41
049D:  MOVF   31,W
049E:  MOVWF  40
049F:  MOVF   30,W
04A0:  MOVWF  3F
04A1:  MOVLW  FF
04A2:  MOVWF  46
04A3:  MOVWF  45
04A4:  MOVWF  44
04A5:  MOVWF  43
*
04CF:  MOVF   7A,W
04D0:  MOVWF  33
04D1:  MOVF   79,W
04D2:  MOVWF  32
04D3:  MOVF   78,W
04D4:  MOVWF  31
04D5:  MOVF   77,W
04D6:  MOVWF  30
....................      } 
....................  
....................      while(temp>0) { 
04D7:  MOVF   37,F
04D8:  BTFSS  03.2
04D9:  GOTO   4E3
04DA:  MOVF   38,F
04DB:  BTFSS  03.2
04DC:  GOTO   4E3
04DD:  MOVF   39,F
04DE:  BTFSS  03.2
04DF:  GOTO   4E3
04E0:  MOVF   3A,F
04E1:  BTFSC  03.2
04E2:  GOTO   55F
....................          temp=(num/base); 
04E3:  BCF    03.1
04E4:  MOVF   33,W
04E5:  MOVWF  4A
04E6:  MOVF   32,W
04E7:  MOVWF  49
04E8:  MOVF   31,W
04E9:  MOVWF  48
04EA:  MOVF   30,W
04EB:  MOVWF  47
04EC:  CLRF   4E
04ED:  CLRF   4D
04EE:  CLRF   4C
04EF:  MOVF   34,W
04F0:  MOVWF  4B
04F1:  BCF    03.6
04F2:  CALL   411
04F3:  MOVF   7A,W
04F4:  BSF    03.6
04F5:  MOVWF  3A
04F6:  MOVF   79,W
04F7:  MOVWF  39
04F8:  MOVF   78,W
04F9:  MOVWF  38
04FA:  MOVF   77,W
04FB:  MOVWF  37
....................          s[cnt]=(num%base)+'0';    // Conversion 
04FC:  MOVF   3D,W
04FD:  ADDWF  35,W
04FE:  MOVWF  78
04FF:  MOVF   36,W
0500:  MOVWF  7A
0501:  BTFSC  03.0
0502:  INCF   7A,F
0503:  MOVF   78,W
0504:  MOVWF  3F
0505:  MOVF   7A,W
0506:  MOVWF  40
0507:  CLRF   42
0508:  MOVF   04,W
0509:  MOVWF  41
050A:  BCF    42.0
050B:  BTFSC  03.7
050C:  BSF    42.0
050D:  BSF    03.1
050E:  MOVLW  43
050F:  MOVWF  04
0510:  BSF    03.7
0511:  MOVF   33,W
0512:  MOVWF  4A
0513:  MOVF   32,W
0514:  MOVWF  49
0515:  MOVF   31,W
0516:  MOVWF  48
0517:  MOVF   30,W
0518:  MOVWF  47
0519:  CLRF   4E
051A:  CLRF   4D
051B:  CLRF   4C
051C:  MOVF   34,W
051D:  MOVWF  4B
051E:  BCF    03.6
051F:  CALL   411
0520:  BSF    03.6
0521:  MOVF   41,W
0522:  MOVWF  04
0523:  BCF    03.7
0524:  BTFSC  42.0
0525:  BSF    03.7
0526:  MOVLW  30
0527:  ADDWF  43,W
0528:  MOVWF  77
0529:  MOVF   44,W
052A:  MOVWF  78
052B:  MOVLW  00
052C:  BTFSC  03.0
052D:  MOVLW  01
052E:  ADDWF  78,F
052F:  MOVF   45,W
0530:  MOVWF  79
0531:  MOVLW  00
0532:  BTFSC  03.0
0533:  MOVLW  01
0534:  ADDWF  79,F
0535:  MOVF   46,W
0536:  MOVWF  7A
0537:  MOVLW  00
0538:  BTFSC  03.0
0539:  MOVLW  01
053A:  ADDWF  7A,F
053B:  MOVF   3F,W
053C:  MOVWF  04
053D:  BCF    03.7
053E:  BTFSC  40.0
053F:  BSF    03.7
0540:  MOVF   77,W
0541:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0542:  MOVF   3D,W
0543:  ADDWF  35,W
0544:  MOVWF  04
0545:  BCF    03.7
0546:  BTFSC  36.0
0547:  BSF    03.7
0548:  MOVF   00,W
0549:  SUBLW  39
054A:  BTFSC  03.0
054B:  GOTO   555
....................             s[cnt]+=0x7; 
054C:  MOVF   3D,W
054D:  ADDWF  35,W
054E:  MOVWF  04
054F:  BCF    03.7
0550:  BTFSC  36.0
0551:  BSF    03.7
0552:  MOVLW  07
0553:  ADDWF  00,W
0554:  MOVWF  00
....................  
....................          cnt++; 
0555:  INCF   3D,F
....................          num=temp; 
0556:  MOVF   3A,W
0557:  MOVWF  33
0558:  MOVF   39,W
0559:  MOVWF  32
055A:  MOVF   38,W
055B:  MOVWF  31
055C:  MOVF   37,W
055D:  MOVWF  30
055E:  GOTO   4D7
....................      } 
....................  
....................      if(sign==1) { 
055F:  DECFSZ 3C,W
0560:  GOTO   56A
....................          s[cnt]=0x2D;      // Negative sign 
0561:  MOVF   3D,W
0562:  ADDWF  35,W
0563:  MOVWF  04
0564:  BCF    03.7
0565:  BTFSC  36.0
0566:  BSF    03.7
0567:  MOVLW  2D
0568:  MOVWF  00
....................          cnt++; 
0569:  INCF   3D,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
056A:  CLRF   3B
056B:  BCF    03.0
056C:  RRF    3D,W
056D:  SUBWF  3B,W
056E:  BTFSC  03.0
056F:  GOTO   5A0
....................  
....................          c=s[i]; 
0570:  MOVF   3B,W
0571:  ADDWF  35,W
0572:  MOVWF  04
0573:  BCF    03.7
0574:  BTFSC  36.0
0575:  BSF    03.7
0576:  MOVF   00,W
0577:  MOVWF  3E
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0578:  MOVF   3B,W
0579:  ADDWF  35,W
057A:  MOVWF  78
057B:  MOVF   36,W
057C:  MOVWF  7A
057D:  BTFSC  03.0
057E:  INCF   7A,F
057F:  MOVF   78,W
0580:  MOVWF  3F
0581:  MOVF   7A,W
0582:  MOVWF  40
0583:  MOVF   3B,W
0584:  SUBWF  3D,W
0585:  ADDLW  FF
0586:  ADDWF  35,W
0587:  MOVWF  04
0588:  BCF    03.7
0589:  BTFSC  36.0
058A:  BSF    03.7
058B:  MOVF   00,W
058C:  MOVWF  41
058D:  MOVF   3F,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  40.0
0591:  BSF    03.7
0592:  MOVF   41,W
0593:  MOVWF  00
....................          s[cnt-i-1]=c; 
0594:  MOVF   3B,W
0595:  SUBWF  3D,W
0596:  ADDLW  FF
0597:  ADDWF  35,W
0598:  MOVWF  04
0599:  BCF    03.7
059A:  BTFSC  36.0
059B:  BSF    03.7
059C:  MOVF   3E,W
059D:  MOVWF  00
059E:  INCF   3B,F
059F:  GOTO   56B
....................      } 
....................      s[cnt]='\0';     // End the string 
05A0:  MOVF   3D,W
05A1:  ADDWF  35,W
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  BTFSC  36.0
05A5:  BSF    03.7
05A6:  CLRF   00
....................      return s; 
05A7:  MOVF   35,W
05A8:  MOVWF  78
05A9:  MOVF   36,W
05AA:  MOVWF  79
05AB:  BCF    03.6
05AC:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
....................  
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S NGUYN 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S NGUYN DI 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
009F:  MOVLW  34
00A0:  MOVWF  04
00A1:  BSF    03.7
00A2:  MOVF   00,W
00A3:  BTFSC  03.2
00A4:  GOTO   0B2
00A5:  MOVLW  06
00A6:  MOVWF  78
00A7:  CLRF   77
00A8:  DECFSZ 77,F
00A9:  GOTO   0A8
00AA:  DECFSZ 78,F
00AB:  GOTO   0A7
00AC:  MOVLW  7B
00AD:  MOVWF  77
00AE:  DECFSZ 77,F
00AF:  GOTO   0AE
00B0:  DECFSZ 00,F
00B1:  GOTO   0A5
00B2:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0146:  BSF    07.0
....................    output_float(LCD_DATA5); 
0147:  BSF    07.1
....................    output_float(LCD_DATA6); 
0148:  BSF    07.2
....................    output_float(LCD_DATA7); 
0149:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
014A:  BCF    03.5
014B:  BSF    09.2
014C:  BSF    03.5
014D:  BCF    09.2
....................    delay_cycles(1); 
014E:  NOP
....................    lcd_output_enable(1); 
014F:  BCF    03.5
0150:  BSF    09.0
0151:  BSF    03.5
0152:  BCF    09.0
....................    delay_cycles(1); 
0153:  NOP
....................    high = lcd_read_nibble(); 
0154:  BCF    03.5
0155:  CALL   0FB
0156:  MOVF   78,W
0157:  BSF    03.6
0158:  MOVWF  3A
....................        
....................    lcd_output_enable(0); 
0159:  BCF    03.6
015A:  BCF    09.0
015B:  BSF    03.5
015C:  BCF    09.0
....................    delay_cycles(1); 
015D:  NOP
....................    lcd_output_enable(1); 
015E:  BCF    03.5
015F:  BSF    09.0
0160:  BSF    03.5
0161:  BCF    09.0
....................    delay_us(1); 
0162:  GOTO   163
0163:  GOTO   164
0164:  NOP
....................    low = lcd_read_nibble(); 
0165:  BCF    03.5
0166:  CALL   0FB
0167:  MOVF   78,W
0168:  BSF    03.6
0169:  MOVWF  39
....................        
....................    lcd_output_enable(0); 
016A:  BCF    03.6
016B:  BCF    09.0
016C:  BSF    03.5
016D:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
016E:  BCF    03.5
016F:  BCF    31.0
0170:  MOVF   31,W
0171:  BSF    03.5
0172:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0173:  BCF    03.5
0174:  BCF    31.1
0175:  MOVF   31,W
0176:  BSF    03.5
0177:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0178:  BCF    03.5
0179:  BCF    31.2
017A:  MOVF   31,W
017B:  BSF    03.5
017C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
017D:  BCF    03.5
017E:  BCF    31.3
017F:  MOVF   31,W
0180:  BSF    03.5
0181:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0182:  BCF    03.5
0183:  BSF    03.6
0184:  SWAPF  3A,W
0185:  MOVWF  77
0186:  MOVLW  F0
0187:  ANDWF  77,F
0188:  MOVF   77,W
0189:  IORWF  39,W
018A:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00FB:  BSF    03.6
00FC:  CLRF   3B
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
00FD:  BCF    03.6
00FE:  BSF    31.0
00FF:  MOVF   31,W
0100:  BSF    03.5
0101:  MOVWF  07
0102:  MOVLW  00
0103:  BCF    03.5
0104:  BTFSC  07.0
0105:  MOVLW  01
0106:  BSF    03.6
0107:  IORWF  3B,F
....................    n |= input(LCD_DATA5) << 1; 
0108:  BCF    03.6
0109:  BSF    31.1
010A:  MOVF   31,W
010B:  BSF    03.5
010C:  MOVWF  07
010D:  MOVLW  00
010E:  BCF    03.5
010F:  BTFSC  07.1
0110:  MOVLW  01
0111:  MOVWF  77
0112:  BCF    03.0
0113:  RLF    77,F
0114:  MOVF   77,W
0115:  BSF    03.6
0116:  IORWF  3B,F
....................    n |= input(LCD_DATA6) << 2; 
0117:  BCF    03.6
0118:  BSF    31.2
0119:  MOVF   31,W
011A:  BSF    03.5
011B:  MOVWF  07
011C:  MOVLW  00
011D:  BCF    03.5
011E:  BTFSC  07.2
011F:  MOVLW  01
0120:  MOVWF  77
0121:  RLF    77,F
0122:  RLF    77,F
0123:  MOVLW  FC
0124:  ANDWF  77,F
0125:  MOVF   77,W
0126:  BSF    03.6
0127:  IORWF  3B,F
....................    n |= input(LCD_DATA7) << 3; 
0128:  BCF    03.6
0129:  BSF    31.3
012A:  MOVF   31,W
012B:  BSF    03.5
012C:  MOVWF  07
012D:  MOVLW  00
012E:  BCF    03.5
012F:  BTFSC  07.3
0130:  MOVLW  01
0131:  MOVWF  77
0132:  RLF    77,F
0133:  RLF    77,F
0134:  RLF    77,F
0135:  MOVLW  F8
0136:  ANDWF  77,F
0137:  MOVF   77,W
0138:  BSF    03.6
0139:  IORWF  3B,F
....................     
....................    return(n); 
013A:  MOVF   3B,W
013B:  MOVWF  78
....................   #else 
013C:  BCF    03.6
013D:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00B3:  BSF    03.6
00B4:  BTFSC  3A.0
00B5:  GOTO   0BA
00B6:  BCF    03.6
00B7:  BCF    07.0
00B8:  GOTO   0BC
00B9:  BSF    03.6
00BA:  BCF    03.6
00BB:  BSF    07.0
00BC:  BCF    31.0
00BD:  MOVF   31,W
00BE:  BSF    03.5
00BF:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00C0:  BCF    03.5
00C1:  BSF    03.6
00C2:  BTFSC  3A.1
00C3:  GOTO   0C8
00C4:  BCF    03.6
00C5:  BCF    07.1
00C6:  GOTO   0CA
00C7:  BSF    03.6
00C8:  BCF    03.6
00C9:  BSF    07.1
00CA:  BCF    31.1
00CB:  MOVF   31,W
00CC:  BSF    03.5
00CD:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00CE:  BCF    03.5
00CF:  BSF    03.6
00D0:  BTFSC  3A.2
00D1:  GOTO   0D6
00D2:  BCF    03.6
00D3:  BCF    07.2
00D4:  GOTO   0D8
00D5:  BSF    03.6
00D6:  BCF    03.6
00D7:  BSF    07.2
00D8:  BCF    31.2
00D9:  MOVF   31,W
00DA:  BSF    03.5
00DB:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00DC:  BCF    03.5
00DD:  BSF    03.6
00DE:  BTFSC  3A.3
00DF:  GOTO   0E4
00E0:  BCF    03.6
00E1:  BCF    07.3
00E2:  GOTO   0E6
00E3:  BSF    03.6
00E4:  BCF    03.6
00E5:  BSF    07.3
00E6:  BCF    31.3
00E7:  MOVF   31,W
00E8:  BSF    03.5
00E9:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00EA:  NOP
....................    lcd_output_enable(1); 
00EB:  BCF    03.5
00EC:  BSF    09.0
00ED:  BSF    03.5
00EE:  BCF    09.0
....................    delay_us(2); 
00EF:  MOVLW  02
00F0:  MOVWF  77
00F1:  DECFSZ 77,F
00F2:  GOTO   0F1
00F3:  GOTO   0F4
00F4:  NOP
....................    lcd_output_enable(0); 
00F5:  BCF    03.5
00F6:  BCF    09.0
00F7:  BSF    03.5
00F8:  BCF    09.0
00F9:  BCF    03.5
00FA:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
013E:  BSF    03.5
013F:  BCF    09.0
....................    lcd_rs_tris(); 
0140:  BCF    09.1
....................    lcd_rw_tris(); 
0141:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0142:  BCF    03.5
0143:  BCF    09.1
0144:  BSF    03.5
0145:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
018B:  MOVF   78,W
018C:  MOVWF  39
018D:  BTFSS  39.7
018E:  GOTO   192
018F:  BSF    03.5
0190:  BCF    03.6
0191:  GOTO   146
....................    lcd_output_rs(address); 
0192:  MOVF   37,F
0193:  BTFSS  03.2
0194:  GOTO   199
0195:  BCF    03.6
0196:  BCF    09.1
0197:  GOTO   19B
0198:  BSF    03.6
0199:  BCF    03.6
019A:  BSF    09.1
019B:  BSF    03.5
019C:  BCF    09.1
....................    delay_cycles(1); 
019D:  NOP
....................    lcd_output_rw(0); 
019E:  BCF    03.5
019F:  BCF    09.2
01A0:  BSF    03.5
01A1:  BCF    09.2
....................    delay_cycles(1); 
01A2:  NOP
....................    lcd_output_enable(0); 
01A3:  BCF    03.5
01A4:  BCF    09.0
01A5:  BSF    03.5
01A6:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01A7:  BCF    03.5
01A8:  BSF    03.6
01A9:  SWAPF  38,W
01AA:  MOVWF  39
01AB:  MOVLW  0F
01AC:  ANDWF  39,F
01AD:  MOVF   39,W
01AE:  MOVWF  3A
01AF:  BCF    03.6
01B0:  CALL   0B3
....................    lcd_send_nibble(n & 0xf); 
01B1:  BSF    03.6
01B2:  MOVF   38,W
01B3:  ANDLW  0F
01B4:  MOVWF  39
01B5:  MOVWF  3A
01B6:  BCF    03.6
01B7:  CALL   0B3
01B8:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01B9:  MOVLW  28
01BA:  BSF    03.6
01BB:  MOVWF  30
01BC:  MOVLW  0C
01BD:  MOVWF  31
01BE:  MOVLW  01
01BF:  MOVWF  32
01C0:  MOVLW  06
01C1:  MOVWF  33
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01C2:  BCF    03.6
01C3:  BCF    09.0
01C4:  BSF    03.5
01C5:  BCF    09.0
....................    lcd_output_rs(0); 
01C6:  BCF    03.5
01C7:  BCF    09.1
01C8:  BSF    03.5
01C9:  BCF    09.1
....................    lcd_output_rw(0); 
01CA:  BCF    03.5
01CB:  BCF    09.2
01CC:  BSF    03.5
01CD:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01CE:  BCF    03.5
01CF:  BCF    31.0
01D0:  MOVF   31,W
01D1:  BSF    03.5
01D2:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01D3:  BCF    03.5
01D4:  BCF    31.1
01D5:  MOVF   31,W
01D6:  BSF    03.5
01D7:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01D8:  BCF    03.5
01D9:  BCF    31.2
01DA:  MOVF   31,W
01DB:  BSF    03.5
01DC:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01DD:  BCF    03.5
01DE:  BCF    31.3
01DF:  MOVF   31,W
01E0:  BSF    03.5
01E1:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01E2:  BCF    09.0
....................    lcd_rs_tris(); 
01E3:  BCF    09.1
....................    lcd_rw_tris(); 
01E4:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
01E5:  MOVLW  0F
01E6:  BCF    03.5
01E7:  BSF    03.6
01E8:  MOVWF  34
01E9:  BCF    03.6
01EA:  CALL   09F
....................    for(i=1;i<=3;++i) 
01EB:  MOVLW  01
01EC:  BSF    03.6
01ED:  MOVWF  2F
01EE:  MOVF   2F,W
01EF:  SUBLW  03
01F0:  BTFSS  03.0
01F1:  GOTO   1FE
....................    { 
....................        lcd_send_nibble(3); 
01F2:  MOVLW  03
01F3:  MOVWF  3A
01F4:  BCF    03.6
01F5:  CALL   0B3
....................        delay_ms(5); 
01F6:  MOVLW  05
01F7:  BSF    03.6
01F8:  MOVWF  34
01F9:  BCF    03.6
01FA:  CALL   09F
01FB:  BSF    03.6
01FC:  INCF   2F,F
01FD:  GOTO   1EE
....................    } 
....................     
....................    lcd_send_nibble(2); 
01FE:  MOVLW  02
01FF:  MOVWF  3A
0200:  BCF    03.6
0201:  CALL   0B3
....................    delay_ms(5); 
0202:  MOVLW  05
0203:  BSF    03.6
0204:  MOVWF  34
0205:  BCF    03.6
0206:  CALL   09F
....................    for(i=0;i<=3;++i) 
0207:  BSF    03.6
0208:  CLRF   2F
0209:  MOVF   2F,W
020A:  SUBLW  03
020B:  BTFSS  03.0
020C:  GOTO   21B
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
020D:  MOVLW  30
020E:  ADDWF  2F,W
020F:  MOVWF  04
0210:  BSF    03.7
0211:  MOVF   00,W
0212:  MOVWF  34
0213:  CLRF   37
0214:  MOVF   34,W
0215:  MOVWF  38
0216:  BCF    03.6
0217:  CALL   13E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0218:  BSF    03.6
0219:  INCF   2F,F
021A:  GOTO   209
021B:  BCF    03.6
021C:  BSF    0A.3
021D:  BCF    0A.4
021E:  GOTO   121 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0373:  BSF    03.6
0374:  DECFSZ 34,W
0375:  GOTO   377
0376:  GOTO   37A
....................       address=LCD_LINE_TWO; 
0377:  MOVLW  40
0378:  MOVWF  35
0379:  GOTO   37B
....................    else 
....................       address=0; 
037A:  CLRF   35
....................       
....................    address+=x-1; 
037B:  MOVLW  01
037C:  SUBWF  33,W
037D:  ADDWF  35,F
....................    lcd_send_byte(0,0x80|address); 
037E:  MOVF   35,W
037F:  IORLW  80
0380:  MOVWF  36
0381:  CLRF   37
0382:  MOVF   36,W
0383:  MOVWF  38
0384:  BCF    03.6
0385:  CALL   13E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0386:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0387:  BSF    03.6
0388:  MOVF   32,W
0389:  XORLW  07
038A:  BCF    03.6
038B:  BTFSC  03.2
038C:  GOTO   397
038D:  XORLW  0B
038E:  BTFSC  03.2
038F:  GOTO   39E
0390:  XORLW  06
0391:  BTFSC  03.2
0392:  GOTO   3AA
0393:  XORLW  02
0394:  BTFSC  03.2
0395:  GOTO   3B2
0396:  GOTO   3B9
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0397:  MOVLW  01
0398:  BSF    03.6
0399:  MOVWF  33
039A:  MOVWF  34
039B:  BCF    03.6
039C:  CALL   373
039D:  GOTO   3C0
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
039E:  BSF    03.6
039F:  CLRF   37
03A0:  MOVLW  01
03A1:  MOVWF  38
03A2:  BCF    03.6
03A3:  CALL   13E
....................                      delay_ms(2); 
03A4:  MOVLW  02
03A5:  BSF    03.6
03A6:  MOVWF  34
03A7:  BCF    03.6
03A8:  CALL   09F
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03A9:  GOTO   3C0
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03AA:  MOVLW  01
03AB:  BSF    03.6
03AC:  MOVWF  33
03AD:  MOVLW  02
03AE:  MOVWF  34
03AF:  BCF    03.6
03B0:  CALL   373
03B1:  GOTO   3C0
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03B2:  BSF    03.6
03B3:  CLRF   37
03B4:  MOVLW  10
03B5:  MOVWF  38
03B6:  BCF    03.6
03B7:  CALL   13E
03B8:  GOTO   3C0
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03B9:  MOVLW  01
03BA:  BSF    03.6
03BB:  MOVWF  37
03BC:  MOVF   32,W
03BD:  MOVWF  38
03BE:  BCF    03.6
03BF:  CALL   13E
....................      #endif 
....................    } 
03C0:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
....................  
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0; 
.................... INT1 TT_CONFIG=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
082D:  CLRF   3C
.................... //INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR TT_DEVICE_CHAR[]=" "; 
082E:  MOVLW  20
082F:  MOVWF  3D
0830:  CLRF   3E
.................... //INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR *PACKAGE[]={"S","ID", "S_S" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
0831:  MOVLW  53
0832:  MOVWF  4F
0833:  CLRF   50
0834:  MOVLW  49
0835:  MOVWF  51
0836:  MOVLW  44
0837:  MOVWF  52
0838:  CLRF   53
0839:  MOVLW  53
083A:  MOVWF  54
083B:  MOVLW  5F
083C:  MOVWF  55
083D:  MOVLW  53
083E:  MOVWF  56
083F:  CLRF   57
0840:  MOVLW  4C
0841:  MOVWF  58
0842:  MOVLW  45
0843:  MOVWF  59
0844:  MOVLW  4E
0845:  MOVWF  5A
0846:  MOVLW  47
0847:  MOVWF  5B
0848:  MOVLW  48
0849:  MOVWF  5C
084A:  MOVLW  54
084B:  MOVWF  5D
084C:  CLRF   5E
084D:  MOVLW  44
084E:  MOVWF  5F
084F:  MOVLW  41
0850:  MOVWF  60
0851:  MOVLW  54
0852:  MOVWF  61
0853:  MOVLW  41
0854:  MOVWF  62
0855:  MOVLW  31
0856:  MOVWF  63
0857:  CLRF   64
0858:  MOVLW  44
0859:  MOVWF  65
085A:  MOVLW  41
085B:  MOVWF  66
085C:  MOVLW  54
085D:  MOVWF  67
085E:  MOVLW  41
085F:  MOVWF  68
0860:  MOVLW  32
0861:  MOVWF  69
0862:  CLRF   6A
0863:  MOVLW  43
0864:  MOVWF  6B
0865:  MOVLW  48
0866:  MOVWF  6C
0867:  MOVLW  45
0868:  MOVWF  6D
0869:  MOVLW  43
086A:  MOVWF  6E
086B:  MOVLW  4B
086C:  MOVWF  6F
086D:  MOVLW  53
086E:  MOVWF  70
086F:  MOVLW  55
0870:  MOVWF  71
0871:  MOVLW  4D
0872:  MOVWF  72
0873:  CLRF   73
0874:  MOVLW  23
0875:  MOVWF  74
0876:  CLRF   75
0877:  CLRF   40
0878:  MOVLW  4F
0879:  MOVWF  3F
087A:  CLRF   42
087B:  MOVLW  51
087C:  MOVWF  41
087D:  CLRF   44
087E:  MOVLW  54
087F:  MOVWF  43
0880:  CLRF   46
0881:  MOVLW  58
0882:  MOVWF  45
0883:  CLRF   48
0884:  MOVLW  5F
0885:  MOVWF  47
0886:  CLRF   4A
0887:  MOVLW  65
0888:  MOVWF  49
0889:  CLRF   4C
088A:  MOVLW  6B
088B:  MOVWF  4B
088C:  CLRF   4E
088D:  MOVLW  74
088E:  MOVWF  4D
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE","SENSOR","#"}; 
088F:  MOVLW  53
0890:  BSF    03.5
0891:  MOVWF  30
0892:  CLRF   31
0893:  MOVLW  49
0894:  MOVWF  32
0895:  MOVLW  44
0896:  MOVWF  33
0897:  CLRF   34
0898:  MOVLW  43
0899:  MOVWF  35
089A:  MOVLW  5F
089B:  MOVWF  36
089C:  MOVLW  46
089D:  MOVWF  37
089E:  CLRF   38
089F:  MOVLW  4C
08A0:  MOVWF  39
08A1:  MOVLW  45
08A2:  MOVWF  3A
08A3:  MOVLW  4E
08A4:  MOVWF  3B
08A5:  MOVLW  47
08A6:  MOVWF  3C
08A7:  MOVLW  48
08A8:  MOVWF  3D
08A9:  MOVLW  54
08AA:  MOVWF  3E
08AB:  CLRF   3F
08AC:  MOVLW  49
08AD:  MOVWF  40
08AE:  MOVLW  44
08AF:  MOVWF  41
08B0:  MOVLW  5F
08B1:  MOVWF  42
08B2:  CLRF   43
08B3:  MOVLW  44
08B4:  MOVWF  44
08B5:  MOVLW  45
08B6:  MOVWF  45
08B7:  MOVLW  56
08B8:  MOVWF  46
08B9:  MOVLW  49
08BA:  MOVWF  47
08BB:  MOVLW  43
08BC:  MOVWF  48
08BD:  MOVLW  45
08BE:  MOVWF  49
08BF:  CLRF   4A
08C0:  MOVLW  53
08C1:  MOVWF  4B
08C2:  MOVLW  45
08C3:  MOVWF  4C
08C4:  MOVLW  4E
08C5:  MOVWF  4D
08C6:  MOVLW  53
08C7:  MOVWF  4E
08C8:  MOVLW  4F
08C9:  MOVWF  4F
08CA:  MOVLW  52
08CB:  MOVWF  50
08CC:  CLRF   51
08CD:  MOVLW  23
08CE:  MOVWF  52
08CF:  CLRF   53
08D0:  CLRF   21
08D1:  MOVLW  B0
08D2:  MOVWF  20
08D3:  CLRF   23
08D4:  MOVLW  B2
08D5:  MOVWF  22
08D6:  CLRF   25
08D7:  MOVLW  B5
08D8:  MOVWF  24
08D9:  CLRF   27
08DA:  MOVLW  B9
08DB:  MOVWF  26
08DC:  CLRF   29
08DD:  MOVLW  C0
08DE:  MOVWF  28
08DF:  CLRF   2B
08E0:  MOVLW  C4
08E1:  MOVWF  2A
08E2:  CLRF   2D
08E3:  MOVLW  CB
08E4:  MOVWF  2C
08E5:  CLRF   2F
08E6:  MOVLW  D2
08E7:  MOVWF  2E
.................... CHAR NHIETDO1[]="27"; 
08E8:  MOVLW  32
08E9:  MOVWF  7B
08EA:  MOVLW  37
08EB:  MOVWF  7C
08EC:  CLRF   7D
.................... CHAR NHIETDO2[]="27"; 
08ED:  MOVLW  32
08EE:  MOVWF  54
08EF:  MOVLW  37
08F0:  MOVWF  55
08F1:  CLRF   56
.................... CHAR ID_[]="0"; 
08F2:  MOVLW  30
08F3:  MOVWF  57
08F4:  CLRF   58
.................... CHAR TEMP_CHAR[]="0"; 
08F5:  MOVWF  59
08F6:  CLRF   5A
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;    
.................... //--------------------------------------------------------------------// 
.................... #INT_RDA 
.................... VOID NGAT() 
.................... {    
....................    KYTU[VT] = GETC (); 
*
0058:  MOVLW  10
0059:  ADDWF  76,W
005A:  MOVWF  04
005B:  BSF    03.7
005C:  BTFSS  0C.5
005D:  GOTO   05C
005E:  MOVF   1A,W
005F:  MOVWF  00
....................  
....................    IF (KYTU[VT] == '.') 
0060:  MOVLW  10
0061:  ADDWF  76,W
0062:  MOVWF  04
0063:  BSF    03.7
0064:  MOVF   00,W
0065:  SUBLW  2E
0066:  BTFSS  03.2
0067:  GOTO   071
....................    { 
....................        
....................       KYTU[VT] = '\0'; 
0068:  MOVLW  10
0069:  ADDWF  76,W
006A:  MOVWF  04
006B:  BSF    03.7
006C:  CLRF   00
....................       VT = 0; 
006D:  CLRF   76
....................       TTNHAN = 1; 
006E:  MOVLW  01
006F:  MOVWF  7E
....................    } 
0070:  GOTO   072
....................  
....................    ELSE 
....................    VT++; 
0071:  INCF   76,F
0072:  BCF    0C.5
0073:  BCF    0A.3
0074:  BCF    0A.4
0075:  GOTO   031
.................... } 
....................  
.................... VOID CHON_ID() 
.................... { 
....................    TT_STT = 1; 
*
060D:  BSF    3B.2
....................    LCD_GOTOXY (1, 1) ; 
060E:  MOVLW  01
060F:  BSF    03.6
0610:  MOVWF  33
0611:  MOVWF  34
0612:  BCF    03.6
0613:  CALL   373
....................    DELAY_MS (10); 
0614:  MOVLW  0A
0615:  BSF    03.6
0616:  MOVWF  34
0617:  BCF    03.6
0618:  CALL   09F
....................    PRINTF (LCD_PUTC, "CHON ID: "); 
0619:  MOVLW  76
061A:  BSF    03.6
061B:  MOVWF  0D
061C:  MOVLW  00
061D:  MOVWF  0F
061E:  BCF    03.6
061F:  CALL   3C1
....................  
....................    WHILE (TT_STT) 
0620:  BTFSS  3B.2
0621:  GOTO   65F
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0622:  BSF    03.5
0623:  BSF    06.2
0624:  BCF    03.5
0625:  BTFSC  06.2
0626:  GOTO   65E
....................       { 
....................          ID_NODE ++; 
0627:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
0628:  MOVF   39,W
0629:  SUBLW  0F
062A:  BTFSS  03.0
062B:  CLRF   39
....................          DELAY_MS (300); 
062C:  MOVLW  02
062D:  BSF    03.6
062E:  MOVWF  2F
062F:  MOVLW  96
0630:  MOVWF  34
0631:  BCF    03.6
0632:  CALL   09F
0633:  BSF    03.6
0634:  DECFSZ 2F,F
0635:  GOTO   62F
....................          ITOA (ID_NODE, 10, ID_); 
0636:  CLRF   33
0637:  CLRF   32
0638:  CLRF   31
0639:  BCF    03.6
063A:  MOVF   39,W
063B:  BSF    03.6
063C:  MOVWF  30
063D:  MOVLW  0A
063E:  MOVWF  34
063F:  CLRF   36
0640:  MOVLW  D7
0641:  MOVWF  35
0642:  BCF    03.6
0643:  CALL   48D
....................          LCD_GOTOXY (7, 2) ; 
0644:  MOVLW  07
0645:  BSF    03.6
0646:  MOVWF  33
0647:  MOVLW  02
0648:  MOVWF  34
0649:  BCF    03.6
064A:  CALL   373
....................          DELAY_MS (10); 
064B:  MOVLW  0A
064C:  BSF    03.6
064D:  MOVWF  34
064E:  BCF    03.6
064F:  CALL   09F
....................          PRINTF (LCD_PUTC, ID_); 
0650:  MOVLW  D7
0651:  MOVWF  04
0652:  BCF    03.7
0653:  CALL   5AD
....................          DELAY_MS (1); 
0654:  MOVLW  01
0655:  BSF    03.6
0656:  MOVWF  34
0657:  BCF    03.6
0658:  CALL   09F
....................          OUTPUT_TOGGLE (PIN_D0); 
0659:  BSF    03.5
065A:  BCF    08.0
065B:  MOVLW  01
065C:  BCF    03.5
065D:  XORWF  08,F
....................       } 
065E:  GOTO   620
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_STT = 1; 
*
0660:  BSF    3B.2
....................    LCD_GOTOXY (1, 1) ; 
0661:  MOVLW  01
0662:  BSF    03.6
0663:  MOVWF  33
0664:  MOVWF  34
0665:  BCF    03.6
0666:  CALL   373
....................    DELAY_MS (10); 
0667:  MOVLW  0A
0668:  BSF    03.6
0669:  MOVWF  34
066A:  BCF    03.6
066B:  CALL   09F
....................    PRINTF (LCD_PUTC, "CHON DEVICE: "); 
066C:  MOVLW  7B
066D:  BSF    03.6
066E:  MOVWF  0D
066F:  MOVLW  00
0670:  MOVWF  0F
0671:  BCF    03.6
0672:  CALL   3C1
....................  
....................    WHILE (TT_STT) 
0673:  BTFSS  3B.2
0674:  GOTO   72D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0675:  BSF    03.5
0676:  BSF    06.2
0677:  BCF    03.5
0678:  BTFSC  06.2
0679:  GOTO   6E0
....................       { 
....................          STT_DEVICE ++; 
067A:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
067B:  MOVF   3A,W
067C:  SUBLW  07
067D:  BTFSS  03.0
067E:  CLRF   3A
....................          DELAY_MS (300); 
067F:  MOVLW  02
0680:  BSF    03.6
0681:  MOVWF  2F
0682:  MOVLW  96
0683:  MOVWF  34
0684:  BCF    03.6
0685:  CALL   09F
0686:  BSF    03.6
0687:  DECFSZ 2F,F
0688:  GOTO   682
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
0689:  CLRF   33
068A:  CLRF   32
068B:  CLRF   31
068C:  BCF    03.6
068D:  MOVF   3A,W
068E:  BSF    03.6
068F:  MOVWF  30
0690:  MOVLW  0A
0691:  MOVWF  34
0692:  CLRF   36
0693:  MOVLW  D9
0694:  MOVWF  35
0695:  BCF    03.6
0696:  CALL   48D
....................          LCD_GOTOXY (7, 2) ; 
0697:  MOVLW  07
0698:  BSF    03.6
0699:  MOVWF  33
069A:  MOVLW  02
069B:  MOVWF  34
069C:  BCF    03.6
069D:  CALL   373
....................          DELAY_MS (10); 
069E:  MOVLW  0A
069F:  BSF    03.6
06A0:  MOVWF  34
06A1:  BCF    03.6
06A2:  CALL   09F
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06A3:  MOVLW  D9
06A4:  MOVWF  04
06A5:  BCF    03.7
06A6:  CALL   5AD
....................          DELAY_MS (1); 
06A7:  MOVLW  01
06A8:  BSF    03.6
06A9:  MOVWF  34
06AA:  BCF    03.6
06AB:  CALL   09F
....................          PRINTF (LCD_PUTC, " TT "); 
06AC:  MOVLW  82
06AD:  BSF    03.6
06AE:  MOVWF  0D
06AF:  MOVLW  00
06B0:  MOVWF  0F
06B1:  BCF    03.6
06B2:  CALL   3C1
....................          DELAY_MS (1); 
06B3:  MOVLW  01
06B4:  BSF    03.6
06B5:  MOVWF  34
06B6:  BCF    03.6
06B7:  CALL   09F
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
06B8:  MOVF   3A,W
06B9:  BSF    03.6
06BA:  MOVWF  2F
06BB:  CLRF   31
06BC:  MOVLW  3C
06BD:  MOVWF  30
06BE:  BCF    03.6
06BF:  CALL   5CA
06C0:  MOVLW  00
06C1:  BTFSC  78.0
06C2:  MOVLW  01
06C3:  BSF    03.6
06C4:  MOVWF  2F
06C5:  CLRF   33
06C6:  CLRF   32
06C7:  CLRF   31
06C8:  MOVF   2F,W
06C9:  MOVWF  30
06CA:  MOVLW  0A
06CB:  MOVWF  34
06CC:  CLRF   36
06CD:  MOVLW  D9
06CE:  MOVWF  35
06CF:  BCF    03.6
06D0:  CALL   48D
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06D1:  MOVLW  D9
06D2:  MOVWF  04
06D3:  BCF    03.7
06D4:  CALL   5AD
....................          DELAY_MS (1); 
06D5:  MOVLW  01
06D6:  BSF    03.6
06D7:  MOVWF  34
06D8:  BCF    03.6
06D9:  CALL   09F
....................          OUTPUT_TOGGLE (PIN_D0); 
06DA:  BSF    03.5
06DB:  BCF    08.0
06DC:  MOVLW  01
06DD:  BCF    03.5
06DE:  XORWF  08,F
....................       } 
06DF:  GOTO   72C
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06E0:  BSF    03.5
06E1:  BSF    06.3
06E2:  BCF    03.5
06E3:  BTFSC  06.3
06E4:  GOTO   72C
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
06E5:  MOVF   3A,W
06E6:  BSF    03.6
06E7:  MOVWF  2F
06E8:  CLRF   31
06E9:  MOVLW  3C
06EA:  MOVWF  30
06EB:  BCF    03.6
06EC:  CALL   5CA
06ED:  MOVLW  00
06EE:  BTFSS  78.0
06EF:  MOVLW  01
06F0:  BSF    03.6
06F1:  MOVWF  2F
06F2:  BCF    03.6
06F3:  MOVF   3A,W
06F4:  BSF    03.6
06F5:  MOVWF  30
06F6:  MOVF   2F,W
06F7:  MOVWF  31
06F8:  CLRF   33
06F9:  MOVLW  3C
06FA:  MOVWF  32
06FB:  BCF    03.6
06FC:  GOTO   5E3
....................          LCD_GOTOXY (12, 2) ; 
06FD:  MOVLW  0C
06FE:  BSF    03.6
06FF:  MOVWF  33
0700:  MOVLW  02
0701:  MOVWF  34
0702:  BCF    03.6
0703:  CALL   373
....................          DELAY_MS (300); 
0704:  MOVLW  02
0705:  BSF    03.6
0706:  MOVWF  2F
0707:  MOVLW  96
0708:  MOVWF  34
0709:  BCF    03.6
070A:  CALL   09F
070B:  BSF    03.6
070C:  DECFSZ 2F,F
070D:  GOTO   707
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
070E:  BCF    03.6
070F:  MOVF   3A,W
0710:  BSF    03.6
0711:  MOVWF  2F
0712:  CLRF   31
0713:  MOVLW  3C
0714:  MOVWF  30
0715:  BCF    03.6
0716:  CALL   5CA
0717:  MOVLW  00
0718:  BTFSC  78.0
0719:  MOVLW  01
071A:  BSF    03.6
071B:  MOVWF  2F
071C:  CLRF   33
071D:  CLRF   32
071E:  CLRF   31
071F:  MOVF   2F,W
0720:  MOVWF  30
0721:  MOVLW  0A
0722:  MOVWF  34
0723:  CLRF   36
0724:  MOVLW  D9
0725:  MOVWF  35
0726:  BCF    03.6
0727:  CALL   48D
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0728:  MOVLW  D9
0729:  MOVWF  04
072A:  BCF    03.7
072B:  CALL   5AD
....................       } 
072C:  GOTO   673
....................  
....................    } 
....................  
.................... } 
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    ID_NODE = 0; 
*
0742:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_FUN = 0; 
....................    TT_STT = 0; 
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    SWITCH (CONFIG_FUN) 
*
0607:  MOVF   38,W
0608:  ADDLW  FC
0609:  BTFSC  03.0
060A:  GOTO   743
060B:  ADDLW  04
060C:  GOTO   746
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
065F:  GOTO   743
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE () ; 
....................       BREAK; 
*
072D:  GOTO   743
....................  
....................       CASE 2: 
....................       //CONFIG_SENSOR (); 
....................        
....................       LCD_GOTOXY (10, 2) ; 
072E:  MOVLW  0A
072F:  BSF    03.6
0730:  MOVWF  33
0731:  MOVLW  02
0732:  MOVWF  34
0733:  BCF    03.6
0734:  CALL   373
....................       DELAY_MS (10); 
0735:  MOVLW  0A
0736:  BSF    03.6
0737:  MOVWF  34
0738:  BCF    03.6
0739:  CALL   09F
....................       PRINTF (LCD_PUTC, "CASE1"); 
073A:  MOVLW  85
073B:  BSF    03.6
073C:  MOVWF  0D
073D:  MOVLW  00
073E:  MOVWF  0F
073F:  BCF    03.6
0740:  CALL   3C1
....................       BREAK; 
0741:  GOTO   743
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
0743:  BCF    0A.3
0744:  BCF    0A.4
0745:  GOTO   797 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
074E:  BSF    3B.1
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 1) ; 
074F:  MOVLW  01
0750:  BSF    03.6
0751:  MOVWF  33
0752:  MOVWF  34
0753:  BCF    03.6
0754:  CALL   373
....................    DELAY_MS (10); 
0755:  MOVLW  0A
0756:  BSF    03.6
0757:  MOVWF  34
0758:  BCF    03.6
0759:  CALL   09F
....................    PRINTF (LCD_PUTC, "CASE: "); 
075A:  MOVLW  88
075B:  BSF    03.6
075C:  MOVWF  0D
075D:  MOVLW  00
075E:  MOVWF  0F
075F:  BCF    03.6
0760:  CALL   3C1
....................  
....................    WHILE (TT_FUN) 
0761:  BTFSS  3B.1
0762:  GOTO   796
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0763:  BSF    03.5
0764:  BSF    06.2
0765:  BCF    03.5
0766:  BTFSC  06.2
0767:  GOTO   795
....................       { 
....................          CONFIG_FUN ++; 
0768:  INCF   38,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0769:  MOVF   38,W
076A:  SUBLW  03
076B:  BTFSS  03.0
076C:  CLRF   38
....................          DELAY_MS (300); 
076D:  MOVLW  02
076E:  BSF    03.6
076F:  MOVWF  2F
0770:  MOVLW  96
0771:  MOVWF  34
0772:  BCF    03.6
0773:  CALL   09F
0774:  BSF    03.6
0775:  DECFSZ 2F,F
0776:  GOTO   770
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (7, 2) ; 
0777:  MOVLW  07
0778:  MOVWF  33
0779:  MOVLW  02
077A:  MOVWF  34
077B:  BCF    03.6
077C:  CALL   373
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
077D:  BSF    03.6
077E:  CLRF   33
077F:  CLRF   32
0780:  CLRF   31
0781:  BCF    03.6
0782:  MOVF   38,W
0783:  BSF    03.6
0784:  MOVWF  30
0785:  MOVLW  0A
0786:  MOVWF  34
0787:  CLRF   36
0788:  MOVLW  D9
0789:  MOVWF  35
078A:  BCF    03.6
078B:  CALL   48D
....................          DELAY_MS (10); 
078C:  MOVLW  0A
078D:  BSF    03.6
078E:  MOVWF  34
078F:  BCF    03.6
0790:  CALL   09F
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0791:  MOVLW  D9
0792:  MOVWF  04
0793:  BCF    03.7
0794:  CALL   5AD
....................       } 
0795:  GOTO   761
....................    } 
....................  
....................    SELLECT_FUN (); 
0796:  GOTO   607
0797:  BSF    0A.3
0798:  BCF    0A.4
0799:  GOTO   136 (RETURN)
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    IF ( ! TT_CONFIG) 
....................    { 
....................       TT_DEVICE_CHAR = ""; 
....................       FOR (INT I = 0; I < 8; I++) 
....................       { 
....................          IF (TT_DEVICE[I]) 
....................          { 
....................             ITOA (I, 10, TEMP_CHAR); 
....................             STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
....................          } 
....................  
....................       } 
....................  
....................       TEMP_CHAR = " * "; 
....................       STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
....................       PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
....................       PACKAGE_CONFIG[1] = ID_; 
....................        
....................       FOR (INT J = 0; J < 8; J++) 
....................       { 
....................          PRINTF (PACKAGE_CONFIG[J]); 
....................          DELAY_MS (1); 
....................       } 
....................  
....................        
....................       LCD_GOTOXY (1, 1) ; 
....................       DELAY_MS (10); 
....................       PRINTF (LCD_PUTC, "CONFIG DONE"); 
....................       LCD_GOTOXY (1, 2) ; 
....................       DELAY_MS (10); 
....................       PRINTF (LCD_PUTC, TT_DEVICE_CHAR); 
....................       PACKAGE[1] = ID_; 
....................    } 
.................... } 
....................  
.................... VOID QUET_PHIM() 
.................... { 
....................     
....................    IF (INPUT (BT1_PIN) == 0) //NEU NUT BAM DUOC BAM 
....................    { 
....................       LCD_GOTOXY (1, 1) ; 
....................       DELAY_MS (10); 
....................       PRINTF (LCD_PUTC, "BT1"); 
....................       FOR (INT I = 0; I < 5; I++) // SAU 10S VAN CON NHAN NUT 
....................       { 
....................          IF (INPUT (BT1_PIN) == 0) 
....................          { 
....................             DELAY_MS (1000); 
....................  
....................             IF (I == 4) 
....................             { 
....................                //CONFIG NODE 
....................                TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
....................                PRINTF (LCD_PUTC, "-- > CONFIG"); 
....................                CONFIG_DONE (); 
....................             } 
....................          } 
....................  
....................          ELSE // NHAN NUT < 10S 
....................          { 
....................             BUTT_OKE (); //OKE 
....................             I = 10; // THOAT FOR 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  VOID NGAT_NGOAI  () 
*
0098:  BSF    03.6
0099:  CLRF   55
....................  { 
....................     //QUET_PHIM (); 
....................    INT I=0; 
009A:  BCF    03.6
009B:  BCF    0B.1
009C:  BCF    0A.3
009D:  BCF    0A.4
009E:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07D2:  MOVLW  01
07D3:  BSF    03.6
07D4:  MOVWF  33
07D5:  MOVWF  34
07D6:  BCF    03.6
07D7:  CALL   373
....................     DELAY_MS (10); 
07D8:  MOVLW  0A
07D9:  BSF    03.6
07DA:  MOVWF  34
07DB:  BCF    03.6
07DC:  CALL   09F
....................     PRINTF (LCD_PUTC, KYTU); 
07DD:  MOVLW  10
07DE:  MOVWF  04
07DF:  BSF    03.7
07E0:  CALL   5AD
....................     DELAY_MS (1); 
07E1:  MOVLW  01
07E2:  BSF    03.6
07E3:  MOVWF  34
07E4:  BCF    03.6
07E5:  CALL   09F
07E6:  BSF    0A.3
07E7:  BCF    0A.4
07E8:  GOTO   1A3 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
021F:  BSF    03.6
0220:  RLF    2F,W
0221:  MOVWF  77
0222:  RLF    77,F
0223:  MOVLW  FC
0224:  ANDWF  77,F
0225:  BCF    03.6
0226:  MOVF   1F,W
0227:  ANDLW  C3
0228:  IORWF  77,W
0229:  MOVWF  1F
....................     KQADC = 0; 
022A:  CLRF   33
022B:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
022C:  BSF    03.6
022D:  CLRF   30
022E:  MOVF   30,W
022F:  SUBLW  63
0230:  BTFSS  03.0
0231:  GOTO   246
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0232:  BCF    03.6
0233:  BSF    1F.1
0234:  BTFSC  1F.1
0235:  GOTO   234
0236:  BSF    03.5
0237:  MOVF   1E,W
0238:  BCF    03.5
0239:  ADDWF  32,F
023A:  MOVF   1E,W
023B:  BTFSC  03.0
023C:  INCFSZ 1E,W
023D:  ADDWF  33,F
....................        DELAY_MS (1); 
023E:  MOVLW  01
023F:  BSF    03.6
0240:  MOVWF  34
0241:  BCF    03.6
0242:  CALL   09F
0243:  BSF    03.6
0244:  INCF   30,F
0245:  GOTO   22E
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0246:  BCF    03.6
0247:  MOVF   33,W
0248:  BSF    03.6
0249:  MOVWF  32
024A:  BCF    03.6
024B:  MOVF   32,W
024C:  BSF    03.6
024D:  MOVWF  31
*
026A:  MOVF   7A,W
026B:  MOVWF  34
026C:  MOVF   79,W
026D:  MOVWF  33
026E:  MOVF   78,W
026F:  MOVWF  32
0270:  MOVF   77,W
0271:  MOVWF  31
0272:  MOVLW  9A
0273:  MOVWF  38
0274:  MOVLW  99
0275:  MOVWF  37
0276:  MOVLW  4C
0277:  MOVWF  36
0278:  MOVLW  86
0279:  MOVWF  35
*
0343:  MOVF   7A,W
0344:  MOVWF  34
0345:  MOVF   79,W
0346:  MOVWF  33
0347:  MOVF   78,W
0348:  MOVWF  32
0349:  MOVF   77,W
034A:  MOVWF  31
*
0369:  MOVF   79,W
036A:  BCF    03.6
036B:  MOVWF  33
036C:  MOVF   78,W
036D:  MOVWF  32
....................     RETURN KQADC; 
036E:  MOVF   32,W
036F:  MOVWF  78
0370:  BSF    0A.3
0371:  BCF    0A.4
0372:  GOTO   12E (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
079A:  BSF    03.6
079B:  CLRF   2F
079C:  MOVF   2F,W
079D:  SUBLW  1E
079E:  BTFSS  03.0
079F:  GOTO   7AE
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07A0:  BSF    03.5
07A1:  BCF    03.6
07A2:  BCF    08.1
07A3:  MOVLW  02
07A4:  BCF    03.5
07A5:  XORWF  08,F
....................        DELAY_MS (100); 
07A6:  MOVLW  64
07A7:  BSF    03.6
07A8:  MOVWF  34
07A9:  BCF    03.6
07AA:  CALL   09F
07AB:  BSF    03.6
07AC:  INCF   2F,F
07AD:  GOTO   79C
....................     } 
07AE:  BCF    03.6
07AF:  BSF    0A.3
07B0:  BCF    0A.4
07B1:  GOTO   139 (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  BSF    03.5
0804:  BSF    03.6
0805:  BSF    07.3
0806:  MOVLW  08
0807:  BCF    03.6
0808:  MOVWF  19
0809:  MOVLW  02
080A:  MOVWF  1A
080B:  MOVLW  A6
080C:  MOVWF  18
080D:  MOVLW  90
080E:  BCF    03.5
080F:  MOVWF  18
0810:  MOVLW  FF
0811:  MOVWF  31
0812:  CLRF   38
0813:  CLRF   39
0814:  CLRF   3A
0815:  BCF    3B.0
0816:  BCF    3B.1
0817:  BCF    3B.2
0818:  CLRF   76
0819:  CLRF   7E
081A:  BSF    03.5
081B:  BSF    03.6
081C:  MOVF   09,W
081D:  ANDLW  C0
081E:  MOVWF  09
081F:  BCF    03.6
0820:  BCF    1F.4
0821:  BCF    1F.5
0822:  MOVLW  00
0823:  BSF    03.6
0824:  MOVWF  08
0825:  BCF    03.5
0826:  CLRF   07
0827:  CLRF   08
0828:  CLRF   09
0829:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
08F7:  MOVLW  00
08F8:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
08F9:  MOVLW  FF
08FA:  MOVWF  06
....................     SET_TRIS_E (0); 
08FB:  BCF    09.0
08FC:  BCF    09.1
08FD:  BCF    09.2
08FE:  BCF    09.3
....................     SET_TRIS_C (0X80); 
08FF:  MOVLW  80
0900:  MOVWF  07
0901:  BCF    03.5
0902:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0903:  BSF    1F.6
0904:  BCF    1F.7
0905:  BSF    03.5
0906:  BSF    1F.7
0907:  BCF    03.5
0908:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0909:  BSF    03.5
090A:  BSF    03.6
090B:  MOVF   09,W
090C:  ANDLW  C0
090D:  MOVWF  09
090E:  BCF    03.6
090F:  BCF    1F.4
0910:  BCF    1F.5
0911:  MOVLW  01
0912:  BSF    03.6
0913:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0914:  BCF    03.5
0915:  BCF    03.6
0916:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0917:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0918:  BSF    0B.4
0919:  BSF    03.5
091A:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
091B:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
091C:  MOVLW  C0
091D:  BCF    03.5
091E:  IORWF  0B,F
....................     LCD_INIT (); // KHOI TAO LCD 
091F:  BCF    0A.3
0920:  GOTO   1B9
0921:  BSF    0A.3
....................     ID_NODE = 0; 
0922:  CLRF   39
....................     TT_CONFIG = 0; 
0923:  BCF    3B.0
....................     OUTPUT_D (0X00) ; 
0924:  BSF    03.5
0925:  CLRF   08
0926:  BCF    03.5
0927:  CLRF   08
....................     TTNHAN = 0; 
0928:  CLRF   7E
....................  
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0929:  BSF    03.6
092A:  CLRF   2F
092B:  BCF    0A.3
092C:  BCF    03.6
092D:  GOTO   21F
092E:  BSF    0A.3
092F:  CLRF   35
0930:  MOVF   78,W
0931:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0932:  BTFSS  3B.0
0933:  GOTO   137
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0934:  BCF    0A.3
0935:  GOTO   74E
0936:  BSF    0A.3
....................        } 
....................  
....................        CHUONG_TRINH_CON (); 
0937:  BCF    0A.3
0938:  GOTO   79A
0939:  BSF    0A.3
....................  
....................        IF (AN0 > 26) 
093A:  MOVF   35,F
093B:  BTFSS  03.2
093C:  GOTO   141
093D:  MOVF   34,W
093E:  SUBLW  1A
093F:  BTFSC  03.0
0940:  GOTO   19E
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0941:  BSF    03.6
0942:  CLRF   33
0943:  CLRF   32
0944:  BCF    03.6
0945:  MOVF   35,W
0946:  BSF    03.6
0947:  MOVWF  31
0948:  BCF    03.6
0949:  MOVF   34,W
094A:  BSF    03.6
094B:  MOVWF  30
094C:  MOVLW  0A
094D:  MOVWF  34
094E:  CLRF   36
094F:  MOVLW  7B
0950:  MOVWF  35
0951:  BCF    0A.3
0952:  BCF    03.6
0953:  CALL   48D
0954:  BSF    0A.3
....................           PACKAGE[4] = NHIETDO1; 
0955:  CLRF   48
0956:  MOVLW  7B
0957:  MOVWF  47
....................           ITOA (AN1, 10, NHIETDO2); 
0958:  BSF    03.6
0959:  CLRF   33
095A:  CLRF   32
095B:  BCF    03.6
095C:  MOVF   37,W
095D:  BSF    03.6
095E:  MOVWF  31
095F:  BCF    03.6
0960:  MOVF   36,W
0961:  BSF    03.6
0962:  MOVWF  30
0963:  MOVLW  0A
0964:  MOVWF  34
0965:  CLRF   36
0966:  MOVLW  D4
0967:  MOVWF  35
0968:  BCF    0A.3
0969:  BCF    03.6
096A:  CALL   48D
096B:  BSF    0A.3
....................           PACKAGE[5] = NHIETDO2; 
096C:  CLRF   4A
096D:  MOVLW  D4
096E:  MOVWF  49
....................            
....................           FOR (INT I = 0; I < 8; I++) 
096F:  BSF    03.6
0970:  CLRF   2E
0971:  MOVF   2E,W
0972:  SUBLW  07
0973:  BTFSS  03.0
0974:  GOTO   192
....................           { 
....................              PRINTF (PACKAGE[I]); 
0975:  BCF    03.0
0976:  RLF    2E,W
0977:  ADDLW  3F
0978:  MOVWF  04
0979:  BCF    03.7
097A:  INCF   04,F
097B:  MOVF   00,W
097C:  MOVWF  30
097D:  DECF   04,F
097E:  MOVF   00,W
097F:  MOVWF  2F
0980:  MOVWF  04
0981:  BCF    03.7
0982:  BTFSC  30.0
0983:  BSF    03.7
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  GOTO   7B2
0987:  BSF    0A.3
....................              DELAY_MS (1); 
0988:  MOVLW  01
0989:  BSF    03.6
098A:  MOVWF  34
098B:  BCF    0A.3
098C:  BCF    03.6
098D:  CALL   09F
098E:  BSF    0A.3
098F:  BSF    03.6
0990:  INCF   2E,F
0991:  GOTO   171
....................           }         
....................           DELAY_MS (1000); 
0992:  MOVLW  04
0993:  MOVWF  2F
0994:  MOVLW  FA
0995:  MOVWF  34
0996:  BCF    0A.3
0997:  BCF    03.6
0998:  CALL   09F
0999:  BSF    0A.3
099A:  BSF    03.6
099B:  DECFSZ 2F,F
099C:  GOTO   194
099D:  BCF    03.6
....................        } 
....................        IF (TTNHAN == 1) 
099E:  DECFSZ 7E,W
099F:  GOTO   1B8
....................        { 
....................            
....................           TTNHAN = 0; 
09A0:  CLRF   7E
....................           XUATLCD (); 
09A1:  BCF    0A.3
09A2:  GOTO   7D2
09A3:  BSF    0A.3
....................            
....................           OUTPUT_TOGGLE (PIN_D0); 
09A4:  BSF    03.5
09A5:  BCF    08.0
09A6:  MOVLW  01
09A7:  BCF    03.5
09A8:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D1); 
09A9:  BSF    03.5
09AA:  BCF    08.1
09AB:  MOVLW  02
09AC:  BCF    03.5
09AD:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D2); 
09AE:  BSF    03.5
09AF:  BCF    08.2
09B0:  MOVLW  04
09B1:  BCF    03.5
09B2:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D3); 
09B3:  BSF    03.5
09B4:  BCF    08.3
09B5:  MOVLW  08
09B6:  BCF    03.5
09B7:  XORWF  08,F
....................        } 
09B8:  GOTO   129
....................     } 
....................  } 
09B9:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
