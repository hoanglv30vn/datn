CCS PCM C Compiler, Version 5.015, 5967               14-Oct-21 02:27

               Filename:   E:\DATN\NODE\pic\hellopicc\hellopic.lst

               ROM used:   2859 words (35%)
                           Largest free fragment is 2048
               RAM used:   157 (43%) at main() level
                           212 (58%) worst case
               Stack used: 8 locations (4 in main + 4 for interrupts)
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   16A
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   23D
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   062
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  43
005D:  RETLW  41
005E:  RETLW  53
005F:  RETLW  45
0060:  RETLW  31
0061:  RETLW  00
*
008A:  DATA E3,37
008B:  DATA 6E,33
008C:  DATA E9,33
008D:  DATA 00,00
*
028E:  BCF    03.6
028F:  MOVF   0B,W
0290:  BSF    03.6
0291:  MOVWF  34
0292:  BCF    03.6
0293:  BCF    0B.7
0294:  BSF    03.5
0295:  BSF    03.6
0296:  BSF    0C.7
0297:  BSF    0C.0
0298:  NOP
0299:  NOP
029A:  BCF    03.5
029B:  BTFSS  34.7
029C:  GOTO   2A0
029D:  BCF    03.6
029E:  BSF    0B.7
029F:  BSF    03.6
02A0:  MOVF   0C,W
02A1:  ANDLW  7F
02A2:  BTFSC  03.2
02A3:  GOTO   2DB
02A4:  MOVWF  34
02A5:  MOVF   0D,W
02A6:  MOVWF  35
02A7:  MOVF   0F,W
02A8:  MOVWF  36
02A9:  MOVF   34,W
02AA:  MOVWF  37
02AB:  BCF    03.6
02AC:  CALL   1E3
02AD:  BSF    03.6
02AE:  MOVF   35,W
02AF:  MOVWF  0D
02B0:  MOVF   36,W
02B1:  MOVWF  0F
02B2:  BCF    03.6
02B3:  MOVF   0B,W
02B4:  BSF    03.6
02B5:  MOVWF  37
02B6:  BCF    03.6
02B7:  BCF    0B.7
02B8:  BSF    03.5
02B9:  BSF    03.6
02BA:  BSF    0C.7
02BB:  BSF    0C.0
02BC:  NOP
02BD:  NOP
02BE:  BCF    03.5
02BF:  BTFSS  37.7
02C0:  GOTO   2C4
02C1:  BCF    03.6
02C2:  BSF    0B.7
02C3:  BSF    03.6
02C4:  RLF    0C,W
02C5:  RLF    0E,W
02C6:  ANDLW  7F
02C7:  BTFSC  03.2
02C8:  GOTO   2DB
02C9:  MOVWF  34
02CA:  MOVF   0D,W
02CB:  MOVWF  35
02CC:  MOVF   0F,W
02CD:  MOVWF  36
02CE:  MOVF   34,W
02CF:  MOVWF  37
02D0:  BCF    03.6
02D1:  CALL   1E3
02D2:  BSF    03.6
02D3:  MOVF   35,W
02D4:  MOVWF  0D
02D5:  MOVF   36,W
02D6:  MOVWF  0F
02D7:  INCF   0D,F
02D8:  BTFSC  03.2
02D9:  INCF   0F,F
02DA:  GOTO   28E
*
03B2:  MOVLW  8E
03B3:  MOVWF  77
03B4:  MOVF   6D,W
03B5:  MOVWF  78
03B6:  MOVF   6C,W
03B7:  MOVWF  79
03B8:  CLRF   7A
03B9:  MOVF   78,F
03BA:  BTFSS  03.2
03BB:  GOTO   3C6
03BC:  MOVF   79,W
03BD:  MOVWF  78
03BE:  CLRF   79
03BF:  MOVLW  08
03C0:  SUBWF  77,F
03C1:  MOVF   78,F
03C2:  BTFSS  03.2
03C3:  GOTO   3C6
03C4:  CLRF   77
03C5:  GOTO   3CE
03C6:  BCF    03.0
03C7:  BTFSC  78.7
03C8:  GOTO   3CD
03C9:  RLF    79,F
03CA:  RLF    78,F
03CB:  DECF   77,F
03CC:  GOTO   3C6
03CD:  BCF    78.7
*
03E0:  BSF    03.5
03E1:  BCF    03.6
03E2:  MOVF   6C,W
03E3:  BTFSC  03.2
03E4:  GOTO   4CC
03E5:  BCF    03.5
03E6:  BSF    03.6
03E7:  MOVWF  18
03E8:  MOVF   10,W
03E9:  BTFSS  03.2
03EA:  GOTO   3EE
03EB:  BSF    03.5
03EC:  BCF    03.6
03ED:  GOTO   4CC
03EE:  SUBWF  18,F
03EF:  BTFSS  03.0
03F0:  GOTO   3F9
03F1:  MOVLW  7F
03F2:  ADDWF  18,F
03F3:  BTFSS  03.0
03F4:  GOTO   3F8
03F5:  BSF    03.5
03F6:  BCF    03.6
03F7:  GOTO   4CC
03F8:  GOTO   405
03F9:  MOVLW  81
03FA:  SUBWF  18,F
03FB:  BTFSC  03.0
03FC:  GOTO   400
03FD:  BSF    03.5
03FE:  BCF    03.6
03FF:  GOTO   4CC
0400:  BTFSS  03.2
0401:  GOTO   405
0402:  BSF    03.5
0403:  BCF    03.6
0404:  GOTO   4CC
0405:  MOVF   18,W
0406:  MOVWF  77
0407:  CLRF   78
0408:  CLRF   79
0409:  CLRF   7A
040A:  CLRF   17
040B:  BSF    03.5
040C:  BCF    03.6
040D:  MOVF   6D,W
040E:  BCF    03.5
040F:  BSF    03.6
0410:  MOVWF  16
0411:  BSF    16.7
0412:  BSF    03.5
0413:  BCF    03.6
0414:  MOVF   6E,W
0415:  BCF    03.5
0416:  BSF    03.6
0417:  MOVWF  15
0418:  BSF    03.5
0419:  BCF    03.6
041A:  MOVF   6F,W
041B:  BCF    03.5
041C:  BSF    03.6
041D:  MOVWF  14
041E:  MOVLW  19
041F:  MOVWF  18
0420:  MOVF   13,W
0421:  SUBWF  14,F
0422:  BTFSC  03.0
0423:  GOTO   434
0424:  MOVLW  01
0425:  SUBWF  15,F
0426:  BTFSC  03.0
0427:  GOTO   434
0428:  SUBWF  16,F
0429:  BTFSC  03.0
042A:  GOTO   434
042B:  SUBWF  17,F
042C:  BTFSC  03.0
042D:  GOTO   434
042E:  INCF   17,F
042F:  INCF   16,F
0430:  INCF   15,F
0431:  MOVF   13,W
0432:  ADDWF  14,F
0433:  GOTO   466
0434:  MOVF   12,W
0435:  SUBWF  15,F
0436:  BTFSC  03.0
0437:  GOTO   44F
0438:  MOVLW  01
0439:  SUBWF  16,F
043A:  BTFSC  03.0
043B:  GOTO   44F
043C:  SUBWF  17,F
043D:  BTFSC  03.0
043E:  GOTO   44F
043F:  INCF   17,F
0440:  INCF   16,F
0441:  MOVF   12,W
0442:  ADDWF  15,F
0443:  MOVF   13,W
0444:  ADDWF  14,F
0445:  BTFSS  03.0
0446:  GOTO   466
0447:  INCF   15,F
0448:  BTFSS  03.2
0449:  GOTO   466
044A:  INCF   16,F
044B:  BTFSS  03.2
044C:  GOTO   466
044D:  INCF   17,F
044E:  GOTO   466
044F:  MOVF   11,W
0450:  IORLW  80
0451:  SUBWF  16,F
0452:  BTFSC  03.0
0453:  GOTO   465
0454:  MOVLW  01
0455:  SUBWF  17,F
0456:  BTFSC  03.0
0457:  GOTO   465
0458:  INCF   17,F
0459:  MOVF   11,W
045A:  IORLW  80
045B:  ADDWF  16,F
045C:  MOVF   12,W
045D:  ADDWF  15,F
045E:  BTFSS  03.0
045F:  GOTO   443
0460:  INCF   16,F
0461:  BTFSS  03.2
0462:  GOTO   443
0463:  INCF   17,F
0464:  GOTO   443
0465:  BSF    7A.0
0466:  DECFSZ 18,F
0467:  GOTO   469
0468:  GOTO   474
0469:  BCF    03.0
046A:  RLF    14,F
046B:  RLF    15,F
046C:  RLF    16,F
046D:  RLF    17,F
046E:  BCF    03.0
046F:  RLF    7A,F
0470:  RLF    79,F
0471:  RLF    78,F
0472:  RLF    19,F
0473:  GOTO   420
0474:  BTFSS  19.0
0475:  GOTO   47C
0476:  BCF    03.0
0477:  RRF    78,F
0478:  RRF    79,F
0479:  RRF    7A,F
047A:  RRF    19,F
047B:  GOTO   481
047C:  DECFSZ 77,F
047D:  GOTO   481
047E:  BSF    03.5
047F:  BCF    03.6
0480:  GOTO   4CC
0481:  BTFSC  19.7
0482:  GOTO   4AA
0483:  BCF    03.0
0484:  RLF    14,F
0485:  RLF    15,F
0486:  RLF    16,F
0487:  RLF    17,F
0488:  MOVF   13,W
0489:  SUBWF  14,F
048A:  BTFSC  03.0
048B:  GOTO   496
048C:  MOVLW  01
048D:  SUBWF  15,F
048E:  BTFSC  03.0
048F:  GOTO   496
0490:  SUBWF  16,F
0491:  BTFSC  03.0
0492:  GOTO   496
0493:  SUBWF  17,F
0494:  BTFSS  03.0
0495:  GOTO   4BC
0496:  MOVF   12,W
0497:  SUBWF  15,F
0498:  BTFSC  03.0
0499:  GOTO   4A1
049A:  MOVLW  01
049B:  SUBWF  16,F
049C:  BTFSC  03.0
049D:  GOTO   4A1
049E:  SUBWF  17,F
049F:  BTFSS  03.0
04A0:  GOTO   4BC
04A1:  MOVF   11,W
04A2:  IORLW  80
04A3:  SUBWF  16,F
04A4:  BTFSC  03.0
04A5:  GOTO   4AA
04A6:  MOVLW  01
04A7:  SUBWF  17,F
04A8:  BTFSS  03.0
04A9:  GOTO   4BC
04AA:  INCF   7A,F
04AB:  BTFSS  03.2
04AC:  GOTO   4BC
04AD:  INCF   79,F
04AE:  BTFSS  03.2
04AF:  GOTO   4BC
04B0:  INCF   78,F
04B1:  BTFSS  03.2
04B2:  GOTO   4BC
04B3:  INCF   77,F
04B4:  BTFSS  03.2
04B5:  GOTO   4B9
04B6:  BSF    03.5
04B7:  BCF    03.6
04B8:  GOTO   4CC
04B9:  RRF    78,F
04BA:  RRF    79,F
04BB:  RRF    7A,F
04BC:  BSF    03.5
04BD:  BCF    03.6
04BE:  MOVF   6D,W
04BF:  BCF    03.5
04C0:  BSF    03.6
04C1:  MOVWF  18
04C2:  MOVF   11,W
04C3:  XORWF  18,F
04C4:  BTFSS  18.7
04C5:  GOTO   4C8
04C6:  BSF    78.7
04C7:  GOTO   4D2
04C8:  BCF    78.7
04C9:  GOTO   4D2
04CA:  BSF    03.5
04CB:  BCF    03.6
04CC:  CLRF   77
04CD:  CLRF   78
04CE:  CLRF   79
04CF:  CLRF   7A
04D0:  BCF    03.5
04D1:  BSF    03.6
*
04DC:  MOVLW  8E
04DD:  MOVWF  77
04DE:  MOVF   6C,W
04DF:  SUBWF  77,F
04E0:  MOVF   6D,W
04E1:  MOVWF  79
04E2:  MOVF   6E,W
04E3:  MOVWF  78
04E4:  BSF    79.7
04E5:  MOVF   77,F
04E6:  BTFSC  03.2
04E7:  GOTO   4F3
04E8:  BCF    03.0
04E9:  MOVF   79,F
04EA:  BTFSS  03.2
04EB:  GOTO   4EF
04EC:  MOVF   78,F
04ED:  BTFSC  03.2
04EE:  GOTO   4F3
04EF:  RRF    79,F
04F0:  RRF    78,F
04F1:  DECFSZ 77,F
04F2:  GOTO   4E8
04F3:  BTFSS  6D.7
04F4:  GOTO   4FA
04F5:  COMF   78,F
04F6:  COMF   79,F
04F7:  INCF   78,F
04F8:  BTFSC  03.2
04F9:  INCF   79,F
*
0531:  MOVLW  20
0532:  MOVWF  26
0533:  CLRF   22
0534:  CLRF   23
0535:  CLRF   24
0536:  CLRF   25
0537:  MOVF   1D,W
0538:  MOVWF  7A
0539:  MOVF   1C,W
053A:  MOVWF  79
053B:  MOVF   1B,W
053C:  MOVWF  78
053D:  MOVF   1A,W
053E:  MOVWF  77
053F:  BCF    03.0
0540:  BTFSS  77.0
0541:  GOTO   550
0542:  MOVF   1E,W
0543:  ADDWF  22,F
0544:  MOVF   1F,W
0545:  BTFSC  03.0
0546:  INCFSZ 1F,W
0547:  ADDWF  23,F
0548:  MOVF   20,W
0549:  BTFSC  03.0
054A:  INCFSZ 20,W
054B:  ADDWF  24,F
054C:  MOVF   21,W
054D:  BTFSC  03.0
054E:  INCFSZ 21,W
054F:  ADDWF  25,F
0550:  RRF    25,F
0551:  RRF    24,F
0552:  RRF    23,F
0553:  RRF    22,F
0554:  RRF    7A,F
0555:  RRF    79,F
0556:  RRF    78,F
0557:  RRF    77,F
0558:  DECFSZ 26,F
0559:  GOTO   53F
*
0594:  BTFSC  03.1
0595:  GOTO   599
0596:  MOVLW  2A
0597:  MOVWF  04
0598:  BSF    03.7
0599:  MOVF   25,W
059A:  XORWF  29,W
059B:  ANDLW  80
059C:  MOVWF  2F
059D:  BTFSS  25.7
059E:  GOTO   5AA
059F:  COMF   22,F
05A0:  COMF   23,F
05A1:  COMF   24,F
05A2:  COMF   25,F
05A3:  INCF   22,F
05A4:  BTFSC  03.2
05A5:  INCF   23,F
05A6:  BTFSC  03.2
05A7:  INCF   24,F
05A8:  BTFSC  03.2
05A9:  INCF   25,F
05AA:  BTFSS  29.7
05AB:  GOTO   5B7
05AC:  COMF   26,F
05AD:  COMF   27,F
05AE:  COMF   28,F
05AF:  COMF   29,F
05B0:  INCF   26,F
05B1:  BTFSC  03.2
05B2:  INCF   27,F
05B3:  BTFSC  03.2
05B4:  INCF   28,F
05B5:  BTFSC  03.2
05B6:  INCF   29,F
05B7:  CLRF   77
05B8:  CLRF   78
05B9:  CLRF   79
05BA:  CLRF   7A
05BB:  CLRF   2A
05BC:  CLRF   2B
05BD:  CLRF   2C
05BE:  CLRF   2D
05BF:  MOVF   29,W
05C0:  IORWF  28,W
05C1:  IORWF  27,W
05C2:  IORWF  26,W
05C3:  BTFSC  03.2
05C4:  GOTO   5F5
05C5:  MOVLW  20
05C6:  MOVWF  2E
05C7:  BCF    03.0
05C8:  RLF    22,F
05C9:  RLF    23,F
05CA:  RLF    24,F
05CB:  RLF    25,F
05CC:  RLF    2A,F
05CD:  RLF    2B,F
05CE:  RLF    2C,F
05CF:  RLF    2D,F
05D0:  MOVF   29,W
05D1:  SUBWF  2D,W
05D2:  BTFSS  03.2
05D3:  GOTO   5DE
05D4:  MOVF   28,W
05D5:  SUBWF  2C,W
05D6:  BTFSS  03.2
05D7:  GOTO   5DE
05D8:  MOVF   27,W
05D9:  SUBWF  2B,W
05DA:  BTFSS  03.2
05DB:  GOTO   5DE
05DC:  MOVF   26,W
05DD:  SUBWF  2A,W
05DE:  BTFSS  03.0
05DF:  GOTO   5EF
05E0:  MOVF   26,W
05E1:  SUBWF  2A,F
05E2:  MOVF   27,W
05E3:  BTFSS  03.0
05E4:  INCFSZ 27,W
05E5:  SUBWF  2B,F
05E6:  MOVF   28,W
05E7:  BTFSS  03.0
05E8:  INCFSZ 28,W
05E9:  SUBWF  2C,F
05EA:  MOVF   29,W
05EB:  BTFSS  03.0
05EC:  INCFSZ 29,W
05ED:  SUBWF  2D,F
05EE:  BSF    03.0
05EF:  RLF    77,F
05F0:  RLF    78,F
05F1:  RLF    79,F
05F2:  RLF    7A,F
05F3:  DECFSZ 2E,F
05F4:  GOTO   5C7
05F5:  BTFSS  2F.7
05F6:  GOTO   602
05F7:  COMF   77,F
05F8:  COMF   78,F
05F9:  COMF   79,F
05FA:  COMF   7A,F
05FB:  INCF   77,F
05FC:  BTFSC  03.2
05FD:  INCF   78,F
05FE:  BTFSC  03.2
05FF:  INCF   79,F
0600:  BTFSC  03.2
0601:  INCF   7A,F
0602:  MOVF   2A,W
0603:  MOVWF  00
0604:  INCF   04,F
0605:  MOVF   2B,W
0606:  MOVWF  00
0607:  INCF   04,F
0608:  MOVF   2C,W
0609:  MOVWF  00
060A:  INCF   04,F
060B:  MOVF   2D,W
060C:  MOVWF  00
*
064B:  BTFSC  03.1
064C:  GOTO   650
064D:  MOVLW  2A
064E:  MOVWF  04
064F:  BSF    03.7
0650:  MOVF   25,W
0651:  XORWF  29,W
0652:  ANDLW  80
0653:  MOVWF  2F
0654:  BTFSS  25.7
0655:  GOTO   661
0656:  COMF   22,F
0657:  COMF   23,F
0658:  COMF   24,F
0659:  COMF   25,F
065A:  INCF   22,F
065B:  BTFSC  03.2
065C:  INCF   23,F
065D:  BTFSC  03.2
065E:  INCF   24,F
065F:  BTFSC  03.2
0660:  INCF   25,F
0661:  BTFSS  29.7
0662:  GOTO   66E
0663:  COMF   26,F
0664:  COMF   27,F
0665:  COMF   28,F
0666:  COMF   29,F
0667:  INCF   26,F
0668:  BTFSC  03.2
0669:  INCF   27,F
066A:  BTFSC  03.2
066B:  INCF   28,F
066C:  BTFSC  03.2
066D:  INCF   29,F
066E:  CLRF   77
066F:  CLRF   78
0670:  CLRF   79
0671:  CLRF   7A
0672:  CLRF   2A
0673:  CLRF   2B
0674:  CLRF   2C
0675:  CLRF   2D
0676:  MOVF   29,W
0677:  IORWF  28,W
0678:  IORWF  27,W
0679:  IORWF  26,W
067A:  BTFSC  03.2
067B:  GOTO   6AC
067C:  MOVLW  20
067D:  MOVWF  2E
067E:  BCF    03.0
067F:  RLF    22,F
0680:  RLF    23,F
0681:  RLF    24,F
0682:  RLF    25,F
0683:  RLF    2A,F
0684:  RLF    2B,F
0685:  RLF    2C,F
0686:  RLF    2D,F
0687:  MOVF   29,W
0688:  SUBWF  2D,W
0689:  BTFSS  03.2
068A:  GOTO   695
068B:  MOVF   28,W
068C:  SUBWF  2C,W
068D:  BTFSS  03.2
068E:  GOTO   695
068F:  MOVF   27,W
0690:  SUBWF  2B,W
0691:  BTFSS  03.2
0692:  GOTO   695
0693:  MOVF   26,W
0694:  SUBWF  2A,W
0695:  BTFSS  03.0
0696:  GOTO   6A6
0697:  MOVF   26,W
0698:  SUBWF  2A,F
0699:  MOVF   27,W
069A:  BTFSS  03.0
069B:  INCFSZ 27,W
069C:  SUBWF  2B,F
069D:  MOVF   28,W
069E:  BTFSS  03.0
069F:  INCFSZ 28,W
06A0:  SUBWF  2C,F
06A1:  MOVF   29,W
06A2:  BTFSS  03.0
06A3:  INCFSZ 29,W
06A4:  SUBWF  2D,F
06A5:  BSF    03.0
06A6:  RLF    77,F
06A7:  RLF    78,F
06A8:  RLF    79,F
06A9:  RLF    7A,F
06AA:  DECFSZ 2E,F
06AB:  GOTO   67E
06AC:  BTFSS  2F.7
06AD:  GOTO   6B9
06AE:  COMF   77,F
06AF:  COMF   78,F
06B0:  COMF   79,F
06B1:  COMF   7A,F
06B2:  INCF   77,F
06B3:  BTFSC  03.2
06B4:  INCF   78,F
06B5:  BTFSC  03.2
06B6:  INCF   79,F
06B7:  BTFSC  03.2
06B8:  INCF   7A,F
06B9:  MOVF   2A,W
06BA:  MOVWF  00
06BB:  INCF   04,F
06BC:  MOVF   2B,W
06BD:  MOVWF  00
06BE:  INCF   04,F
06BF:  MOVF   2C,W
06C0:  MOVWF  00
06C1:  INCF   04,F
06C2:  MOVF   2D,W
06C3:  MOVWF  00
*
0794:  MOVF   00,F
0795:  BTFSC  03.2
0796:  GOTO   7B1
0797:  BSF    03.5
0798:  CLRF   6D
0799:  MOVF   04,W
079A:  MOVWF  6C
079B:  BCF    6D.0
079C:  BTFSC  03.7
079D:  BSF    6D.0
079E:  MOVF   00,W
079F:  BCF    03.5
07A0:  BTFSS  0C.4
07A1:  GOTO   7A0
07A2:  MOVWF  19
07A3:  BSF    03.5
07A4:  MOVF   6C,W
07A5:  MOVWF  04
07A6:  BCF    03.7
07A7:  BTFSC  6D.0
07A8:  BSF    03.7
07A9:  INCF   04,F
07AA:  BTFSS  03.2
07AB:  GOTO   7AF
07AC:  BCF    03.5
07AD:  INCF   05,F
07AE:  BSF    03.5
07AF:  BCF    03.5
07B0:  GOTO   794
07B1:  BSF    0A.3
07B2:  BCF    0A.4
07B3:  GOTO   338 (RETURN)
*
085C:  MOVF   00,F
085D:  BTFSC  03.2
085E:  GOTO   082
085F:  BSF    03.5
0860:  CLRF   6B
0861:  MOVF   04,W
0862:  MOVWF  6A
0863:  BCF    6B.0
0864:  BTFSC  03.7
0865:  BSF    6B.0
0866:  BCF    03.5
0867:  CLRF   2B
0868:  BTFSC  0B.7
0869:  BSF    2B.7
086A:  BCF    0B.7
086B:  MOVF   00,W
086C:  BSF    03.6
086D:  MOVWF  37
086E:  BCF    0A.3
086F:  BCF    03.6
0870:  CALL   1E3
0871:  BSF    0A.3
0872:  BTFSC  2B.7
0873:  BSF    0B.7
0874:  BSF    03.5
0875:  MOVF   6A,W
0876:  MOVWF  04
0877:  BCF    03.7
0878:  BTFSC  6B.0
0879:  BSF    03.7
087A:  INCF   04,F
087B:  BTFSS  03.2
087C:  GOTO   080
087D:  BCF    03.5
087E:  INCF   05,F
087F:  BSF    03.5
0880:  BCF    03.5
0881:  GOTO   05C
0882:  CLRF   2B
0883:  BTFSC  0B.7
0884:  BSF    2B.7
0885:  BCF    0B.7
*
08D8:  MOVF   00,F
08D9:  BTFSC  03.2
08DA:  GOTO   0FE
08DB:  BSF    03.5
08DC:  CLRF   6B
08DD:  MOVF   04,W
08DE:  MOVWF  6A
08DF:  BCF    6B.0
08E0:  BTFSC  03.7
08E1:  BSF    6B.0
08E2:  BCF    03.5
08E3:  CLRF   2B
08E4:  BTFSC  0B.7
08E5:  BSF    2B.7
08E6:  BCF    0B.7
08E7:  MOVF   00,W
08E8:  BSF    03.6
08E9:  MOVWF  37
08EA:  BCF    0A.3
08EB:  BCF    03.6
08EC:  CALL   1E3
08ED:  BSF    0A.3
08EE:  BTFSC  2B.7
08EF:  BSF    0B.7
08F0:  BSF    03.5
08F1:  MOVF   6A,W
08F2:  MOVWF  04
08F3:  BCF    03.7
08F4:  BTFSC  6B.0
08F5:  BSF    03.7
08F6:  INCF   04,F
08F7:  BTFSS  03.2
08F8:  GOTO   0FC
08F9:  BCF    03.5
08FA:  INCF   05,F
08FB:  BSF    03.5
08FC:  BCF    03.5
08FD:  GOTO   0D8
*
0904:  BSF    0A.0
0905:  BCF    0A.1
0906:  BCF    0A.2
0907:  ADDWF  02,F
0908:  GOTO   006
0909:  GOTO   099
090A:  GOTO   0FF
090B:  GOTO   100
*
0934:  MOVF   00,F
0935:  BTFSC  03.2
0936:  GOTO   15A
0937:  BSF    03.5
0938:  CLRF   6B
0939:  MOVF   04,W
093A:  MOVWF  6A
093B:  BCF    6B.0
093C:  BTFSC  03.7
093D:  BSF    6B.0
093E:  BCF    03.5
093F:  CLRF   2B
0940:  BTFSC  0B.7
0941:  BSF    2B.7
0942:  BCF    0B.7
0943:  MOVF   00,W
0944:  BSF    03.6
0945:  MOVWF  37
0946:  BCF    0A.3
0947:  BCF    03.6
0948:  CALL   1E3
0949:  BSF    0A.3
094A:  BTFSC  2B.7
094B:  BSF    0B.7
094C:  BSF    03.5
094D:  MOVF   6A,W
094E:  MOVWF  04
094F:  BCF    03.7
0950:  BTFSC  6B.0
0951:  BSF    03.7
0952:  INCF   04,F
0953:  BTFSS  03.2
0954:  GOTO   158
0955:  BCF    03.5
0956:  INCF   05,F
0957:  BSF    03.5
0958:  BCF    03.5
0959:  GOTO   134
095A:  CLRF   2B
095B:  BTFSC  0B.7
095C:  BSF    2B.7
095D:  BCF    0B.7
*
0ABC:  MOVF   00,F
0ABD:  BTFSC  03.2
0ABE:  GOTO   2E2
0ABF:  BSF    03.5
0AC0:  CLRF   6B
0AC1:  MOVF   04,W
0AC2:  MOVWF  6A
0AC3:  BCF    6B.0
0AC4:  BTFSC  03.7
0AC5:  BSF    6B.0
0AC6:  BCF    03.5
0AC7:  CLRF   2B
0AC8:  BTFSC  0B.7
0AC9:  BSF    2B.7
0ACA:  BCF    0B.7
0ACB:  MOVF   00,W
0ACC:  BSF    03.6
0ACD:  MOVWF  37
0ACE:  BCF    0A.3
0ACF:  BCF    03.6
0AD0:  CALL   1E3
0AD1:  BSF    0A.3
0AD2:  BTFSC  2B.7
0AD3:  BSF    0B.7
0AD4:  BSF    03.5
0AD5:  MOVF   6A,W
0AD6:  MOVWF  04
0AD7:  BCF    03.7
0AD8:  BTFSC  6B.0
0AD9:  BSF    03.7
0ADA:  INCF   04,F
0ADB:  BTFSS  03.2
0ADC:  GOTO   2E0
0ADD:  BCF    03.5
0ADE:  INCF   05,F
0ADF:  BSF    03.5
0AE0:  BCF    03.5
0AE1:  GOTO   2BC
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0996:  BCF    03.6
0997:  CLRF   2C
0998:  CLRF   2D
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0504:  BSF    03.6
0505:  CLRF   15
0506:  CLRF   14
0507:  CLRF   13
0508:  MOVLW  01
0509:  MOVWF  12
050A:  CLRF   16
050B:  CLRF   17
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
050C:  BSF    03.5
050D:  BCF    03.6
050E:  BTFSS  6D.7
050F:  GOTO   564
....................          sign=1;        // Check for negative number 
0510:  MOVLW  01
0511:  BCF    03.5
0512:  BSF    03.6
0513:  MOVWF  16
....................          num*=-1; 
0514:  BSF    03.5
0515:  BCF    03.6
0516:  MOVF   6D,W
0517:  BCF    03.5
0518:  BSF    03.6
0519:  MOVWF  1D
051A:  BSF    03.5
051B:  BCF    03.6
051C:  MOVF   6C,W
051D:  BCF    03.5
051E:  BSF    03.6
051F:  MOVWF  1C
0520:  BSF    03.5
0521:  BCF    03.6
0522:  MOVF   6B,W
0523:  BCF    03.5
0524:  BSF    03.6
0525:  MOVWF  1B
0526:  BSF    03.5
0527:  BCF    03.6
0528:  MOVF   6A,W
0529:  BCF    03.5
052A:  BSF    03.6
052B:  MOVWF  1A
052C:  MOVLW  FF
052D:  MOVWF  21
052E:  MOVWF  20
052F:  MOVWF  1F
0530:  MOVWF  1E
*
055A:  MOVF   7A,W
055B:  BSF    03.5
055C:  BCF    03.6
055D:  MOVWF  6D
055E:  MOVF   79,W
055F:  MOVWF  6C
0560:  MOVF   78,W
0561:  MOVWF  6B
0562:  MOVF   77,W
0563:  MOVWF  6A
....................      } 
....................  
....................      while(temp>0) { 
0564:  BCF    03.5
0565:  BSF    03.6
0566:  MOVF   12,F
0567:  BTFSS  03.2
0568:  GOTO   572
0569:  MOVF   13,F
056A:  BTFSS  03.2
056B:  GOTO   572
056C:  MOVF   14,F
056D:  BTFSS  03.2
056E:  GOTO   572
056F:  MOVF   15,F
0570:  BTFSC  03.2
0571:  GOTO   712
....................          temp=(num/base); 
0572:  BCF    03.1
0573:  BSF    03.5
0574:  BCF    03.6
0575:  MOVF   6D,W
0576:  BCF    03.5
0577:  BSF    03.6
0578:  MOVWF  25
0579:  BSF    03.5
057A:  BCF    03.6
057B:  MOVF   6C,W
057C:  BCF    03.5
057D:  BSF    03.6
057E:  MOVWF  24
057F:  BSF    03.5
0580:  BCF    03.6
0581:  MOVF   6B,W
0582:  BCF    03.5
0583:  BSF    03.6
0584:  MOVWF  23
0585:  BSF    03.5
0586:  BCF    03.6
0587:  MOVF   6A,W
0588:  BCF    03.5
0589:  BSF    03.6
058A:  MOVWF  22
058B:  CLRF   29
058C:  CLRF   28
058D:  CLRF   27
058E:  BSF    03.5
058F:  BCF    03.6
0590:  MOVF   6E,W
0591:  BCF    03.5
0592:  BSF    03.6
0593:  MOVWF  26
*
060D:  MOVF   7A,W
060E:  MOVWF  15
060F:  MOVF   79,W
0610:  MOVWF  14
0611:  MOVF   78,W
0612:  MOVWF  13
0613:  MOVF   77,W
0614:  MOVWF  12
....................          s[cnt]=(num%base)+'0';    // Conversion 
0615:  MOVF   17,W
0616:  ADDWF  10,W
0617:  MOVWF  78
0618:  MOVF   11,W
0619:  MOVWF  7A
061A:  BTFSC  03.0
061B:  INCF   7A,F
061C:  MOVF   78,W
061D:  MOVWF  19
061E:  MOVF   7A,W
061F:  MOVWF  1A
0620:  CLRF   1C
0621:  MOVF   04,W
0622:  MOVWF  1B
0623:  BCF    1C.0
0624:  BTFSC  03.7
0625:  BSF    1C.0
0626:  BSF    03.1
0627:  MOVLW  1D
0628:  MOVWF  04
0629:  BSF    03.7
062A:  BSF    03.5
062B:  BCF    03.6
062C:  MOVF   6D,W
062D:  BCF    03.5
062E:  BSF    03.6
062F:  MOVWF  25
0630:  BSF    03.5
0631:  BCF    03.6
0632:  MOVF   6C,W
0633:  BCF    03.5
0634:  BSF    03.6
0635:  MOVWF  24
0636:  BSF    03.5
0637:  BCF    03.6
0638:  MOVF   6B,W
0639:  BCF    03.5
063A:  BSF    03.6
063B:  MOVWF  23
063C:  BSF    03.5
063D:  BCF    03.6
063E:  MOVF   6A,W
063F:  BCF    03.5
0640:  BSF    03.6
0641:  MOVWF  22
0642:  CLRF   29
0643:  CLRF   28
0644:  CLRF   27
0645:  BSF    03.5
0646:  BCF    03.6
0647:  MOVF   6E,W
0648:  BCF    03.5
0649:  BSF    03.6
064A:  MOVWF  26
*
06C4:  MOVF   1B,W
06C5:  MOVWF  04
06C6:  BCF    03.7
06C7:  BTFSC  1C.0
06C8:  BSF    03.7
06C9:  MOVLW  30
06CA:  ADDWF  1D,W
06CB:  MOVWF  77
06CC:  MOVF   1E,W
06CD:  MOVWF  78
06CE:  MOVLW  00
06CF:  BTFSC  03.0
06D0:  MOVLW  01
06D1:  ADDWF  78,F
06D2:  MOVF   1F,W
06D3:  MOVWF  79
06D4:  MOVLW  00
06D5:  BTFSC  03.0
06D6:  MOVLW  01
06D7:  ADDWF  79,F
06D8:  MOVF   20,W
06D9:  MOVWF  7A
06DA:  MOVLW  00
06DB:  BTFSC  03.0
06DC:  MOVLW  01
06DD:  ADDWF  7A,F
06DE:  MOVF   19,W
06DF:  MOVWF  04
06E0:  BCF    03.7
06E1:  BTFSC  1A.0
06E2:  BSF    03.7
06E3:  MOVF   77,W
06E4:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
06E5:  MOVF   17,W
06E6:  ADDWF  10,W
06E7:  MOVWF  04
06E8:  BCF    03.7
06E9:  BTFSC  11.0
06EA:  BSF    03.7
06EB:  MOVF   00,W
06EC:  SUBLW  39
06ED:  BTFSC  03.0
06EE:  GOTO   6F8
....................             s[cnt]+=0x7; 
06EF:  MOVF   17,W
06F0:  ADDWF  10,W
06F1:  MOVWF  04
06F2:  BCF    03.7
06F3:  BTFSC  11.0
06F4:  BSF    03.7
06F5:  MOVLW  07
06F6:  ADDWF  00,W
06F7:  MOVWF  00
....................  
....................          cnt++; 
06F8:  INCF   17,F
....................          num=temp; 
06F9:  MOVF   15,W
06FA:  BSF    03.5
06FB:  BCF    03.6
06FC:  MOVWF  6D
06FD:  BCF    03.5
06FE:  BSF    03.6
06FF:  MOVF   14,W
0700:  BSF    03.5
0701:  BCF    03.6
0702:  MOVWF  6C
0703:  BCF    03.5
0704:  BSF    03.6
0705:  MOVF   13,W
0706:  BSF    03.5
0707:  BCF    03.6
0708:  MOVWF  6B
0709:  BCF    03.5
070A:  BSF    03.6
070B:  MOVF   12,W
070C:  BSF    03.5
070D:  BCF    03.6
070E:  MOVWF  6A
070F:  GOTO   564
0710:  BCF    03.5
0711:  BSF    03.6
....................      } 
....................  
....................      if(sign==1) { 
0712:  DECFSZ 16,W
0713:  GOTO   71D
....................          s[cnt]=0x2D;      // Negative sign 
0714:  MOVF   17,W
0715:  ADDWF  10,W
0716:  MOVWF  04
0717:  BCF    03.7
0718:  BTFSC  11.0
0719:  BSF    03.7
071A:  MOVLW  2D
071B:  MOVWF  00
....................          cnt++; 
071C:  INCF   17,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
071D:  BSF    03.5
071E:  BCF    03.6
071F:  CLRF   6F
0720:  BCF    03.0
0721:  BCF    03.5
0722:  BSF    03.6
0723:  RRF    17,W
0724:  BSF    03.5
0725:  BCF    03.6
0726:  SUBWF  6F,W
0727:  BTFSC  03.0
0728:  GOTO   769
....................  
....................          c=s[i]; 
0729:  MOVF   6F,W
072A:  BCF    03.5
072B:  BSF    03.6
072C:  ADDWF  10,W
072D:  MOVWF  04
072E:  BCF    03.7
072F:  BTFSC  11.0
0730:  BSF    03.7
0731:  MOVF   00,W
0732:  MOVWF  18
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0733:  BSF    03.5
0734:  BCF    03.6
0735:  MOVF   6F,W
0736:  BCF    03.5
0737:  BSF    03.6
0738:  ADDWF  10,W
0739:  MOVWF  78
073A:  MOVF   11,W
073B:  MOVWF  7A
073C:  BTFSC  03.0
073D:  INCF   7A,F
073E:  MOVF   78,W
073F:  MOVWF  19
0740:  MOVF   7A,W
0741:  MOVWF  1A
0742:  BSF    03.5
0743:  BCF    03.6
0744:  MOVF   6F,W
0745:  BCF    03.5
0746:  BSF    03.6
0747:  SUBWF  17,W
0748:  ADDLW  FF
0749:  ADDWF  10,W
074A:  MOVWF  04
074B:  BCF    03.7
074C:  BTFSC  11.0
074D:  BSF    03.7
074E:  MOVF   00,W
074F:  MOVWF  1B
0750:  MOVF   19,W
0751:  MOVWF  04
0752:  BCF    03.7
0753:  BTFSC  1A.0
0754:  BSF    03.7
0755:  MOVF   1B,W
0756:  MOVWF  00
....................          s[cnt-i-1]=c; 
0757:  BSF    03.5
0758:  BCF    03.6
0759:  MOVF   6F,W
075A:  BCF    03.5
075B:  BSF    03.6
075C:  SUBWF  17,W
075D:  ADDLW  FF
075E:  ADDWF  10,W
075F:  MOVWF  04
0760:  BCF    03.7
0761:  BTFSC  11.0
0762:  BSF    03.7
0763:  MOVF   18,W
0764:  MOVWF  00
0765:  BSF    03.5
0766:  BCF    03.6
0767:  INCF   6F,F
0768:  GOTO   720
....................      } 
....................      s[cnt]='\0';     // End the string 
0769:  BCF    03.5
076A:  BSF    03.6
076B:  MOVF   17,W
076C:  ADDWF  10,W
076D:  MOVWF  04
076E:  BCF    03.7
076F:  BTFSC  11.0
0770:  BSF    03.7
0771:  CLRF   00
....................      return s; 
0772:  MOVF   10,W
0773:  MOVWF  78
0774:  MOVF   11,W
0775:  MOVWF  79
0776:  BCF    03.6
0777:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
....................  
.................... /* 
.................... int atoi(CONST char *s) : sting --> s nguyn 
.................... long atol(CONST char *s) : string --> s nguyn di 
.................... float atof(CONST char *s) : string --> s thuc 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
01CF:  MOVLW  38
01D0:  MOVWF  04
01D1:  BSF    03.7
01D2:  MOVF   00,W
01D3:  BTFSC  03.2
01D4:  GOTO   1E2
01D5:  MOVLW  06
01D6:  MOVWF  78
01D7:  CLRF   77
01D8:  DECFSZ 77,F
01D9:  GOTO   1D8
01DA:  DECFSZ 78,F
01DB:  GOTO   1D7
01DC:  MOVLW  7B
01DD:  MOVWF  77
01DE:  DECFSZ 77,F
01DF:  GOTO   1DE
01E0:  DECFSZ 00,F
01E1:  GOTO   1D5
01E2:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #define BT1_PIN PIN_B1 
.................... #define BT2_PIN PIN_B2 
.................... #define BT3_PIN PIN_B3 
.................... #define LCD_ENABLE_PIN  PIN_E0                                    
.................... #define LCD_RS_PIN      PIN_E1                                 
.................... #define LCD_RW_PIN      PIN_E2                               
.................... #define LCD_DATA4       PIN_C0                                
.................... #define LCD_DATA5       PIN_C1                                  
.................... #define LCD_DATA6       PIN_C2                                    
.................... #define LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00DE:  BSF    07.0
....................    output_float(LCD_DATA5); 
00DF:  BSF    07.1
....................    output_float(LCD_DATA6); 
00E0:  BSF    07.2
....................    output_float(LCD_DATA7); 
00E1:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00E2:  BCF    03.5
00E3:  BSF    09.2
00E4:  BSF    03.5
00E5:  BCF    09.2
....................    delay_cycles(1); 
00E6:  NOP
....................    lcd_output_enable(1); 
00E7:  BCF    03.5
00E8:  BSF    09.0
00E9:  BSF    03.5
00EA:  BCF    09.0
....................    delay_cycles(1); 
00EB:  NOP
....................    high = lcd_read_nibble(); 
*
012E:  MOVF   78,W
012F:  MOVWF  3F
....................        
....................    lcd_output_enable(0); 
0130:  BCF    03.6
0131:  BCF    09.0
0132:  BSF    03.5
0133:  BCF    09.0
....................    delay_cycles(1); 
0134:  NOP
....................    lcd_output_enable(1); 
0135:  BCF    03.5
0136:  BSF    09.0
0137:  BSF    03.5
0138:  BCF    09.0
....................    delay_us(1); 
0139:  GOTO   13A
013A:  GOTO   13B
013B:  NOP
....................    low = lcd_read_nibble(); 
*
017E:  MOVF   78,W
017F:  MOVWF  3E
....................        
....................    lcd_output_enable(0); 
0180:  BCF    03.6
0181:  BCF    09.0
0182:  BSF    03.5
0183:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0184:  BCF    03.5
0185:  BCF    32.0
0186:  MOVF   32,W
0187:  BSF    03.5
0188:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0189:  BCF    03.5
018A:  BCF    32.1
018B:  MOVF   32,W
018C:  BSF    03.5
018D:  MOVWF  07
....................    output_drive(LCD_DATA6); 
018E:  BCF    03.5
018F:  BCF    32.2
0190:  MOVF   32,W
0191:  BSF    03.5
0192:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0193:  BCF    03.5
0194:  BCF    32.3
0195:  MOVF   32,W
0196:  BSF    03.5
0197:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0198:  BCF    03.5
0199:  BSF    03.6
019A:  SWAPF  3F,W
019B:  MOVWF  77
019C:  MOVLW  F0
019D:  ANDWF  77,F
019E:  MOVF   77,W
019F:  IORWF  3E,W
01A0:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
00EC:  BCF    03.5
00ED:  BSF    03.6
00EE:  CLRF   40
*
013C:  BCF    03.5
013D:  BSF    03.6
013E:  CLRF   40
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
00EF:  BCF    03.6
00F0:  BSF    32.0
00F1:  MOVF   32,W
00F2:  BSF    03.5
00F3:  MOVWF  07
00F4:  MOVLW  00
00F5:  BCF    03.5
00F6:  BTFSC  07.0
00F7:  MOVLW  01
00F8:  BSF    03.6
00F9:  IORWF  40,F
*
013F:  BCF    03.6
0140:  BSF    32.0
0141:  MOVF   32,W
0142:  BSF    03.5
0143:  MOVWF  07
0144:  MOVLW  00
0145:  BCF    03.5
0146:  BTFSC  07.0
0147:  MOVLW  01
0148:  BSF    03.6
0149:  IORWF  40,F
....................    n |= input(LCD_DATA5) << 1; 
*
00FA:  BCF    03.6
00FB:  BSF    32.1
00FC:  MOVF   32,W
00FD:  BSF    03.5
00FE:  MOVWF  07
00FF:  MOVLW  00
0100:  BCF    03.5
0101:  BTFSC  07.1
0102:  MOVLW  01
0103:  MOVWF  77
0104:  BCF    03.0
0105:  RLF    77,F
0106:  MOVF   77,W
0107:  BSF    03.6
0108:  IORWF  40,F
*
014A:  BCF    03.6
014B:  BSF    32.1
014C:  MOVF   32,W
014D:  BSF    03.5
014E:  MOVWF  07
014F:  MOVLW  00
0150:  BCF    03.5
0151:  BTFSC  07.1
0152:  MOVLW  01
0153:  MOVWF  77
0154:  BCF    03.0
0155:  RLF    77,F
0156:  MOVF   77,W
0157:  BSF    03.6
0158:  IORWF  40,F
....................    n |= input(LCD_DATA6) << 2; 
*
0109:  BCF    03.6
010A:  BSF    32.2
010B:  MOVF   32,W
010C:  BSF    03.5
010D:  MOVWF  07
010E:  MOVLW  00
010F:  BCF    03.5
0110:  BTFSC  07.2
0111:  MOVLW  01
0112:  MOVWF  77
0113:  RLF    77,F
0114:  RLF    77,F
0115:  MOVLW  FC
0116:  ANDWF  77,F
0117:  MOVF   77,W
0118:  BSF    03.6
0119:  IORWF  40,F
*
0159:  BCF    03.6
015A:  BSF    32.2
015B:  MOVF   32,W
015C:  BSF    03.5
015D:  MOVWF  07
015E:  MOVLW  00
015F:  BCF    03.5
0160:  BTFSC  07.2
0161:  MOVLW  01
0162:  MOVWF  77
0163:  RLF    77,F
0164:  RLF    77,F
0165:  MOVLW  FC
0166:  ANDWF  77,F
0167:  MOVF   77,W
0168:  BSF    03.6
0169:  IORWF  40,F
....................    n |= input(LCD_DATA7) << 3; 
*
011A:  BCF    03.6
011B:  BSF    32.3
011C:  MOVF   32,W
011D:  BSF    03.5
011E:  MOVWF  07
011F:  MOVLW  00
0120:  BCF    03.5
0121:  BTFSC  07.3
0122:  MOVLW  01
0123:  MOVWF  77
0124:  RLF    77,F
0125:  RLF    77,F
0126:  RLF    77,F
0127:  MOVLW  F8
0128:  ANDWF  77,F
0129:  MOVF   77,W
012A:  BSF    03.6
012B:  IORWF  40,F
*
016A:  BCF    03.6
016B:  BSF    32.3
016C:  MOVF   32,W
016D:  BSF    03.5
016E:  MOVWF  07
016F:  MOVLW  00
0170:  BCF    03.5
0171:  BTFSC  07.3
0172:  MOVLW  01
0173:  MOVWF  77
0174:  RLF    77,F
0175:  RLF    77,F
0176:  RLF    77,F
0177:  MOVLW  F8
0178:  ANDWF  77,F
0179:  MOVF   77,W
017A:  BSF    03.6
017B:  IORWF  40,F
....................     
....................    return(n); 
*
012C:  MOVF   40,W
012D:  MOVWF  78
*
017C:  MOVF   40,W
017D:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
008E:  BSF    03.6
008F:  BTFSC  3F.0
0090:  GOTO   095
0091:  BCF    03.6
0092:  BCF    07.0
0093:  GOTO   097
0094:  BSF    03.6
0095:  BCF    03.6
0096:  BSF    07.0
0097:  BCF    32.0
0098:  MOVF   32,W
0099:  BSF    03.5
009A:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
009B:  BCF    03.5
009C:  BSF    03.6
009D:  BTFSC  3F.1
009E:  GOTO   0A3
009F:  BCF    03.6
00A0:  BCF    07.1
00A1:  GOTO   0A5
00A2:  BSF    03.6
00A3:  BCF    03.6
00A4:  BSF    07.1
00A5:  BCF    32.1
00A6:  MOVF   32,W
00A7:  BSF    03.5
00A8:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00A9:  BCF    03.5
00AA:  BSF    03.6
00AB:  BTFSC  3F.2
00AC:  GOTO   0B1
00AD:  BCF    03.6
00AE:  BCF    07.2
00AF:  GOTO   0B3
00B0:  BSF    03.6
00B1:  BCF    03.6
00B2:  BSF    07.2
00B3:  BCF    32.2
00B4:  MOVF   32,W
00B5:  BSF    03.5
00B6:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
00B7:  BCF    03.5
00B8:  BSF    03.6
00B9:  BTFSC  3F.3
00BA:  GOTO   0BF
00BB:  BCF    03.6
00BC:  BCF    07.3
00BD:  GOTO   0C1
00BE:  BSF    03.6
00BF:  BCF    03.6
00C0:  BSF    07.3
00C1:  BCF    32.3
00C2:  MOVF   32,W
00C3:  BSF    03.5
00C4:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
00C5:  NOP
....................    lcd_output_enable(1); 
00C6:  BCF    03.5
00C7:  BSF    09.0
00C8:  BSF    03.5
00C9:  BCF    09.0
....................    delay_us(2); 
00CA:  MOVLW  02
00CB:  MOVWF  77
00CC:  DECFSZ 77,F
00CD:  GOTO   0CC
00CE:  GOTO   0CF
00CF:  NOP
....................    lcd_output_enable(0); 
00D0:  BCF    03.5
00D1:  BCF    09.0
00D2:  BSF    03.5
00D3:  BCF    09.0
00D4:  BCF    03.5
00D5:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
00D6:  BSF    03.5
00D7:  BCF    09.0
....................    lcd_rs_tris(); 
00D8:  BCF    09.1
....................    lcd_rw_tris(); 
00D9:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00DA:  BCF    03.5
00DB:  BCF    09.1
00DC:  BSF    03.5
00DD:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01A1:  MOVF   78,W
01A2:  MOVWF  3E
01A3:  BTFSS  3E.7
01A4:  GOTO   1A8
01A5:  BSF    03.5
01A6:  BCF    03.6
01A7:  GOTO   0DE
....................    lcd_output_rs(address); 
01A8:  MOVF   3C,F
01A9:  BTFSS  03.2
01AA:  GOTO   1AF
01AB:  BCF    03.6
01AC:  BCF    09.1
01AD:  GOTO   1B1
01AE:  BSF    03.6
01AF:  BCF    03.6
01B0:  BSF    09.1
01B1:  BSF    03.5
01B2:  BCF    09.1
....................    delay_cycles(1); 
01B3:  NOP
....................    lcd_output_rw(0); 
01B4:  BCF    03.5
01B5:  BCF    09.2
01B6:  BSF    03.5
01B7:  BCF    09.2
....................    delay_cycles(1); 
01B8:  NOP
....................    lcd_output_enable(0); 
01B9:  BCF    03.5
01BA:  BCF    09.0
01BB:  BSF    03.5
01BC:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01BD:  BCF    03.5
01BE:  BSF    03.6
01BF:  SWAPF  3D,W
01C0:  MOVWF  3E
01C1:  MOVLW  0F
01C2:  ANDWF  3E,F
01C3:  MOVF   3E,W
01C4:  MOVWF  3F
01C5:  BCF    03.6
01C6:  CALL   08E
....................    lcd_send_nibble(n & 0xf); 
01C7:  BSF    03.6
01C8:  MOVF   3D,W
01C9:  ANDLW  0F
01CA:  MOVWF  3E
01CB:  MOVWF  3F
01CC:  BCF    03.6
01CD:  CALL   08E
01CE:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
*
02E9:  MOVLW  28
02EA:  BSF    03.5
02EB:  MOVWF  6B
02EC:  MOVLW  0C
02ED:  MOVWF  6C
02EE:  MOVLW  01
02EF:  MOVWF  6D
02F0:  MOVLW  06
02F1:  MOVWF  6E
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
02F2:  BCF    03.5
02F3:  BCF    09.0
02F4:  BSF    03.5
02F5:  BCF    09.0
....................    lcd_output_rs(0); 
02F6:  BCF    03.5
02F7:  BCF    09.1
02F8:  BSF    03.5
02F9:  BCF    09.1
....................    lcd_output_rw(0); 
02FA:  BCF    03.5
02FB:  BCF    09.2
02FC:  BSF    03.5
02FD:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
02FE:  BCF    03.5
02FF:  BCF    32.0
0300:  MOVF   32,W
0301:  BSF    03.5
0302:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0303:  BCF    03.5
0304:  BCF    32.1
0305:  MOVF   32,W
0306:  BSF    03.5
0307:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0308:  BCF    03.5
0309:  BCF    32.2
030A:  MOVF   32,W
030B:  BSF    03.5
030C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
030D:  BCF    03.5
030E:  BCF    32.3
030F:  MOVF   32,W
0310:  BSF    03.5
0311:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0312:  BCF    09.0
....................    lcd_rs_tris(); 
0313:  BCF    09.1
....................    lcd_rw_tris(); 
0314:  BCF    09.2
0315:  BCF    03.5
0316:  CLRF   2B
0317:  BTFSC  0B.7
0318:  BSF    2B.7
0319:  BCF    0B.7
....................  #endif 
....................      
....................    delay_ms(15); 
031A:  MOVLW  0F
031B:  BSF    03.6
031C:  MOVWF  38
031D:  BCF    03.6
031E:  CALL   1CF
031F:  BTFSC  2B.7
0320:  BSF    0B.7
....................    for(i=1;i<=3;++i) 
0321:  MOVLW  01
0322:  BSF    03.5
0323:  MOVWF  6A
0324:  MOVF   6A,W
0325:  SUBLW  03
0326:  BTFSS  03.0
0327:  GOTO   342
0328:  BCF    03.5
0329:  CLRF   2B
032A:  BTFSC  0B.7
032B:  BSF    2B.7
032C:  BCF    0B.7
....................    { 
....................        lcd_send_nibble(3); 
032D:  MOVLW  03
032E:  BSF    03.6
032F:  MOVWF  3F
0330:  BCF    03.6
0331:  CALL   08E
0332:  BTFSC  2B.7
0333:  BSF    0B.7
0334:  CLRF   2B
0335:  BTFSC  0B.7
0336:  BSF    2B.7
0337:  BCF    0B.7
....................        delay_ms(5); 
0338:  MOVLW  05
0339:  BSF    03.6
033A:  MOVWF  38
033B:  BCF    03.6
033C:  CALL   1CF
033D:  BTFSC  2B.7
033E:  BSF    0B.7
033F:  BSF    03.5
0340:  INCF   6A,F
0341:  GOTO   324
0342:  BCF    03.5
0343:  CLRF   2B
0344:  BTFSC  0B.7
0345:  BSF    2B.7
0346:  BCF    0B.7
....................    } 
....................     
....................    lcd_send_nibble(2); 
0347:  MOVLW  02
0348:  BSF    03.6
0349:  MOVWF  3F
034A:  BCF    03.6
034B:  CALL   08E
034C:  BTFSC  2B.7
034D:  BSF    0B.7
034E:  CLRF   2B
034F:  BTFSC  0B.7
0350:  BSF    2B.7
0351:  BCF    0B.7
....................    delay_ms(5); 
0352:  MOVLW  05
0353:  BSF    03.6
0354:  MOVWF  38
0355:  BCF    03.6
0356:  CALL   1CF
0357:  BTFSC  2B.7
0358:  BSF    0B.7
....................    for(i=0;i<=3;++i) 
0359:  BSF    03.5
035A:  CLRF   6A
035B:  MOVF   6A,W
035C:  SUBLW  03
035D:  BTFSS  03.0
035E:  GOTO   379
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
035F:  MOVLW  EB
0360:  ADDWF  6A,W
0361:  MOVWF  04
0362:  BCF    03.7
0363:  MOVF   00,W
0364:  MOVWF  6F
0365:  BCF    03.5
0366:  CLRF   2B
0367:  BTFSC  0B.7
0368:  BSF    2B.7
0369:  BCF    0B.7
036A:  BSF    03.6
036B:  CLRF   3C
036C:  BSF    03.5
036D:  BCF    03.6
036E:  MOVF   6F,W
036F:  BCF    03.5
0370:  BSF    03.6
0371:  MOVWF  3D
0372:  BCF    03.6
0373:  CALL   0D6
0374:  BTFSC  2B.7
0375:  BSF    0B.7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0376:  BSF    03.5
0377:  INCF   6A,F
0378:  GOTO   35B
0379:  BCF    03.5
037A:  BSF    0A.3
037B:  BCF    0A.4
037C:  GOTO   258 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01F7:  DECFSZ 39,W
01F8:  GOTO   1FA
01F9:  GOTO   1FD
*
021B:  DECFSZ 39,W
021C:  GOTO   21E
021D:  GOTO   221
*
0246:  DECFSZ 39,W
0247:  GOTO   249
0248:  GOTO   24C
*
0838:  DECFSZ 39,W
0839:  GOTO   03B
083A:  GOTO   03E
*
08B4:  DECFSZ 39,W
08B5:  GOTO   0B7
08B6:  GOTO   0BA
*
0910:  DECFSZ 39,W
0911:  GOTO   113
0912:  GOTO   116
*
0A98:  DECFSZ 39,W
0A99:  GOTO   29B
0A9A:  GOTO   29E
....................       address=LCD_LINE_TWO; 
*
01FA:  MOVLW  40
01FB:  MOVWF  3A
01FC:  GOTO   1FE
*
021E:  MOVLW  40
021F:  MOVWF  3A
0220:  GOTO   222
*
0249:  MOVLW  40
024A:  MOVWF  3A
024B:  GOTO   24D
*
083B:  MOVLW  40
083C:  MOVWF  3A
083D:  GOTO   03F
*
08B7:  MOVLW  40
08B8:  MOVWF  3A
08B9:  GOTO   0BB
*
0913:  MOVLW  40
0914:  MOVWF  3A
0915:  GOTO   117
*
0A9B:  MOVLW  40
0A9C:  MOVWF  3A
0A9D:  GOTO   29F
....................    else 
....................       address=0; 
*
01FD:  CLRF   3A
*
0221:  CLRF   3A
*
024C:  CLRF   3A
*
083E:  CLRF   3A
*
08BA:  CLRF   3A
*
0916:  CLRF   3A
*
0A9E:  CLRF   3A
....................       
....................    address+=x-1; 
*
01FE:  MOVLW  01
01FF:  SUBWF  38,W
0200:  ADDWF  3A,F
*
0222:  MOVLW  01
0223:  SUBWF  38,W
0224:  ADDWF  3A,F
*
024D:  MOVLW  01
024E:  SUBWF  38,W
024F:  ADDWF  3A,F
*
083F:  MOVLW  01
0840:  SUBWF  38,W
0841:  ADDWF  3A,F
*
08BB:  MOVLW  01
08BC:  SUBWF  38,W
08BD:  ADDWF  3A,F
*
0917:  MOVLW  01
0918:  SUBWF  38,W
0919:  ADDWF  3A,F
*
0A9F:  MOVLW  01
0AA0:  SUBWF  38,W
0AA1:  ADDWF  3A,F
....................    lcd_send_byte(0,0x80|address); 
*
0201:  MOVF   3A,W
0202:  IORLW  80
0203:  MOVWF  3B
0204:  CLRF   3C
0205:  MOVF   3B,W
0206:  MOVWF  3D
0207:  BCF    03.6
0208:  CALL   0D6
*
0225:  MOVF   3A,W
0226:  IORLW  80
0227:  MOVWF  3B
0228:  CLRF   3C
0229:  MOVF   3B,W
022A:  MOVWF  3D
022B:  BCF    03.6
022C:  CALL   0D6
*
0250:  MOVF   3A,W
0251:  IORLW  80
0252:  MOVWF  3B
0253:  CLRF   3C
0254:  MOVF   3B,W
0255:  MOVWF  3D
0256:  BCF    03.6
0257:  CALL   0D6
*
0842:  MOVF   3A,W
0843:  IORLW  80
0844:  MOVWF  3B
0845:  CLRF   3C
0846:  MOVF   3B,W
0847:  MOVWF  3D
0848:  BCF    0A.3
0849:  BCF    03.6
084A:  CALL   0D6
084B:  BSF    0A.3
084C:  CLRF   2B
084D:  BTFSC  0B.7
084E:  BSF    2B.7
084F:  BCF    0B.7
*
08BE:  MOVF   3A,W
08BF:  IORLW  80
08C0:  MOVWF  3B
08C1:  CLRF   3C
08C2:  MOVF   3B,W
08C3:  MOVWF  3D
08C4:  BCF    0A.3
08C5:  BCF    03.6
08C6:  CALL   0D6
08C7:  BSF    0A.3
08C8:  CLRF   2B
08C9:  BTFSC  0B.7
08CA:  BSF    2B.7
08CB:  BCF    0B.7
*
091A:  MOVF   3A,W
091B:  IORLW  80
091C:  MOVWF  3B
091D:  CLRF   3C
091E:  MOVF   3B,W
091F:  MOVWF  3D
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   0D6
0923:  BSF    0A.3
0924:  CLRF   2B
0925:  BTFSC  0B.7
0926:  BSF    2B.7
0927:  BCF    0B.7
*
0AA2:  MOVF   3A,W
0AA3:  IORLW  80
0AA4:  MOVWF  3B
0AA5:  CLRF   3C
0AA6:  MOVF   3B,W
0AA7:  MOVWF  3D
0AA8:  BCF    0A.3
0AA9:  BCF    03.6
0AAA:  CALL   0D6
0AAB:  BSF    0A.3
0AAC:  CLRF   2B
0AAD:  BTFSC  0B.7
0AAE:  BSF    2B.7
0AAF:  BCF    0B.7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
01E3:  BSF    03.6
01E4:  MOVF   37,W
01E5:  XORLW  07
01E6:  BCF    03.6
01E7:  BTFSC  03.2
01E8:  GOTO   1F3
01E9:  XORLW  0B
01EA:  BTFSC  03.2
01EB:  GOTO   20A
01EC:  XORLW  06
01ED:  BTFSC  03.2
01EE:  GOTO   216
01EF:  XORLW  02
01F0:  BTFSC  03.2
01F1:  GOTO   22E
01F2:  GOTO   235
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01F3:  MOVLW  01
01F4:  BSF    03.6
01F5:  MOVWF  38
01F6:  MOVWF  39
*
0209:  GOTO   23C
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
020A:  BSF    03.6
020B:  CLRF   3C
020C:  MOVLW  01
020D:  MOVWF  3D
020E:  BCF    03.6
020F:  CALL   0D6
....................                      delay_ms(2); 
0210:  MOVLW  02
0211:  BSF    03.6
0212:  MOVWF  38
0213:  BCF    03.6
0214:  CALL   1CF
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0215:  GOTO   23C
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0216:  MOVLW  01
0217:  BSF    03.6
0218:  MOVWF  38
0219:  MOVLW  02
021A:  MOVWF  39
*
022D:  GOTO   23C
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
022E:  BSF    03.6
022F:  CLRF   3C
0230:  MOVLW  10
0231:  MOVWF  3D
0232:  BCF    03.6
0233:  CALL   0D6
0234:  GOTO   23C
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0235:  MOVLW  01
0236:  BSF    03.6
0237:  MOVWF  3C
0238:  MOVF   37,W
0239:  MOVWF  3D
023A:  BCF    03.6
023B:  CALL   0D6
....................      #endif 
....................    } 
023C:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
....................  
.................... UNSIGNED INT8 CONFIG_FUN=0, CONFIG_STT=0, ID_NODE = 0; 
.................... INT1 TT_CONFIG=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
0999:  CLRF   3D
.................... INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
099A:  CLRF   3E
.................... //INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... INT8 DATA1 = 2; 
.................... CHAR *NHAN1[], *NHAN[]="HELLO"; 
099B:  MOVLW  48
099C:  MOVWF  44
099D:  MOVLW  45
099E:  MOVWF  45
099F:  MOVLW  4C
09A0:  MOVWF  46
09A1:  MOVWF  47
09A2:  MOVLW  4F
09A3:  MOVWF  48
09A4:  CLRF   49
09A5:  CLRF   43
09A6:  MOVLW  44
09A7:  MOVWF  42
.................... CHAR *PACKAGE[]={"S","ID", "COMMAND" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
09A8:  MOVLW  53
09A9:  BSF    03.5
09AA:  MOVWF  20
09AB:  CLRF   21
09AC:  MOVLW  49
09AD:  MOVWF  22
09AE:  MOVLW  44
09AF:  MOVWF  23
09B0:  CLRF   24
09B1:  MOVLW  43
09B2:  MOVWF  25
09B3:  MOVLW  4F
09B4:  MOVWF  26
09B5:  MOVLW  4D
09B6:  MOVWF  27
09B7:  MOVWF  28
09B8:  MOVLW  41
09B9:  MOVWF  29
09BA:  MOVLW  4E
09BB:  MOVWF  2A
09BC:  MOVLW  44
09BD:  MOVWF  2B
09BE:  CLRF   2C
09BF:  MOVLW  4C
09C0:  MOVWF  2D
09C1:  MOVLW  45
09C2:  MOVWF  2E
09C3:  MOVLW  4E
09C4:  MOVWF  2F
09C5:  MOVLW  47
09C6:  MOVWF  30
09C7:  MOVLW  48
09C8:  MOVWF  31
09C9:  MOVLW  54
09CA:  MOVWF  32
09CB:  CLRF   33
09CC:  MOVLW  44
09CD:  MOVWF  34
09CE:  MOVLW  41
09CF:  MOVWF  35
09D0:  MOVLW  54
09D1:  MOVWF  36
09D2:  MOVLW  41
09D3:  MOVWF  37
09D4:  MOVLW  31
09D5:  MOVWF  38
09D6:  CLRF   39
09D7:  MOVLW  44
09D8:  MOVWF  3A
09D9:  MOVLW  41
09DA:  MOVWF  3B
09DB:  MOVLW  54
09DC:  MOVWF  3C
09DD:  MOVLW  41
09DE:  MOVWF  3D
09DF:  MOVLW  32
09E0:  MOVWF  3E
09E1:  CLRF   3F
09E2:  MOVLW  43
09E3:  MOVWF  40
09E4:  MOVLW  48
09E5:  MOVWF  41
09E6:  MOVLW  45
09E7:  MOVWF  42
09E8:  MOVLW  43
09E9:  MOVWF  43
09EA:  MOVLW  4B
09EB:  MOVWF  44
09EC:  MOVLW  53
09ED:  MOVWF  45
09EE:  MOVLW  55
09EF:  MOVWF  46
09F0:  MOVLW  4D
09F1:  MOVWF  47
09F2:  CLRF   48
09F3:  MOVLW  23
09F4:  MOVWF  49
09F5:  CLRF   4A
09F6:  BCF    03.5
09F7:  CLRF   4B
09F8:  MOVLW  A0
09F9:  MOVWF  4A
09FA:  CLRF   4D
09FB:  MOVLW  A2
09FC:  MOVWF  4C
09FD:  CLRF   4F
09FE:  MOVLW  A5
09FF:  MOVWF  4E
0A00:  CLRF   51
0A01:  MOVLW  AD
0A02:  MOVWF  50
0A03:  CLRF   53
0A04:  MOVLW  B4
0A05:  MOVWF  52
0A06:  CLRF   55
0A07:  MOVLW  BA
0A08:  MOVWF  54
0A09:  CLRF   57
0A0A:  MOVLW  C0
0A0B:  MOVWF  56
0A0C:  CLRF   59
0A0D:  MOVLW  C9
0A0E:  MOVWF  58
.................... CHAR NHIETDO1[]="27"; 
0A0F:  MOVLW  32
0A10:  MOVWF  5A
0A11:  MOVLW  37
0A12:  MOVWF  5B
0A13:  CLRF   5C
.................... CHAR NHIETDO2[]="27"; 
0A14:  MOVLW  32
0A15:  MOVWF  5D
0A16:  MOVLW  37
0A17:  MOVWF  5E
0A18:  CLRF   5F
.................... char id_[]="0"; 
0A19:  MOVLW  30
0A1A:  MOVWF  60
0A1B:  CLRF   61
.................... CHAR RCV[]="RECEIVED"; 
0A1C:  MOVLW  52
0A1D:  MOVWF  62
0A1E:  MOVLW  45
0A1F:  MOVWF  63
0A20:  MOVLW  43
0A21:  MOVWF  64
0A22:  MOVLW  45
0A23:  MOVWF  65
0A24:  MOVLW  49
0A25:  MOVWF  66
0A26:  MOVLW  56
0A27:  MOVWF  67
0A28:  MOVLW  45
0A29:  MOVWF  68
0A2A:  MOVLW  44
0A2B:  MOVWF  69
0A2C:  CLRF   6A
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;    
.................... //--------------------------------------------------------------------// 
.................... #INT_RDA 
.................... VOID NGAT() 
.................... { 
....................    KYTU[VT] = GETC (); 
*
0062:  MOVLW  CB
0063:  ADDWF  6B,W
0064:  MOVWF  04
0065:  BCF    03.7
0066:  BTFSS  0C.5
0067:  GOTO   066
0068:  MOVF   1A,W
0069:  MOVWF  00
....................  
....................    IF (KYTU[VT] == id_[0]) 
006A:  MOVLW  CB
006B:  ADDWF  6B,W
006C:  MOVWF  04
006D:  BCF    03.7
006E:  MOVF   60,W
006F:  SUBWF  00,W
0070:  BTFSS  03.2
0071:  GOTO   074
....................    { 
....................       TTNHAN = 1; 
0072:  MOVLW  01
0073:  MOVWF  6C
....................    } 
....................  
....................    IF (KYTU[VT] == '.') 
0074:  MOVLW  CB
0075:  ADDWF  6B,W
0076:  MOVWF  04
0077:  BCF    03.7
0078:  MOVF   00,W
0079:  SUBLW  2E
007A:  BTFSS  03.2
007B:  GOTO   085
....................    { 
....................        
....................       KYTU[VT] = '\0'; 
007C:  MOVLW  CB
007D:  ADDWF  6B,W
007E:  MOVWF  04
007F:  BCF    03.7
0080:  CLRF   00
....................       VT = 0; 
0081:  CLRF   6B
....................       TTNHAN = 1; 
0082:  MOVLW  01
0083:  MOVWF  6C
....................    } 
0084:  GOTO   086
....................  
....................    ELSE 
....................    VT++; 
0085:  INCF   6B,F
0086:  BCF    0C.5
0087:  BCF    0A.3
0088:  BCF    0A.4
0089:  GOTO   031
.................... } 
....................  
.................... VOID CHON_ID() 
.................... { 
....................    TT_STT = 1; 
*
0806:  BSF    3C.2
....................  
....................    WHILE (TT_STT) 
0807:  BTFSS  3C.2
0808:  GOTO   095
....................    { 
....................       IF (input (BT3_PIN) == 0) //neu nut bam duoc bam 
0809:  BSF    03.5
080A:  BSF    06.3
080B:  BCF    03.5
080C:  BTFSC  06.3
080D:  GOTO   094
....................       { 
....................          ID_NODE ++; 
080E:  INCF   3B,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
080F:  MOVF   3B,W
0810:  SUBLW  0F
0811:  BTFSS  03.0
0812:  CLRF   3B
0813:  CLRF   2B
0814:  BTFSC  0B.7
0815:  BSF    2B.7
0816:  BCF    0B.7
....................          DELAY_MS (200) ; 
0817:  MOVLW  C8
0818:  BSF    03.6
0819:  MOVWF  38
081A:  BCF    0A.3
081B:  BCF    03.6
081C:  CALL   1CF
081D:  BSF    0A.3
081E:  BTFSC  2B.7
081F:  BSF    0B.7
....................          ITOA (ID_NODE, 10, id_); 
0820:  BSF    03.5
0821:  CLRF   6D
0822:  CLRF   6C
0823:  CLRF   6B
0824:  BCF    03.5
0825:  MOVF   3B,W
0826:  BSF    03.5
0827:  MOVWF  6A
0828:  MOVLW  0A
0829:  MOVWF  6E
082A:  BCF    03.5
082B:  BSF    03.6
082C:  CLRF   11
082D:  MOVLW  60
082E:  MOVWF  10
082F:  BCF    0A.3
0830:  BCF    03.6
0831:  CALL   504
0832:  BSF    0A.3
....................          LCD_GOTOXY (1, 2) ; 
0833:  MOVLW  01
0834:  BSF    03.6
0835:  MOVWF  38
0836:  MOVLW  02
0837:  MOVWF  39
....................          DELAY_MS (10); 
*
0850:  MOVLW  0A
0851:  BSF    03.6
0852:  MOVWF  38
0853:  BCF    0A.3
0854:  BCF    03.6
0855:  CALL   1CF
0856:  BSF    0A.3
0857:  BTFSC  2B.7
0858:  BSF    0B.7
....................          PRINTF (LCD_PUTC, id_); 
0859:  MOVLW  60
085A:  MOVWF  04
085B:  BCF    03.7
....................          DELAY_MS (1); 
*
0886:  MOVLW  01
0887:  BSF    03.6
0888:  MOVWF  38
0889:  BCF    0A.3
088A:  BCF    03.6
088B:  CALL   1CF
088C:  BSF    0A.3
088D:  BTFSC  2B.7
088E:  BSF    0B.7
....................          OUTPUT_TOGGLE (PIN_D0);          
088F:  BSF    03.5
0890:  BCF    08.0
0891:  MOVLW  01
0892:  BCF    03.5
0893:  XORWF  08,F
....................       } 
0894:  GOTO   007
....................    } 
....................  
....................     
....................  
....................    PACKAGE[1] = id_; 
0895:  CLRF   4D
0896:  MOVLW  60
0897:  MOVWF  4C
.................... } 
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    ID_NODE = 0; 
*
0900:  CLRF   3B
....................    //TT_SENSOR ={0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE ={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_FUN = 0; 
*
02DD:  BCF    3C.1
....................    TT_STT = 0; 
02DE:  BCF    3C.2
.................... } 
....................  
.................... VOID CONFIG_NODE() 
.................... { 
....................    SWITCH (CONFIG_FUN) 
*
0800:  MOVF   39,W
0801:  ADDLW  FC
0802:  BTFSC  03.0
0803:  GOTO   101
0804:  ADDLW  04
0805:  GOTO   104
....................    { 
....................       CASE 0: 
....................       CHON_ID () ; 
....................       BREAK; 
*
0898:  GOTO   101
....................  
....................       CASE 1: 
....................       //CONFIG_DEVICE () ; 
....................       NHAN="CASE1"; 
0899:  BSF    03.5
089A:  CLRF   6A
089B:  CLRF   6B
089C:  MOVLW  42
089D:  MOVWF  04
089E:  BCF    03.7
089F:  MOVF   6A,W
08A0:  ADDWF  04,F
08A1:  MOVF   6B,W
08A2:  BCF    0A.3
08A3:  BCF    03.5
08A4:  CALL   058
08A5:  BSF    0A.3
08A6:  MOVWF  00
08A7:  IORLW  00
08A8:  BTFSC  03.2
08A9:  GOTO   0AF
08AA:  BSF    03.5
08AB:  INCF   6B,F
08AC:  INCF   6A,F
08AD:  GOTO   09C
08AE:  BCF    03.5
....................       LCD_GOTOXY (10, 2) ; 
08AF:  MOVLW  0A
08B0:  BSF    03.6
08B1:  MOVWF  38
08B2:  MOVLW  02
08B3:  MOVWF  39
....................       DELAY_MS (10); 
*
08CC:  MOVLW  0A
08CD:  BSF    03.6
08CE:  MOVWF  38
08CF:  BCF    0A.3
08D0:  BCF    03.6
08D1:  CALL   1CF
08D2:  BSF    0A.3
08D3:  BTFSC  2B.7
08D4:  BSF    0B.7
....................       PRINTF (LCD_PUTC, NHAN); 
08D5:  MOVLW  42
08D6:  MOVWF  04
08D7:  BCF    03.7
....................       BREAK; 
*
08FE:  GOTO   101
....................  
....................       CASE 2: 
....................       //CONFIG_SENSOR () ; 
....................       BREAK; 
08FF:  GOTO   101
....................  
....................       CASE 3: 
....................       RESET_CONFIG () ; 
....................       BREAK; 
....................    } 
*
0901:  BSF    0A.3
0902:  BCF    0A.4
0903:  GOTO   2E4 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0A66:  BSF    3C.1
....................  
....................    WHILE (TT_FUN) 
0A67:  BTFSS  3C.1
0A68:  GOTO   2E3
....................    { 
....................       IF (input (BT2_PIN) == 0) //neu nut bam duoc bam 
0A69:  BSF    03.5
0A6A:  BSF    06.2
0A6B:  BCF    03.5
0A6C:  BTFSC  06.2
0A6D:  GOTO   2E2
....................       { 
....................          CONFIG_FUN ++; 
0A6E:  INCF   39,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0A6F:  MOVF   39,W
0A70:  SUBLW  03
0A71:  BTFSS  03.0
0A72:  CLRF   39
0A73:  CLRF   2B
0A74:  BTFSC  0B.7
0A75:  BSF    2B.7
0A76:  BCF    0B.7
....................          DELAY_MS (200) ; 
0A77:  MOVLW  C8
0A78:  BSF    03.6
0A79:  MOVWF  38
0A7A:  BCF    0A.3
0A7B:  BCF    03.6
0A7C:  CALL   1CF
0A7D:  BSF    0A.3
0A7E:  BTFSC  2B.7
0A7F:  BSF    0B.7
....................           
....................          //HIEN THI 
....................          ITOA (CONFIG_FUN, 10, id_); 
0A80:  BSF    03.5
0A81:  CLRF   6D
0A82:  CLRF   6C
0A83:  CLRF   6B
0A84:  BCF    03.5
0A85:  MOVF   39,W
0A86:  BSF    03.5
0A87:  MOVWF  6A
0A88:  MOVLW  0A
0A89:  MOVWF  6E
0A8A:  BCF    03.5
0A8B:  BSF    03.6
0A8C:  CLRF   11
0A8D:  MOVLW  60
0A8E:  MOVWF  10
0A8F:  BCF    0A.3
0A90:  BCF    03.6
0A91:  CALL   504
0A92:  BSF    0A.3
....................          LCD_GOTOXY (1, 2) ; 
0A93:  MOVLW  01
0A94:  BSF    03.6
0A95:  MOVWF  38
0A96:  MOVLW  02
0A97:  MOVWF  39
....................          DELAY_MS (10); 
*
0AB0:  MOVLW  0A
0AB1:  BSF    03.6
0AB2:  MOVWF  38
0AB3:  BCF    0A.3
0AB4:  BCF    03.6
0AB5:  CALL   1CF
0AB6:  BSF    0A.3
0AB7:  BTFSC  2B.7
0AB8:  BSF    0B.7
....................          PRINTF (LCD_PUTC, id_);          
0AB9:  MOVLW  60
0ABA:  MOVWF  04
0ABB:  BCF    03.7
....................       } 
*
0AE2:  GOTO   267
....................    } 
....................  
....................    CONFIG_NODE () ; 
0AE3:  GOTO   000
.................... } 
....................  
.................... VOID quet_phim() 
.................... { 
.................... /*   IF (TT_CONFIG) 
....................    { 
....................       IF (input (BT2_PIN) == 0) //neu nut bam duoc bam 
....................       { 
....................          LCD_GOTOXY (1, 1) ; 
....................          DELAY_MS (10); 
....................          PRINTF (LCD_PUTC, "BT2"); 
....................          BUTT_FUN () ; 
....................          CONFIG_NODE () ; 
....................       } 
....................  
....................        
....................       else IF (input (BT3_PIN) == 0) //neu nut bam duoc bam 
....................       { 
....................          LCD_GOTOXY (1, 1) ; 
....................          DELAY_MS (10); 
....................          PRINTF (LCD_PUTC, "BT3"); 
....................          //BUTT_TT () ; 
....................       } 
....................    } 
....................    */ 
....................  
....................     
....................    IF (input (BT1_PIN) == 0) //neu nut bam duoc bam 
*
023D:  BSF    03.5
023E:  BSF    06.1
023F:  BCF    03.5
0240:  BTFSC  06.1
0241:  GOTO   2E5
....................    { 
....................       LCD_GOTOXY (1, 1) ; 
0242:  MOVLW  01
0243:  BSF    03.6
0244:  MOVWF  38
0245:  MOVWF  39
....................       DELAY_MS (10); 
*
0258:  MOVLW  0A
0259:  BSF    03.6
025A:  MOVWF  38
025B:  BCF    03.6
025C:  CALL   1CF
....................       PRINTF (LCD_PUTC, "BT1"); 
025D:  MOVLW  42
025E:  BSF    03.6
025F:  MOVWF  37
0260:  BCF    03.6
0261:  CALL   1E3
0262:  MOVLW  54
0263:  BSF    03.6
0264:  MOVWF  37
0265:  BCF    03.6
0266:  CALL   1E3
0267:  MOVLW  31
0268:  BSF    03.6
0269:  MOVWF  37
026A:  BCF    03.6
026B:  CALL   1E3
....................       FOR (INT I = 0; I < 10; I++) 
026C:  BSF    03.6
026D:  CLRF   33
026E:  MOVF   33,W
026F:  SUBLW  09
0270:  BTFSS  03.0
0271:  GOTO   2E4
....................       { 
....................          IF (input (BT1_PIN) == 0) 
0272:  BSF    03.5
0273:  BCF    03.6
0274:  BSF    06.1
0275:  BCF    03.5
0276:  BTFSC  06.1
0277:  GOTO   2DD
....................          { 
....................             DELAY_MS (1000) ; 
0278:  MOVLW  04
0279:  BSF    03.6
027A:  MOVWF  34
027B:  MOVLW  FA
027C:  MOVWF  38
027D:  BCF    03.6
027E:  CALL   1CF
027F:  BSF    03.6
0280:  DECFSZ 34,F
0281:  GOTO   27B
....................  
....................             IF (I == 9) 
0282:  MOVF   33,W
0283:  SUBLW  09
0284:  BTFSS  03.2
0285:  GOTO   2DB
....................             { 
....................                //CONFIG NODE 
....................                TT_CONFIG = ~TT_CONFIG; 
0286:  MOVLW  01
0287:  BCF    03.6
0288:  XORWF  3C,F
....................                PRINTF (LCD_PUTC, "config"); 
0289:  MOVLW  8A
028A:  BSF    03.6
028B:  MOVWF  0D
028C:  MOVLW  00
028D:  MOVWF  0F
....................             } 
....................          } 
*
02DB:  GOTO   2E2
02DC:  BCF    03.6
....................  
....................          ELSE 
....................          { 
....................             BUTT_OKE () ; 
....................             I = 10; 
*
02DF:  MOVLW  0A
02E0:  BSF    03.6
02E1:  MOVWF  33
....................          } 
02E2:  INCF   33,F
02E3:  GOTO   26E
02E4:  BCF    03.6
....................       } 
....................    } 
....................  
.................... } 
....................  
.................... #INT_EXT 
....................  VOID ngat_ngoai  () 
....................  { 
....................     quet_phim (); 
02E5:  BCF    0B.1
02E6:  BCF    0A.3
02E7:  BCF    0A.4
02E8:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
090C:  MOVLW  01
090D:  BSF    03.6
090E:  MOVWF  38
090F:  MOVWF  39
....................     DELAY_MS (10); 
*
0928:  MOVLW  0A
0929:  BSF    03.6
092A:  MOVWF  38
092B:  BCF    0A.3
092C:  BCF    03.6
092D:  CALL   1CF
092E:  BSF    0A.3
092F:  BTFSC  2B.7
0930:  BSF    0B.7
....................     PRINTF (LCD_PUTC, KYTU); 
0931:  MOVLW  CB
0932:  MOVWF  04
0933:  BCF    03.7
....................     DELAY_MS (1); 
*
095E:  MOVLW  01
095F:  BSF    03.6
0960:  MOVWF  38
0961:  BCF    0A.3
0962:  BCF    03.6
0963:  CALL   1CF
0964:  BSF    0A.3
0965:  BTFSC  2B.7
0966:  BSF    0B.7
0967:  BSF    0A.3
0968:  BCF    0A.4
0969:  GOTO   361 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT kenh) 
....................  { 
....................     SET_ADC_CHANNEL (kenh); 
*
037D:  BSF    03.5
037E:  RLF    6A,W
037F:  MOVWF  77
0380:  RLF    77,F
0381:  MOVLW  FC
0382:  ANDWF  77,F
0383:  BCF    03.5
0384:  MOVF   1F,W
0385:  ANDLW  C3
0386:  IORWF  77,W
0387:  MOVWF  1F
....................     KQADC = 0; 
0388:  CLRF   34
0389:  CLRF   33
....................     FOR (INT I = 0; I < 100; I++) 
038A:  BSF    03.5
038B:  CLRF   6B
038C:  MOVF   6B,W
038D:  SUBLW  63
038E:  BTFSS  03.0
038F:  GOTO   3AA
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0390:  BCF    03.5
0391:  BSF    1F.1
0392:  BTFSC  1F.1
0393:  GOTO   392
0394:  BSF    03.5
0395:  MOVF   1E,W
0396:  BCF    03.5
0397:  ADDWF  33,F
0398:  MOVF   1E,W
0399:  BTFSC  03.0
039A:  INCFSZ 1E,W
039B:  ADDWF  34,F
039C:  CLRF   2B
039D:  BTFSC  0B.7
039E:  BSF    2B.7
039F:  BCF    0B.7
....................        DELAY_MS (1); 
03A0:  MOVLW  01
03A1:  BSF    03.6
03A2:  MOVWF  38
03A3:  BCF    03.6
03A4:  CALL   1CF
03A5:  BTFSC  2B.7
03A6:  BSF    0B.7
03A7:  BSF    03.5
03A8:  INCF   6B,F
03A9:  GOTO   38C
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
03AA:  BCF    03.5
03AB:  MOVF   34,W
03AC:  BSF    03.5
03AD:  MOVWF  6D
03AE:  BCF    03.5
03AF:  MOVF   33,W
03B0:  BSF    03.5
03B1:  MOVWF  6C
*
03CE:  MOVF   7A,W
03CF:  MOVWF  6F
03D0:  MOVF   79,W
03D1:  MOVWF  6E
03D2:  MOVF   78,W
03D3:  MOVWF  6D
03D4:  MOVF   77,W
03D5:  MOVWF  6C
03D6:  MOVLW  9A
03D7:  BCF    03.5
03D8:  BSF    03.6
03D9:  MOVWF  13
03DA:  MOVLW  99
03DB:  MOVWF  12
03DC:  MOVLW  4C
03DD:  MOVWF  11
03DE:  MOVLW  86
03DF:  MOVWF  10
*
04D2:  MOVF   7A,W
04D3:  BSF    03.5
04D4:  BCF    03.6
04D5:  MOVWF  6F
04D6:  MOVF   79,W
04D7:  MOVWF  6E
04D8:  MOVF   78,W
04D9:  MOVWF  6D
04DA:  MOVF   77,W
04DB:  MOVWF  6C
*
04FA:  MOVF   79,W
04FB:  BCF    03.5
04FC:  MOVWF  34
04FD:  MOVF   78,W
04FE:  MOVWF  33
....................     RETURN KQADC; 
04FF:  MOVF   33,W
0500:  MOVWF  78
0501:  BSF    0A.3
0502:  BCF    0A.4
0503:  GOTO   260 (RETURN)
....................  } 
....................  
....................  VOID chuong_trinh_con  () 
....................  { 
....................     for (INT i = 0; i <= 30; i++) 
*
0778:  BSF    03.5
0779:  CLRF   6A
077A:  MOVF   6A,W
077B:  SUBLW  1E
077C:  BTFSS  03.0
077D:  GOTO   790
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
077E:  BCF    08.1
077F:  MOVLW  02
0780:  BCF    03.5
0781:  XORWF  08,F
0782:  CLRF   2B
0783:  BTFSC  0B.7
0784:  BSF    2B.7
0785:  BCF    0B.7
....................        delay_ms (100); 
0786:  MOVLW  64
0787:  BSF    03.6
0788:  MOVWF  38
0789:  BCF    03.6
078A:  CALL   1CF
078B:  BTFSC  2B.7
078C:  BSF    0B.7
078D:  BSF    03.5
078E:  INCF   6A,F
078F:  GOTO   77A
....................     } 
0790:  BCF    03.5
0791:  BSF    0A.3
0792:  BCF    0A.4
0793:  GOTO   2E6 (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
096A:  MOVF   03,W
096B:  ANDLW  1F
096C:  MOVWF  03
096D:  BSF    03.5
096E:  BSF    03.6
096F:  BSF    07.3
0970:  MOVLW  08
0971:  BCF    03.6
0972:  MOVWF  19
0973:  MOVLW  02
0974:  MOVWF  1A
0975:  MOVLW  A6
0976:  MOVWF  18
0977:  MOVLW  90
0978:  BCF    03.5
0979:  MOVWF  18
097A:  MOVLW  FF
097B:  MOVWF  32
097C:  CLRF   39
097D:  CLRF   3A
097E:  CLRF   3B
097F:  BCF    3C.0
0980:  BCF    3C.1
0981:  BCF    3C.2
0982:  MOVLW  02
0983:  MOVWF  3F
0984:  CLRF   6B
0985:  CLRF   6C
0986:  BSF    03.5
0987:  BSF    03.6
0988:  MOVF   09,W
0989:  ANDLW  C0
098A:  MOVWF  09
098B:  BCF    03.6
098C:  BCF    1F.4
098D:  BCF    1F.5
098E:  MOVLW  00
098F:  BSF    03.6
0990:  MOVWF  08
0991:  BCF    03.5
0992:  CLRF   07
0993:  CLRF   08
0994:  CLRF   09
0995:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
0A2D:  MOVLW  F0
0A2E:  BSF    03.5
0A2F:  MOVWF  08
....................     SET_TRIS_B (0xFF); 
0A30:  MOVLW  FF
0A31:  MOVWF  06
....................     SET_TRIS_E (0); 
0A32:  BCF    09.0
0A33:  BCF    09.1
0A34:  BCF    09.2
0A35:  BCF    09.3
....................     SET_TRIS_C (0x80); 
0A36:  MOVLW  80
0A37:  MOVWF  07
0A38:  BCF    03.5
0A39:  MOVWF  32
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0A3A:  BSF    1F.6
0A3B:  BCF    1F.7
0A3C:  BSF    03.5
0A3D:  BSF    1F.7
0A3E:  BCF    03.5
0A3F:  BSF    1F.0
....................     SETUP_ADC_PORTS (sAN0); 
0A40:  BSF    03.5
0A41:  BSF    03.6
0A42:  MOVF   09,W
0A43:  ANDLW  C0
0A44:  MOVWF  09
0A45:  BCF    03.6
0A46:  BCF    1F.4
0A47:  BCF    1F.5
0A48:  MOVLW  01
0A49:  BSF    03.6
0A4A:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_RDA); 
0A4B:  BCF    03.6
0A4C:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0A4D:  MOVLW  C0
0A4E:  BCF    03.5
0A4F:  IORWF  0B,F
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0A50:  BSF    0B.5
....................     enable_interrupts (INT_EXT); //Cho phep ngat ngoai 
0A51:  BSF    0B.4
....................     enable_interrupts (INT_EXT_H2L); //Ngat xay ra khi co xung tu cao xuong thap 
0A52:  BSF    0B.4
0A53:  BSF    03.5
0A54:  BCF    01.6
....................     LCD_INIT (); // KHOI TAO LCD 
0A55:  BCF    0A.3
0A56:  BCF    03.5
0A57:  GOTO   2E9
0A58:  BSF    0A.3
....................     ID_NODE = 0; 
0A59:  CLRF   3B
....................     TT_CONFIG = 0; 
0A5A:  BCF    3C.0
....................  
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0A5B:  BSF    03.5
0A5C:  CLRF   6A
0A5D:  BCF    0A.3
0A5E:  BCF    03.5
0A5F:  GOTO   37D
0A60:  BSF    0A.3
0A61:  CLRF   36
0A62:  MOVF   78,W
0A63:  MOVWF  35
....................  
....................        IF (TT_CONFIG) 
0A64:  BTFSS  3C.0
0A65:  GOTO   2E4
....................        { 
....................           BUTT_FUN () ; 
....................        } 
....................  
....................        chuong_trinh_con (); 
*
0AE4:  BCF    0A.3
0AE5:  GOTO   778
0AE6:  BSF    0A.3
....................  
....................        IF (AN0 > 26) 
0AE7:  MOVF   36,F
0AE8:  BTFSS  03.2
0AE9:  GOTO   2EE
0AEA:  MOVF   35,W
0AEB:  SUBLW  1A
0AEC:  BTFSC  03.0
0AED:  GOTO   35D
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0AEE:  BSF    03.5
0AEF:  CLRF   6D
0AF0:  CLRF   6C
0AF1:  BCF    03.5
0AF2:  MOVF   36,W
0AF3:  BSF    03.5
0AF4:  MOVWF  6B
0AF5:  BCF    03.5
0AF6:  MOVF   35,W
0AF7:  BSF    03.5
0AF8:  MOVWF  6A
0AF9:  MOVLW  0A
0AFA:  MOVWF  6E
0AFB:  BCF    03.5
0AFC:  BSF    03.6
0AFD:  CLRF   11
0AFE:  MOVLW  5A
0AFF:  MOVWF  10
0B00:  BCF    0A.3
0B01:  BCF    03.6
0B02:  CALL   504
0B03:  BSF    0A.3
....................           PACKAGE[4] = NHIETDO1; 
0B04:  CLRF   53
0B05:  MOVLW  5A
0B06:  MOVWF  52
....................           ITOA (AN1, 10, NHIETDO2); 
0B07:  BSF    03.5
0B08:  CLRF   6D
0B09:  CLRF   6C
0B0A:  BCF    03.5
0B0B:  MOVF   38,W
0B0C:  BSF    03.5
0B0D:  MOVWF  6B
0B0E:  BCF    03.5
0B0F:  MOVF   37,W
0B10:  BSF    03.5
0B11:  MOVWF  6A
0B12:  MOVLW  0A
0B13:  MOVWF  6E
0B14:  BCF    03.5
0B15:  BSF    03.6
0B16:  CLRF   11
0B17:  MOVLW  5D
0B18:  MOVWF  10
0B19:  BCF    0A.3
0B1A:  BCF    03.6
0B1B:  CALL   504
0B1C:  BSF    0A.3
....................           PACKAGE[5] = NHIETDO2; 
0B1D:  CLRF   55
0B1E:  MOVLW  5D
0B1F:  MOVWF  54
....................            
....................           for (INT i = 0; i < 8; i++) 
0B20:  BSF    03.5
0B21:  CLRF   69
0B22:  MOVF   69,W
0B23:  SUBLW  07
0B24:  BTFSS  03.0
0B25:  GOTO   349
....................           { 
....................              PRINTF (PACKAGE[i]); 
0B26:  BCF    03.0
0B27:  RLF    69,W
0B28:  ADDLW  4A
0B29:  MOVWF  04
0B2A:  BCF    03.7
0B2B:  INCF   04,F
0B2C:  MOVF   00,W
0B2D:  MOVWF  6B
0B2E:  DECF   04,F
0B2F:  MOVF   00,W
0B30:  MOVWF  6A
0B31:  MOVWF  04
0B32:  BCF    03.7
0B33:  BTFSC  6B.0
0B34:  BSF    03.7
0B35:  BCF    0A.3
0B36:  BCF    03.5
0B37:  GOTO   794
0B38:  BSF    0A.3
0B39:  CLRF   2B
0B3A:  BTFSC  0B.7
0B3B:  BSF    2B.7
0B3C:  BCF    0B.7
....................              DELAY_MS (1); 
0B3D:  MOVLW  01
0B3E:  BSF    03.6
0B3F:  MOVWF  38
0B40:  BCF    0A.3
0B41:  BCF    03.6
0B42:  CALL   1CF
0B43:  BSF    0A.3
0B44:  BTFSC  2B.7
0B45:  BSF    0B.7
0B46:  BSF    03.5
0B47:  INCF   69,F
0B48:  GOTO   322
....................           } 
....................  
....................            
....................           DELAY_MS (1000); 
0B49:  MOVLW  04
0B4A:  MOVWF  6A
0B4B:  BCF    03.5
0B4C:  CLRF   2B
0B4D:  BTFSC  0B.7
0B4E:  BSF    2B.7
0B4F:  BCF    0B.7
0B50:  MOVLW  FA
0B51:  BSF    03.6
0B52:  MOVWF  38
0B53:  BCF    0A.3
0B54:  BCF    03.6
0B55:  CALL   1CF
0B56:  BSF    0A.3
0B57:  BTFSC  2B.7
0B58:  BSF    0B.7
0B59:  BSF    03.5
0B5A:  DECFSZ 6A,F
0B5B:  GOTO   34B
0B5C:  BCF    03.5
....................        } 
....................  
....................        IF (TTNHAN == 1) 
0B5D:  DECFSZ 6C,W
0B5E:  GOTO   375
....................        { 
....................            
....................           TTNHAN = 0; 
0B5F:  CLRF   6C
....................           XUATLCD (); 
0B60:  GOTO   10C
....................            
....................           OUTPUT_TOGGLE (PIN_D0); 
0B61:  BSF    03.5
0B62:  BCF    08.0
0B63:  MOVLW  01
0B64:  BCF    03.5
0B65:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D1); 
0B66:  BSF    03.5
0B67:  BCF    08.1
0B68:  MOVLW  02
0B69:  BCF    03.5
0B6A:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D2); 
0B6B:  BSF    03.5
0B6C:  BCF    08.2
0B6D:  MOVLW  04
0B6E:  BCF    03.5
0B6F:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D3); 
0B70:  BSF    03.5
0B71:  BCF    08.3
0B72:  MOVLW  08
0B73:  BCF    03.5
0B74:  XORWF  08,F
....................        } 
0B75:  GOTO   25B
....................     } 
....................  } 
....................  
0B76:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
