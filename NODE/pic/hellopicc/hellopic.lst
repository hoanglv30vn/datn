CCS PCM C Compiler, Version 5.015, 5967               15-Oct-21 15:54

               Filename:   E:\DATN\NODE\pic\hellopicc\hellopic.lst

               ROM used:   2802 words (34%)
                           Largest free fragment is 2048
               RAM used:   187 (51%) at main() level
                           227 (62%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   13A
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   09C
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   065
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  BCF    0A.0
005E:  BCF    0A.1
005F:  BCF    0A.2
0060:  ADDWF  02,F
0061:  RETLW  20
0062:  RETLW  2A
0063:  RETLW  20
0064:  RETLW  00
*
0083:  DATA 49,22
0084:  DATA 3A,10
0085:  DATA 00,00
0086:  DATA C4,22
0087:  DATA D6,24
0088:  DATA C3,22
0089:  DATA 3A,10
008A:  DATA 00,01
008B:  DATA C3,20
008C:  DATA D3,22
008D:  DATA 31,00
008E:  DATA C3,27
008F:  DATA 4E,23
0090:  DATA C9,23
0091:  DATA 00,01
0092:  DATA C3,20
0093:  DATA D3,22
0094:  DATA 3A,10
0095:  DATA 00,00
0096:  DATA C3,27
0097:  DATA 4E,23
0098:  DATA C9,23
0099:  DATA 20,22
009A:  DATA 4F,27
009B:  DATA 45,00
*
0274:  MOVLW  8E
0275:  MOVWF  77
0276:  MOVF   32,W
0277:  MOVWF  78
0278:  MOVF   31,W
0279:  MOVWF  79
027A:  CLRF   7A
027B:  MOVF   78,F
027C:  BTFSS  03.2
027D:  GOTO   288
027E:  MOVF   79,W
027F:  MOVWF  78
0280:  CLRF   79
0281:  MOVLW  08
0282:  SUBWF  77,F
0283:  MOVF   78,F
0284:  BTFSS  03.2
0285:  GOTO   288
0286:  CLRF   77
0287:  GOTO   290
0288:  BCF    03.0
0289:  BTFSC  78.7
028A:  GOTO   28F
028B:  RLF    79,F
028C:  RLF    78,F
028D:  DECF   77,F
028E:  GOTO   288
028F:  BCF    78.7
*
02A0:  MOVF   31,W
02A1:  BTFSC  03.2
02A2:  GOTO   365
02A3:  MOVWF  3D
02A4:  MOVF   35,W
02A5:  BTFSC  03.2
02A6:  GOTO   365
02A7:  SUBWF  3D,F
02A8:  BTFSS  03.0
02A9:  GOTO   2AF
02AA:  MOVLW  7F
02AB:  ADDWF  3D,F
02AC:  BTFSC  03.0
02AD:  GOTO   365
02AE:  GOTO   2B5
02AF:  MOVLW  81
02B0:  SUBWF  3D,F
02B1:  BTFSS  03.0
02B2:  GOTO   365
02B3:  BTFSC  03.2
02B4:  GOTO   365
02B5:  MOVF   3D,W
02B6:  MOVWF  77
02B7:  CLRF   78
02B8:  CLRF   79
02B9:  CLRF   7A
02BA:  CLRF   3C
02BB:  MOVF   32,W
02BC:  MOVWF  3B
02BD:  BSF    3B.7
02BE:  MOVF   33,W
02BF:  MOVWF  3A
02C0:  MOVF   34,W
02C1:  MOVWF  39
02C2:  MOVLW  19
02C3:  MOVWF  3D
02C4:  MOVF   38,W
02C5:  SUBWF  39,F
02C6:  BTFSC  03.0
02C7:  GOTO   2D8
02C8:  MOVLW  01
02C9:  SUBWF  3A,F
02CA:  BTFSC  03.0
02CB:  GOTO   2D8
02CC:  SUBWF  3B,F
02CD:  BTFSC  03.0
02CE:  GOTO   2D8
02CF:  SUBWF  3C,F
02D0:  BTFSC  03.0
02D1:  GOTO   2D8
02D2:  INCF   3C,F
02D3:  INCF   3B,F
02D4:  INCF   3A,F
02D5:  MOVF   38,W
02D6:  ADDWF  39,F
02D7:  GOTO   30A
02D8:  MOVF   37,W
02D9:  SUBWF  3A,F
02DA:  BTFSC  03.0
02DB:  GOTO   2F3
02DC:  MOVLW  01
02DD:  SUBWF  3B,F
02DE:  BTFSC  03.0
02DF:  GOTO   2F3
02E0:  SUBWF  3C,F
02E1:  BTFSC  03.0
02E2:  GOTO   2F3
02E3:  INCF   3C,F
02E4:  INCF   3B,F
02E5:  MOVF   37,W
02E6:  ADDWF  3A,F
02E7:  MOVF   38,W
02E8:  ADDWF  39,F
02E9:  BTFSS  03.0
02EA:  GOTO   30A
02EB:  INCF   3A,F
02EC:  BTFSS  03.2
02ED:  GOTO   30A
02EE:  INCF   3B,F
02EF:  BTFSS  03.2
02F0:  GOTO   30A
02F1:  INCF   3C,F
02F2:  GOTO   30A
02F3:  MOVF   36,W
02F4:  IORLW  80
02F5:  SUBWF  3B,F
02F6:  BTFSC  03.0
02F7:  GOTO   309
02F8:  MOVLW  01
02F9:  SUBWF  3C,F
02FA:  BTFSC  03.0
02FB:  GOTO   309
02FC:  INCF   3C,F
02FD:  MOVF   36,W
02FE:  IORLW  80
02FF:  ADDWF  3B,F
0300:  MOVF   37,W
0301:  ADDWF  3A,F
0302:  BTFSS  03.0
0303:  GOTO   2E7
0304:  INCF   3B,F
0305:  BTFSS  03.2
0306:  GOTO   2E7
0307:  INCF   3C,F
0308:  GOTO   2E7
0309:  BSF    7A.0
030A:  DECFSZ 3D,F
030B:  GOTO   30D
030C:  GOTO   318
030D:  BCF    03.0
030E:  RLF    39,F
030F:  RLF    3A,F
0310:  RLF    3B,F
0311:  RLF    3C,F
0312:  BCF    03.0
0313:  RLF    7A,F
0314:  RLF    79,F
0315:  RLF    78,F
0316:  RLF    3E,F
0317:  GOTO   2C4
0318:  BTFSS  3E.0
0319:  GOTO   320
031A:  BCF    03.0
031B:  RRF    78,F
031C:  RRF    79,F
031D:  RRF    7A,F
031E:  RRF    3E,F
031F:  GOTO   323
0320:  DECF   77,F
0321:  BTFSC  03.2
0322:  GOTO   365
0323:  BTFSC  3E.7
0324:  GOTO   34C
0325:  BCF    03.0
0326:  RLF    39,F
0327:  RLF    3A,F
0328:  RLF    3B,F
0329:  RLF    3C,F
032A:  MOVF   38,W
032B:  SUBWF  39,F
032C:  BTFSC  03.0
032D:  GOTO   338
032E:  MOVLW  01
032F:  SUBWF  3A,F
0330:  BTFSC  03.0
0331:  GOTO   338
0332:  SUBWF  3B,F
0333:  BTFSC  03.0
0334:  GOTO   338
0335:  SUBWF  3C,F
0336:  BTFSS  03.0
0337:  GOTO   35B
0338:  MOVF   37,W
0339:  SUBWF  3A,F
033A:  BTFSC  03.0
033B:  GOTO   343
033C:  MOVLW  01
033D:  SUBWF  3B,F
033E:  BTFSC  03.0
033F:  GOTO   343
0340:  SUBWF  3C,F
0341:  BTFSS  03.0
0342:  GOTO   35B
0343:  MOVF   36,W
0344:  IORLW  80
0345:  SUBWF  3B,F
0346:  BTFSC  03.0
0347:  GOTO   34C
0348:  MOVLW  01
0349:  SUBWF  3C,F
034A:  BTFSS  03.0
034B:  GOTO   35B
034C:  INCF   7A,F
034D:  BTFSS  03.2
034E:  GOTO   35B
034F:  INCF   79,F
0350:  BTFSS  03.2
0351:  GOTO   35B
0352:  INCF   78,F
0353:  BTFSS  03.2
0354:  GOTO   35B
0355:  INCF   77,F
0356:  BTFSC  03.2
0357:  GOTO   365
0358:  RRF    78,F
0359:  RRF    79,F
035A:  RRF    7A,F
035B:  MOVF   32,W
035C:  MOVWF  3D
035D:  MOVF   36,W
035E:  XORWF  3D,F
035F:  BTFSS  3D.7
0360:  GOTO   363
0361:  BSF    78.7
0362:  GOTO   369
0363:  BCF    78.7
0364:  GOTO   369
0365:  CLRF   77
0366:  CLRF   78
0367:  CLRF   79
0368:  CLRF   7A
*
0371:  MOVLW  8E
0372:  MOVWF  77
0373:  MOVF   31,W
0374:  SUBWF  77,F
0375:  MOVF   32,W
0376:  MOVWF  79
0377:  MOVF   33,W
0378:  MOVWF  78
0379:  BSF    79.7
037A:  MOVF   77,F
037B:  BTFSC  03.2
037C:  GOTO   388
037D:  BCF    03.0
037E:  MOVF   79,F
037F:  BTFSS  03.2
0380:  GOTO   384
0381:  MOVF   78,F
0382:  BTFSC  03.2
0383:  GOTO   388
0384:  RRF    79,F
0385:  RRF    78,F
0386:  DECFSZ 77,F
0387:  GOTO   37D
0388:  BTFSS  32.7
0389:  GOTO   38F
038A:  COMF   78,F
038B:  COMF   79,F
038C:  INCF   78,F
038D:  BTFSC  03.2
038E:  INCF   79,F
*
03E7:  MOVF   0B,W
03E8:  BSF    03.6
03E9:  MOVWF  31
03EA:  BCF    03.6
03EB:  BCF    0B.7
03EC:  BSF    03.5
03ED:  BSF    03.6
03EE:  BSF    0C.7
03EF:  BSF    0C.0
03F0:  NOP
03F1:  NOP
03F2:  BCF    03.5
03F3:  BTFSS  31.7
03F4:  GOTO   3F8
03F5:  BCF    03.6
03F6:  BSF    0B.7
03F7:  BSF    03.6
03F8:  MOVF   0C,W
03F9:  ANDLW  7F
03FA:  BTFSC  03.2
03FB:  GOTO   435
03FC:  MOVWF  31
03FD:  MOVF   0D,W
03FE:  MOVWF  32
03FF:  MOVF   0F,W
0400:  MOVWF  33
0401:  MOVF   31,W
0402:  MOVWF  34
0403:  BCF    03.6
0404:  CALL   3AD
0405:  BSF    03.6
0406:  MOVF   32,W
0407:  MOVWF  0D
0408:  MOVF   33,W
0409:  MOVWF  0F
040A:  BCF    03.6
040B:  MOVF   0B,W
040C:  BSF    03.6
040D:  MOVWF  34
040E:  BCF    03.6
040F:  BCF    0B.7
0410:  BSF    03.5
0411:  BSF    03.6
0412:  BSF    0C.7
0413:  BSF    0C.0
0414:  NOP
0415:  NOP
0416:  BCF    03.5
0417:  BTFSS  34.7
0418:  GOTO   41C
0419:  BCF    03.6
041A:  BSF    0B.7
041B:  BSF    03.6
041C:  RLF    0C,W
041D:  RLF    0E,W
041E:  ANDLW  7F
041F:  BTFSC  03.2
0420:  GOTO   435
0421:  MOVWF  31
0422:  MOVF   0D,W
0423:  MOVWF  32
0424:  MOVF   0F,W
0425:  MOVWF  33
0426:  MOVF   31,W
0427:  MOVWF  34
0428:  BCF    03.6
0429:  CALL   3AD
042A:  BSF    03.6
042B:  MOVF   32,W
042C:  MOVWF  0D
042D:  MOVF   33,W
042E:  MOVWF  0F
042F:  INCF   0D,F
0430:  BTFSC  03.2
0431:  INCF   0F,F
0432:  BCF    03.6
0433:  GOTO   3E7
0434:  BSF    03.6
0435:  BCF    03.6
0436:  RETURN
0437:  BTFSC  03.1
0438:  GOTO   43C
0439:  MOVLW  50
043A:  MOVWF  04
043B:  BSF    03.7
043C:  BSF    03.6
043D:  MOVF   4B,W
043E:  XORWF  4F,W
043F:  ANDLW  80
0440:  MOVWF  55
0441:  BTFSS  4B.7
0442:  GOTO   44E
0443:  COMF   48,F
0444:  COMF   49,F
0445:  COMF   4A,F
0446:  COMF   4B,F
0447:  INCF   48,F
0448:  BTFSC  03.2
0449:  INCF   49,F
044A:  BTFSC  03.2
044B:  INCF   4A,F
044C:  BTFSC  03.2
044D:  INCF   4B,F
044E:  BTFSS  4F.7
044F:  GOTO   45B
0450:  COMF   4C,F
0451:  COMF   4D,F
0452:  COMF   4E,F
0453:  COMF   4F,F
0454:  INCF   4C,F
0455:  BTFSC  03.2
0456:  INCF   4D,F
0457:  BTFSC  03.2
0458:  INCF   4E,F
0459:  BTFSC  03.2
045A:  INCF   4F,F
045B:  CLRF   77
045C:  CLRF   78
045D:  CLRF   79
045E:  CLRF   7A
045F:  CLRF   50
0460:  CLRF   51
0461:  CLRF   52
0462:  CLRF   53
0463:  MOVF   4F,W
0464:  IORWF  4E,W
0465:  IORWF  4D,W
0466:  IORWF  4C,W
0467:  BTFSC  03.2
0468:  GOTO   499
0469:  MOVLW  20
046A:  MOVWF  54
046B:  BCF    03.0
046C:  RLF    48,F
046D:  RLF    49,F
046E:  RLF    4A,F
046F:  RLF    4B,F
0470:  RLF    50,F
0471:  RLF    51,F
0472:  RLF    52,F
0473:  RLF    53,F
0474:  MOVF   4F,W
0475:  SUBWF  53,W
0476:  BTFSS  03.2
0477:  GOTO   482
0478:  MOVF   4E,W
0479:  SUBWF  52,W
047A:  BTFSS  03.2
047B:  GOTO   482
047C:  MOVF   4D,W
047D:  SUBWF  51,W
047E:  BTFSS  03.2
047F:  GOTO   482
0480:  MOVF   4C,W
0481:  SUBWF  50,W
0482:  BTFSS  03.0
0483:  GOTO   493
0484:  MOVF   4C,W
0485:  SUBWF  50,F
0486:  MOVF   4D,W
0487:  BTFSS  03.0
0488:  INCFSZ 4D,W
0489:  SUBWF  51,F
048A:  MOVF   4E,W
048B:  BTFSS  03.0
048C:  INCFSZ 4E,W
048D:  SUBWF  52,F
048E:  MOVF   4F,W
048F:  BTFSS  03.0
0490:  INCFSZ 4F,W
0491:  SUBWF  53,F
0492:  BSF    03.0
0493:  RLF    77,F
0494:  RLF    78,F
0495:  RLF    79,F
0496:  RLF    7A,F
0497:  DECFSZ 54,F
0498:  GOTO   46B
0499:  BTFSS  55.7
049A:  GOTO   4A6
049B:  COMF   77,F
049C:  COMF   78,F
049D:  COMF   79,F
049E:  COMF   7A,F
049F:  INCF   77,F
04A0:  BTFSC  03.2
04A1:  INCF   78,F
04A2:  BTFSC  03.2
04A3:  INCF   79,F
04A4:  BTFSC  03.2
04A5:  INCF   7A,F
04A6:  MOVF   50,W
04A7:  MOVWF  00
04A8:  INCF   04,F
04A9:  MOVF   51,W
04AA:  MOVWF  00
04AB:  INCF   04,F
04AC:  MOVF   52,W
04AD:  MOVWF  00
04AE:  INCF   04,F
04AF:  MOVF   53,W
04B0:  MOVWF  00
04B1:  BCF    03.6
04B2:  RETURN
*
04CC:  MOVLW  20
04CD:  MOVWF  4C
04CE:  CLRF   48
04CF:  CLRF   49
04D0:  CLRF   4A
04D1:  CLRF   4B
04D2:  MOVF   43,W
04D3:  MOVWF  7A
04D4:  MOVF   42,W
04D5:  MOVWF  79
04D6:  MOVF   41,W
04D7:  MOVWF  78
04D8:  MOVF   40,W
04D9:  MOVWF  77
04DA:  BCF    03.0
04DB:  BTFSS  77.0
04DC:  GOTO   4EB
04DD:  MOVF   44,W
04DE:  ADDWF  48,F
04DF:  MOVF   45,W
04E0:  BTFSC  03.0
04E1:  INCFSZ 45,W
04E2:  ADDWF  49,F
04E3:  MOVF   46,W
04E4:  BTFSC  03.0
04E5:  INCFSZ 46,W
04E6:  ADDWF  4A,F
04E7:  MOVF   47,W
04E8:  BTFSC  03.0
04E9:  INCFSZ 47,W
04EA:  ADDWF  4B,F
04EB:  RRF    4B,F
04EC:  RRF    4A,F
04ED:  RRF    49,F
04EE:  RRF    48,F
04EF:  RRF    7A,F
04F0:  RRF    79,F
04F1:  RRF    78,F
04F2:  RRF    77,F
04F3:  DECFSZ 4C,F
04F4:  GOTO   4DA
*
05D3:  MOVF   00,F
05D4:  BTFSC  03.2
05D5:  GOTO   5EF
05D6:  BSF    03.6
05D7:  CLRF   32
05D8:  MOVF   04,W
05D9:  MOVWF  31
05DA:  BCF    32.0
05DB:  BTFSC  03.7
05DC:  BSF    32.0
05DD:  MOVF   00,W
05DE:  MOVWF  34
05DF:  BCF    03.6
05E0:  CALL   3AD
05E1:  BSF    03.6
05E2:  MOVF   31,W
05E3:  MOVWF  04
05E4:  BCF    03.7
05E5:  BTFSC  32.0
05E6:  BSF    03.7
05E7:  INCF   04,F
05E8:  BTFSS  03.2
05E9:  GOTO   5ED
05EA:  BCF    03.6
05EB:  INCF   05,F
05EC:  BSF    03.6
05ED:  BCF    03.6
05EE:  GOTO   5D3
05EF:  RETURN
05F0:  BSF    03.6
05F1:  MOVF   31,W
05F2:  ANDLW  07
05F3:  MOVWF  77
05F4:  RRF    31,W
05F5:  MOVWF  78
05F6:  RRF    78,F
05F7:  RRF    78,F
05F8:  MOVLW  1F
05F9:  ANDWF  78,F
05FA:  MOVF   78,W
05FB:  ADDWF  32,W
05FC:  MOVWF  04
05FD:  BCF    03.7
05FE:  BTFSC  33.0
05FF:  BSF    03.7
0600:  MOVF   00,W
0601:  MOVWF  78
0602:  INCF   77,F
0603:  GOTO   605
0604:  RRF    78,F
0605:  DECFSZ 77,F
0606:  GOTO   604
0607:  BCF    03.6
0608:  RETURN
0609:  BSF    03.6
060A:  MOVF   30,W
060B:  ANDLW  07
060C:  MOVWF  77
060D:  RRF    30,W
060E:  MOVWF  78
060F:  RRF    78,F
0610:  RRF    78,F
0611:  MOVLW  1F
0612:  ANDWF  78,F
0613:  MOVF   78,W
0614:  ADDWF  32,W
0615:  MOVWF  04
0616:  BCF    03.7
0617:  BTFSC  33.0
0618:  BSF    03.7
0619:  CLRF   78
061A:  INCF   78,F
061B:  INCF   77,F
061C:  GOTO   61E
061D:  RLF    78,F
061E:  DECFSZ 77,F
061F:  GOTO   61D
0620:  MOVF   31,F
0621:  BTFSC  03.2
0622:  GOTO   626
0623:  MOVF   78,W
0624:  IORWF  00,F
0625:  GOTO   629
0626:  COMF   78,F
0627:  MOVF   78,W
0628:  ANDWF  00,F
0629:  BCF    03.6
062A:  BCF    0A.3
062B:  BCF    0A.4
062C:  GOTO   726 (RETURN)
*
0770:  BSF    0A.0
0771:  BSF    0A.1
0772:  BSF    0A.2
0773:  ADDWF  02,F
0774:  GOTO   634
0775:  GOTO   689
0776:  GOTO   757
0777:  GOTO   76B
*
07D7:  MOVF   00,F
07D8:  BTFSC  03.2
07D9:  GOTO   7F4
07DA:  BSF    03.6
07DB:  CLRF   34
07DC:  MOVF   04,W
07DD:  MOVWF  33
07DE:  BCF    34.0
07DF:  BTFSC  03.7
07E0:  BSF    34.0
07E1:  MOVF   00,W
07E2:  BCF    03.6
07E3:  BTFSS  0C.4
07E4:  GOTO   7E3
07E5:  MOVWF  19
07E6:  BSF    03.6
07E7:  MOVF   33,W
07E8:  MOVWF  04
07E9:  BCF    03.7
07EA:  BTFSC  34.0
07EB:  BSF    03.7
07EC:  INCF   04,F
07ED:  BTFSS  03.2
07EE:  GOTO   7F2
07EF:  BCF    03.6
07F0:  INCF   05,F
07F1:  BSF    03.6
07F2:  BCF    03.6
07F3:  GOTO   7D7
07F4:  RETURN
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0800:  BSF    03.6
0801:  MOVF   32,W
0802:  MOVWF  36
0803:  MOVF   31,W
0804:  MOVWF  35
0805:  MOVF   36,W
0806:  MOVWF  7A
0807:  MOVF   35,W
0808:  MOVWF  04
0809:  BCF    03.7
080A:  BTFSC  7A.0
080B:  BSF    03.7
080C:  MOVF   00,F
080D:  BTFSC  03.2
080E:  GOTO   013
080F:  INCF   35,F
0810:  BTFSC  03.2
0811:  INCF   36,F
0812:  GOTO   005
....................    while(*s2 != '\0') 
0813:  MOVF   34,W
0814:  MOVWF  7A
0815:  MOVF   33,W
0816:  MOVWF  04
0817:  BCF    03.7
0818:  BTFSC  7A.0
0819:  BSF    03.7
081A:  MOVF   00,F
081B:  BTFSC  03.2
081C:  GOTO   036
....................    { 
....................       *s = *s2; 
081D:  MOVF   35,W
081E:  MOVWF  37
081F:  MOVF   36,W
0820:  MOVWF  38
0821:  MOVF   33,W
0822:  MOVWF  04
0823:  BCF    03.7
0824:  BTFSC  34.0
0825:  BSF    03.7
0826:  MOVF   00,W
0827:  MOVWF  39
0828:  MOVF   37,W
0829:  MOVWF  04
082A:  BCF    03.7
082B:  BTFSC  38.0
082C:  BSF    03.7
082D:  MOVF   39,W
082E:  MOVWF  00
....................       ++s; 
082F:  INCF   35,F
0830:  BTFSC  03.2
0831:  INCF   36,F
....................       ++s2; 
0832:  INCF   33,F
0833:  BTFSC  03.2
0834:  INCF   34,F
0835:  GOTO   013
....................    } 
....................  
....................    *s = '\0'; 
0836:  MOVF   35,W
0837:  MOVWF  04
0838:  BCF    03.7
0839:  BTFSC  36.0
083A:  BSF    03.7
083B:  CLRF   00
....................    return(s1); 
083C:  MOVF   31,W
083D:  MOVWF  78
083E:  MOVF   32,W
083F:  MOVWF  79
0840:  BCF    03.6
0841:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0965:  BCF    03.6
0966:  CLRF   2B
0967:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04B3:  BSF    03.6
04B4:  CLRF   3B
04B5:  CLRF   3A
04B6:  CLRF   39
04B7:  MOVLW  01
04B8:  MOVWF  38
04B9:  CLRF   3D
04BA:  CLRF   3E
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04BB:  BTFSS  34.7
04BC:  GOTO   4FD
....................          sign=1;        // Check for negative number 
04BD:  MOVLW  01
04BE:  MOVWF  3D
....................          num*=-1; 
04BF:  MOVF   34,W
04C0:  MOVWF  43
04C1:  MOVF   33,W
04C2:  MOVWF  42
04C3:  MOVF   32,W
04C4:  MOVWF  41
04C5:  MOVF   31,W
04C6:  MOVWF  40
04C7:  MOVLW  FF
04C8:  MOVWF  47
04C9:  MOVWF  46
04CA:  MOVWF  45
04CB:  MOVWF  44
*
04F5:  MOVF   7A,W
04F6:  MOVWF  34
04F7:  MOVF   79,W
04F8:  MOVWF  33
04F9:  MOVF   78,W
04FA:  MOVWF  32
04FB:  MOVF   77,W
04FC:  MOVWF  31
....................      } 
....................  
....................      while(temp>0) { 
04FD:  MOVF   38,F
04FE:  BTFSS  03.2
04FF:  GOTO   509
0500:  MOVF   39,F
0501:  BTFSS  03.2
0502:  GOTO   509
0503:  MOVF   3A,F
0504:  BTFSS  03.2
0505:  GOTO   509
0506:  MOVF   3B,F
0507:  BTFSC  03.2
0508:  GOTO   585
....................          temp=(num/base); 
0509:  BCF    03.1
050A:  MOVF   34,W
050B:  MOVWF  4B
050C:  MOVF   33,W
050D:  MOVWF  4A
050E:  MOVF   32,W
050F:  MOVWF  49
0510:  MOVF   31,W
0511:  MOVWF  48
0512:  CLRF   4F
0513:  CLRF   4E
0514:  CLRF   4D
0515:  MOVF   35,W
0516:  MOVWF  4C
0517:  BCF    03.6
0518:  CALL   437
0519:  MOVF   7A,W
051A:  BSF    03.6
051B:  MOVWF  3B
051C:  MOVF   79,W
051D:  MOVWF  3A
051E:  MOVF   78,W
051F:  MOVWF  39
0520:  MOVF   77,W
0521:  MOVWF  38
....................          s[cnt]=(num%base)+'0';    // Conversion 
0522:  MOVF   3E,W
0523:  ADDWF  36,W
0524:  MOVWF  78
0525:  MOVF   37,W
0526:  MOVWF  7A
0527:  BTFSC  03.0
0528:  INCF   7A,F
0529:  MOVF   78,W
052A:  MOVWF  40
052B:  MOVF   7A,W
052C:  MOVWF  41
052D:  CLRF   43
052E:  MOVF   04,W
052F:  MOVWF  42
0530:  BCF    43.0
0531:  BTFSC  03.7
0532:  BSF    43.0
0533:  BSF    03.1
0534:  MOVLW  44
0535:  MOVWF  04
0536:  BSF    03.7
0537:  MOVF   34,W
0538:  MOVWF  4B
0539:  MOVF   33,W
053A:  MOVWF  4A
053B:  MOVF   32,W
053C:  MOVWF  49
053D:  MOVF   31,W
053E:  MOVWF  48
053F:  CLRF   4F
0540:  CLRF   4E
0541:  CLRF   4D
0542:  MOVF   35,W
0543:  MOVWF  4C
0544:  BCF    03.6
0545:  CALL   437
0546:  BSF    03.6
0547:  MOVF   42,W
0548:  MOVWF  04
0549:  BCF    03.7
054A:  BTFSC  43.0
054B:  BSF    03.7
054C:  MOVLW  30
054D:  ADDWF  44,W
054E:  MOVWF  77
054F:  MOVF   45,W
0550:  MOVWF  78
0551:  MOVLW  00
0552:  BTFSC  03.0
0553:  MOVLW  01
0554:  ADDWF  78,F
0555:  MOVF   46,W
0556:  MOVWF  79
0557:  MOVLW  00
0558:  BTFSC  03.0
0559:  MOVLW  01
055A:  ADDWF  79,F
055B:  MOVF   47,W
055C:  MOVWF  7A
055D:  MOVLW  00
055E:  BTFSC  03.0
055F:  MOVLW  01
0560:  ADDWF  7A,F
0561:  MOVF   40,W
0562:  MOVWF  04
0563:  BCF    03.7
0564:  BTFSC  41.0
0565:  BSF    03.7
0566:  MOVF   77,W
0567:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0568:  MOVF   3E,W
0569:  ADDWF  36,W
056A:  MOVWF  04
056B:  BCF    03.7
056C:  BTFSC  37.0
056D:  BSF    03.7
056E:  MOVF   00,W
056F:  SUBLW  39
0570:  BTFSC  03.0
0571:  GOTO   57B
....................             s[cnt]+=0x7; 
0572:  MOVF   3E,W
0573:  ADDWF  36,W
0574:  MOVWF  04
0575:  BCF    03.7
0576:  BTFSC  37.0
0577:  BSF    03.7
0578:  MOVLW  07
0579:  ADDWF  00,W
057A:  MOVWF  00
....................  
....................          cnt++; 
057B:  INCF   3E,F
....................          num=temp; 
057C:  MOVF   3B,W
057D:  MOVWF  34
057E:  MOVF   3A,W
057F:  MOVWF  33
0580:  MOVF   39,W
0581:  MOVWF  32
0582:  MOVF   38,W
0583:  MOVWF  31
0584:  GOTO   4FD
....................      } 
....................  
....................      if(sign==1) { 
0585:  DECFSZ 3D,W
0586:  GOTO   590
....................          s[cnt]=0x2D;      // Negative sign 
0587:  MOVF   3E,W
0588:  ADDWF  36,W
0589:  MOVWF  04
058A:  BCF    03.7
058B:  BTFSC  37.0
058C:  BSF    03.7
058D:  MOVLW  2D
058E:  MOVWF  00
....................          cnt++; 
058F:  INCF   3E,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0590:  CLRF   3C
0591:  BCF    03.0
0592:  RRF    3E,W
0593:  SUBWF  3C,W
0594:  BTFSC  03.0
0595:  GOTO   5C6
....................  
....................          c=s[i]; 
0596:  MOVF   3C,W
0597:  ADDWF  36,W
0598:  MOVWF  04
0599:  BCF    03.7
059A:  BTFSC  37.0
059B:  BSF    03.7
059C:  MOVF   00,W
059D:  MOVWF  3F
....................          s[i]=s[cnt-i-1];        // Reverse the number 
059E:  MOVF   3C,W
059F:  ADDWF  36,W
05A0:  MOVWF  78
05A1:  MOVF   37,W
05A2:  MOVWF  7A
05A3:  BTFSC  03.0
05A4:  INCF   7A,F
05A5:  MOVF   78,W
05A6:  MOVWF  40
05A7:  MOVF   7A,W
05A8:  MOVWF  41
05A9:  MOVF   3C,W
05AA:  SUBWF  3E,W
05AB:  ADDLW  FF
05AC:  ADDWF  36,W
05AD:  MOVWF  04
05AE:  BCF    03.7
05AF:  BTFSC  37.0
05B0:  BSF    03.7
05B1:  MOVF   00,W
05B2:  MOVWF  42
05B3:  MOVF   40,W
05B4:  MOVWF  04
05B5:  BCF    03.7
05B6:  BTFSC  41.0
05B7:  BSF    03.7
05B8:  MOVF   42,W
05B9:  MOVWF  00
....................          s[cnt-i-1]=c; 
05BA:  MOVF   3C,W
05BB:  SUBWF  3E,W
05BC:  ADDLW  FF
05BD:  ADDWF  36,W
05BE:  MOVWF  04
05BF:  BCF    03.7
05C0:  BTFSC  37.0
05C1:  BSF    03.7
05C2:  MOVF   3F,W
05C3:  MOVWF  00
05C4:  INCF   3C,F
05C5:  GOTO   591
....................      } 
....................      s[cnt]='\0';     // End the string 
05C6:  MOVF   3E,W
05C7:  ADDWF  36,W
05C8:  MOVWF  04
05C9:  BCF    03.7
05CA:  BTFSC  37.0
05CB:  BSF    03.7
05CC:  CLRF   00
....................      return s; 
05CD:  MOVF   36,W
05CE:  MOVWF  78
05CF:  MOVF   37,W
05D0:  MOVWF  79
05D1:  BCF    03.6
05D2:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S NGUYN 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S NGUYN DI 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
00C5:  MOVLW  35
00C6:  MOVWF  04
00C7:  BSF    03.7
00C8:  MOVF   00,W
00C9:  BTFSC  03.2
00CA:  GOTO   0D8
00CB:  MOVLW  06
00CC:  MOVWF  78
00CD:  CLRF   77
00CE:  DECFSZ 77,F
00CF:  GOTO   0CE
00D0:  DECFSZ 78,F
00D1:  GOTO   0CD
00D2:  MOVLW  7B
00D3:  MOVWF  77
00D4:  DECFSZ 77,F
00D5:  GOTO   0D4
00D6:  DECFSZ 00,F
00D7:  GOTO   0CB
00D8:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
016C:  BSF    07.0
....................    output_float(LCD_DATA5); 
016D:  BSF    07.1
....................    output_float(LCD_DATA6); 
016E:  BSF    07.2
....................    output_float(LCD_DATA7); 
016F:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0170:  BCF    03.5
0171:  BSF    09.2
0172:  BSF    03.5
0173:  BCF    09.2
....................    delay_cycles(1); 
0174:  NOP
....................    lcd_output_enable(1); 
0175:  BCF    03.5
0176:  BSF    09.0
0177:  BSF    03.5
0178:  BCF    09.0
....................    delay_cycles(1); 
0179:  NOP
....................    high = lcd_read_nibble(); 
017A:  BCF    03.5
017B:  CALL   121
017C:  MOVF   78,W
017D:  BSF    03.6
017E:  MOVWF  3C
....................        
....................    lcd_output_enable(0); 
017F:  BCF    03.6
0180:  BCF    09.0
0181:  BSF    03.5
0182:  BCF    09.0
....................    delay_cycles(1); 
0183:  NOP
....................    lcd_output_enable(1); 
0184:  BCF    03.5
0185:  BSF    09.0
0186:  BSF    03.5
0187:  BCF    09.0
....................    delay_us(1); 
0188:  GOTO   189
0189:  GOTO   18A
018A:  NOP
....................    low = lcd_read_nibble(); 
018B:  BCF    03.5
018C:  CALL   121
018D:  MOVF   78,W
018E:  BSF    03.6
018F:  MOVWF  3B
....................        
....................    lcd_output_enable(0); 
0190:  BCF    03.6
0191:  BCF    09.0
0192:  BSF    03.5
0193:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0194:  BCF    03.5
0195:  BCF    31.0
0196:  MOVF   31,W
0197:  BSF    03.5
0198:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0199:  BCF    03.5
019A:  BCF    31.1
019B:  MOVF   31,W
019C:  BSF    03.5
019D:  MOVWF  07
....................    output_drive(LCD_DATA6); 
019E:  BCF    03.5
019F:  BCF    31.2
01A0:  MOVF   31,W
01A1:  BSF    03.5
01A2:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01A3:  BCF    03.5
01A4:  BCF    31.3
01A5:  MOVF   31,W
01A6:  BSF    03.5
01A7:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01A8:  BCF    03.5
01A9:  BSF    03.6
01AA:  SWAPF  3C,W
01AB:  MOVWF  77
01AC:  MOVLW  F0
01AD:  ANDWF  77,F
01AE:  MOVF   77,W
01AF:  IORWF  3B,W
01B0:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0121:  BSF    03.6
0122:  CLRF   3D
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0123:  BCF    03.6
0124:  BSF    31.0
0125:  MOVF   31,W
0126:  BSF    03.5
0127:  MOVWF  07
0128:  MOVLW  00
0129:  BCF    03.5
012A:  BTFSC  07.0
012B:  MOVLW  01
012C:  BSF    03.6
012D:  IORWF  3D,F
....................    n |= input(LCD_DATA5) << 1; 
012E:  BCF    03.6
012F:  BSF    31.1
0130:  MOVF   31,W
0131:  BSF    03.5
0132:  MOVWF  07
0133:  MOVLW  00
0134:  BCF    03.5
0135:  BTFSC  07.1
0136:  MOVLW  01
0137:  MOVWF  77
0138:  BCF    03.0
0139:  RLF    77,F
013A:  MOVF   77,W
013B:  BSF    03.6
013C:  IORWF  3D,F
....................    n |= input(LCD_DATA6) << 2; 
013D:  BCF    03.6
013E:  BSF    31.2
013F:  MOVF   31,W
0140:  BSF    03.5
0141:  MOVWF  07
0142:  MOVLW  00
0143:  BCF    03.5
0144:  BTFSC  07.2
0145:  MOVLW  01
0146:  MOVWF  77
0147:  RLF    77,F
0148:  RLF    77,F
0149:  MOVLW  FC
014A:  ANDWF  77,F
014B:  MOVF   77,W
014C:  BSF    03.6
014D:  IORWF  3D,F
....................    n |= input(LCD_DATA7) << 3; 
014E:  BCF    03.6
014F:  BSF    31.3
0150:  MOVF   31,W
0151:  BSF    03.5
0152:  MOVWF  07
0153:  MOVLW  00
0154:  BCF    03.5
0155:  BTFSC  07.3
0156:  MOVLW  01
0157:  MOVWF  77
0158:  RLF    77,F
0159:  RLF    77,F
015A:  RLF    77,F
015B:  MOVLW  F8
015C:  ANDWF  77,F
015D:  MOVF   77,W
015E:  BSF    03.6
015F:  IORWF  3D,F
....................     
....................    return(n); 
0160:  MOVF   3D,W
0161:  MOVWF  78
....................   #else 
0162:  BCF    03.6
0163:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00D9:  BSF    03.6
00DA:  BTFSC  3C.0
00DB:  GOTO   0E0
00DC:  BCF    03.6
00DD:  BCF    07.0
00DE:  GOTO   0E2
00DF:  BSF    03.6
00E0:  BCF    03.6
00E1:  BSF    07.0
00E2:  BCF    31.0
00E3:  MOVF   31,W
00E4:  BSF    03.5
00E5:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00E6:  BCF    03.5
00E7:  BSF    03.6
00E8:  BTFSC  3C.1
00E9:  GOTO   0EE
00EA:  BCF    03.6
00EB:  BCF    07.1
00EC:  GOTO   0F0
00ED:  BSF    03.6
00EE:  BCF    03.6
00EF:  BSF    07.1
00F0:  BCF    31.1
00F1:  MOVF   31,W
00F2:  BSF    03.5
00F3:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00F4:  BCF    03.5
00F5:  BSF    03.6
00F6:  BTFSC  3C.2
00F7:  GOTO   0FC
00F8:  BCF    03.6
00F9:  BCF    07.2
00FA:  GOTO   0FE
00FB:  BSF    03.6
00FC:  BCF    03.6
00FD:  BSF    07.2
00FE:  BCF    31.2
00FF:  MOVF   31,W
0100:  BSF    03.5
0101:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0102:  BCF    03.5
0103:  BSF    03.6
0104:  BTFSC  3C.3
0105:  GOTO   10A
0106:  BCF    03.6
0107:  BCF    07.3
0108:  GOTO   10C
0109:  BSF    03.6
010A:  BCF    03.6
010B:  BSF    07.3
010C:  BCF    31.3
010D:  MOVF   31,W
010E:  BSF    03.5
010F:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0110:  NOP
....................    lcd_output_enable(1); 
0111:  BCF    03.5
0112:  BSF    09.0
0113:  BSF    03.5
0114:  BCF    09.0
....................    delay_us(2); 
0115:  MOVLW  02
0116:  MOVWF  77
0117:  DECFSZ 77,F
0118:  GOTO   117
0119:  GOTO   11A
011A:  NOP
....................    lcd_output_enable(0); 
011B:  BCF    03.5
011C:  BCF    09.0
011D:  BSF    03.5
011E:  BCF    09.0
011F:  BCF    03.5
0120:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0164:  BSF    03.5
0165:  BCF    09.0
....................    lcd_rs_tris(); 
0166:  BCF    09.1
....................    lcd_rw_tris(); 
0167:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0168:  BCF    03.5
0169:  BCF    09.1
016A:  BSF    03.5
016B:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01B1:  MOVF   78,W
01B2:  MOVWF  3B
01B3:  BTFSS  3B.7
01B4:  GOTO   1B8
01B5:  BSF    03.5
01B6:  BCF    03.6
01B7:  GOTO   16C
....................    lcd_output_rs(address); 
01B8:  MOVF   39,F
01B9:  BTFSS  03.2
01BA:  GOTO   1BF
01BB:  BCF    03.6
01BC:  BCF    09.1
01BD:  GOTO   1C1
01BE:  BSF    03.6
01BF:  BCF    03.6
01C0:  BSF    09.1
01C1:  BSF    03.5
01C2:  BCF    09.1
....................    delay_cycles(1); 
01C3:  NOP
....................    lcd_output_rw(0); 
01C4:  BCF    03.5
01C5:  BCF    09.2
01C6:  BSF    03.5
01C7:  BCF    09.2
....................    delay_cycles(1); 
01C8:  NOP
....................    lcd_output_enable(0); 
01C9:  BCF    03.5
01CA:  BCF    09.0
01CB:  BSF    03.5
01CC:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01CD:  BCF    03.5
01CE:  BSF    03.6
01CF:  SWAPF  3A,W
01D0:  MOVWF  3B
01D1:  MOVLW  0F
01D2:  ANDWF  3B,F
01D3:  MOVF   3B,W
01D4:  MOVWF  3C
01D5:  BCF    03.6
01D6:  CALL   0D9
....................    lcd_send_nibble(n & 0xf); 
01D7:  BSF    03.6
01D8:  MOVF   3A,W
01D9:  ANDLW  0F
01DA:  MOVWF  3B
01DB:  MOVWF  3C
01DC:  BCF    03.6
01DD:  CALL   0D9
01DE:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01DF:  MOVLW  28
01E0:  BSF    03.6
01E1:  MOVWF  30
01E2:  MOVLW  0C
01E3:  MOVWF  31
01E4:  MOVLW  01
01E5:  MOVWF  32
01E6:  MOVLW  06
01E7:  MOVWF  33
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01E8:  BCF    03.6
01E9:  BCF    09.0
01EA:  BSF    03.5
01EB:  BCF    09.0
....................    lcd_output_rs(0); 
01EC:  BCF    03.5
01ED:  BCF    09.1
01EE:  BSF    03.5
01EF:  BCF    09.1
....................    lcd_output_rw(0); 
01F0:  BCF    03.5
01F1:  BCF    09.2
01F2:  BSF    03.5
01F3:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01F4:  BCF    03.5
01F5:  BCF    31.0
01F6:  MOVF   31,W
01F7:  BSF    03.5
01F8:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01F9:  BCF    03.5
01FA:  BCF    31.1
01FB:  MOVF   31,W
01FC:  BSF    03.5
01FD:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01FE:  BCF    03.5
01FF:  BCF    31.2
0200:  MOVF   31,W
0201:  BSF    03.5
0202:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0203:  BCF    03.5
0204:  BCF    31.3
0205:  MOVF   31,W
0206:  BSF    03.5
0207:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0208:  BCF    09.0
....................    lcd_rs_tris(); 
0209:  BCF    09.1
....................    lcd_rw_tris(); 
020A:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
020B:  MOVLW  0F
020C:  BCF    03.5
020D:  BSF    03.6
020E:  MOVWF  35
020F:  BCF    03.6
0210:  CALL   0C5
....................    for(i=1;i<=3;++i) 
0211:  MOVLW  01
0212:  BSF    03.6
0213:  MOVWF  2F
0214:  MOVF   2F,W
0215:  SUBLW  03
0216:  BTFSS  03.0
0217:  GOTO   224
....................    { 
....................        lcd_send_nibble(3); 
0218:  MOVLW  03
0219:  MOVWF  3C
021A:  BCF    03.6
021B:  CALL   0D9
....................        delay_ms(5); 
021C:  MOVLW  05
021D:  BSF    03.6
021E:  MOVWF  35
021F:  BCF    03.6
0220:  CALL   0C5
0221:  BSF    03.6
0222:  INCF   2F,F
0223:  GOTO   214
....................    } 
....................     
....................    lcd_send_nibble(2); 
0224:  MOVLW  02
0225:  MOVWF  3C
0226:  BCF    03.6
0227:  CALL   0D9
....................    delay_ms(5); 
0228:  MOVLW  05
0229:  BSF    03.6
022A:  MOVWF  35
022B:  BCF    03.6
022C:  CALL   0C5
....................    for(i=0;i<=3;++i) 
022D:  BSF    03.6
022E:  CLRF   2F
022F:  MOVF   2F,W
0230:  SUBLW  03
0231:  BTFSS  03.0
0232:  GOTO   241
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0233:  MOVLW  30
0234:  ADDWF  2F,W
0235:  MOVWF  04
0236:  BSF    03.7
0237:  MOVF   00,W
0238:  MOVWF  34
0239:  CLRF   39
023A:  MOVF   34,W
023B:  MOVWF  3A
023C:  BCF    03.6
023D:  CALL   164
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
023E:  BSF    03.6
023F:  INCF   2F,F
0240:  GOTO   22F
0241:  BCF    03.6
0242:  BSF    0A.3
0243:  BCF    0A.4
0244:  GOTO   264 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0399:  BSF    03.6
039A:  DECFSZ 36,W
039B:  GOTO   39D
039C:  GOTO   3A0
....................       address=LCD_LINE_TWO; 
039D:  MOVLW  40
039E:  MOVWF  37
039F:  GOTO   3A1
....................    else 
....................       address=0; 
03A0:  CLRF   37
....................       
....................    address+=x-1; 
03A1:  MOVLW  01
03A2:  SUBWF  35,W
03A3:  ADDWF  37,F
....................    lcd_send_byte(0,0x80|address); 
03A4:  MOVF   37,W
03A5:  IORLW  80
03A6:  MOVWF  38
03A7:  CLRF   39
03A8:  MOVF   38,W
03A9:  MOVWF  3A
03AA:  BCF    03.6
03AB:  CALL   164
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03AC:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03AD:  BSF    03.6
03AE:  MOVF   34,W
03AF:  XORLW  07
03B0:  BCF    03.6
03B1:  BTFSC  03.2
03B2:  GOTO   3BD
03B3:  XORLW  0B
03B4:  BTFSC  03.2
03B5:  GOTO   3C4
03B6:  XORLW  06
03B7:  BTFSC  03.2
03B8:  GOTO   3D0
03B9:  XORLW  02
03BA:  BTFSC  03.2
03BB:  GOTO   3D8
03BC:  GOTO   3DF
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03BD:  MOVLW  01
03BE:  BSF    03.6
03BF:  MOVWF  35
03C0:  MOVWF  36
03C1:  BCF    03.6
03C2:  CALL   399
03C3:  GOTO   3E6
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03C4:  BSF    03.6
03C5:  CLRF   39
03C6:  MOVLW  01
03C7:  MOVWF  3A
03C8:  BCF    03.6
03C9:  CALL   164
....................                      delay_ms(2); 
03CA:  MOVLW  02
03CB:  BSF    03.6
03CC:  MOVWF  35
03CD:  BCF    03.6
03CE:  CALL   0C5
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03CF:  GOTO   3E6
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03D0:  MOVLW  01
03D1:  BSF    03.6
03D2:  MOVWF  35
03D3:  MOVLW  02
03D4:  MOVWF  36
03D5:  BCF    03.6
03D6:  CALL   399
03D7:  GOTO   3E6
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03D8:  BSF    03.6
03D9:  CLRF   39
03DA:  MOVLW  10
03DB:  MOVWF  3A
03DC:  BCF    03.6
03DD:  CALL   164
03DE:  GOTO   3E6
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03DF:  MOVLW  01
03E0:  BSF    03.6
03E1:  MOVWF  39
03E2:  MOVF   34,W
03E3:  MOVWF  3A
03E4:  BCF    03.6
03E5:  CALL   164
....................      #endif 
....................    } 
03E6:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0; 
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
0968:  CLRF   3C
.................... //INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR TT_DEVICE_CHAR[]=" "; 
0969:  MOVLW  20
096A:  MOVWF  3D
096B:  CLRF   3E
.................... //INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
.................... CHAR *PACKAGE[]={"S","ID", "S_S" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
096C:  MOVLW  53
096D:  MOVWF  4F
096E:  CLRF   50
096F:  MOVLW  49
0970:  MOVWF  51
0971:  MOVLW  44
0972:  MOVWF  52
0973:  CLRF   53
0974:  MOVLW  53
0975:  MOVWF  54
0976:  MOVLW  5F
0977:  MOVWF  55
0978:  MOVLW  53
0979:  MOVWF  56
097A:  CLRF   57
097B:  MOVLW  4C
097C:  MOVWF  58
097D:  MOVLW  45
097E:  MOVWF  59
097F:  MOVLW  4E
0980:  MOVWF  5A
0981:  MOVLW  47
0982:  MOVWF  5B
0983:  MOVLW  48
0984:  MOVWF  5C
0985:  MOVLW  54
0986:  MOVWF  5D
0987:  CLRF   5E
0988:  MOVLW  44
0989:  MOVWF  5F
098A:  MOVLW  41
098B:  MOVWF  60
098C:  MOVLW  54
098D:  MOVWF  61
098E:  MOVLW  41
098F:  MOVWF  62
0990:  MOVLW  31
0991:  MOVWF  63
0992:  CLRF   64
0993:  MOVLW  44
0994:  MOVWF  65
0995:  MOVLW  41
0996:  MOVWF  66
0997:  MOVLW  54
0998:  MOVWF  67
0999:  MOVLW  41
099A:  MOVWF  68
099B:  MOVLW  32
099C:  MOVWF  69
099D:  CLRF   6A
099E:  MOVLW  43
099F:  MOVWF  6B
09A0:  MOVLW  48
09A1:  MOVWF  6C
09A2:  MOVLW  45
09A3:  MOVWF  6D
09A4:  MOVLW  43
09A5:  MOVWF  6E
09A6:  MOVLW  4B
09A7:  MOVWF  6F
09A8:  MOVLW  53
09A9:  MOVWF  70
09AA:  MOVLW  55
09AB:  MOVWF  71
09AC:  MOVLW  4D
09AD:  MOVWF  72
09AE:  CLRF   73
09AF:  MOVLW  23
09B0:  MOVWF  74
09B1:  CLRF   75
09B2:  CLRF   40
09B3:  MOVLW  4F
09B4:  MOVWF  3F
09B5:  CLRF   42
09B6:  MOVLW  51
09B7:  MOVWF  41
09B8:  CLRF   44
09B9:  MOVLW  54
09BA:  MOVWF  43
09BB:  CLRF   46
09BC:  MOVLW  58
09BD:  MOVWF  45
09BE:  CLRF   48
09BF:  MOVLW  5F
09C0:  MOVWF  47
09C1:  CLRF   4A
09C2:  MOVLW  65
09C3:  MOVWF  49
09C4:  CLRF   4C
09C5:  MOVLW  6B
09C6:  MOVWF  4B
09C7:  CLRF   4E
09C8:  MOVLW  74
09C9:  MOVWF  4D
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE","SENSOR","#"}; 
09CA:  MOVLW  53
09CB:  BSF    03.5
09CC:  MOVWF  30
09CD:  CLRF   31
09CE:  MOVLW  49
09CF:  MOVWF  32
09D0:  MOVLW  44
09D1:  MOVWF  33
09D2:  CLRF   34
09D3:  MOVLW  43
09D4:  MOVWF  35
09D5:  MOVLW  5F
09D6:  MOVWF  36
09D7:  MOVLW  46
09D8:  MOVWF  37
09D9:  CLRF   38
09DA:  MOVLW  4C
09DB:  MOVWF  39
09DC:  MOVLW  45
09DD:  MOVWF  3A
09DE:  MOVLW  4E
09DF:  MOVWF  3B
09E0:  MOVLW  47
09E1:  MOVWF  3C
09E2:  MOVLW  48
09E3:  MOVWF  3D
09E4:  MOVLW  54
09E5:  MOVWF  3E
09E6:  CLRF   3F
09E7:  MOVLW  49
09E8:  MOVWF  40
09E9:  MOVLW  44
09EA:  MOVWF  41
09EB:  MOVLW  5F
09EC:  MOVWF  42
09ED:  CLRF   43
09EE:  MOVLW  44
09EF:  MOVWF  44
09F0:  MOVLW  45
09F1:  MOVWF  45
09F2:  MOVLW  56
09F3:  MOVWF  46
09F4:  MOVLW  49
09F5:  MOVWF  47
09F6:  MOVLW  43
09F7:  MOVWF  48
09F8:  MOVLW  45
09F9:  MOVWF  49
09FA:  CLRF   4A
09FB:  MOVLW  53
09FC:  MOVWF  4B
09FD:  MOVLW  45
09FE:  MOVWF  4C
09FF:  MOVLW  4E
0A00:  MOVWF  4D
0A01:  MOVLW  53
0A02:  MOVWF  4E
0A03:  MOVLW  4F
0A04:  MOVWF  4F
0A05:  MOVLW  52
0A06:  MOVWF  50
0A07:  CLRF   51
0A08:  MOVLW  23
0A09:  MOVWF  52
0A0A:  CLRF   53
0A0B:  CLRF   21
0A0C:  MOVLW  B0
0A0D:  MOVWF  20
0A0E:  CLRF   23
0A0F:  MOVLW  B2
0A10:  MOVWF  22
0A11:  CLRF   25
0A12:  MOVLW  B5
0A13:  MOVWF  24
0A14:  CLRF   27
0A15:  MOVLW  B9
0A16:  MOVWF  26
0A17:  CLRF   29
0A18:  MOVLW  C0
0A19:  MOVWF  28
0A1A:  CLRF   2B
0A1B:  MOVLW  C4
0A1C:  MOVWF  2A
0A1D:  CLRF   2D
0A1E:  MOVLW  CB
0A1F:  MOVWF  2C
0A20:  CLRF   2F
0A21:  MOVLW  D2
0A22:  MOVWF  2E
.................... CHAR NHIETDO1[]="27"; 
0A23:  MOVLW  32
0A24:  MOVWF  7B
0A25:  MOVLW  37
0A26:  MOVWF  7C
0A27:  CLRF   7D
.................... CHAR NHIETDO2[]="27"; 
0A28:  MOVLW  32
0A29:  MOVWF  54
0A2A:  MOVLW  37
0A2B:  MOVWF  55
0A2C:  CLRF   56
.................... CHAR ID_[]="0"; 
0A2D:  MOVLW  30
0A2E:  MOVWF  57
0A2F:  CLRF   58
.................... CHAR TEMP_CHAR[]="0"; 
0A30:  MOVWF  59
0A31:  CLRF   5A
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;    
.................... //--------------------------------------------------------------------// 
.................... #INT_RDA 
.................... VOID NGAT() 
.................... { 
....................     
....................    KYTU[VT] = GETC (); 
*
0065:  MOVLW  10
0066:  ADDWF  76,W
0067:  MOVWF  04
0068:  BSF    03.7
0069:  BTFSS  0C.5
006A:  GOTO   069
006B:  MOVF   1A,W
006C:  MOVWF  00
....................  
....................    IF (KYTU[VT] == '.') 
006D:  MOVLW  10
006E:  ADDWF  76,W
006F:  MOVWF  04
0070:  BSF    03.7
0071:  MOVF   00,W
0072:  SUBLW  2E
0073:  BTFSS  03.2
0074:  GOTO   07E
....................    { 
....................       KYTU[VT] = '\0'; 
0075:  MOVLW  10
0076:  ADDWF  76,W
0077:  MOVWF  04
0078:  BSF    03.7
0079:  CLRF   00
....................       VT = 0; 
007A:  CLRF   76
....................       TTNHAN = 1; 
007B:  MOVLW  01
007C:  MOVWF  7E
....................    } 
007D:  GOTO   07F
....................  
....................    ELSE 
....................    VT++; 
007E:  INCF   76,F
007F:  BCF    0C.5
0080:  BCF    0A.3
0081:  BCF    0A.4
0082:  GOTO   031
.................... } 
....................  
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0634:  BCF    3B.1
....................    TT_STT = 1; 
0635:  BSF    3B.3
....................    LCD_GOTOXY (1, 2) ; 
0636:  MOVLW  01
0637:  BSF    03.6
0638:  MOVWF  35
0639:  MOVLW  02
063A:  MOVWF  36
063B:  BCF    03.6
063C:  CALL   399
....................    DELAY_MS (10); 
063D:  MOVLW  0A
063E:  BSF    03.6
063F:  MOVWF  35
0640:  BCF    03.6
0641:  CALL   0C5
....................    PRINTF (LCD_PUTC, "ID: "); 
0642:  MOVLW  83
0643:  BSF    03.6
0644:  MOVWF  0D
0645:  MOVLW  00
0646:  MOVWF  0F
0647:  BCF    03.6
0648:  CALL   3E7
....................  
....................    WHILE (TT_STT) 
0649:  BTFSS  3B.3
064A:  GOTO   688
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
064B:  BSF    03.5
064C:  BSF    06.2
064D:  BCF    03.5
064E:  BTFSC  06.2
064F:  GOTO   687
....................       { 
....................          ID_NODE ++; 
0650:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
0651:  MOVF   39,W
0652:  SUBLW  0F
0653:  BTFSS  03.0
0654:  CLRF   39
....................          DELAY_MS (300); 
0655:  MOVLW  02
0656:  BSF    03.6
0657:  MOVWF  2F
0658:  MOVLW  96
0659:  MOVWF  35
065A:  BCF    03.6
065B:  CALL   0C5
065C:  BSF    03.6
065D:  DECFSZ 2F,F
065E:  GOTO   658
....................          ITOA (ID_NODE, 10, ID_); 
065F:  CLRF   34
0660:  CLRF   33
0661:  CLRF   32
0662:  BCF    03.6
0663:  MOVF   39,W
0664:  BSF    03.6
0665:  MOVWF  31
0666:  MOVLW  0A
0667:  MOVWF  35
0668:  CLRF   37
0669:  MOVLW  D7
066A:  MOVWF  36
066B:  BCF    03.6
066C:  CALL   4B3
....................          LCD_GOTOXY (9, 2) ; 
066D:  MOVLW  09
066E:  BSF    03.6
066F:  MOVWF  35
0670:  MOVLW  02
0671:  MOVWF  36
0672:  BCF    03.6
0673:  CALL   399
....................          DELAY_MS (10); 
0674:  MOVLW  0A
0675:  BSF    03.6
0676:  MOVWF  35
0677:  BCF    03.6
0678:  CALL   0C5
....................          PRINTF (LCD_PUTC, ID_); 
0679:  MOVLW  D7
067A:  MOVWF  04
067B:  BCF    03.7
067C:  CALL   5D3
....................          DELAY_MS (1); 
067D:  MOVLW  01
067E:  BSF    03.6
067F:  MOVWF  35
0680:  BCF    03.6
0681:  CALL   0C5
....................          OUTPUT_TOGGLE (PIN_D0); 
0682:  BSF    03.5
0683:  BCF    08.0
0684:  MOVLW  01
0685:  BCF    03.5
0686:  XORWF  08,F
....................       } 
0687:  GOTO   649
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0689:  BCF    3B.1
....................    TT_STT = 1; 
068A:  BSF    3B.3
....................    LCD_GOTOXY (1, 2) ; 
068B:  MOVLW  01
068C:  BSF    03.6
068D:  MOVWF  35
068E:  MOVLW  02
068F:  MOVWF  36
0690:  BCF    03.6
0691:  CALL   399
....................    DELAY_MS (10); 
0692:  MOVLW  0A
0693:  BSF    03.6
0694:  MOVWF  35
0695:  BCF    03.6
0696:  CALL   0C5
....................    PRINTF (LCD_PUTC, "DEVICE: "); 
0697:  MOVLW  86
0698:  BSF    03.6
0699:  MOVWF  0D
069A:  MOVLW  00
069B:  MOVWF  0F
069C:  BCF    03.6
069D:  CALL   3E7
....................  
....................    WHILE (TT_STT) 
069E:  BTFSS  3B.3
069F:  GOTO   756
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06A0:  BSF    03.5
06A1:  BSF    06.2
06A2:  BCF    03.5
06A3:  BTFSC  06.2
06A4:  GOTO   709
....................       { 
....................          STT_DEVICE ++; 
06A5:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
06A6:  MOVF   3A,W
06A7:  SUBLW  07
06A8:  BTFSS  03.0
06A9:  CLRF   3A
....................          DELAY_MS (300); 
06AA:  MOVLW  02
06AB:  BSF    03.6
06AC:  MOVWF  2F
06AD:  MOVLW  96
06AE:  MOVWF  35
06AF:  BCF    03.6
06B0:  CALL   0C5
06B1:  BSF    03.6
06B2:  DECFSZ 2F,F
06B3:  GOTO   6AD
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
06B4:  CLRF   34
06B5:  CLRF   33
06B6:  CLRF   32
06B7:  BCF    03.6
06B8:  MOVF   3A,W
06B9:  BSF    03.6
06BA:  MOVWF  31
06BB:  MOVLW  0A
06BC:  MOVWF  35
06BD:  CLRF   37
06BE:  MOVLW  D9
06BF:  MOVWF  36
06C0:  BCF    03.6
06C1:  CALL   4B3
....................          LCD_GOTOXY (9, 2) ; 
06C2:  MOVLW  09
06C3:  BSF    03.6
06C4:  MOVWF  35
06C5:  MOVLW  02
06C6:  MOVWF  36
06C7:  BCF    03.6
06C8:  CALL   399
....................          DELAY_MS (10); 
06C9:  MOVLW  0A
06CA:  BSF    03.6
06CB:  MOVWF  35
06CC:  BCF    03.6
06CD:  CALL   0C5
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06CE:  MOVLW  D9
06CF:  MOVWF  04
06D0:  BCF    03.7
06D1:  CALL   5D3
....................          DELAY_MS (1); 
06D2:  MOVLW  01
06D3:  BSF    03.6
06D4:  MOVWF  35
06D5:  BCF    03.6
06D6:  CALL   0C5
....................          PRINTF (LCD_PUTC, ":"); 
06D7:  MOVLW  3A
06D8:  BSF    03.6
06D9:  MOVWF  34
06DA:  BCF    03.6
06DB:  CALL   3AD
....................          DELAY_MS (1); 
06DC:  MOVLW  01
06DD:  BSF    03.6
06DE:  MOVWF  35
06DF:  BCF    03.6
06E0:  CALL   0C5
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
06E1:  MOVF   3A,W
06E2:  BSF    03.6
06E3:  MOVWF  31
06E4:  CLRF   33
06E5:  MOVLW  3C
06E6:  MOVWF  32
06E7:  BCF    03.6
06E8:  CALL   5F0
06E9:  MOVLW  00
06EA:  BTFSC  78.0
06EB:  MOVLW  01
06EC:  BSF    03.6
06ED:  MOVWF  2F
06EE:  CLRF   34
06EF:  CLRF   33
06F0:  CLRF   32
06F1:  MOVF   2F,W
06F2:  MOVWF  31
06F3:  MOVLW  0A
06F4:  MOVWF  35
06F5:  CLRF   37
06F6:  MOVLW  D9
06F7:  MOVWF  36
06F8:  BCF    03.6
06F9:  CALL   4B3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06FA:  MOVLW  D9
06FB:  MOVWF  04
06FC:  BCF    03.7
06FD:  CALL   5D3
....................          DELAY_MS (1); 
06FE:  MOVLW  01
06FF:  BSF    03.6
0700:  MOVWF  35
0701:  BCF    03.6
0702:  CALL   0C5
....................          OUTPUT_TOGGLE (PIN_D0); 
0703:  BSF    03.5
0704:  BCF    08.0
0705:  MOVLW  01
0706:  BCF    03.5
0707:  XORWF  08,F
....................       } 
0708:  GOTO   755
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0709:  BSF    03.5
070A:  BSF    06.3
070B:  BCF    03.5
070C:  BTFSC  06.3
070D:  GOTO   755
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
070E:  MOVF   3A,W
070F:  BSF    03.6
0710:  MOVWF  31
0711:  CLRF   33
0712:  MOVLW  3C
0713:  MOVWF  32
0714:  BCF    03.6
0715:  CALL   5F0
0716:  MOVLW  00
0717:  BTFSS  78.0
0718:  MOVLW  01
0719:  BSF    03.6
071A:  MOVWF  2F
071B:  BCF    03.6
071C:  MOVF   3A,W
071D:  BSF    03.6
071E:  MOVWF  30
071F:  MOVF   2F,W
0720:  MOVWF  31
0721:  CLRF   33
0722:  MOVLW  3C
0723:  MOVWF  32
0724:  BCF    03.6
0725:  GOTO   609
....................          LCD_GOTOXY (12, 2) ; 
0726:  MOVLW  0C
0727:  BSF    03.6
0728:  MOVWF  35
0729:  MOVLW  02
072A:  MOVWF  36
072B:  BCF    03.6
072C:  CALL   399
....................          DELAY_MS (300); 
072D:  MOVLW  02
072E:  BSF    03.6
072F:  MOVWF  2F
0730:  MOVLW  96
0731:  MOVWF  35
0732:  BCF    03.6
0733:  CALL   0C5
0734:  BSF    03.6
0735:  DECFSZ 2F,F
0736:  GOTO   730
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0737:  BCF    03.6
0738:  MOVF   3A,W
0739:  BSF    03.6
073A:  MOVWF  31
073B:  CLRF   33
073C:  MOVLW  3C
073D:  MOVWF  32
073E:  BCF    03.6
073F:  CALL   5F0
0740:  MOVLW  00
0741:  BTFSC  78.0
0742:  MOVLW  01
0743:  BSF    03.6
0744:  MOVWF  2F
0745:  CLRF   34
0746:  CLRF   33
0747:  CLRF   32
0748:  MOVF   2F,W
0749:  MOVWF  31
074A:  MOVLW  0A
074B:  MOVWF  35
074C:  CLRF   37
074D:  MOVLW  D9
074E:  MOVWF  36
074F:  BCF    03.6
0750:  CALL   4B3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0751:  MOVLW  D9
0752:  MOVWF  04
0753:  BCF    03.7
0754:  CALL   5D3
....................       } 
0755:  GOTO   69E
....................    } 
.................... } 
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
076B:  BCF    3B.1
....................    ID_NODE = 0; 
076C:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00BD:  BCF    03.6
00BE:  BCF    3B.1
....................    TT_FUN = 0; 
00BF:  BCF    3B.2
....................    TT_STT = 0; 
00C0:  BCF    3B.3
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
062D:  BCF    3B.1
....................  
....................    SWITCH (CONFIG_FUN) 
062E:  MOVF   38,W
062F:  ADDLW  FC
0630:  BTFSC  03.0
0631:  GOTO   76D
0632:  ADDLW  04
0633:  GOTO   770
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0688:  GOTO   76D
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0756:  GOTO   76D
....................  
....................       CASE 2: 
....................       //CONFIG_SENSOR (); 
....................        
....................       LCD_GOTOXY (10, 2) ; 
0757:  MOVLW  0A
0758:  BSF    03.6
0759:  MOVWF  35
075A:  MOVLW  02
075B:  MOVWF  36
075C:  BCF    03.6
075D:  CALL   399
....................       DELAY_MS (10); 
075E:  MOVLW  0A
075F:  BSF    03.6
0760:  MOVWF  35
0761:  BCF    03.6
0762:  CALL   0C5
....................       PRINTF (LCD_PUTC, "CASE1"); 
0763:  MOVLW  8B
0764:  BSF    03.6
0765:  MOVWF  0D
0766:  MOVLW  00
0767:  MOVWF  0F
0768:  BCF    03.6
0769:  CALL   3E7
....................       BREAK; 
076A:  GOTO   76D
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
076D:  BCF    0A.3
076E:  BCF    0A.4
076F:  GOTO   7D4 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0778:  BSF    3B.2
....................    LCD_GOTOXY (1, 1) ; 
0779:  MOVLW  01
077A:  BSF    03.6
077B:  MOVWF  35
077C:  MOVWF  36
077D:  BCF    03.6
077E:  CALL   399
....................    DELAY_MS (10); 
077F:  MOVLW  0A
0780:  BSF    03.6
0781:  MOVWF  35
0782:  BCF    03.6
0783:  CALL   0C5
....................    PRINTF (LCD_PUTC, "CONFIG"); 
0784:  MOVLW  8E
0785:  BSF    03.6
0786:  MOVWF  0D
0787:  MOVLW  00
0788:  MOVWF  0F
0789:  BCF    03.6
078A:  CALL   3E7
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
078B:  MOVLW  01
078C:  BSF    03.6
078D:  MOVWF  35
078E:  MOVLW  02
078F:  MOVWF  36
0790:  BCF    03.6
0791:  CALL   399
....................    DELAY_MS (10); 
0792:  MOVLW  0A
0793:  BSF    03.6
0794:  MOVWF  35
0795:  BCF    03.6
0796:  CALL   0C5
....................    PRINTF (LCD_PUTC, "CASE: "); 
0797:  MOVLW  92
0798:  BSF    03.6
0799:  MOVWF  0D
079A:  MOVLW  00
079B:  MOVWF  0F
079C:  BCF    03.6
079D:  CALL   3E7
....................  
....................    WHILE (TT_FUN) 
079E:  BTFSS  3B.2
079F:  GOTO   7D3
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
07A0:  BSF    03.5
07A1:  BSF    06.2
07A2:  BCF    03.5
07A3:  BTFSC  06.2
07A4:  GOTO   7D2
....................       { 
....................          CONFIG_FUN ++; 
07A5:  INCF   38,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
07A6:  MOVF   38,W
07A7:  SUBLW  03
07A8:  BTFSS  03.0
07A9:  CLRF   38
....................          DELAY_MS (300); 
07AA:  MOVLW  02
07AB:  BSF    03.6
07AC:  MOVWF  2F
07AD:  MOVLW  96
07AE:  MOVWF  35
07AF:  BCF    03.6
07B0:  CALL   0C5
07B1:  BSF    03.6
07B2:  DECFSZ 2F,F
07B3:  GOTO   7AD
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (9, 2) ; 
07B4:  MOVLW  09
07B5:  MOVWF  35
07B6:  MOVLW  02
07B7:  MOVWF  36
07B8:  BCF    03.6
07B9:  CALL   399
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
07BA:  BSF    03.6
07BB:  CLRF   34
07BC:  CLRF   33
07BD:  CLRF   32
07BE:  BCF    03.6
07BF:  MOVF   38,W
07C0:  BSF    03.6
07C1:  MOVWF  31
07C2:  MOVLW  0A
07C3:  MOVWF  35
07C4:  CLRF   37
07C5:  MOVLW  D9
07C6:  MOVWF  36
07C7:  BCF    03.6
07C8:  CALL   4B3
....................          DELAY_MS (10); 
07C9:  MOVLW  0A
07CA:  BSF    03.6
07CB:  MOVWF  35
07CC:  BCF    03.6
07CD:  CALL   0C5
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
07CE:  MOVLW  D9
07CF:  MOVWF  04
07D0:  BCF    03.7
07D1:  CALL   5D3
....................       } 
07D2:  GOTO   79E
....................    } 
....................  
....................    SELLECT_FUN (); 
07D3:  GOTO   62D
07D4:  BSF    0A.3
07D5:  BCF    0A.4
07D6:  GOTO   27A (RETURN)
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_DEVICE_CHAR = ""; 
*
0842:  BSF    03.6
0843:  CLRF   31
0844:  CLRF   32
0845:  MOVLW  3D
0846:  MOVWF  04
0847:  BCF    03.7
0848:  MOVF   31,W
0849:  ADDWF  04,F
084A:  MOVF   32,W
084B:  BCF    0A.3
084C:  BCF    03.6
084D:  CALL   058
084E:  BSF    0A.3
084F:  MOVWF  00
0850:  IORLW  00
0851:  BTFSC  03.2
0852:  GOTO   058
0853:  BSF    03.6
0854:  INCF   32,F
0855:  INCF   31,F
0856:  GOTO   045
0857:  BCF    03.6
....................    FOR (INT I = 0; I < 8; I++) 
0858:  BSF    03.6
0859:  CLRF   2F
085A:  MOVF   2F,W
085B:  SUBLW  07
085C:  BTFSS  03.0
085D:  GOTO   084
....................    { 
....................       IF (TT_DEVICE[I]) 
085E:  MOVF   2F,W
085F:  MOVWF  31
0860:  CLRF   33
0861:  MOVLW  3C
0862:  MOVWF  32
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   5F0
0866:  BSF    0A.3
0867:  BTFSS  78.0
0868:  GOTO   081
....................       { 
....................          ITOA (I, 10, TEMP_CHAR); 
0869:  BSF    03.6
086A:  CLRF   34
086B:  CLRF   33
086C:  CLRF   32
086D:  MOVF   2F,W
086E:  MOVWF  31
086F:  MOVLW  0A
0870:  MOVWF  35
0871:  CLRF   37
0872:  MOVLW  D9
0873:  MOVWF  36
0874:  BCF    0A.3
0875:  BCF    03.6
0876:  CALL   4B3
0877:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
0878:  BSF    03.6
0879:  CLRF   32
087A:  MOVLW  3D
087B:  MOVWF  31
087C:  CLRF   34
087D:  MOVLW  D9
087E:  MOVWF  33
087F:  BCF    03.6
0880:  CALL   000
....................       } 
0881:  BSF    03.6
0882:  INCF   2F,F
0883:  GOTO   05A
....................    } 
....................  
....................    TEMP_CHAR = " * "; 
0884:  CLRF   31
0885:  CLRF   32
0886:  MOVLW  D9
0887:  MOVWF  04
0888:  BCF    03.7
0889:  MOVF   31,W
088A:  ADDWF  04,F
088B:  MOVF   32,W
088C:  BCF    0A.3
088D:  BCF    03.6
088E:  CALL   05D
088F:  BSF    0A.3
0890:  MOVWF  00
0891:  IORLW  00
0892:  BTFSC  03.2
0893:  GOTO   099
0894:  BSF    03.6
0895:  INCF   32,F
0896:  INCF   31,F
0897:  GOTO   086
0898:  BCF    03.6
....................    STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
0899:  BSF    03.6
089A:  CLRF   32
089B:  MOVLW  3D
089C:  MOVWF  31
089D:  CLRF   34
089E:  MOVLW  D9
089F:  MOVWF  33
08A0:  BCF    03.6
08A1:  CALL   000
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
08A2:  BSF    03.5
08A3:  CLRF   2B
08A4:  MOVLW  3D
08A5:  MOVWF  2A
....................    PACKAGE_CONFIG[1] = ID_; 
08A6:  CLRF   23
08A7:  MOVLW  D7
08A8:  MOVWF  22
....................     
....................    FOR (INT J = 0; J < 8; J++) 
08A9:  BCF    03.5
08AA:  BSF    03.6
08AB:  CLRF   30
08AC:  MOVF   30,W
08AD:  SUBLW  07
08AE:  BTFSS  03.0
08AF:  GOTO   0CD
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08B0:  BCF    03.0
08B1:  RLF    30,W
08B2:  ADDLW  A0
08B3:  MOVWF  04
08B4:  BCF    03.7
08B5:  INCF   04,F
08B6:  MOVF   00,W
08B7:  MOVWF  32
08B8:  DECF   04,F
08B9:  MOVF   00,W
08BA:  MOVWF  31
08BB:  MOVWF  04
08BC:  BCF    03.7
08BD:  BTFSC  32.0
08BE:  BSF    03.7
08BF:  BCF    0A.3
08C0:  BCF    03.6
08C1:  CALL   7D7
08C2:  BSF    0A.3
....................       DELAY_MS (1); 
08C3:  MOVLW  01
08C4:  BSF    03.6
08C5:  MOVWF  35
08C6:  BCF    0A.3
08C7:  BCF    03.6
08C8:  CALL   0C5
08C9:  BSF    0A.3
08CA:  BSF    03.6
08CB:  INCF   30,F
08CC:  GOTO   0AC
....................    } 
....................  
....................     
....................    LCD_GOTOXY (1, 1) ; 
08CD:  MOVLW  01
08CE:  MOVWF  35
08CF:  MOVWF  36
08D0:  BCF    0A.3
08D1:  BCF    03.6
08D2:  CALL   399
08D3:  BSF    0A.3
....................    DELAY_MS (10); 
08D4:  MOVLW  0A
08D5:  BSF    03.6
08D6:  MOVWF  35
08D7:  BCF    0A.3
08D8:  BCF    03.6
08D9:  CALL   0C5
08DA:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE"); 
08DB:  MOVLW  96
08DC:  BSF    03.6
08DD:  MOVWF  0D
08DE:  MOVLW  00
08DF:  MOVWF  0F
08E0:  BCF    0A.3
08E1:  BCF    03.6
08E2:  CALL   3E7
08E3:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
08E4:  MOVLW  01
08E5:  BSF    03.6
08E6:  MOVWF  35
08E7:  MOVLW  02
08E8:  MOVWF  36
08E9:  BCF    0A.3
08EA:  BCF    03.6
08EB:  CALL   399
08EC:  BSF    0A.3
....................    DELAY_MS (10); 
08ED:  MOVLW  0A
08EE:  BSF    03.6
08EF:  MOVWF  35
08F0:  BCF    0A.3
08F1:  BCF    03.6
08F2:  CALL   0C5
08F3:  BSF    0A.3
....................    PRINTF (LCD_PUTC, TT_DEVICE_CHAR); 
08F4:  MOVLW  3D
08F5:  MOVWF  04
08F6:  BCF    03.7
08F7:  BCF    0A.3
08F8:  CALL   5D3
08F9:  BSF    0A.3
....................    PACKAGE[1] = ID_; 
08FA:  CLRF   42
08FB:  MOVLW  D7
08FC:  MOVWF  41
....................    TT_CONFIG_DONE = 0; 
08FD:  BCF    3B.1
08FE:  BSF    0A.3
08FF:  BCF    0A.4
0900:  GOTO   27E (RETURN)
.................... } 
....................  
.................... VOID QUET_PHIM() 
*
009C:  BSF    03.6
009D:  CLRF   56
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
009E:  BSF    03.5
009F:  BCF    03.6
00A0:  BSF    06.1
00A1:  BCF    03.5
00A2:  BTFSC  06.1
00A3:  GOTO   0B2
....................    { 
....................       IF (TMR1IF) 
00A4:  BTFSS  0C.0
00A5:  GOTO   0AF
....................       { 
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00A6:  BCF    0C.0
00A7:  CLRF   0E
00A8:  MOVLW  0B
00A9:  MOVWF  0F
00AA:  MOVLW  DC
00AB:  MOVWF  0E
00AC:  BSF    03.6
00AD:  INCF   56,F
00AE:  BCF    03.6
....................       } 
00AF:  BSF    03.6
00B0:  GOTO   09E
00B1:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 40) 
00B2:  BSF    03.6
00B3:  MOVF   56,W
00B4:  SUBLW  28
00B5:  BTFSC  03.0
00B6:  GOTO   0BD
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00B7:  MOVLW  01
00B8:  BCF    03.6
00B9:  XORWF  3B,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00BA:  BSF    3B.1
....................    } 
00BB:  GOTO   0C1
00BC:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
....................  
....................     
....................    /* 
....................    IF (INPUT (BT1_PIN) == 0) //NEU NUT BAM DUOC BAM 
....................    { 
....................       FOR (INT I = 0; I < 5; I++) // SAU 5S VAN CON NHAN NUT 
....................       { 
....................          IF (INPUT (BT1_PIN) == 0) 
....................          { 
....................             //DELAY_MS (1000); 
....................  
....................             IF (I == 4) 
....................             { 
....................                //CONFIG NODE 
....................                TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
....................                //CONFIG_DONE (); 
....................                TT_CONFIG_DONE = 1; 
....................             } 
....................          } 
....................  
....................          ELSE // NHAN NUT < 5S 
....................          { 
....................             BUTT_OKE (); //OKE 
....................             I = 10; // THOAT FOR 
....................          } 
....................       } 
....................    } 
....................  
....................    */ 
.................... } 
....................  
.................... #INT_EXT 
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
*
00C1:  BCF    0B.1
00C2:  BCF    0A.3
00C3:  BCF    0A.4
00C4:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
091B:  MOVLW  01
091C:  BSF    03.6
091D:  MOVWF  35
091E:  MOVWF  36
091F:  BCF    0A.3
0920:  BCF    03.6
0921:  CALL   399
0922:  BSF    0A.3
....................     DELAY_MS (10); 
0923:  MOVLW  0A
0924:  BSF    03.6
0925:  MOVWF  35
0926:  BCF    0A.3
0927:  BCF    03.6
0928:  CALL   0C5
0929:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTU); 
092A:  MOVLW  10
092B:  MOVWF  04
092C:  BSF    03.7
092D:  BCF    0A.3
092E:  CALL   5D3
092F:  BSF    0A.3
....................     DELAY_MS (1); 
0930:  MOVLW  01
0931:  BSF    03.6
0932:  MOVWF  35
0933:  BCF    0A.3
0934:  BCF    03.6
0935:  CALL   0C5
0936:  BSF    0A.3
0937:  BSF    0A.3
0938:  BCF    0A.4
0939:  GOTO   2E7 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
0245:  BSF    03.6
0246:  RLF    2F,W
0247:  MOVWF  77
0248:  RLF    77,F
0249:  MOVLW  FC
024A:  ANDWF  77,F
024B:  BCF    03.6
024C:  MOVF   1F,W
024D:  ANDLW  C3
024E:  IORWF  77,W
024F:  MOVWF  1F
....................     KQADC = 0; 
0250:  CLRF   33
0251:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0252:  BSF    03.6
0253:  CLRF   30
0254:  MOVF   30,W
0255:  SUBLW  63
0256:  BTFSS  03.0
0257:  GOTO   26C
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0258:  BCF    03.6
0259:  BSF    1F.1
025A:  BTFSC  1F.1
025B:  GOTO   25A
025C:  BSF    03.5
025D:  MOVF   1E,W
025E:  BCF    03.5
025F:  ADDWF  32,F
0260:  MOVF   1E,W
0261:  BTFSC  03.0
0262:  INCFSZ 1E,W
0263:  ADDWF  33,F
....................        DELAY_MS (1); 
0264:  MOVLW  01
0265:  BSF    03.6
0266:  MOVWF  35
0267:  BCF    03.6
0268:  CALL   0C5
0269:  BSF    03.6
026A:  INCF   30,F
026B:  GOTO   254
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
026C:  BCF    03.6
026D:  MOVF   33,W
026E:  BSF    03.6
026F:  MOVWF  32
0270:  BCF    03.6
0271:  MOVF   32,W
0272:  BSF    03.6
0273:  MOVWF  31
*
0290:  MOVF   7A,W
0291:  MOVWF  34
0292:  MOVF   79,W
0293:  MOVWF  33
0294:  MOVF   78,W
0295:  MOVWF  32
0296:  MOVF   77,W
0297:  MOVWF  31
0298:  MOVLW  9A
0299:  MOVWF  38
029A:  MOVLW  99
029B:  MOVWF  37
029C:  MOVLW  4C
029D:  MOVWF  36
029E:  MOVLW  86
029F:  MOVWF  35
*
0369:  MOVF   7A,W
036A:  MOVWF  34
036B:  MOVF   79,W
036C:  MOVWF  33
036D:  MOVF   78,W
036E:  MOVWF  32
036F:  MOVF   77,W
0370:  MOVWF  31
*
038F:  MOVF   79,W
0390:  BCF    03.6
0391:  MOVWF  33
0392:  MOVF   78,W
0393:  MOVWF  32
....................     RETURN KQADC; 
0394:  MOVF   32,W
0395:  MOVWF  78
0396:  BSF    0A.3
0397:  BCF    0A.4
0398:  GOTO   272 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0901:  BSF    03.6
0902:  CLRF   2F
0903:  MOVF   2F,W
0904:  SUBLW  1E
0905:  BTFSS  03.0
0906:  GOTO   117
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
0907:  BSF    03.5
0908:  BCF    03.6
0909:  BCF    08.1
090A:  MOVLW  02
090B:  BCF    03.5
090C:  XORWF  08,F
....................        DELAY_MS (100); 
090D:  MOVLW  64
090E:  BSF    03.6
090F:  MOVWF  35
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   0C5
0913:  BSF    0A.3
0914:  BSF    03.6
0915:  INCF   2F,F
0916:  GOTO   103
....................     } 
0917:  BCF    03.6
0918:  BSF    0A.3
0919:  BCF    0A.4
091A:  GOTO   27F (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
093A:  MOVF   03,W
093B:  ANDLW  1F
093C:  MOVWF  03
093D:  BSF    03.5
093E:  BSF    03.6
093F:  BSF    07.3
0940:  MOVLW  08
0941:  BCF    03.6
0942:  MOVWF  19
0943:  MOVLW  02
0944:  MOVWF  1A
0945:  MOVLW  A6
0946:  MOVWF  18
0947:  MOVLW  90
0948:  BCF    03.5
0949:  MOVWF  18
094A:  MOVLW  FF
094B:  MOVWF  31
094C:  CLRF   38
094D:  CLRF   39
094E:  CLRF   3A
094F:  BCF    3B.0
0950:  BCF    3B.1
0951:  BCF    3B.2
0952:  BCF    3B.3
0953:  CLRF   76
0954:  CLRF   7E
0955:  BSF    03.5
0956:  BSF    03.6
0957:  MOVF   09,W
0958:  ANDLW  C0
0959:  MOVWF  09
095A:  BCF    03.6
095B:  BCF    1F.4
095C:  BCF    1F.5
095D:  MOVLW  00
095E:  BSF    03.6
095F:  MOVWF  08
0960:  BCF    03.5
0961:  CLRF   07
0962:  CLRF   08
0963:  CLRF   09
0964:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0A32:  MOVLW  00
0A33:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0A34:  MOVLW  FF
0A35:  MOVWF  06
....................     SET_TRIS_E (0); 
0A36:  BCF    09.0
0A37:  BCF    09.1
0A38:  BCF    09.2
0A39:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0A3A:  MOVLW  80
0A3B:  MOVWF  07
0A3C:  BCF    03.5
0A3D:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0A3E:  BSF    1F.6
0A3F:  BCF    1F.7
0A40:  BSF    03.5
0A41:  BSF    1F.7
0A42:  BCF    03.5
0A43:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0A44:  BSF    03.5
0A45:  BSF    03.6
0A46:  MOVF   09,W
0A47:  ANDLW  C0
0A48:  MOVWF  09
0A49:  BCF    03.6
0A4A:  BCF    1F.4
0A4B:  BCF    1F.5
0A4C:  MOVLW  01
0A4D:  BSF    03.6
0A4E:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0A4F:  BCF    03.5
0A50:  BCF    03.6
0A51:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0A52:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0A53:  BSF    0B.4
0A54:  BSF    03.5
0A55:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0A56:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0A57:  MOVLW  C0
0A58:  BCF    03.5
0A59:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8) ; 
0A5A:  MOVLW  35
0A5B:  MOVWF  10
....................     //SET_TIMER1 (0) ; 
....................     SET_TIMER1 (3036) ; 
0A5C:  CLRF   0E
0A5D:  MOVLW  0B
0A5E:  MOVWF  0F
0A5F:  MOVLW  DC
0A60:  MOVWF  0E
....................     TMR1IF = 0; 
0A61:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0A62:  BCF    0A.3
0A63:  GOTO   1DF
0A64:  BSF    0A.3
....................     ID_NODE = 0; 
0A65:  CLRF   39
....................     TT_CONFIG = 0; 
0A66:  BCF    3B.0
....................     TT_CONFIG_DONE = 0; 
0A67:  BCF    3B.1
....................     OUTPUT_D (0X00); 
0A68:  BSF    03.5
0A69:  CLRF   08
0A6A:  BCF    03.5
0A6B:  CLRF   08
....................     TTNHAN = 0; 
0A6C:  CLRF   7E
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0A6D:  BSF    03.6
0A6E:  CLRF   2F
0A6F:  BCF    0A.3
0A70:  BCF    03.6
0A71:  GOTO   245
0A72:  BSF    0A.3
0A73:  CLRF   35
0A74:  MOVF   78,W
0A75:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0A76:  BTFSS  3B.0
0A77:  GOTO   27C
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0A78:  BCF    0A.3
0A79:  GOTO   778
0A7A:  BSF    0A.3
....................        } 
0A7B:  GOTO   27E
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0A7C:  BTFSC  3B.1
....................        { 
....................           CONFIG_DONE () ; 
0A7D:  GOTO   042
....................        } 
....................  
....................        CHUONG_TRINH_CON (); 
0A7E:  GOTO   101
....................  
....................        IF (AN0 > 26) 
0A7F:  MOVF   35,F
0A80:  BTFSS  03.2
0A81:  GOTO   286
0A82:  MOVF   34,W
0A83:  SUBLW  1A
0A84:  BTFSC  03.0
0A85:  GOTO   2E3
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0A86:  BSF    03.6
0A87:  CLRF   34
0A88:  CLRF   33
0A89:  BCF    03.6
0A8A:  MOVF   35,W
0A8B:  BSF    03.6
0A8C:  MOVWF  32
0A8D:  BCF    03.6
0A8E:  MOVF   34,W
0A8F:  BSF    03.6
0A90:  MOVWF  31
0A91:  MOVLW  0A
0A92:  MOVWF  35
0A93:  CLRF   37
0A94:  MOVLW  7B
0A95:  MOVWF  36
0A96:  BCF    0A.3
0A97:  BCF    03.6
0A98:  CALL   4B3
0A99:  BSF    0A.3
....................           PACKAGE[4] = NHIETDO1; 
0A9A:  CLRF   48
0A9B:  MOVLW  7B
0A9C:  MOVWF  47
....................           ITOA (AN1, 10, NHIETDO2); 
0A9D:  BSF    03.6
0A9E:  CLRF   34
0A9F:  CLRF   33
0AA0:  BCF    03.6
0AA1:  MOVF   37,W
0AA2:  BSF    03.6
0AA3:  MOVWF  32
0AA4:  BCF    03.6
0AA5:  MOVF   36,W
0AA6:  BSF    03.6
0AA7:  MOVWF  31
0AA8:  MOVLW  0A
0AA9:  MOVWF  35
0AAA:  CLRF   37
0AAB:  MOVLW  D4
0AAC:  MOVWF  36
0AAD:  BCF    0A.3
0AAE:  BCF    03.6
0AAF:  CALL   4B3
0AB0:  BSF    0A.3
....................           PACKAGE[5] = NHIETDO2; 
0AB1:  CLRF   4A
0AB2:  MOVLW  D4
0AB3:  MOVWF  49
....................            
....................           FOR (INT I = 0; I < 8; I++) 
0AB4:  BSF    03.6
0AB5:  CLRF   2E
0AB6:  MOVF   2E,W
0AB7:  SUBLW  07
0AB8:  BTFSS  03.0
0AB9:  GOTO   2D7
....................           { 
....................              PRINTF (PACKAGE[I]); 
0ABA:  BCF    03.0
0ABB:  RLF    2E,W
0ABC:  ADDLW  3F
0ABD:  MOVWF  04
0ABE:  BCF    03.7
0ABF:  INCF   04,F
0AC0:  MOVF   00,W
0AC1:  MOVWF  30
0AC2:  DECF   04,F
0AC3:  MOVF   00,W
0AC4:  MOVWF  2F
0AC5:  MOVWF  04
0AC6:  BCF    03.7
0AC7:  BTFSC  30.0
0AC8:  BSF    03.7
0AC9:  BCF    0A.3
0ACA:  BCF    03.6
0ACB:  CALL   7D7
0ACC:  BSF    0A.3
....................              DELAY_MS (1); 
0ACD:  MOVLW  01
0ACE:  BSF    03.6
0ACF:  MOVWF  35
0AD0:  BCF    0A.3
0AD1:  BCF    03.6
0AD2:  CALL   0C5
0AD3:  BSF    0A.3
0AD4:  BSF    03.6
0AD5:  INCF   2E,F
0AD6:  GOTO   2B6
....................           } 
....................  
....................           DELAY_MS (1000); 
0AD7:  MOVLW  04
0AD8:  MOVWF  2F
0AD9:  MOVLW  FA
0ADA:  MOVWF  35
0ADB:  BCF    0A.3
0ADC:  BCF    03.6
0ADD:  CALL   0C5
0ADE:  BSF    0A.3
0ADF:  BSF    03.6
0AE0:  DECFSZ 2F,F
0AE1:  GOTO   2D9
0AE2:  BCF    03.6
....................        } 
....................  
....................        IF (TTNHAN == 1) 
0AE3:  DECFSZ 7E,W
0AE4:  GOTO   2FB
....................        { 
....................            
....................           TTNHAN = 0; 
0AE5:  CLRF   7E
....................           XUATLCD (); 
0AE6:  GOTO   11B
....................            
....................           OUTPUT_TOGGLE (PIN_D0); 
0AE7:  BSF    03.5
0AE8:  BCF    08.0
0AE9:  MOVLW  01
0AEA:  BCF    03.5
0AEB:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D1); 
0AEC:  BSF    03.5
0AED:  BCF    08.1
0AEE:  MOVLW  02
0AEF:  BCF    03.5
0AF0:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D2); 
0AF1:  BSF    03.5
0AF2:  BCF    08.2
0AF3:  MOVLW  04
0AF4:  BCF    03.5
0AF5:  XORWF  08,F
....................           OUTPUT_TOGGLE (PIN_D3); 
0AF6:  BSF    03.5
0AF7:  BCF    08.3
0AF8:  MOVLW  08
0AF9:  BCF    03.5
0AFA:  XORWF  08,F
....................        } 
0AFB:  GOTO   26D
....................     } 
....................  } 
....................  
0AFC:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
