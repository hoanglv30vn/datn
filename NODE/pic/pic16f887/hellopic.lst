CCS PCM C Compiler, Version 5.015, 5967               19-Oct-21 01:08

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3172 words (39%)
                           Largest free fragment is 2048
               RAM used:   210 (57%) at main() level
                           250 (68%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   273
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   084
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0B3
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  20
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  2A
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 00,00
006C:  DATA C4,22
006D:  DATA D6,24
006E:  DATA C3,22
006F:  DATA 3A,10
0070:  DATA 00,01
0071:  DATA 3A,10
0072:  DATA 20,10
0073:  DATA 20,00
0074:  DATA D3,22
0075:  DATA CE,29
0076:  DATA 4F,29
0077:  DATA 3A,10
0078:  DATA 00,01
0079:  DATA 3A,10
007A:  DATA 20,10
007B:  DATA 20,00
007C:  DATA C3,27
007D:  DATA 4E,23
007E:  DATA C9,23
007F:  DATA 00,01
0080:  DATA C3,20
0081:  DATA D3,22
0082:  DATA 3A,10
0083:  DATA 00,00
*
0280:  MOVLW  8E
0281:  MOVWF  77
0282:  MOVF   40,W
0283:  MOVWF  78
0284:  MOVF   3F,W
0285:  MOVWF  79
0286:  CLRF   7A
0287:  MOVF   78,F
0288:  BTFSS  03.2
0289:  GOTO   294
028A:  MOVF   79,W
028B:  MOVWF  78
028C:  CLRF   79
028D:  MOVLW  08
028E:  SUBWF  77,F
028F:  MOVF   78,F
0290:  BTFSS  03.2
0291:  GOTO   294
0292:  CLRF   77
0293:  GOTO   29C
0294:  BCF    03.0
0295:  BTFSC  78.7
0296:  GOTO   29B
0297:  RLF    79,F
0298:  RLF    78,F
0299:  DECF   77,F
029A:  GOTO   294
029B:  BCF    78.7
*
02AC:  MOVF   3F,W
02AD:  BTFSC  03.2
02AE:  GOTO   371
02AF:  MOVWF  4B
02B0:  MOVF   43,W
02B1:  BTFSC  03.2
02B2:  GOTO   371
02B3:  SUBWF  4B,F
02B4:  BTFSS  03.0
02B5:  GOTO   2BB
02B6:  MOVLW  7F
02B7:  ADDWF  4B,F
02B8:  BTFSC  03.0
02B9:  GOTO   371
02BA:  GOTO   2C1
02BB:  MOVLW  81
02BC:  SUBWF  4B,F
02BD:  BTFSS  03.0
02BE:  GOTO   371
02BF:  BTFSC  03.2
02C0:  GOTO   371
02C1:  MOVF   4B,W
02C2:  MOVWF  77
02C3:  CLRF   78
02C4:  CLRF   79
02C5:  CLRF   7A
02C6:  CLRF   4A
02C7:  MOVF   40,W
02C8:  MOVWF  49
02C9:  BSF    49.7
02CA:  MOVF   41,W
02CB:  MOVWF  48
02CC:  MOVF   42,W
02CD:  MOVWF  47
02CE:  MOVLW  19
02CF:  MOVWF  4B
02D0:  MOVF   46,W
02D1:  SUBWF  47,F
02D2:  BTFSC  03.0
02D3:  GOTO   2E4
02D4:  MOVLW  01
02D5:  SUBWF  48,F
02D6:  BTFSC  03.0
02D7:  GOTO   2E4
02D8:  SUBWF  49,F
02D9:  BTFSC  03.0
02DA:  GOTO   2E4
02DB:  SUBWF  4A,F
02DC:  BTFSC  03.0
02DD:  GOTO   2E4
02DE:  INCF   4A,F
02DF:  INCF   49,F
02E0:  INCF   48,F
02E1:  MOVF   46,W
02E2:  ADDWF  47,F
02E3:  GOTO   316
02E4:  MOVF   45,W
02E5:  SUBWF  48,F
02E6:  BTFSC  03.0
02E7:  GOTO   2FF
02E8:  MOVLW  01
02E9:  SUBWF  49,F
02EA:  BTFSC  03.0
02EB:  GOTO   2FF
02EC:  SUBWF  4A,F
02ED:  BTFSC  03.0
02EE:  GOTO   2FF
02EF:  INCF   4A,F
02F0:  INCF   49,F
02F1:  MOVF   45,W
02F2:  ADDWF  48,F
02F3:  MOVF   46,W
02F4:  ADDWF  47,F
02F5:  BTFSS  03.0
02F6:  GOTO   316
02F7:  INCF   48,F
02F8:  BTFSS  03.2
02F9:  GOTO   316
02FA:  INCF   49,F
02FB:  BTFSS  03.2
02FC:  GOTO   316
02FD:  INCF   4A,F
02FE:  GOTO   316
02FF:  MOVF   44,W
0300:  IORLW  80
0301:  SUBWF  49,F
0302:  BTFSC  03.0
0303:  GOTO   315
0304:  MOVLW  01
0305:  SUBWF  4A,F
0306:  BTFSC  03.0
0307:  GOTO   315
0308:  INCF   4A,F
0309:  MOVF   44,W
030A:  IORLW  80
030B:  ADDWF  49,F
030C:  MOVF   45,W
030D:  ADDWF  48,F
030E:  BTFSS  03.0
030F:  GOTO   2F3
0310:  INCF   49,F
0311:  BTFSS  03.2
0312:  GOTO   2F3
0313:  INCF   4A,F
0314:  GOTO   2F3
0315:  BSF    7A.0
0316:  DECFSZ 4B,F
0317:  GOTO   319
0318:  GOTO   324
0319:  BCF    03.0
031A:  RLF    47,F
031B:  RLF    48,F
031C:  RLF    49,F
031D:  RLF    4A,F
031E:  BCF    03.0
031F:  RLF    7A,F
0320:  RLF    79,F
0321:  RLF    78,F
0322:  RLF    4C,F
0323:  GOTO   2D0
0324:  BTFSS  4C.0
0325:  GOTO   32C
0326:  BCF    03.0
0327:  RRF    78,F
0328:  RRF    79,F
0329:  RRF    7A,F
032A:  RRF    4C,F
032B:  GOTO   32F
032C:  DECF   77,F
032D:  BTFSC  03.2
032E:  GOTO   371
032F:  BTFSC  4C.7
0330:  GOTO   358
0331:  BCF    03.0
0332:  RLF    47,F
0333:  RLF    48,F
0334:  RLF    49,F
0335:  RLF    4A,F
0336:  MOVF   46,W
0337:  SUBWF  47,F
0338:  BTFSC  03.0
0339:  GOTO   344
033A:  MOVLW  01
033B:  SUBWF  48,F
033C:  BTFSC  03.0
033D:  GOTO   344
033E:  SUBWF  49,F
033F:  BTFSC  03.0
0340:  GOTO   344
0341:  SUBWF  4A,F
0342:  BTFSS  03.0
0343:  GOTO   367
0344:  MOVF   45,W
0345:  SUBWF  48,F
0346:  BTFSC  03.0
0347:  GOTO   34F
0348:  MOVLW  01
0349:  SUBWF  49,F
034A:  BTFSC  03.0
034B:  GOTO   34F
034C:  SUBWF  4A,F
034D:  BTFSS  03.0
034E:  GOTO   367
034F:  MOVF   44,W
0350:  IORLW  80
0351:  SUBWF  49,F
0352:  BTFSC  03.0
0353:  GOTO   358
0354:  MOVLW  01
0355:  SUBWF  4A,F
0356:  BTFSS  03.0
0357:  GOTO   367
0358:  INCF   7A,F
0359:  BTFSS  03.2
035A:  GOTO   367
035B:  INCF   79,F
035C:  BTFSS  03.2
035D:  GOTO   367
035E:  INCF   78,F
035F:  BTFSS  03.2
0360:  GOTO   367
0361:  INCF   77,F
0362:  BTFSC  03.2
0363:  GOTO   371
0364:  RRF    78,F
0365:  RRF    79,F
0366:  RRF    7A,F
0367:  MOVF   40,W
0368:  MOVWF  4B
0369:  MOVF   44,W
036A:  XORWF  4B,F
036B:  BTFSS  4B.7
036C:  GOTO   36F
036D:  BSF    78.7
036E:  GOTO   375
036F:  BCF    78.7
0370:  GOTO   375
0371:  CLRF   77
0372:  CLRF   78
0373:  CLRF   79
0374:  CLRF   7A
*
037D:  MOVLW  8E
037E:  MOVWF  77
037F:  MOVF   3F,W
0380:  SUBWF  77,F
0381:  MOVF   40,W
0382:  MOVWF  79
0383:  MOVF   41,W
0384:  MOVWF  78
0385:  BSF    79.7
0386:  MOVF   77,F
0387:  BTFSC  03.2
0388:  GOTO   394
0389:  BCF    03.0
038A:  MOVF   79,F
038B:  BTFSS  03.2
038C:  GOTO   390
038D:  MOVF   78,F
038E:  BTFSC  03.2
038F:  GOTO   394
0390:  RRF    79,F
0391:  RRF    78,F
0392:  DECFSZ 77,F
0393:  GOTO   389
0394:  BTFSS  40.7
0395:  GOTO   39B
0396:  COMF   78,F
0397:  COMF   79,F
0398:  INCF   78,F
0399:  BTFSC  03.2
039A:  INCF   79,F
*
03F3:  MOVF   0B,W
03F4:  BSF    03.6
03F5:  MOVWF  3D
03F6:  BCF    03.6
03F7:  BCF    0B.7
03F8:  BSF    03.5
03F9:  BSF    03.6
03FA:  BSF    0C.7
03FB:  BSF    0C.0
03FC:  NOP
03FD:  NOP
03FE:  BCF    03.5
03FF:  BTFSS  3D.7
0400:  GOTO   404
0401:  BCF    03.6
0402:  BSF    0B.7
0403:  BSF    03.6
0404:  MOVF   0C,W
0405:  ANDLW  7F
0406:  BTFSC  03.2
0407:  GOTO   441
0408:  MOVWF  3D
0409:  MOVF   0D,W
040A:  MOVWF  3E
040B:  MOVF   0F,W
040C:  MOVWF  3F
040D:  MOVF   3D,W
040E:  MOVWF  40
040F:  BCF    03.6
0410:  CALL   3B9
0411:  BSF    03.6
0412:  MOVF   3E,W
0413:  MOVWF  0D
0414:  MOVF   3F,W
0415:  MOVWF  0F
0416:  BCF    03.6
0417:  MOVF   0B,W
0418:  BSF    03.6
0419:  MOVWF  40
041A:  BCF    03.6
041B:  BCF    0B.7
041C:  BSF    03.5
041D:  BSF    03.6
041E:  BSF    0C.7
041F:  BSF    0C.0
0420:  NOP
0421:  NOP
0422:  BCF    03.5
0423:  BTFSS  40.7
0424:  GOTO   428
0425:  BCF    03.6
0426:  BSF    0B.7
0427:  BSF    03.6
0428:  RLF    0C,W
0429:  RLF    0E,W
042A:  ANDLW  7F
042B:  BTFSC  03.2
042C:  GOTO   441
042D:  MOVWF  3D
042E:  MOVF   0D,W
042F:  MOVWF  3E
0430:  MOVF   0F,W
0431:  MOVWF  3F
0432:  MOVF   3D,W
0433:  MOVWF  40
0434:  BCF    03.6
0435:  CALL   3B9
0436:  BSF    03.6
0437:  MOVF   3E,W
0438:  MOVWF  0D
0439:  MOVF   3F,W
043A:  MOVWF  0F
043B:  INCF   0D,F
043C:  BTFSC  03.2
043D:  INCF   0F,F
043E:  BCF    03.6
043F:  GOTO   3F3
0440:  BSF    03.6
0441:  BCF    03.6
0442:  RETURN
0443:  BTFSC  03.1
0444:  GOTO   448
0445:  MOVLW  5E
0446:  MOVWF  04
0447:  BSF    03.7
0448:  BSF    03.6
0449:  MOVF   59,W
044A:  XORWF  5D,W
044B:  ANDLW  80
044C:  MOVWF  63
044D:  BTFSS  59.7
044E:  GOTO   45A
044F:  COMF   56,F
0450:  COMF   57,F
0451:  COMF   58,F
0452:  COMF   59,F
0453:  INCF   56,F
0454:  BTFSC  03.2
0455:  INCF   57,F
0456:  BTFSC  03.2
0457:  INCF   58,F
0458:  BTFSC  03.2
0459:  INCF   59,F
045A:  BTFSS  5D.7
045B:  GOTO   467
045C:  COMF   5A,F
045D:  COMF   5B,F
045E:  COMF   5C,F
045F:  COMF   5D,F
0460:  INCF   5A,F
0461:  BTFSC  03.2
0462:  INCF   5B,F
0463:  BTFSC  03.2
0464:  INCF   5C,F
0465:  BTFSC  03.2
0466:  INCF   5D,F
0467:  CLRF   77
0468:  CLRF   78
0469:  CLRF   79
046A:  CLRF   7A
046B:  CLRF   5E
046C:  CLRF   5F
046D:  CLRF   60
046E:  CLRF   61
046F:  MOVF   5D,W
0470:  IORWF  5C,W
0471:  IORWF  5B,W
0472:  IORWF  5A,W
0473:  BTFSC  03.2
0474:  GOTO   4A5
0475:  MOVLW  20
0476:  MOVWF  62
0477:  BCF    03.0
0478:  RLF    56,F
0479:  RLF    57,F
047A:  RLF    58,F
047B:  RLF    59,F
047C:  RLF    5E,F
047D:  RLF    5F,F
047E:  RLF    60,F
047F:  RLF    61,F
0480:  MOVF   5D,W
0481:  SUBWF  61,W
0482:  BTFSS  03.2
0483:  GOTO   48E
0484:  MOVF   5C,W
0485:  SUBWF  60,W
0486:  BTFSS  03.2
0487:  GOTO   48E
0488:  MOVF   5B,W
0489:  SUBWF  5F,W
048A:  BTFSS  03.2
048B:  GOTO   48E
048C:  MOVF   5A,W
048D:  SUBWF  5E,W
048E:  BTFSS  03.0
048F:  GOTO   49F
0490:  MOVF   5A,W
0491:  SUBWF  5E,F
0492:  MOVF   5B,W
0493:  BTFSS  03.0
0494:  INCFSZ 5B,W
0495:  SUBWF  5F,F
0496:  MOVF   5C,W
0497:  BTFSS  03.0
0498:  INCFSZ 5C,W
0499:  SUBWF  60,F
049A:  MOVF   5D,W
049B:  BTFSS  03.0
049C:  INCFSZ 5D,W
049D:  SUBWF  61,F
049E:  BSF    03.0
049F:  RLF    77,F
04A0:  RLF    78,F
04A1:  RLF    79,F
04A2:  RLF    7A,F
04A3:  DECFSZ 62,F
04A4:  GOTO   477
04A5:  BTFSS  63.7
04A6:  GOTO   4B2
04A7:  COMF   77,F
04A8:  COMF   78,F
04A9:  COMF   79,F
04AA:  COMF   7A,F
04AB:  INCF   77,F
04AC:  BTFSC  03.2
04AD:  INCF   78,F
04AE:  BTFSC  03.2
04AF:  INCF   79,F
04B0:  BTFSC  03.2
04B1:  INCF   7A,F
04B2:  MOVF   5E,W
04B3:  MOVWF  00
04B4:  INCF   04,F
04B5:  MOVF   5F,W
04B6:  MOVWF  00
04B7:  INCF   04,F
04B8:  MOVF   60,W
04B9:  MOVWF  00
04BA:  INCF   04,F
04BB:  MOVF   61,W
04BC:  MOVWF  00
04BD:  BCF    03.6
04BE:  RETURN
*
04D8:  MOVLW  20
04D9:  MOVWF  5A
04DA:  CLRF   56
04DB:  CLRF   57
04DC:  CLRF   58
04DD:  CLRF   59
04DE:  MOVF   51,W
04DF:  MOVWF  7A
04E0:  MOVF   50,W
04E1:  MOVWF  79
04E2:  MOVF   4F,W
04E3:  MOVWF  78
04E4:  MOVF   4E,W
04E5:  MOVWF  77
04E6:  BCF    03.0
04E7:  BTFSS  77.0
04E8:  GOTO   4F7
04E9:  MOVF   52,W
04EA:  ADDWF  56,F
04EB:  MOVF   53,W
04EC:  BTFSC  03.0
04ED:  INCFSZ 53,W
04EE:  ADDWF  57,F
04EF:  MOVF   54,W
04F0:  BTFSC  03.0
04F1:  INCFSZ 54,W
04F2:  ADDWF  58,F
04F3:  MOVF   55,W
04F4:  BTFSC  03.0
04F5:  INCFSZ 55,W
04F6:  ADDWF  59,F
04F7:  RRF    59,F
04F8:  RRF    58,F
04F9:  RRF    57,F
04FA:  RRF    56,F
04FB:  RRF    7A,F
04FC:  RRF    79,F
04FD:  RRF    78,F
04FE:  RRF    77,F
04FF:  DECFSZ 5A,F
0500:  GOTO   4E6
*
05DF:  MOVF   00,F
05E0:  BTFSC  03.2
05E1:  GOTO   5FB
05E2:  BSF    03.6
05E3:  CLRF   3F
05E4:  MOVF   04,W
05E5:  MOVWF  3E
05E6:  BCF    3F.0
05E7:  BTFSC  03.7
05E8:  BSF    3F.0
05E9:  MOVF   00,W
05EA:  MOVWF  40
05EB:  BCF    03.6
05EC:  CALL   3B9
05ED:  BSF    03.6
05EE:  MOVF   3E,W
05EF:  MOVWF  04
05F0:  BCF    03.7
05F1:  BTFSC  3F.0
05F2:  BSF    03.7
05F3:  INCF   04,F
05F4:  BTFSS  03.2
05F5:  GOTO   5F9
05F6:  BCF    03.6
05F7:  INCF   05,F
05F8:  BSF    03.6
05F9:  BCF    03.6
05FA:  GOTO   5DF
05FB:  RETURN
05FC:  BSF    03.6
05FD:  MOVF   3F,W
05FE:  ANDLW  07
05FF:  MOVWF  77
0600:  RRF    3F,W
0601:  MOVWF  78
0602:  RRF    78,F
0603:  RRF    78,F
0604:  MOVLW  1F
0605:  ANDWF  78,F
0606:  MOVF   78,W
0607:  ADDWF  40,W
0608:  MOVWF  04
0609:  BCF    03.7
060A:  BTFSC  41.0
060B:  BSF    03.7
060C:  MOVF   00,W
060D:  MOVWF  78
060E:  INCF   77,F
060F:  GOTO   611
0610:  RRF    78,F
0611:  DECFSZ 77,F
0612:  GOTO   610
0613:  BCF    03.6
0614:  RETURN
0615:  BSF    03.6
0616:  MOVF   3E,W
0617:  ANDLW  07
0618:  MOVWF  77
0619:  RRF    3E,W
061A:  MOVWF  78
061B:  RRF    78,F
061C:  RRF    78,F
061D:  MOVLW  1F
061E:  ANDWF  78,F
061F:  MOVF   78,W
0620:  ADDWF  40,W
0621:  MOVWF  04
0622:  BCF    03.7
0623:  BTFSC  41.0
0624:  BSF    03.7
0625:  CLRF   78
0626:  INCF   78,F
0627:  INCF   77,F
0628:  GOTO   62A
0629:  RLF    78,F
062A:  DECFSZ 77,F
062B:  GOTO   629
062C:  MOVF   3F,F
062D:  BTFSC  03.2
062E:  GOTO   632
062F:  MOVF   78,W
0630:  IORWF  00,F
0631:  GOTO   635
0632:  COMF   78,F
0633:  MOVF   78,W
0634:  ANDWF  00,F
0635:  BCF    03.6
0636:  RETURN
*
06D8:  MOVF   00,F
06D9:  BTFSC  03.2
06DA:  GOTO   6F5
06DB:  BSF    03.6
06DC:  CLRF   41
06DD:  MOVF   04,W
06DE:  MOVWF  40
06DF:  BCF    41.0
06E0:  BTFSC  03.7
06E1:  BSF    41.0
06E2:  MOVF   00,W
06E3:  BCF    03.6
06E4:  BTFSS  0C.4
06E5:  GOTO   6E4
06E6:  MOVWF  19
06E7:  BSF    03.6
06E8:  MOVF   40,W
06E9:  MOVWF  04
06EA:  BCF    03.7
06EB:  BTFSC  41.0
06EC:  BSF    03.7
06ED:  INCF   04,F
06EE:  BTFSS  03.2
06EF:  GOTO   6F3
06F0:  BCF    03.6
06F1:  INCF   05,F
06F2:  BSF    03.6
06F3:  BCF    03.6
06F4:  GOTO   6D8
06F5:  RETURN
*
0A6B:  BCF    0A.0
0A6C:  BSF    0A.1
0A6D:  BCF    0A.2
0A6E:  ADDWF  02,F
0A6F:  GOTO   007
0A70:  GOTO   06E
0A71:  GOTO   16A
0A72:  GOTO   266
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
069A:  BSF    03.6
069B:  MOVF   40,W
069C:  MOVWF  44
069D:  MOVF   3F,W
069E:  MOVWF  43
069F:  MOVF   44,W
06A0:  MOVWF  7A
06A1:  MOVF   43,W
06A2:  MOVWF  04
06A3:  BCF    03.7
06A4:  BTFSC  7A.0
06A5:  BSF    03.7
06A6:  MOVF   00,F
06A7:  BTFSC  03.2
06A8:  GOTO   6AD
06A9:  INCF   43,F
06AA:  BTFSC  03.2
06AB:  INCF   44,F
06AC:  GOTO   69F
....................    while(*s2 != '\0') 
06AD:  MOVF   42,W
06AE:  MOVWF  7A
06AF:  MOVF   41,W
06B0:  MOVWF  04
06B1:  BCF    03.7
06B2:  BTFSC  7A.0
06B3:  BSF    03.7
06B4:  MOVF   00,F
06B5:  BTFSC  03.2
06B6:  GOTO   6CC
....................    { 
....................       *s = *s2; 
06B7:  MOVF   41,W
06B8:  MOVWF  04
06B9:  BCF    03.7
06BA:  BTFSC  42.0
06BB:  BSF    03.7
06BC:  MOVF   00,W
06BD:  MOVWF  47
06BE:  MOVF   43,W
06BF:  MOVWF  04
06C0:  BCF    03.7
06C1:  BTFSC  44.0
06C2:  BSF    03.7
06C3:  MOVF   47,W
06C4:  MOVWF  00
....................       ++s; 
06C5:  INCF   43,F
06C6:  BTFSC  03.2
06C7:  INCF   44,F
....................       ++s2; 
06C8:  INCF   41,F
06C9:  BTFSC  03.2
06CA:  INCF   42,F
06CB:  GOTO   6AD
....................    } 
....................  
....................    *s = '\0'; 
06CC:  MOVF   43,W
06CD:  MOVWF  04
06CE:  BCF    03.7
06CF:  BTFSC  44.0
06D0:  BSF    03.7
06D1:  CLRF   00
....................    return(s1); 
06D2:  MOVF   3F,W
06D3:  MOVWF  78
06D4:  MOVF   40,W
06D5:  MOVWF  79
06D6:  BCF    03.6
06D7:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0AA0:  BCF    03.6
0AA1:  CLRF   2B
0AA2:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04BF:  BSF    03.6
04C0:  CLRF   49
04C1:  CLRF   48
04C2:  CLRF   47
04C3:  MOVLW  01
04C4:  MOVWF  46
04C5:  CLRF   4B
04C6:  CLRF   4C
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04C7:  BTFSS  42.7
04C8:  GOTO   509
....................          sign=1;        // Check for negative number 
04C9:  MOVLW  01
04CA:  MOVWF  4B
....................          num*=-1; 
04CB:  MOVF   42,W
04CC:  MOVWF  51
04CD:  MOVF   41,W
04CE:  MOVWF  50
04CF:  MOVF   40,W
04D0:  MOVWF  4F
04D1:  MOVF   3F,W
04D2:  MOVWF  4E
04D3:  MOVLW  FF
04D4:  MOVWF  55
04D5:  MOVWF  54
04D6:  MOVWF  53
04D7:  MOVWF  52
*
0501:  MOVF   7A,W
0502:  MOVWF  42
0503:  MOVF   79,W
0504:  MOVWF  41
0505:  MOVF   78,W
0506:  MOVWF  40
0507:  MOVF   77,W
0508:  MOVWF  3F
....................      } 
....................  
....................      while(temp>0) { 
0509:  MOVF   46,F
050A:  BTFSS  03.2
050B:  GOTO   515
050C:  MOVF   47,F
050D:  BTFSS  03.2
050E:  GOTO   515
050F:  MOVF   48,F
0510:  BTFSS  03.2
0511:  GOTO   515
0512:  MOVF   49,F
0513:  BTFSC  03.2
0514:  GOTO   591
....................          temp=(num/base); 
0515:  BCF    03.1
0516:  MOVF   42,W
0517:  MOVWF  59
0518:  MOVF   41,W
0519:  MOVWF  58
051A:  MOVF   40,W
051B:  MOVWF  57
051C:  MOVF   3F,W
051D:  MOVWF  56
051E:  CLRF   5D
051F:  CLRF   5C
0520:  CLRF   5B
0521:  MOVF   43,W
0522:  MOVWF  5A
0523:  BCF    03.6
0524:  CALL   443
0525:  MOVF   7A,W
0526:  BSF    03.6
0527:  MOVWF  49
0528:  MOVF   79,W
0529:  MOVWF  48
052A:  MOVF   78,W
052B:  MOVWF  47
052C:  MOVF   77,W
052D:  MOVWF  46
....................          s[cnt]=(num%base)+'0';    // Conversion 
052E:  MOVF   4C,W
052F:  ADDWF  44,W
0530:  MOVWF  78
0531:  MOVF   45,W
0532:  MOVWF  7A
0533:  BTFSC  03.0
0534:  INCF   7A,F
0535:  MOVF   78,W
0536:  MOVWF  4E
0537:  MOVF   7A,W
0538:  MOVWF  4F
0539:  CLRF   51
053A:  MOVF   04,W
053B:  MOVWF  50
053C:  BCF    51.0
053D:  BTFSC  03.7
053E:  BSF    51.0
053F:  BSF    03.1
0540:  MOVLW  52
0541:  MOVWF  04
0542:  BSF    03.7
0543:  MOVF   42,W
0544:  MOVWF  59
0545:  MOVF   41,W
0546:  MOVWF  58
0547:  MOVF   40,W
0548:  MOVWF  57
0549:  MOVF   3F,W
054A:  MOVWF  56
054B:  CLRF   5D
054C:  CLRF   5C
054D:  CLRF   5B
054E:  MOVF   43,W
054F:  MOVWF  5A
0550:  BCF    03.6
0551:  CALL   443
0552:  BSF    03.6
0553:  MOVF   50,W
0554:  MOVWF  04
0555:  BCF    03.7
0556:  BTFSC  51.0
0557:  BSF    03.7
0558:  MOVLW  30
0559:  ADDWF  52,W
055A:  MOVWF  77
055B:  MOVF   53,W
055C:  MOVWF  78
055D:  MOVLW  00
055E:  BTFSC  03.0
055F:  MOVLW  01
0560:  ADDWF  78,F
0561:  MOVF   54,W
0562:  MOVWF  79
0563:  MOVLW  00
0564:  BTFSC  03.0
0565:  MOVLW  01
0566:  ADDWF  79,F
0567:  MOVF   55,W
0568:  MOVWF  7A
0569:  MOVLW  00
056A:  BTFSC  03.0
056B:  MOVLW  01
056C:  ADDWF  7A,F
056D:  MOVF   4E,W
056E:  MOVWF  04
056F:  BCF    03.7
0570:  BTFSC  4F.0
0571:  BSF    03.7
0572:  MOVF   77,W
0573:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0574:  MOVF   4C,W
0575:  ADDWF  44,W
0576:  MOVWF  04
0577:  BCF    03.7
0578:  BTFSC  45.0
0579:  BSF    03.7
057A:  MOVF   00,W
057B:  SUBLW  39
057C:  BTFSC  03.0
057D:  GOTO   587
....................             s[cnt]+=0x7; 
057E:  MOVF   4C,W
057F:  ADDWF  44,W
0580:  MOVWF  04
0581:  BCF    03.7
0582:  BTFSC  45.0
0583:  BSF    03.7
0584:  MOVLW  07
0585:  ADDWF  00,W
0586:  MOVWF  00
....................  
....................          cnt++; 
0587:  INCF   4C,F
....................          num=temp; 
0588:  MOVF   49,W
0589:  MOVWF  42
058A:  MOVF   48,W
058B:  MOVWF  41
058C:  MOVF   47,W
058D:  MOVWF  40
058E:  MOVF   46,W
058F:  MOVWF  3F
0590:  GOTO   509
....................      } 
....................  
....................      if(sign==1) { 
0591:  DECFSZ 4B,W
0592:  GOTO   59C
....................          s[cnt]=0x2D;      // Negative sign 
0593:  MOVF   4C,W
0594:  ADDWF  44,W
0595:  MOVWF  04
0596:  BCF    03.7
0597:  BTFSC  45.0
0598:  BSF    03.7
0599:  MOVLW  2D
059A:  MOVWF  00
....................          cnt++; 
059B:  INCF   4C,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
059C:  CLRF   4A
059D:  BCF    03.0
059E:  RRF    4C,W
059F:  SUBWF  4A,W
05A0:  BTFSC  03.0
05A1:  GOTO   5D2
....................  
....................          c=s[i]; 
05A2:  MOVF   4A,W
05A3:  ADDWF  44,W
05A4:  MOVWF  04
05A5:  BCF    03.7
05A6:  BTFSC  45.0
05A7:  BSF    03.7
05A8:  MOVF   00,W
05A9:  MOVWF  4D
....................          s[i]=s[cnt-i-1];        // Reverse the number 
05AA:  MOVF   4A,W
05AB:  ADDWF  44,W
05AC:  MOVWF  78
05AD:  MOVF   45,W
05AE:  MOVWF  7A
05AF:  BTFSC  03.0
05B0:  INCF   7A,F
05B1:  MOVF   78,W
05B2:  MOVWF  4E
05B3:  MOVF   7A,W
05B4:  MOVWF  4F
05B5:  MOVF   4A,W
05B6:  SUBWF  4C,W
05B7:  ADDLW  FF
05B8:  ADDWF  44,W
05B9:  MOVWF  04
05BA:  BCF    03.7
05BB:  BTFSC  45.0
05BC:  BSF    03.7
05BD:  MOVF   00,W
05BE:  MOVWF  50
05BF:  MOVF   4E,W
05C0:  MOVWF  04
05C1:  BCF    03.7
05C2:  BTFSC  4F.0
05C3:  BSF    03.7
05C4:  MOVF   50,W
05C5:  MOVWF  00
....................          s[cnt-i-1]=c; 
05C6:  MOVF   4A,W
05C7:  SUBWF  4C,W
05C8:  ADDLW  FF
05C9:  ADDWF  44,W
05CA:  MOVWF  04
05CB:  BCF    03.7
05CC:  BTFSC  45.0
05CD:  BSF    03.7
05CE:  MOVF   4D,W
05CF:  MOVWF  00
05D0:  INCF   4A,F
05D1:  GOTO   59D
....................      } 
....................      s[cnt]='\0';     // End the string 
05D2:  MOVF   4C,W
05D3:  ADDWF  44,W
05D4:  MOVWF  04
05D5:  BCF    03.7
05D6:  BTFSC  45.0
05D7:  BSF    03.7
05D8:  CLRF   00
....................      return s; 
05D9:  MOVF   44,W
05DA:  MOVWF  78
05DB:  MOVF   45,W
05DC:  MOVWF  79
05DD:  BCF    03.6
05DE:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... //#INCLUDE <TV_LCD.C> 
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S? NGUY?N 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S? NGUY?N D?I 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S? THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
00D1:  MOVLW  42
00D2:  MOVWF  04
00D3:  BSF    03.7
00D4:  MOVF   00,W
00D5:  BTFSC  03.2
00D6:  GOTO   0E4
00D7:  MOVLW  06
00D8:  MOVWF  78
00D9:  CLRF   77
00DA:  DECFSZ 77,F
00DB:  GOTO   0DA
00DC:  DECFSZ 78,F
00DD:  GOTO   0D9
00DE:  MOVLW  7B
00DF:  MOVWF  77
00E0:  DECFSZ 77,F
00E1:  GOTO   0E0
00E2:  DECFSZ 00,F
00E3:  GOTO   0D7
00E4:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0178:  BSF    07.0
....................    output_float(LCD_DATA5); 
0179:  BSF    07.1
....................    output_float(LCD_DATA6); 
017A:  BSF    07.2
....................    output_float(LCD_DATA7); 
017B:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
017C:  BCF    03.5
017D:  BSF    09.2
017E:  BSF    03.5
017F:  BCF    09.2
....................    delay_cycles(1); 
0180:  NOP
....................    lcd_output_enable(1); 
0181:  BCF    03.5
0182:  BSF    09.0
0183:  BSF    03.5
0184:  BCF    09.0
....................    delay_cycles(1); 
0185:  NOP
....................    high = lcd_read_nibble(); 
0186:  BCF    03.5
0187:  CALL   12D
0188:  MOVF   78,W
0189:  BSF    03.6
018A:  MOVWF  48
....................        
....................    lcd_output_enable(0); 
018B:  BCF    03.6
018C:  BCF    09.0
018D:  BSF    03.5
018E:  BCF    09.0
....................    delay_cycles(1); 
018F:  NOP
....................    lcd_output_enable(1); 
0190:  BCF    03.5
0191:  BSF    09.0
0192:  BSF    03.5
0193:  BCF    09.0
....................    delay_us(1); 
0194:  GOTO   195
0195:  GOTO   196
0196:  NOP
....................    low = lcd_read_nibble(); 
0197:  BCF    03.5
0198:  CALL   12D
0199:  MOVF   78,W
019A:  BSF    03.6
019B:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
019C:  BCF    03.6
019D:  BCF    09.0
019E:  BSF    03.5
019F:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01A0:  BCF    03.5
01A1:  BCF    31.0
01A2:  MOVF   31,W
01A3:  BSF    03.5
01A4:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01A5:  BCF    03.5
01A6:  BCF    31.1
01A7:  MOVF   31,W
01A8:  BSF    03.5
01A9:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01AA:  BCF    03.5
01AB:  BCF    31.2
01AC:  MOVF   31,W
01AD:  BSF    03.5
01AE:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01AF:  BCF    03.5
01B0:  BCF    31.3
01B1:  MOVF   31,W
01B2:  BSF    03.5
01B3:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01B4:  BCF    03.5
01B5:  BSF    03.6
01B6:  SWAPF  48,W
01B7:  MOVWF  77
01B8:  MOVLW  F0
01B9:  ANDWF  77,F
01BA:  MOVF   77,W
01BB:  IORWF  47,W
01BC:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
012D:  BSF    03.6
012E:  CLRF   49
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
012F:  BCF    03.6
0130:  BSF    31.0
0131:  MOVF   31,W
0132:  BSF    03.5
0133:  MOVWF  07
0134:  MOVLW  00
0135:  BCF    03.5
0136:  BTFSC  07.0
0137:  MOVLW  01
0138:  BSF    03.6
0139:  IORWF  49,F
....................    n |= input(LCD_DATA5) << 1; 
013A:  BCF    03.6
013B:  BSF    31.1
013C:  MOVF   31,W
013D:  BSF    03.5
013E:  MOVWF  07
013F:  MOVLW  00
0140:  BCF    03.5
0141:  BTFSC  07.1
0142:  MOVLW  01
0143:  MOVWF  77
0144:  BCF    03.0
0145:  RLF    77,F
0146:  MOVF   77,W
0147:  BSF    03.6
0148:  IORWF  49,F
....................    n |= input(LCD_DATA6) << 2; 
0149:  BCF    03.6
014A:  BSF    31.2
014B:  MOVF   31,W
014C:  BSF    03.5
014D:  MOVWF  07
014E:  MOVLW  00
014F:  BCF    03.5
0150:  BTFSC  07.2
0151:  MOVLW  01
0152:  MOVWF  77
0153:  RLF    77,F
0154:  RLF    77,F
0155:  MOVLW  FC
0156:  ANDWF  77,F
0157:  MOVF   77,W
0158:  BSF    03.6
0159:  IORWF  49,F
....................    n |= input(LCD_DATA7) << 3; 
015A:  BCF    03.6
015B:  BSF    31.3
015C:  MOVF   31,W
015D:  BSF    03.5
015E:  MOVWF  07
015F:  MOVLW  00
0160:  BCF    03.5
0161:  BTFSC  07.3
0162:  MOVLW  01
0163:  MOVWF  77
0164:  RLF    77,F
0165:  RLF    77,F
0166:  RLF    77,F
0167:  MOVLW  F8
0168:  ANDWF  77,F
0169:  MOVF   77,W
016A:  BSF    03.6
016B:  IORWF  49,F
....................     
....................    return(n); 
016C:  MOVF   49,W
016D:  MOVWF  78
....................   #else 
016E:  BCF    03.6
016F:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00E5:  BSF    03.6
00E6:  BTFSC  48.0
00E7:  GOTO   0EC
00E8:  BCF    03.6
00E9:  BCF    07.0
00EA:  GOTO   0EE
00EB:  BSF    03.6
00EC:  BCF    03.6
00ED:  BSF    07.0
00EE:  BCF    31.0
00EF:  MOVF   31,W
00F0:  BSF    03.5
00F1:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00F2:  BCF    03.5
00F3:  BSF    03.6
00F4:  BTFSC  48.1
00F5:  GOTO   0FA
00F6:  BCF    03.6
00F7:  BCF    07.1
00F8:  GOTO   0FC
00F9:  BSF    03.6
00FA:  BCF    03.6
00FB:  BSF    07.1
00FC:  BCF    31.1
00FD:  MOVF   31,W
00FE:  BSF    03.5
00FF:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0100:  BCF    03.5
0101:  BSF    03.6
0102:  BTFSC  48.2
0103:  GOTO   108
0104:  BCF    03.6
0105:  BCF    07.2
0106:  GOTO   10A
0107:  BSF    03.6
0108:  BCF    03.6
0109:  BSF    07.2
010A:  BCF    31.2
010B:  MOVF   31,W
010C:  BSF    03.5
010D:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
010E:  BCF    03.5
010F:  BSF    03.6
0110:  BTFSC  48.3
0111:  GOTO   116
0112:  BCF    03.6
0113:  BCF    07.3
0114:  GOTO   118
0115:  BSF    03.6
0116:  BCF    03.6
0117:  BSF    07.3
0118:  BCF    31.3
0119:  MOVF   31,W
011A:  BSF    03.5
011B:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
011C:  NOP
....................    lcd_output_enable(1); 
011D:  BCF    03.5
011E:  BSF    09.0
011F:  BSF    03.5
0120:  BCF    09.0
....................    delay_us(2); 
0121:  MOVLW  02
0122:  MOVWF  77
0123:  DECFSZ 77,F
0124:  GOTO   123
0125:  GOTO   126
0126:  NOP
....................    lcd_output_enable(0); 
0127:  BCF    03.5
0128:  BCF    09.0
0129:  BSF    03.5
012A:  BCF    09.0
012B:  BCF    03.5
012C:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0170:  BSF    03.5
0171:  BCF    09.0
....................    lcd_rs_tris(); 
0172:  BCF    09.1
....................    lcd_rw_tris(); 
0173:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0174:  BCF    03.5
0175:  BCF    09.1
0176:  BSF    03.5
0177:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01BD:  MOVF   78,W
01BE:  MOVWF  47
01BF:  BTFSS  47.7
01C0:  GOTO   1C4
01C1:  BSF    03.5
01C2:  BCF    03.6
01C3:  GOTO   178
....................    lcd_output_rs(address); 
01C4:  MOVF   45,F
01C5:  BTFSS  03.2
01C6:  GOTO   1CB
01C7:  BCF    03.6
01C8:  BCF    09.1
01C9:  GOTO   1CD
01CA:  BSF    03.6
01CB:  BCF    03.6
01CC:  BSF    09.1
01CD:  BSF    03.5
01CE:  BCF    09.1
....................    delay_cycles(1); 
01CF:  NOP
....................    lcd_output_rw(0); 
01D0:  BCF    03.5
01D1:  BCF    09.2
01D2:  BSF    03.5
01D3:  BCF    09.2
....................    delay_cycles(1); 
01D4:  NOP
....................    lcd_output_enable(0); 
01D5:  BCF    03.5
01D6:  BCF    09.0
01D7:  BSF    03.5
01D8:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01D9:  BCF    03.5
01DA:  BSF    03.6
01DB:  SWAPF  46,W
01DC:  MOVWF  47
01DD:  MOVLW  0F
01DE:  ANDWF  47,F
01DF:  MOVF   47,W
01E0:  MOVWF  48
01E1:  BCF    03.6
01E2:  CALL   0E5
....................    lcd_send_nibble(n & 0xf); 
01E3:  BSF    03.6
01E4:  MOVF   46,W
01E5:  ANDLW  0F
01E6:  MOVWF  47
01E7:  MOVWF  48
01E8:  BCF    03.6
01E9:  CALL   0E5
01EA:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01EB:  MOVLW  28
01EC:  BSF    03.6
01ED:  MOVWF  3E
01EE:  MOVLW  0C
01EF:  MOVWF  3F
01F0:  MOVLW  01
01F1:  MOVWF  40
01F2:  MOVLW  06
01F3:  MOVWF  41
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01F4:  BCF    03.6
01F5:  BCF    09.0
01F6:  BSF    03.5
01F7:  BCF    09.0
....................    lcd_output_rs(0); 
01F8:  BCF    03.5
01F9:  BCF    09.1
01FA:  BSF    03.5
01FB:  BCF    09.1
....................    lcd_output_rw(0); 
01FC:  BCF    03.5
01FD:  BCF    09.2
01FE:  BSF    03.5
01FF:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0200:  BCF    03.5
0201:  BCF    31.0
0202:  MOVF   31,W
0203:  BSF    03.5
0204:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0205:  BCF    03.5
0206:  BCF    31.1
0207:  MOVF   31,W
0208:  BSF    03.5
0209:  MOVWF  07
....................    output_drive(LCD_DATA6); 
020A:  BCF    03.5
020B:  BCF    31.2
020C:  MOVF   31,W
020D:  BSF    03.5
020E:  MOVWF  07
....................    output_drive(LCD_DATA7); 
020F:  BCF    03.5
0210:  BCF    31.3
0211:  MOVF   31,W
0212:  BSF    03.5
0213:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0214:  BCF    09.0
....................    lcd_rs_tris(); 
0215:  BCF    09.1
....................    lcd_rw_tris(); 
0216:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0217:  MOVLW  0F
0218:  BCF    03.5
0219:  BSF    03.6
021A:  MOVWF  42
021B:  BCF    03.6
021C:  CALL   0D1
....................    for(i=1;i<=3;++i) 
021D:  MOVLW  01
021E:  BSF    03.6
021F:  MOVWF  3D
0220:  MOVF   3D,W
0221:  SUBLW  03
0222:  BTFSS  03.0
0223:  GOTO   230
....................    { 
....................        lcd_send_nibble(3); 
0224:  MOVLW  03
0225:  MOVWF  48
0226:  BCF    03.6
0227:  CALL   0E5
....................        delay_ms(5); 
0228:  MOVLW  05
0229:  BSF    03.6
022A:  MOVWF  42
022B:  BCF    03.6
022C:  CALL   0D1
022D:  BSF    03.6
022E:  INCF   3D,F
022F:  GOTO   220
....................    } 
....................     
....................    lcd_send_nibble(2); 
0230:  MOVLW  02
0231:  MOVWF  48
0232:  BCF    03.6
0233:  CALL   0E5
....................    delay_ms(5); 
0234:  MOVLW  05
0235:  BSF    03.6
0236:  MOVWF  42
0237:  BCF    03.6
0238:  CALL   0D1
....................    for(i=0;i<=3;++i) 
0239:  BSF    03.6
023A:  CLRF   3D
023B:  MOVF   3D,W
023C:  SUBLW  03
023D:  BTFSS  03.0
023E:  GOTO   24D
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
023F:  MOVLW  3E
0240:  ADDWF  3D,W
0241:  MOVWF  04
0242:  BSF    03.7
0243:  MOVF   00,W
0244:  MOVWF  42
0245:  CLRF   45
0246:  MOVF   42,W
0247:  MOVWF  46
0248:  BCF    03.6
0249:  CALL   170
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
024A:  BSF    03.6
024B:  INCF   3D,F
024C:  GOTO   23B
024D:  BCF    03.6
024E:  BSF    0A.3
024F:  BCF    0A.4
0250:  GOTO   3CC (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
03A5:  BSF    03.6
03A6:  DECFSZ 42,W
03A7:  GOTO   3A9
03A8:  GOTO   3AC
....................       address=LCD_LINE_TWO; 
03A9:  MOVLW  40
03AA:  MOVWF  43
03AB:  GOTO   3AD
....................    else 
....................       address=0; 
03AC:  CLRF   43
....................       
....................    address+=x-1; 
03AD:  MOVLW  01
03AE:  SUBWF  41,W
03AF:  ADDWF  43,F
....................    lcd_send_byte(0,0x80|address); 
03B0:  MOVF   43,W
03B1:  IORLW  80
03B2:  MOVWF  44
03B3:  CLRF   45
03B4:  MOVF   44,W
03B5:  MOVWF  46
03B6:  BCF    03.6
03B7:  CALL   170
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03B8:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03B9:  BSF    03.6
03BA:  MOVF   40,W
03BB:  XORLW  07
03BC:  BCF    03.6
03BD:  BTFSC  03.2
03BE:  GOTO   3C9
03BF:  XORLW  0B
03C0:  BTFSC  03.2
03C1:  GOTO   3D0
03C2:  XORLW  06
03C3:  BTFSC  03.2
03C4:  GOTO   3DC
03C5:  XORLW  02
03C6:  BTFSC  03.2
03C7:  GOTO   3E4
03C8:  GOTO   3EB
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03C9:  MOVLW  01
03CA:  BSF    03.6
03CB:  MOVWF  41
03CC:  MOVWF  42
03CD:  BCF    03.6
03CE:  CALL   3A5
03CF:  GOTO   3F2
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03D0:  BSF    03.6
03D1:  CLRF   45
03D2:  MOVLW  01
03D3:  MOVWF  46
03D4:  BCF    03.6
03D5:  CALL   170
....................                      delay_ms(2); 
03D6:  MOVLW  02
03D7:  BSF    03.6
03D8:  MOVWF  42
03D9:  BCF    03.6
03DA:  CALL   0D1
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03DB:  GOTO   3F2
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03DC:  MOVLW  01
03DD:  BSF    03.6
03DE:  MOVWF  41
03DF:  MOVLW  02
03E0:  MOVWF  42
03E1:  BCF    03.6
03E2:  CALL   3A5
03E3:  GOTO   3F2
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03E4:  BSF    03.6
03E5:  CLRF   45
03E6:  MOVLW  10
03E7:  MOVWF  46
03E8:  BCF    03.6
03E9:  CALL   170
03EA:  GOTO   3F2
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03EB:  MOVLW  01
03EC:  BSF    03.6
03ED:  MOVWF  45
03EE:  MOVF   40,W
03EF:  MOVWF  46
03F0:  BCF    03.6
03F1:  CALL   170
....................      #endif 
....................    } 
03F2:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
....................  
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_SELECT_FUN=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
0AA3:  CLRF   60
.................... INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
0AA4:  CLRF   61
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
0AA5:  MOVLW  20
0AA6:  MOVWF  64
0AA7:  CLRF   65
0AA8:  CLRF   63
0AA9:  MOVLW  64
0AAA:  MOVWF  62
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
0AAB:  MOVLW  20
0AAC:  MOVWF  68
0AAD:  CLRF   69
0AAE:  CLRF   67
0AAF:  MOVLW  68
0AB0:  MOVWF  66
....................  
.................... CHAR *PACKAGE[]={"S","ID", "S_S" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
0AB1:  MOVLW  53
0AB2:  BSF    03.5
0AB3:  MOVWF  30
0AB4:  CLRF   31
0AB5:  MOVLW  49
0AB6:  MOVWF  32
0AB7:  MOVLW  44
0AB8:  MOVWF  33
0AB9:  CLRF   34
0ABA:  MOVLW  53
0ABB:  MOVWF  35
0ABC:  MOVLW  5F
0ABD:  MOVWF  36
0ABE:  MOVLW  53
0ABF:  MOVWF  37
0AC0:  CLRF   38
0AC1:  MOVLW  4C
0AC2:  MOVWF  39
0AC3:  MOVLW  45
0AC4:  MOVWF  3A
0AC5:  MOVLW  4E
0AC6:  MOVWF  3B
0AC7:  MOVLW  47
0AC8:  MOVWF  3C
0AC9:  MOVLW  48
0ACA:  MOVWF  3D
0ACB:  MOVLW  54
0ACC:  MOVWF  3E
0ACD:  CLRF   3F
0ACE:  MOVLW  44
0ACF:  MOVWF  40
0AD0:  MOVLW  41
0AD1:  MOVWF  41
0AD2:  MOVLW  54
0AD3:  MOVWF  42
0AD4:  MOVLW  41
0AD5:  MOVWF  43
0AD6:  MOVLW  31
0AD7:  MOVWF  44
0AD8:  CLRF   45
0AD9:  MOVLW  44
0ADA:  MOVWF  46
0ADB:  MOVLW  41
0ADC:  MOVWF  47
0ADD:  MOVLW  54
0ADE:  MOVWF  48
0ADF:  MOVLW  41
0AE0:  MOVWF  49
0AE1:  MOVLW  32
0AE2:  MOVWF  4A
0AE3:  CLRF   4B
0AE4:  MOVLW  43
0AE5:  MOVWF  4C
0AE6:  MOVLW  48
0AE7:  MOVWF  4D
0AE8:  MOVLW  45
0AE9:  MOVWF  4E
0AEA:  MOVLW  43
0AEB:  MOVWF  4F
0AEC:  MOVLW  4B
0AED:  MOVWF  50
0AEE:  MOVLW  53
0AEF:  MOVWF  51
0AF0:  MOVLW  55
0AF1:  MOVWF  52
0AF2:  MOVLW  4D
0AF3:  MOVWF  53
0AF4:  CLRF   54
0AF5:  MOVLW  23
0AF6:  MOVWF  55
0AF7:  CLRF   56
0AF8:  CLRF   21
0AF9:  MOVLW  B0
0AFA:  MOVWF  20
0AFB:  CLRF   23
0AFC:  MOVLW  B2
0AFD:  MOVWF  22
0AFE:  CLRF   25
0AFF:  MOVLW  B5
0B00:  MOVWF  24
0B01:  CLRF   27
0B02:  MOVLW  B9
0B03:  MOVWF  26
0B04:  CLRF   29
0B05:  MOVLW  C0
0B06:  MOVWF  28
0B07:  CLRF   2B
0B08:  MOVLW  C6
0B09:  MOVWF  2A
0B0A:  CLRF   2D
0B0B:  MOVLW  CC
0B0C:  MOVWF  2C
0B0D:  CLRF   2F
0B0E:  MOVLW  D5
0B0F:  MOVWF  2E
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE1234","SENSOR1234","#"}; 
0B10:  MOVLW  53
0B11:  BCF    03.5
0B12:  BSF    03.6
0B13:  MOVWF  10
0B14:  CLRF   11
0B15:  MOVLW  49
0B16:  MOVWF  12
0B17:  MOVLW  44
0B18:  MOVWF  13
0B19:  CLRF   14
0B1A:  MOVLW  43
0B1B:  MOVWF  15
0B1C:  MOVLW  5F
0B1D:  MOVWF  16
0B1E:  MOVLW  46
0B1F:  MOVWF  17
0B20:  CLRF   18
0B21:  MOVLW  4C
0B22:  MOVWF  19
0B23:  MOVLW  45
0B24:  MOVWF  1A
0B25:  MOVLW  4E
0B26:  MOVWF  1B
0B27:  MOVLW  47
0B28:  MOVWF  1C
0B29:  MOVLW  48
0B2A:  MOVWF  1D
0B2B:  MOVLW  54
0B2C:  MOVWF  1E
0B2D:  CLRF   1F
0B2E:  MOVLW  49
0B2F:  MOVWF  20
0B30:  MOVLW  44
0B31:  MOVWF  21
0B32:  MOVLW  5F
0B33:  MOVWF  22
0B34:  CLRF   23
0B35:  MOVLW  44
0B36:  MOVWF  24
0B37:  MOVLW  45
0B38:  MOVWF  25
0B39:  MOVLW  56
0B3A:  MOVWF  26
0B3B:  MOVLW  49
0B3C:  MOVWF  27
0B3D:  MOVLW  43
0B3E:  MOVWF  28
0B3F:  MOVLW  45
0B40:  MOVWF  29
0B41:  MOVLW  31
0B42:  MOVWF  2A
0B43:  MOVLW  32
0B44:  MOVWF  2B
0B45:  MOVLW  33
0B46:  MOVWF  2C
0B47:  MOVLW  34
0B48:  MOVWF  2D
0B49:  CLRF   2E
0B4A:  MOVLW  53
0B4B:  MOVWF  2F
0B4C:  MOVLW  45
0B4D:  MOVWF  30
0B4E:  MOVLW  4E
0B4F:  MOVWF  31
0B50:  MOVLW  53
0B51:  MOVWF  32
0B52:  MOVLW  4F
0B53:  MOVWF  33
0B54:  MOVLW  52
0B55:  MOVWF  34
0B56:  MOVLW  31
0B57:  MOVWF  35
0B58:  MOVLW  32
0B59:  MOVWF  36
0B5A:  MOVLW  33
0B5B:  MOVWF  37
0B5C:  MOVLW  34
0B5D:  MOVWF  38
0B5E:  CLRF   39
0B5F:  MOVLW  23
0B60:  MOVWF  3A
0B61:  CLRF   3B
0B62:  MOVLW  01
0B63:  BSF    03.5
0B64:  BCF    03.6
0B65:  MOVWF  58
0B66:  MOVLW  10
0B67:  MOVWF  57
0B68:  MOVLW  01
0B69:  MOVWF  5A
0B6A:  MOVLW  12
0B6B:  MOVWF  59
0B6C:  MOVLW  01
0B6D:  MOVWF  5C
0B6E:  MOVLW  15
0B6F:  MOVWF  5B
0B70:  MOVLW  01
0B71:  MOVWF  5E
0B72:  MOVLW  19
0B73:  MOVWF  5D
0B74:  MOVLW  01
0B75:  MOVWF  60
0B76:  MOVLW  20
0B77:  MOVWF  5F
0B78:  MOVLW  01
0B79:  MOVWF  62
0B7A:  MOVLW  24
0B7B:  MOVWF  61
0B7C:  MOVLW  01
0B7D:  MOVWF  64
0B7E:  MOVLW  2F
0B7F:  MOVWF  63
0B80:  MOVLW  01
0B81:  MOVWF  66
0B82:  MOVLW  3A
0B83:  MOVWF  65
.................... CHAR NHIETDO1[]="27"; 
0B84:  MOVLW  32
0B85:  BCF    03.5
0B86:  MOVWF  6A
0B87:  MOVLW  37
0B88:  MOVWF  6B
0B89:  CLRF   6C
.................... CHAR NHIETDO2[]="27"; 
0B8A:  MOVLW  32
0B8B:  MOVWF  6D
0B8C:  MOVLW  37
0B8D:  MOVWF  6E
0B8E:  CLRF   6F
.................... CHAR ID_[]="0"; 
0B8F:  MOVLW  30
0B90:  MOVWF  70
0B91:  CLRF   71
.................... CHAR TEMP_CHAR[]="0"; 
0B92:  MOVWF  72
0B93:  CLRF   73
.................... CHAR *TEMP_CHAR2[]="0"; 
0B94:  MOVWF  7B
0B95:  CLRF   7C
0B96:  CLRF   75
0B97:  MOVLW  7B
0B98:  MOVWF  74
....................  
....................    
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    5F.1
....................    TT_STT = 1; 
0808:  BSF    5F.4
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  41
080C:  MOVLW  02
080D:  MOVWF  42
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   3A5
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  42
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   0D1
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID: "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   3F3
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  5F.4
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  3D
0831:  MOVLW  96
0832:  MOVWF  42
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   0D1
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 3D,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   42
083B:  CLRF   41
083C:  CLRF   40
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  3F
0841:  MOVLW  0A
0842:  MOVWF  43
0843:  CLRF   45
0844:  MOVLW  70
0845:  MOVWF  44
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   4BF
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  41
084D:  MOVLW  02
084E:  MOVWF  42
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   3A5
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  42
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   0D1
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  70
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   5DF
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  42
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   0D1
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    5F.1
....................    TT_STT = 1; 
086F:  BSF    5F.4
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  41
0873:  MOVLW  02
0874:  MOVWF  42
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   3A5
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  42
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   0D1
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE: "); 
0880:  MOVLW  6C
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   3F3
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  5F.4
088A:  GOTO   169
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   10E
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  3D
0898:  MOVLW  96
0899:  MOVWF  42
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   0D1
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 3D,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   42
08A2:  CLRF   41
08A3:  CLRF   40
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  3F
08A8:  MOVLW  0A
08A9:  MOVWF  43
08AA:  CLRF   45
08AB:  MOVLW  72
08AC:  MOVWF  44
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   4BF
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  41
08B4:  MOVLW  02
08B5:  MOVWF  42
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   3A5
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  42
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   0D1
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  72
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   5DF
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  42
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   0D1
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ":    "); 
08CE:  MOVLW  71
08CF:  BSF    03.6
08D0:  MOVWF  0D
08D1:  MOVLW  00
08D2:  MOVWF  0F
08D3:  BCF    0A.3
08D4:  BCF    03.6
08D5:  CALL   3F3
08D6:  BSF    0A.3
....................          DELAY_MS (1); 
08D7:  MOVLW  01
08D8:  BSF    03.6
08D9:  MOVWF  42
08DA:  BCF    0A.3
08DB:  BCF    03.6
08DC:  CALL   0D1
08DD:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08DE:  MOVF   3A,W
08DF:  BSF    03.6
08E0:  MOVWF  3F
08E1:  CLRF   41
08E2:  MOVLW  60
08E3:  MOVWF  40
08E4:  BCF    0A.3
08E5:  BCF    03.6
08E6:  CALL   5FC
08E7:  BSF    0A.3
08E8:  MOVLW  00
08E9:  BTFSC  78.0
08EA:  MOVLW  01
08EB:  BSF    03.6
08EC:  MOVWF  3D
08ED:  CLRF   42
08EE:  CLRF   41
08EF:  CLRF   40
08F0:  MOVF   3D,W
08F1:  MOVWF  3F
08F2:  MOVLW  0A
08F3:  MOVWF  43
08F4:  CLRF   45
08F5:  MOVLW  72
08F6:  MOVWF  44
08F7:  BCF    0A.3
08F8:  BCF    03.6
08F9:  CALL   4BF
08FA:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08FB:  MOVLW  72
08FC:  MOVWF  04
08FD:  BCF    03.7
08FE:  BCF    0A.3
08FF:  CALL   5DF
0900:  BSF    0A.3
....................          DELAY_MS (1); 
0901:  MOVLW  01
0902:  BSF    03.6
0903:  MOVWF  42
0904:  BCF    0A.3
0905:  BCF    03.6
0906:  CALL   0D1
0907:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0908:  BSF    03.5
0909:  BCF    08.0
090A:  MOVLW  01
090B:  BCF    03.5
090C:  XORWF  08,F
....................       } 
090D:  GOTO   168
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
090E:  BSF    03.5
090F:  BSF    06.3
0910:  BCF    03.5
0911:  BTFSC  06.3
0912:  GOTO   168
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
0913:  MOVF   3A,W
0914:  BSF    03.6
0915:  MOVWF  3F
0916:  CLRF   41
0917:  MOVLW  60
0918:  MOVWF  40
0919:  BCF    0A.3
091A:  BCF    03.6
091B:  CALL   5FC
091C:  BSF    0A.3
091D:  MOVLW  00
091E:  BTFSS  78.0
091F:  MOVLW  01
0920:  BSF    03.6
0921:  MOVWF  3D
0922:  BCF    03.6
0923:  MOVF   3A,W
0924:  BSF    03.6
0925:  MOVWF  3E
0926:  MOVF   3D,W
0927:  MOVWF  3F
0928:  CLRF   41
0929:  MOVLW  60
092A:  MOVWF  40
092B:  BCF    0A.3
092C:  BCF    03.6
092D:  CALL   615
092E:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
092F:  MOVLW  0D
0930:  BSF    03.6
0931:  MOVWF  41
0932:  MOVLW  02
0933:  MOVWF  42
0934:  BCF    0A.3
0935:  BCF    03.6
0936:  CALL   3A5
0937:  BSF    0A.3
....................          DELAY_MS (300); 
0938:  MOVLW  02
0939:  BSF    03.6
093A:  MOVWF  3D
093B:  MOVLW  96
093C:  MOVWF  42
093D:  BCF    0A.3
093E:  BCF    03.6
093F:  CALL   0D1
0940:  BSF    0A.3
0941:  BSF    03.6
0942:  DECFSZ 3D,F
0943:  GOTO   13B
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0944:  BCF    03.6
0945:  MOVF   3A,W
0946:  BSF    03.6
0947:  MOVWF  3F
0948:  CLRF   41
0949:  MOVLW  60
094A:  MOVWF  40
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   5FC
094E:  BSF    0A.3
094F:  MOVLW  00
0950:  BTFSC  78.0
0951:  MOVLW  01
0952:  BSF    03.6
0953:  MOVWF  3D
0954:  CLRF   42
0955:  CLRF   41
0956:  CLRF   40
0957:  MOVF   3D,W
0958:  MOVWF  3F
0959:  MOVLW  0A
095A:  MOVWF  43
095B:  CLRF   45
095C:  MOVLW  72
095D:  MOVWF  44
095E:  BCF    0A.3
095F:  BCF    03.6
0960:  CALL   4BF
0961:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0962:  MOVLW  72
0963:  MOVWF  04
0964:  BCF    03.7
0965:  BCF    0A.3
0966:  CALL   5DF
0967:  BSF    0A.3
....................       } 
0968:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
096A:  BCF    5F.1
....................    TT_STT = 1; 
096B:  BSF    5F.4
....................    LCD_GOTOXY (1, 2) ; 
096C:  MOVLW  01
096D:  BSF    03.6
096E:  MOVWF  41
096F:  MOVLW  02
0970:  MOVWF  42
0971:  BCF    0A.3
0972:  BCF    03.6
0973:  CALL   3A5
0974:  BSF    0A.3
....................    DELAY_MS (10); 
0975:  MOVLW  0A
0976:  BSF    03.6
0977:  MOVWF  42
0978:  BCF    0A.3
0979:  BCF    03.6
097A:  CALL   0D1
097B:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR: "); 
097C:  MOVLW  74
097D:  BSF    03.6
097E:  MOVWF  0D
097F:  MOVLW  00
0980:  MOVWF  0F
0981:  BCF    0A.3
0982:  BCF    03.6
0983:  CALL   3F3
0984:  BSF    0A.3
....................    WHILE (TT_STT) 
0985:  BTFSS  5F.4
0986:  GOTO   265
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0987:  BSF    03.5
0988:  BSF    06.2
0989:  BCF    03.5
098A:  BTFSC  06.2
098B:  GOTO   20A
....................       { 
....................          STT_SENSOR ++; 
098C:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
098D:  MOVF   3B,W
098E:  SUBLW  03
098F:  BTFSS  03.0
0990:  CLRF   3B
....................          DELAY_MS (300); 
0991:  MOVLW  02
0992:  BSF    03.6
0993:  MOVWF  3D
0994:  MOVLW  96
0995:  MOVWF  42
0996:  BCF    0A.3
0997:  BCF    03.6
0998:  CALL   0D1
0999:  BSF    0A.3
099A:  BSF    03.6
099B:  DECFSZ 3D,F
099C:  GOTO   194
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
099D:  CLRF   42
099E:  CLRF   41
099F:  CLRF   40
09A0:  BCF    03.6
09A1:  MOVF   3B,W
09A2:  BSF    03.6
09A3:  MOVWF  3F
09A4:  MOVLW  0A
09A5:  MOVWF  43
09A6:  CLRF   45
09A7:  MOVLW  72
09A8:  MOVWF  44
09A9:  BCF    0A.3
09AA:  BCF    03.6
09AB:  CALL   4BF
09AC:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09AD:  MOVLW  09
09AE:  BSF    03.6
09AF:  MOVWF  41
09B0:  MOVLW  02
09B1:  MOVWF  42
09B2:  BCF    0A.3
09B3:  BCF    03.6
09B4:  CALL   3A5
09B5:  BSF    0A.3
....................          DELAY_MS (10); 
09B6:  MOVLW  0A
09B7:  BSF    03.6
09B8:  MOVWF  42
09B9:  BCF    0A.3
09BA:  BCF    03.6
09BB:  CALL   0D1
09BC:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09BD:  MOVLW  72
09BE:  MOVWF  04
09BF:  BCF    03.7
09C0:  BCF    0A.3
09C1:  CALL   5DF
09C2:  BSF    0A.3
....................          DELAY_MS (1); 
09C3:  MOVLW  01
09C4:  BSF    03.6
09C5:  MOVWF  42
09C6:  BCF    0A.3
09C7:  BCF    03.6
09C8:  CALL   0D1
09C9:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ":    "); 
09CA:  MOVLW  79
09CB:  BSF    03.6
09CC:  MOVWF  0D
09CD:  MOVLW  00
09CE:  MOVWF  0F
09CF:  BCF    0A.3
09D0:  BCF    03.6
09D1:  CALL   3F3
09D2:  BSF    0A.3
....................          DELAY_MS (1); 
09D3:  MOVLW  01
09D4:  BSF    03.6
09D5:  MOVWF  42
09D6:  BCF    0A.3
09D7:  BCF    03.6
09D8:  CALL   0D1
09D9:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09DA:  MOVF   3B,W
09DB:  BSF    03.6
09DC:  MOVWF  3F
09DD:  CLRF   41
09DE:  MOVLW  61
09DF:  MOVWF  40
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   5FC
09E3:  BSF    0A.3
09E4:  MOVLW  00
09E5:  BTFSC  78.0
09E6:  MOVLW  01
09E7:  BSF    03.6
09E8:  MOVWF  3D
09E9:  CLRF   42
09EA:  CLRF   41
09EB:  CLRF   40
09EC:  MOVF   3D,W
09ED:  MOVWF  3F
09EE:  MOVLW  0A
09EF:  MOVWF  43
09F0:  CLRF   45
09F1:  MOVLW  72
09F2:  MOVWF  44
09F3:  BCF    0A.3
09F4:  BCF    03.6
09F5:  CALL   4BF
09F6:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09F7:  MOVLW  72
09F8:  MOVWF  04
09F9:  BCF    03.7
09FA:  BCF    0A.3
09FB:  CALL   5DF
09FC:  BSF    0A.3
....................          DELAY_MS (1); 
09FD:  MOVLW  01
09FE:  BSF    03.6
09FF:  MOVWF  42
0A00:  BCF    0A.3
0A01:  BCF    03.6
0A02:  CALL   0D1
0A03:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A04:  BSF    03.5
0A05:  BCF    08.0
0A06:  MOVLW  01
0A07:  BCF    03.5
0A08:  XORWF  08,F
....................       }    
0A09:  GOTO   264
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A0A:  BSF    03.5
0A0B:  BSF    06.3
0A0C:  BCF    03.5
0A0D:  BTFSC  06.3
0A0E:  GOTO   264
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A0F:  MOVF   3B,W
0A10:  BSF    03.6
0A11:  MOVWF  3F
0A12:  CLRF   41
0A13:  MOVLW  61
0A14:  MOVWF  40
0A15:  BCF    0A.3
0A16:  BCF    03.6
0A17:  CALL   5FC
0A18:  BSF    0A.3
0A19:  MOVLW  00
0A1A:  BTFSS  78.0
0A1B:  MOVLW  01
0A1C:  BSF    03.6
0A1D:  MOVWF  3D
0A1E:  BCF    03.6
0A1F:  MOVF   3B,W
0A20:  BSF    03.6
0A21:  MOVWF  3E
0A22:  MOVF   3D,W
0A23:  MOVWF  3F
0A24:  CLRF   41
0A25:  MOVLW  61
0A26:  MOVWF  40
0A27:  BCF    0A.3
0A28:  BCF    03.6
0A29:  CALL   615
0A2A:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A2B:  MOVLW  0D
0A2C:  BSF    03.6
0A2D:  MOVWF  41
0A2E:  MOVLW  02
0A2F:  MOVWF  42
0A30:  BCF    0A.3
0A31:  BCF    03.6
0A32:  CALL   3A5
0A33:  BSF    0A.3
....................          DELAY_MS (300); 
0A34:  MOVLW  02
0A35:  BSF    03.6
0A36:  MOVWF  3D
0A37:  MOVLW  96
0A38:  MOVWF  42
0A39:  BCF    0A.3
0A3A:  BCF    03.6
0A3B:  CALL   0D1
0A3C:  BSF    0A.3
0A3D:  BSF    03.6
0A3E:  DECFSZ 3D,F
0A3F:  GOTO   237
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A40:  BCF    03.6
0A41:  MOVF   3B,W
0A42:  BSF    03.6
0A43:  MOVWF  3F
0A44:  CLRF   41
0A45:  MOVLW  61
0A46:  MOVWF  40
0A47:  BCF    0A.3
0A48:  BCF    03.6
0A49:  CALL   5FC
0A4A:  BSF    0A.3
0A4B:  MOVLW  00
0A4C:  BTFSC  78.0
0A4D:  MOVLW  01
0A4E:  BSF    03.6
0A4F:  MOVWF  3D
0A50:  CLRF   42
0A51:  CLRF   41
0A52:  CLRF   40
0A53:  MOVF   3D,W
0A54:  MOVWF  3F
0A55:  MOVLW  0A
0A56:  MOVWF  43
0A57:  CLRF   45
0A58:  MOVLW  72
0A59:  MOVWF  44
0A5A:  BCF    0A.3
0A5B:  BCF    03.6
0A5C:  CALL   4BF
0A5D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A5E:  MOVLW  72
0A5F:  MOVWF  04
0A60:  BCF    03.7
0A61:  BCF    0A.3
0A62:  CALL   5DF
0A63:  BSF    0A.3
....................       }   
0A64:  GOTO   185
....................        
....................    } 
.................... } 
....................  
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0A66:  BCF    5F.1
....................    ID_NODE = 0; 
0A67:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00AB:  BCF    03.6
00AC:  BCF    5F.1
....................    TT_FUN = 0; 
00AD:  BCF    5F.3
....................    TT_STT = 0; 
00AE:  BCF    5F.4
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   268
0805:  ADDLW  04
0806:  GOTO   26B
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   268
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0969:  GOTO   268
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR ();       
....................       BREAK; 
*
0A65:  GOTO   268
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
0A68:  BCF    0A.3
0A69:  BCF    0A.4
0A6A:  GOTO   696 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0637:  BSF    5F.3
....................    LCD_GOTOXY (1, 1) ; 
0638:  MOVLW  01
0639:  BSF    03.6
063A:  MOVWF  41
063B:  MOVWF  42
063C:  BCF    03.6
063D:  CALL   3A5
....................    DELAY_MS (10); 
063E:  MOVLW  0A
063F:  BSF    03.6
0640:  MOVWF  42
0641:  BCF    03.6
0642:  CALL   0D1
....................    PRINTF (LCD_PUTC, "CONFIG"); 
0643:  MOVLW  7C
0644:  BSF    03.6
0645:  MOVWF  0D
0646:  MOVLW  00
0647:  MOVWF  0F
0648:  BCF    03.6
0649:  CALL   3F3
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
064A:  MOVLW  01
064B:  BSF    03.6
064C:  MOVWF  41
064D:  MOVLW  02
064E:  MOVWF  42
064F:  BCF    03.6
0650:  CALL   3A5
....................    DELAY_MS (10); 
0651:  MOVLW  0A
0652:  BSF    03.6
0653:  MOVWF  42
0654:  BCF    03.6
0655:  CALL   0D1
....................    PRINTF (LCD_PUTC, "CASE: "); 
0656:  MOVLW  80
0657:  BSF    03.6
0658:  MOVWF  0D
0659:  MOVLW  00
065A:  MOVWF  0F
065B:  BCF    03.6
065C:  CALL   3F3
....................  
....................    WHILE (TT_FUN) 
065D:  BTFSS  5F.3
065E:  GOTO   692
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
065F:  BSF    03.5
0660:  BSF    06.2
0661:  BCF    03.5
0662:  BTFSC  06.2
0663:  GOTO   691
....................       { 
....................          CONFIG_FUN ++; 
0664:  INCF   38,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0665:  MOVF   38,W
0666:  SUBLW  03
0667:  BTFSS  03.0
0668:  CLRF   38
....................          DELAY_MS (300); 
0669:  MOVLW  02
066A:  BSF    03.6
066B:  MOVWF  3D
066C:  MOVLW  96
066D:  MOVWF  42
066E:  BCF    03.6
066F:  CALL   0D1
0670:  BSF    03.6
0671:  DECFSZ 3D,F
0672:  GOTO   66C
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (9, 2) ; 
0673:  MOVLW  09
0674:  MOVWF  41
0675:  MOVLW  02
0676:  MOVWF  42
0677:  BCF    03.6
0678:  CALL   3A5
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0679:  BSF    03.6
067A:  CLRF   42
067B:  CLRF   41
067C:  CLRF   40
067D:  BCF    03.6
067E:  MOVF   38,W
067F:  BSF    03.6
0680:  MOVWF  3F
0681:  MOVLW  0A
0682:  MOVWF  43
0683:  CLRF   45
0684:  MOVLW  72
0685:  MOVWF  44
0686:  BCF    03.6
0687:  CALL   4BF
....................          DELAY_MS (10); 
0688:  MOVLW  0A
0689:  BSF    03.6
068A:  MOVWF  42
068B:  BCF    03.6
068C:  CALL   0D1
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
068D:  MOVLW  72
068E:  MOVWF  04
068F:  BCF    03.7
0690:  CALL   5DF
....................       } 
0691:  GOTO   65D
....................    } 
....................    ////// 
....................    IF (!TT_CONFIG_DONE){ 
0692:  BTFSC  5F.1
0693:  GOTO   697
....................    SELLECT_FUN (); 
0694:  BSF    0A.3
0695:  GOTO   000
0696:  BCF    0A.3
....................    } 
0697:  BSF    0A.3
0698:  BCF    0A.4
0699:  GOTO   3E2 (RETURN)
....................     
.................... } 
....................  
.................... VOID XULYDEVICES() 
.................... { 
....................    TEMP_CHAR2 = " ";     
*
070C:  BSF    03.6
070D:  CLRF   3F
070E:  CLRF   40
070F:  MOVLW  74
0710:  MOVWF  04
0711:  BCF    03.7
0712:  MOVF   3F,W
0713:  ADDWF  04,F
0714:  MOVF   40,W
0715:  BCF    03.6
0716:  CALL   058
0717:  MOVWF  00
0718:  IORLW  00
0719:  BTFSC  03.2
071A:  GOTO   720
071B:  BSF    03.6
071C:  INCF   40,F
071D:  INCF   3F,F
071E:  GOTO   70F
071F:  BCF    03.6
....................    FOR (INT I = 0; I < 8; I++) 
0720:  BSF    03.6
0721:  CLRF   3E
0722:  MOVF   3E,W
0723:  SUBLW  07
0724:  BTFSS  03.0
0725:  GOTO   74D
....................    { 
....................       IF (TT_DEVICE[I]) 
0726:  MOVF   3E,W
0727:  MOVWF  3F
0728:  CLRF   41
0729:  MOVLW  60
072A:  MOVWF  40
072B:  BCF    03.6
072C:  CALL   5FC
072D:  BTFSS  78.0
072E:  GOTO   74A
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
072F:  BSF    03.6
0730:  CLRF   42
0731:  CLRF   41
0732:  CLRF   40
0733:  MOVF   3E,W
0734:  MOVWF  3F
0735:  MOVLW  0A
0736:  MOVWF  43
0737:  CLRF   45
0738:  MOVLW  74
0739:  MOVWF  44
073A:  BCF    03.6
073B:  CALL   4BF
....................          DELAY_MS (1);          
073C:  MOVLW  01
073D:  BSF    03.6
073E:  MOVWF  42
073F:  BCF    03.6
0740:  CALL   0D1
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0741:  BSF    03.6
0742:  CLRF   40
0743:  MOVLW  62
0744:  MOVWF  3F
0745:  CLRF   42
0746:  MOVLW  74
0747:  MOVWF  41
0748:  BCF    03.6
0749:  CALL   69A
....................       }       
074A:  BSF    03.6
074B:  INCF   3E,F
074C:  GOTO   722
....................    } 
....................    TEMP_CHAR2 = "*"; 
074D:  CLRF   3F
074E:  CLRF   40
074F:  MOVLW  74
0750:  MOVWF  04
0751:  BCF    03.7
0752:  MOVF   3F,W
0753:  ADDWF  04,F
0754:  MOVF   40,W
0755:  BCF    03.6
0756:  CALL   05E
0757:  MOVWF  00
0758:  IORLW  00
0759:  BTFSC  03.2
075A:  GOTO   760
075B:  BSF    03.6
075C:  INCF   40,F
075D:  INCF   3F,F
075E:  GOTO   74F
075F:  BCF    03.6
....................    DELAY_MS (1);          
0760:  MOVLW  01
0761:  BSF    03.6
0762:  MOVWF  42
0763:  BCF    03.6
0764:  CALL   0D1
....................    STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0765:  BSF    03.6
0766:  CLRF   40
0767:  MOVLW  62
0768:  MOVWF  3F
0769:  CLRF   42
076A:  MOVLW  74
076B:  MOVWF  41
076C:  BCF    03.6
076D:  CALL   69A
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR;        
076E:  BSF    03.5
076F:  CLRF   62
0770:  MOVLW  62
0771:  MOVWF  61
....................    //ID 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
06F6:  BCF    5F.3
....................    TT_STT = 0; 
06F7:  BCF    5F.4
....................    TT_DEVICE_CHAR = ""; 
06F8:  BSF    03.6
06F9:  CLRF   3E
06FA:  CLRF   3F
06FB:  MOVLW  62
06FC:  MOVWF  04
06FD:  BCF    03.7
06FE:  MOVF   3E,W
06FF:  ADDWF  04,F
0700:  MOVF   3F,W
0701:  BCF    03.6
0702:  CALL   064
0703:  MOVWF  00
0704:  IORLW  00
0705:  BTFSC  03.2
0706:  GOTO   70C
0707:  BSF    03.6
0708:  INCF   3F,F
0709:  INCF   3E,F
070A:  GOTO   6FB
070B:  BCF    03.6
....................    
....................    XULYDEVICES(); 
....................    PACKAGE_CONFIG[1] = ID_; 
*
0772:  CLRF   5A
0773:  MOVLW  70
0774:  MOVWF  59
....................  
....................    FOR (INT J = 0; J < 8; J++) 
0775:  BCF    03.5
0776:  BSF    03.6
0777:  CLRF   3D
0778:  MOVF   3D,W
0779:  SUBLW  07
077A:  BTFSS  03.0
077B:  GOTO   795
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
077C:  BCF    03.0
077D:  RLF    3D,W
077E:  ADDLW  D7
077F:  MOVWF  04
0780:  BCF    03.7
0781:  INCF   04,F
0782:  MOVF   00,W
0783:  MOVWF  3F
0784:  DECF   04,F
0785:  MOVF   00,W
0786:  MOVWF  3E
0787:  MOVWF  04
0788:  BCF    03.7
0789:  BTFSC  3F.0
078A:  BSF    03.7
078B:  BCF    03.6
078C:  CALL   6D8
....................       DELAY_MS (1); 
078D:  MOVLW  01
078E:  BSF    03.6
078F:  MOVWF  42
0790:  BCF    03.6
0791:  CALL   0D1
0792:  BSF    03.6
0793:  INCF   3D,F
0794:  GOTO   778
....................    } 
....................  
....................    LCD_GOTOXY (1, 2) ; 
0795:  MOVLW  01
0796:  MOVWF  41
0797:  MOVLW  02
0798:  MOVWF  42
0799:  BCF    03.6
079A:  CALL   3A5
....................    DELAY_MS (10); 
079B:  MOVLW  0A
079C:  BSF    03.6
079D:  MOVWF  42
079E:  BCF    03.6
079F:  CALL   0D1
....................    PRINTF (LCD_PUTC, TT_DEVICE_CHAR); 
07A0:  MOVLW  62
07A1:  MOVWF  04
07A2:  BCF    03.7
07A3:  CALL   5DF
....................  
....................    PACKAGE[1] = ID_; 
07A4:  BSF    03.5
07A5:  CLRF   23
07A6:  MOVLW  70
07A7:  MOVWF  22
....................    TT_CONFIG_DONE = 0; 
07A8:  BCF    03.5
07A9:  BCF    5F.1
07AA:  BSF    0A.3
07AB:  BCF    0A.4
07AC:  GOTO   3E8 (RETURN)
.................... } 
....................  
.................... VOID QUET_PHIM() 
*
0084:  BSF    03.6
0085:  CLRF   64
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
0086:  BSF    03.5
0087:  BCF    03.6
0088:  BSF    06.1
0089:  BCF    03.5
008A:  BTFSC  06.1
008B:  GOTO   09F
....................    { 
....................       IF (TMR1IF)       
008C:  BTFSS  0C.0
008D:  GOTO   09C
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
008E:  BSF    03.5
008F:  BCF    08.2
0090:  MOVLW  04
0091:  BCF    03.5
0092:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
0093:  BCF    0C.0
0094:  CLRF   0E
0095:  MOVLW  0B
0096:  MOVWF  0F
0097:  MOVLW  DC
0098:  MOVWF  0E
0099:  BSF    03.6
009A:  INCF   64,F
009B:  BCF    03.6
....................       } 
009C:  BSF    03.6
009D:  GOTO   086
009E:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 30) 
009F:  BSF    03.6
00A0:  MOVF   64,W
00A1:  SUBLW  1E
00A2:  BTFSC  03.0
00A3:  GOTO   0AB
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00A4:  MOVLW  01
00A5:  BCF    03.6
00A6:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00A7:  BSF    5F.1
....................       TT_FUN = 0; 
00A8:  BCF    5F.3
....................    } 
00A9:  GOTO   0AF
00AA:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    }   
.................... } 
....................  
.................... #INT_EXT 
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
....................  
*
00AF:  BCF    0B.1
00B0:  BCF    0A.3
00B1:  BCF    0A.4
00B2:  GOTO   031
.................... #INT_RDA 
.................... VOID NGAT() 
.................... {    
....................    KYTU[VT] = GETCH (); 
00B3:  MOVLW  3C
00B4:  ADDWF  5A,W
00B5:  MOVWF  04
00B6:  BCF    03.7
00B7:  BTFSS  0C.5
00B8:  GOTO   0B7
00B9:  MOVF   1A,W
00BA:  MOVWF  00
....................    IF (KYTU[VT] == '.') 
00BB:  MOVLW  3C
00BC:  ADDWF  5A,W
00BD:  MOVWF  04
00BE:  BCF    03.7
00BF:  MOVF   00,W
00C0:  SUBLW  2E
00C1:  BTFSS  03.2
00C2:  GOTO   0CC
....................    { 
....................       KYTU[VT] = '\0'; 
00C3:  MOVLW  3C
00C4:  ADDWF  5A,W
00C5:  MOVWF  04
00C6:  BCF    03.7
00C7:  CLRF   00
....................       VT = 0; 
00C8:  CLRF   5A
....................       TTNHAN = 1; 
00C9:  MOVLW  01
00CA:  MOVWF  5B
....................    } 
00CB:  GOTO   0CD
....................    ELSE 
....................    VT++; 
00CC:  INCF   5A,F
00CD:  BCF    0C.5
00CE:  BCF    0A.3
00CF:  BCF    0A.4
00D0:  GOTO   031
.................... } 
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07C5:  MOVLW  01
07C6:  BSF    03.6
07C7:  MOVWF  41
07C8:  MOVWF  42
07C9:  BCF    03.6
07CA:  CALL   3A5
....................     DELAY_MS (10); 
07CB:  MOVLW  0A
07CC:  BSF    03.6
07CD:  MOVWF  42
07CE:  BCF    03.6
07CF:  CALL   0D1
....................     PRINTF (LCD_PUTC, KYTU); 
07D0:  MOVLW  3C
07D1:  MOVWF  04
07D2:  BCF    03.7
07D3:  CALL   5DF
....................     DELAY_MS (1); 
07D4:  MOVLW  01
07D5:  BSF    03.6
07D6:  MOVWF  42
07D7:  BCF    03.6
07D8:  CALL   0D1
07D9:  BSF    0A.3
07DA:  BCF    0A.4
07DB:  GOTO   464 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
0251:  BSF    03.6
0252:  RLF    3D,W
0253:  MOVWF  77
0254:  RLF    77,F
0255:  MOVLW  FC
0256:  ANDWF  77,F
0257:  BCF    03.6
0258:  MOVF   1F,W
0259:  ANDLW  C3
025A:  IORWF  77,W
025B:  MOVWF  1F
....................     KQADC = 0; 
025C:  CLRF   33
025D:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
025E:  BSF    03.6
025F:  CLRF   3E
0260:  MOVF   3E,W
0261:  SUBLW  63
0262:  BTFSS  03.0
0263:  GOTO   278
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0264:  BCF    03.6
0265:  BSF    1F.1
0266:  BTFSC  1F.1
0267:  GOTO   266
0268:  BSF    03.5
0269:  MOVF   1E,W
026A:  BCF    03.5
026B:  ADDWF  32,F
026C:  MOVF   1E,W
026D:  BTFSC  03.0
026E:  INCFSZ 1E,W
026F:  ADDWF  33,F
....................        DELAY_MS (1); 
0270:  MOVLW  01
0271:  BSF    03.6
0272:  MOVWF  42
0273:  BCF    03.6
0274:  CALL   0D1
0275:  BSF    03.6
0276:  INCF   3E,F
0277:  GOTO   260
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0278:  BCF    03.6
0279:  MOVF   33,W
027A:  BSF    03.6
027B:  MOVWF  40
027C:  BCF    03.6
027D:  MOVF   32,W
027E:  BSF    03.6
027F:  MOVWF  3F
*
029C:  MOVF   7A,W
029D:  MOVWF  42
029E:  MOVF   79,W
029F:  MOVWF  41
02A0:  MOVF   78,W
02A1:  MOVWF  40
02A2:  MOVF   77,W
02A3:  MOVWF  3F
02A4:  MOVLW  9A
02A5:  MOVWF  46
02A6:  MOVLW  99
02A7:  MOVWF  45
02A8:  MOVLW  4C
02A9:  MOVWF  44
02AA:  MOVLW  86
02AB:  MOVWF  43
*
0375:  MOVF   7A,W
0376:  MOVWF  42
0377:  MOVF   79,W
0378:  MOVWF  41
0379:  MOVF   78,W
037A:  MOVWF  40
037B:  MOVF   77,W
037C:  MOVWF  3F
*
039B:  MOVF   79,W
039C:  BCF    03.6
039D:  MOVWF  33
039E:  MOVF   78,W
039F:  MOVWF  32
....................     RETURN KQADC; 
03A0:  MOVF   32,W
03A1:  MOVWF  78
03A2:  BSF    0A.3
03A3:  BCF    0A.4
03A4:  GOTO   3DA (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07AD:  BSF    03.6
07AE:  CLRF   3D
07AF:  MOVF   3D,W
07B0:  SUBLW  1E
07B1:  BTFSS  03.0
07B2:  GOTO   7C1
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07B3:  BSF    03.5
07B4:  BCF    03.6
07B5:  BCF    08.1
07B6:  MOVLW  02
07B7:  BCF    03.5
07B8:  XORWF  08,F
....................        DELAY_MS (100); 
07B9:  MOVLW  64
07BA:  BSF    03.6
07BB:  MOVWF  42
07BC:  BCF    03.6
07BD:  CALL   0D1
07BE:  BSF    03.6
07BF:  INCF   3D,F
07C0:  GOTO   7AF
....................     } 
07C1:  BCF    03.6
07C2:  BSF    0A.3
07C3:  BCF    0A.4
07C4:  GOTO   3EC (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0A73:  MOVF   03,W
0A74:  ANDLW  1F
0A75:  MOVWF  03
0A76:  BSF    03.5
0A77:  BSF    03.6
0A78:  BSF    07.3
0A79:  MOVLW  08
0A7A:  BCF    03.6
0A7B:  MOVWF  19
0A7C:  MOVLW  02
0A7D:  MOVWF  1A
0A7E:  MOVLW  A6
0A7F:  MOVWF  18
0A80:  MOVLW  90
0A81:  BCF    03.5
0A82:  MOVWF  18
0A83:  MOVLW  FF
0A84:  MOVWF  31
0A85:  CLRF   38
0A86:  CLRF   39
0A87:  CLRF   3A
0A88:  CLRF   3B
0A89:  CLRF   5A
0A8A:  CLRF   5B
0A8B:  BCF    5F.0
0A8C:  BCF    5F.1
0A8D:  BCF    5F.2
0A8E:  BCF    5F.3
0A8F:  BCF    5F.4
0A90:  BSF    03.5
0A91:  BSF    03.6
0A92:  MOVF   09,W
0A93:  ANDLW  C0
0A94:  MOVWF  09
0A95:  BCF    03.6
0A96:  BCF    1F.4
0A97:  BCF    1F.5
0A98:  MOVLW  00
0A99:  BSF    03.6
0A9A:  MOVWF  08
0A9B:  BCF    03.5
0A9C:  CLRF   07
0A9D:  CLRF   08
0A9E:  CLRF   09
0A9F:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0B99:  MOVLW  00
0B9A:  BSF    03.5
0B9B:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0B9C:  MOVLW  FF
0B9D:  MOVWF  06
....................     SET_TRIS_E (0); 
0B9E:  BCF    09.0
0B9F:  BCF    09.1
0BA0:  BCF    09.2
0BA1:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0BA2:  MOVLW  80
0BA3:  MOVWF  07
0BA4:  BCF    03.5
0BA5:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0BA6:  BSF    1F.6
0BA7:  BCF    1F.7
0BA8:  BSF    03.5
0BA9:  BSF    1F.7
0BAA:  BCF    03.5
0BAB:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0BAC:  BSF    03.5
0BAD:  BSF    03.6
0BAE:  MOVF   09,W
0BAF:  ANDLW  C0
0BB0:  MOVWF  09
0BB1:  BCF    03.6
0BB2:  BCF    1F.4
0BB3:  BCF    1F.5
0BB4:  MOVLW  01
0BB5:  BSF    03.6
0BB6:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0BB7:  BCF    03.5
0BB8:  BCF    03.6
0BB9:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0BBA:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0BBB:  BSF    0B.4
0BBC:  BSF    03.5
0BBD:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0BBE:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0BBF:  MOVLW  C0
0BC0:  BCF    03.5
0BC1:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8) ; 
0BC2:  MOVLW  35
0BC3:  MOVWF  10
....................     //SET_TIMER1 (0) ; 
....................     SET_TIMER1 (3036) ; 
0BC4:  CLRF   0E
0BC5:  MOVLW  0B
0BC6:  MOVWF  0F
0BC7:  MOVLW  DC
0BC8:  MOVWF  0E
....................     TMR1IF = 0; 
0BC9:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0BCA:  BCF    0A.3
0BCB:  GOTO   1EB
0BCC:  BSF    0A.3
....................     ID_NODE = 0; 
0BCD:  CLRF   39
....................     TT_CONFIG = 0; 
0BCE:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0BCF:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0BD0:  BSF    03.5
0BD1:  CLRF   08
0BD2:  BCF    03.5
0BD3:  CLRF   08
....................     TTNHAN = 0; 
0BD4:  CLRF   5B
....................               
....................                 
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0BD5:  BSF    03.6
0BD6:  CLRF   3D
0BD7:  BCF    0A.3
0BD8:  BCF    03.6
0BD9:  GOTO   251
0BDA:  BSF    0A.3
0BDB:  CLRF   35
0BDC:  MOVF   78,W
0BDD:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0BDE:  BTFSS  5F.0
0BDF:  GOTO   3E4
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0BE0:  BCF    0A.3
0BE1:  GOTO   637
0BE2:  BSF    0A.3
....................        } 
0BE3:  GOTO   486
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0BE4:  BTFSS  5F.1
0BE5:  GOTO   3EA
....................        { 
....................           CONFIG_DONE () ; 
0BE6:  BCF    0A.3
0BE7:  GOTO   6F6
0BE8:  BSF    0A.3
....................        } 
0BE9:  GOTO   486
....................         
....................        ELSE  
....................        { 
....................         
....................         
....................        CHUONG_TRINH_CON (); 
0BEA:  BCF    0A.3
0BEB:  GOTO   7AD
0BEC:  BSF    0A.3
....................  
....................        IF (AN0 > 26) 
0BED:  MOVF   35,F
0BEE:  BTFSS  03.2
0BEF:  GOTO   3F4
0BF0:  MOVF   34,W
0BF1:  SUBLW  1A
0BF2:  BTFSC  03.0
0BF3:  GOTO   455
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0BF4:  BSF    03.6
0BF5:  CLRF   42
0BF6:  CLRF   41
0BF7:  BCF    03.6
0BF8:  MOVF   35,W
0BF9:  BSF    03.6
0BFA:  MOVWF  40
0BFB:  BCF    03.6
0BFC:  MOVF   34,W
0BFD:  BSF    03.6
0BFE:  MOVWF  3F
0BFF:  MOVLW  0A
0C00:  MOVWF  43
0C01:  CLRF   45
0C02:  MOVLW  6A
0C03:  MOVWF  44
0C04:  BCF    0A.3
0C05:  BCF    03.6
0C06:  CALL   4BF
0C07:  BSF    0A.3
....................           PACKAGE[4] = NHIETDO1; 
0C08:  BSF    03.5
0C09:  CLRF   29
0C0A:  MOVLW  6A
0C0B:  MOVWF  28
....................           ITOA (AN1, 10, NHIETDO2); 
0C0C:  BCF    03.5
0C0D:  BSF    03.6
0C0E:  CLRF   42
0C0F:  CLRF   41
0C10:  BCF    03.6
0C11:  MOVF   37,W
0C12:  BSF    03.6
0C13:  MOVWF  40
0C14:  BCF    03.6
0C15:  MOVF   36,W
0C16:  BSF    03.6
0C17:  MOVWF  3F
0C18:  MOVLW  0A
0C19:  MOVWF  43
0C1A:  CLRF   45
0C1B:  MOVLW  6D
0C1C:  MOVWF  44
0C1D:  BCF    0A.3
0C1E:  BCF    03.6
0C1F:  CALL   4BF
0C20:  BSF    0A.3
....................           PACKAGE[5] = NHIETDO2; 
0C21:  BSF    03.5
0C22:  CLRF   2B
0C23:  MOVLW  6D
0C24:  MOVWF  2A
....................            
....................           FOR (INT I = 0; I < 8; I++) 
0C25:  BCF    03.5
0C26:  BSF    03.6
0C27:  CLRF   3C
0C28:  MOVF   3C,W
0C29:  SUBLW  07
0C2A:  BTFSS  03.0
0C2B:  GOTO   449
....................           { 
....................              PRINTF (PACKAGE[I]); 
0C2C:  BCF    03.0
0C2D:  RLF    3C,W
0C2E:  ADDLW  A0
0C2F:  MOVWF  04
0C30:  BCF    03.7
0C31:  INCF   04,F
0C32:  MOVF   00,W
0C33:  MOVWF  3E
0C34:  DECF   04,F
0C35:  MOVF   00,W
0C36:  MOVWF  3D
0C37:  MOVWF  04
0C38:  BCF    03.7
0C39:  BTFSC  3E.0
0C3A:  BSF    03.7
0C3B:  BCF    0A.3
0C3C:  BCF    03.6
0C3D:  CALL   6D8
0C3E:  BSF    0A.3
....................              DELAY_MS (1); 
0C3F:  MOVLW  01
0C40:  BSF    03.6
0C41:  MOVWF  42
0C42:  BCF    0A.3
0C43:  BCF    03.6
0C44:  CALL   0D1
0C45:  BSF    0A.3
0C46:  BSF    03.6
0C47:  INCF   3C,F
0C48:  GOTO   428
....................           } 
....................  
....................           DELAY_MS (1000); 
0C49:  MOVLW  04
0C4A:  MOVWF  3D
0C4B:  MOVLW  FA
0C4C:  MOVWF  42
0C4D:  BCF    0A.3
0C4E:  BCF    03.6
0C4F:  CALL   0D1
0C50:  BSF    0A.3
0C51:  BSF    03.6
0C52:  DECFSZ 3D,F
0C53:  GOTO   44B
0C54:  BCF    03.6
....................        } 
....................  
....................        IF (TTNHAN == 1) 
0C55:  DECFSZ 5B,W
0C56:  GOTO   486
....................        { 
....................            
....................           TTNHAN = 0; 
0C57:  CLRF   5B
....................           //TEMP_CHAR = 'K'; 
....................           ID_NODE_NHAN = KYTU[1]-48; 
0C58:  MOVLW  30
0C59:  SUBWF  3D,W
0C5A:  MOVWF  5C
....................           ID_DEVICE_NHAN =KYTU[2]-48 + 64; 
0C5B:  MOVLW  30
0C5C:  SUBWF  3E,W
0C5D:  ADDLW  40
0C5E:  MOVWF  5D
....................           TT_DEVICE_NHAN = KYTU[3]-48;// -48 ASCII --> S?. +64 -->PORT_D (D0=64) 
0C5F:  MOVLW  30
0C60:  SUBWF  3F,W
0C61:  MOVWF  5E
....................           XUATLCD ();                 
0C62:  BCF    0A.3
0C63:  GOTO   7C5
0C64:  BSF    0A.3
....................           IF(ID_NODE_NHAN == ID_NODE) 
0C65:  MOVF   39,W
0C66:  SUBWF  5C,W
0C67:  BTFSS  03.2
0C68:  GOTO   486
....................           { 
....................                OUTPUT_BIT (ID_DEVICE_NHAN,TT_DEVICE_NHAN);  
0C69:  MOVF   5E,F
0C6A:  BTFSS  03.2
0C6B:  GOTO   46E
0C6C:  MOVLW  00
0C6D:  GOTO   46F
0C6E:  MOVLW  01
0C6F:  MOVWF  77
0C70:  MOVF   5D,W
0C71:  BSF    03.6
0C72:  MOVWF  3E
0C73:  MOVF   77,W
0C74:  MOVWF  3F
0C75:  CLRF   41
0C76:  CLRF   40
0C77:  BCF    0A.3
0C78:  BCF    03.6
0C79:  CALL   615
0C7A:  BSF    0A.3
0C7B:  MOVF   5D,W
0C7C:  BSF    03.6
0C7D:  MOVWF  3E
0C7E:  CLRF   3F
0C7F:  CLRF   41
0C80:  MOVLW  80
0C81:  MOVWF  40
0C82:  BCF    0A.3
0C83:  BCF    03.6
0C84:  CALL   615
0C85:  BSF    0A.3
....................           } 
....................  
....................        } 
....................     
....................         
....................        } 
0C86:  GOTO   3D5
....................     } 
....................  } 
....................  
0C87:  SLEEP
....................  
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
