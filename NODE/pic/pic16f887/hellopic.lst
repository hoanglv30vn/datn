CCS PCM C Compiler, Version 5.015, 5967               26-Oct-21 01:55

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4132 words (50%)
                           Largest free fragment is 2048
               RAM used:   234 (64%) at main() level
                           279 (76%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0DC
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   115
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  00
0063:  BCF    0A.0
0064:  BCF    0A.1
0065:  BCF    0A.2
0066:  ADDWF  02,F
0067:  RETLW  5F
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 00,00
0072:  DATA C4,22
0073:  DATA D6,24
0074:  DATA C3,22
0075:  DATA 3A,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 00,01
007C:  DATA D3,22
007D:  DATA CE,29
007E:  DATA 4F,29
007F:  DATA 3A,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 00,01
0085:  DATA 49,22
0086:  DATA DF,23
0087:  DATA 57,1D
0088:  DATA 20,10
0089:  DATA 30,18
008A:  DATA 30,18
008B:  DATA 20,00
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 5F,10
0091:  DATA 20,10
0092:  DATA 20,00
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 5F,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA C3,27
0099:  DATA 4E,23
009A:  DATA C9,23
009B:  DATA 3A,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,00
00A0:  DATA C3,20
00A1:  DATA D3,22
00A2:  DATA 3A,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 20,00
00A8:  DATA A0,16
00A9:  DATA A0,24
00AA:  DATA 44,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 00,01
00B0:  DATA A0,16
00B1:  DATA 20,22
00B2:  DATA 45,2B
00B3:  DATA C9,21
00B4:  DATA C5,29
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 00,01
00B8:  DATA A0,16
00B9:  DATA A0,29
00BA:  DATA 45,27
00BB:  DATA D3,27
00BC:  DATA D2,29
00BD:  DATA 20,10
00BE:  DATA 20,10
00BF:  DATA 00,01
00C0:  DATA A0,16
00C1:  DATA A0,24
00C2:  DATA 44,10
00C3:  DATA 2D,10
00C4:  DATA C7,2B
00C5:  DATA 3A,10
00C6:  DATA 20,10
00C7:  DATA 20,00
00C8:  DATA C3,27
00C9:  DATA 4E,23
00CA:  DATA C9,23
00CB:  DATA 20,22
00CC:  DATA 4F,27
00CD:  DATA 45,10
00CE:  DATA 20,10
00CF:  DATA 20,10
00D0:  DATA 20,10
00D1:  DATA 20,00
00D2:  DATA C3,27
00D3:  DATA 4E,23
00D4:  DATA C9,23
00D5:  DATA 20,22
00D6:  DATA 4F,27
00D7:  DATA 45,10
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,00
*
0300:  MOVF   0B,W
0301:  BSF    03.6
0302:  MOVWF  4D
0303:  BCF    03.6
0304:  BCF    0B.7
0305:  BSF    03.5
0306:  BSF    03.6
0307:  BSF    0C.7
0308:  BSF    0C.0
0309:  NOP
030A:  NOP
030B:  BCF    03.5
030C:  BTFSS  4D.7
030D:  GOTO   311
030E:  BCF    03.6
030F:  BSF    0B.7
0310:  BSF    03.6
0311:  MOVF   0C,W
0312:  ANDLW  7F
0313:  BTFSC  03.2
0314:  GOTO   34E
0315:  MOVWF  4D
0316:  MOVF   0D,W
0317:  MOVWF  4E
0318:  MOVF   0F,W
0319:  MOVWF  4F
031A:  MOVF   4D,W
031B:  MOVWF  50
031C:  BCF    03.6
031D:  CALL   2C6
031E:  BSF    03.6
031F:  MOVF   4E,W
0320:  MOVWF  0D
0321:  MOVF   4F,W
0322:  MOVWF  0F
0323:  BCF    03.6
0324:  MOVF   0B,W
0325:  BSF    03.6
0326:  MOVWF  50
0327:  BCF    03.6
0328:  BCF    0B.7
0329:  BSF    03.5
032A:  BSF    03.6
032B:  BSF    0C.7
032C:  BSF    0C.0
032D:  NOP
032E:  NOP
032F:  BCF    03.5
0330:  BTFSS  50.7
0331:  GOTO   335
0332:  BCF    03.6
0333:  BSF    0B.7
0334:  BSF    03.6
0335:  RLF    0C,W
0336:  RLF    0E,W
0337:  ANDLW  7F
0338:  BTFSC  03.2
0339:  GOTO   34E
033A:  MOVWF  4D
033B:  MOVF   0D,W
033C:  MOVWF  4E
033D:  MOVF   0F,W
033E:  MOVWF  4F
033F:  MOVF   4D,W
0340:  MOVWF  50
0341:  BCF    03.6
0342:  CALL   2C6
0343:  BSF    03.6
0344:  MOVF   4E,W
0345:  MOVWF  0D
0346:  MOVF   4F,W
0347:  MOVWF  0F
0348:  INCF   0D,F
0349:  BTFSC  03.2
034A:  INCF   0F,F
034B:  BCF    03.6
034C:  GOTO   300
034D:  BSF    03.6
034E:  BCF    03.6
034F:  RETURN
0350:  BTFSC  03.1
0351:  GOTO   355
0352:  MOVLW  90
0353:  MOVWF  04
0354:  BSF    03.7
0355:  BSF    03.6
0356:  MOVF   68,W
0357:  XORWF  6C,W
0358:  ANDLW  80
0359:  BSF    03.5
035A:  MOVWF  15
035B:  BCF    03.5
035C:  BTFSS  68.7
035D:  GOTO   369
035E:  COMF   65,F
035F:  COMF   66,F
0360:  COMF   67,F
0361:  COMF   68,F
0362:  INCF   65,F
0363:  BTFSC  03.2
0364:  INCF   66,F
0365:  BTFSC  03.2
0366:  INCF   67,F
0367:  BTFSC  03.2
0368:  INCF   68,F
0369:  BTFSS  6C.7
036A:  GOTO   376
036B:  COMF   69,F
036C:  COMF   6A,F
036D:  COMF   6B,F
036E:  COMF   6C,F
036F:  INCF   69,F
0370:  BTFSC  03.2
0371:  INCF   6A,F
0372:  BTFSC  03.2
0373:  INCF   6B,F
0374:  BTFSC  03.2
0375:  INCF   6C,F
0376:  CLRF   77
0377:  CLRF   78
0378:  CLRF   79
0379:  CLRF   7A
037A:  BSF    03.5
037B:  CLRF   10
037C:  CLRF   11
037D:  CLRF   12
037E:  CLRF   13
037F:  BCF    03.5
0380:  MOVF   6C,W
0381:  IORWF  6B,W
0382:  IORWF  6A,W
0383:  IORWF  69,W
0384:  BTFSC  03.2
0385:  GOTO   3D2
0386:  MOVLW  20
0387:  BSF    03.5
0388:  MOVWF  14
0389:  BCF    03.0
038A:  BCF    03.5
038B:  RLF    65,F
038C:  RLF    66,F
038D:  RLF    67,F
038E:  RLF    68,F
038F:  BSF    03.5
0390:  RLF    10,F
0391:  RLF    11,F
0392:  RLF    12,F
0393:  RLF    13,F
0394:  BCF    03.5
0395:  MOVF   6C,W
0396:  BSF    03.5
0397:  SUBWF  13,W
0398:  BTFSS  03.2
0399:  GOTO   3AA
039A:  BCF    03.5
039B:  MOVF   6B,W
039C:  BSF    03.5
039D:  SUBWF  12,W
039E:  BTFSS  03.2
039F:  GOTO   3AA
03A0:  BCF    03.5
03A1:  MOVF   6A,W
03A2:  BSF    03.5
03A3:  SUBWF  11,W
03A4:  BTFSS  03.2
03A5:  GOTO   3AA
03A6:  BCF    03.5
03A7:  MOVF   69,W
03A8:  BSF    03.5
03A9:  SUBWF  10,W
03AA:  BTFSS  03.0
03AB:  GOTO   3CB
03AC:  BCF    03.5
03AD:  MOVF   69,W
03AE:  BSF    03.5
03AF:  SUBWF  10,F
03B0:  BCF    03.5
03B1:  MOVF   6A,W
03B2:  BTFSS  03.0
03B3:  INCFSZ 6A,W
03B4:  GOTO   3B6
03B5:  GOTO   3B9
03B6:  BSF    03.5
03B7:  SUBWF  11,F
03B8:  BCF    03.5
03B9:  MOVF   6B,W
03BA:  BTFSS  03.0
03BB:  INCFSZ 6B,W
03BC:  GOTO   3BE
03BD:  GOTO   3C1
03BE:  BSF    03.5
03BF:  SUBWF  12,F
03C0:  BCF    03.5
03C1:  MOVF   6C,W
03C2:  BTFSS  03.0
03C3:  INCFSZ 6C,W
03C4:  GOTO   3C6
03C5:  GOTO   3C9
03C6:  BSF    03.5
03C7:  SUBWF  13,F
03C8:  BCF    03.5
03C9:  BSF    03.0
03CA:  BSF    03.5
03CB:  RLF    77,F
03CC:  RLF    78,F
03CD:  RLF    79,F
03CE:  RLF    7A,F
03CF:  DECFSZ 14,F
03D0:  GOTO   389
03D1:  BCF    03.5
03D2:  BSF    03.5
03D3:  BTFSS  15.7
03D4:  GOTO   3E0
03D5:  COMF   77,F
03D6:  COMF   78,F
03D7:  COMF   79,F
03D8:  COMF   7A,F
03D9:  INCF   77,F
03DA:  BTFSC  03.2
03DB:  INCF   78,F
03DC:  BTFSC  03.2
03DD:  INCF   79,F
03DE:  BTFSC  03.2
03DF:  INCF   7A,F
03E0:  MOVF   10,W
03E1:  MOVWF  00
03E2:  INCF   04,F
03E3:  MOVF   11,W
03E4:  MOVWF  00
03E5:  INCF   04,F
03E6:  MOVF   12,W
03E7:  MOVWF  00
03E8:  INCF   04,F
03E9:  MOVF   13,W
03EA:  MOVWF  00
03EB:  BCF    03.5
03EC:  BCF    03.6
03ED:  RETURN
*
0407:  MOVLW  20
0408:  MOVWF  69
0409:  CLRF   65
040A:  CLRF   66
040B:  CLRF   67
040C:  CLRF   68
040D:  MOVF   60,W
040E:  MOVWF  7A
040F:  MOVF   5F,W
0410:  MOVWF  79
0411:  MOVF   5E,W
0412:  MOVWF  78
0413:  MOVF   5D,W
0414:  MOVWF  77
0415:  BCF    03.0
0416:  BTFSS  77.0
0417:  GOTO   426
0418:  MOVF   61,W
0419:  ADDWF  65,F
041A:  MOVF   62,W
041B:  BTFSC  03.0
041C:  INCFSZ 62,W
041D:  ADDWF  66,F
041E:  MOVF   63,W
041F:  BTFSC  03.0
0420:  INCFSZ 63,W
0421:  ADDWF  67,F
0422:  MOVF   64,W
0423:  BTFSC  03.0
0424:  INCFSZ 64,W
0425:  ADDWF  68,F
0426:  RRF    68,F
0427:  RRF    67,F
0428:  RRF    66,F
0429:  RRF    65,F
042A:  RRF    7A,F
042B:  RRF    79,F
042C:  RRF    78,F
042D:  RRF    77,F
042E:  DECFSZ 69,F
042F:  GOTO   415
*
050E:  MOVF   00,F
050F:  BTFSC  03.2
0510:  GOTO   52A
0511:  BSF    03.6
0512:  CLRF   4E
0513:  MOVF   04,W
0514:  MOVWF  4D
0515:  BCF    4E.0
0516:  BTFSC  03.7
0517:  BSF    4E.0
0518:  MOVF   00,W
0519:  MOVWF  50
051A:  BCF    03.6
051B:  CALL   2C6
051C:  BSF    03.6
051D:  MOVF   4D,W
051E:  MOVWF  04
051F:  BCF    03.7
0520:  BTFSC  4E.0
0521:  BSF    03.7
0522:  INCF   04,F
0523:  BTFSS  03.2
0524:  GOTO   528
0525:  BCF    03.6
0526:  INCF   05,F
0527:  BSF    03.6
0528:  BCF    03.6
0529:  GOTO   50E
052A:  RETURN
052B:  BSF    03.6
052C:  MOVF   4E,W
052D:  ANDLW  07
052E:  MOVWF  77
052F:  RRF    4E,W
0530:  MOVWF  78
0531:  RRF    78,F
0532:  RRF    78,F
0533:  MOVLW  1F
0534:  ANDWF  78,F
0535:  MOVF   78,W
0536:  ADDWF  4F,W
0537:  MOVWF  04
0538:  BCF    03.7
0539:  BTFSC  50.0
053A:  BSF    03.7
053B:  MOVF   00,W
053C:  MOVWF  78
053D:  INCF   77,F
053E:  GOTO   540
053F:  RRF    78,F
0540:  DECFSZ 77,F
0541:  GOTO   53F
0542:  BCF    03.6
0543:  RETURN
0544:  BSF    03.6
0545:  MOVF   4D,W
0546:  ANDLW  07
0547:  MOVWF  77
0548:  RRF    4D,W
0549:  MOVWF  78
054A:  RRF    78,F
054B:  RRF    78,F
054C:  MOVLW  1F
054D:  ANDWF  78,F
054E:  MOVF   78,W
054F:  ADDWF  4F,W
0550:  MOVWF  04
0551:  BCF    03.7
0552:  BTFSC  50.0
0553:  BSF    03.7
0554:  CLRF   78
0555:  INCF   78,F
0556:  INCF   77,F
0557:  GOTO   559
0558:  RLF    78,F
0559:  DECFSZ 77,F
055A:  GOTO   558
055B:  MOVF   4E,F
055C:  BTFSC  03.2
055D:  GOTO   561
055E:  MOVF   78,W
055F:  IORWF  00,F
0560:  GOTO   564
0561:  COMF   78,F
0562:  MOVF   78,W
0563:  ANDWF  00,F
0564:  BCF    03.6
0565:  RETURN
*
05EC:  BSF    0A.0
05ED:  BCF    0A.1
05EE:  BSF    0A.2
05EF:  ADDWF  02,F
05F0:  GOTO   5C4
05F1:  GOTO   5CC
05F2:  GOTO   5D4
05F3:  GOTO   5DC
*
0632:  MOVF   00,F
0633:  BTFSC  03.2
0634:  GOTO   64F
0635:  BSF    03.6
0636:  CLRF   50
0637:  MOVF   04,W
0638:  MOVWF  4F
0639:  BCF    50.0
063A:  BTFSC  03.7
063B:  BSF    50.0
063C:  MOVF   00,W
063D:  BCF    03.6
063E:  BTFSS  0C.4
063F:  GOTO   63E
0640:  MOVWF  19
0641:  BSF    03.6
0642:  MOVF   4F,W
0643:  MOVWF  04
0644:  BCF    03.7
0645:  BTFSC  50.0
0646:  BSF    03.7
0647:  INCF   04,F
0648:  BTFSS  03.2
0649:  GOTO   64D
064A:  BCF    03.6
064B:  INCF   05,F
064C:  BSF    03.6
064D:  BCF    03.6
064E:  GOTO   632
064F:  RETURN
*
0B0A:  MOVF   51,W
0B0B:  CLRF   78
0B0C:  SUBWF  50,W
0B0D:  BTFSC  03.0
0B0E:  GOTO   312
0B0F:  MOVF   50,W
0B10:  MOVWF  77
0B11:  GOTO   31E
0B12:  CLRF   77
0B13:  MOVLW  08
0B14:  MOVWF  52
0B15:  RLF    50,F
0B16:  RLF    77,F
0B17:  MOVF   51,W
0B18:  SUBWF  77,W
0B19:  BTFSC  03.0
0B1A:  MOVWF  77
0B1B:  RLF    78,F
0B1C:  DECFSZ 52,F
0B1D:  GOTO   315
*
0B64:  BSF    0A.0
0B65:  BSF    0A.1
0B66:  BCF    0A.2
0B67:  ADDWF  02,F
0B68:  GOTO   007
0B69:  GOTO   06E
0B6A:  GOTO   176
0B6B:  GOTO   27E
*
0CCC:  CLRF   77
0CCD:  CLRF   78
0CCE:  MOVF   53,W
0CCF:  BCF    03.0
0CD0:  BTFSC  54.0
0CD1:  ADDWF  77,F
0CD2:  RRF    77,F
0CD3:  RRF    78,F
0CD4:  BTFSC  54.1
0CD5:  ADDWF  77,F
0CD6:  RRF    77,F
0CD7:  RRF    78,F
0CD8:  BTFSC  54.2
0CD9:  ADDWF  77,F
0CDA:  RRF    77,F
0CDB:  RRF    78,F
0CDC:  BTFSC  54.3
0CDD:  ADDWF  77,F
0CDE:  RRF    77,F
0CDF:  RRF    78,F
0CE0:  BTFSC  54.4
0CE1:  ADDWF  77,F
0CE2:  RRF    77,F
0CE3:  RRF    78,F
0CE4:  BTFSC  54.5
0CE5:  ADDWF  77,F
0CE6:  RRF    77,F
0CE7:  RRF    78,F
0CE8:  BTFSC  54.6
0CE9:  ADDWF  77,F
0CEA:  RRF    77,F
0CEB:  RRF    78,F
0CEC:  BTFSC  54.7
0CED:  ADDWF  77,F
0CEE:  RRF    77,F
0CEF:  RRF    78,F
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05F4:  BSF    03.6
05F5:  MOVF   4F,W
05F6:  MOVWF  53
05F7:  MOVF   4E,W
05F8:  MOVWF  52
05F9:  MOVF   53,W
05FA:  MOVWF  7A
05FB:  MOVF   52,W
05FC:  MOVWF  04
05FD:  BCF    03.7
05FE:  BTFSC  7A.0
05FF:  BSF    03.7
0600:  MOVF   00,F
0601:  BTFSC  03.2
0602:  GOTO   607
0603:  INCF   52,F
0604:  BTFSC  03.2
0605:  INCF   53,F
0606:  GOTO   5F9
....................    while(*s2 != '\0') 
0607:  MOVF   51,W
0608:  MOVWF  7A
0609:  MOVF   50,W
060A:  MOVWF  04
060B:  BCF    03.7
060C:  BTFSC  7A.0
060D:  BSF    03.7
060E:  MOVF   00,F
060F:  BTFSC  03.2
0610:  GOTO   626
....................    { 
....................       *s = *s2; 
0611:  MOVF   50,W
0612:  MOVWF  04
0613:  BCF    03.7
0614:  BTFSC  51.0
0615:  BSF    03.7
0616:  MOVF   00,W
0617:  MOVWF  56
0618:  MOVF   52,W
0619:  MOVWF  04
061A:  BCF    03.7
061B:  BTFSC  53.0
061C:  BSF    03.7
061D:  MOVF   56,W
061E:  MOVWF  00
....................       ++s; 
061F:  INCF   52,F
0620:  BTFSC  03.2
0621:  INCF   53,F
....................       ++s2; 
0622:  INCF   50,F
0623:  BTFSC  03.2
0624:  INCF   51,F
0625:  GOTO   607
....................    } 
....................  
....................    *s = '\0'; 
0626:  MOVF   52,W
0627:  MOVWF  04
0628:  BCF    03.7
0629:  BTFSC  53.0
062A:  BSF    03.7
062B:  CLRF   00
....................    return(s1); 
062C:  MOVF   4E,W
062D:  MOVWF  78
062E:  MOVF   4F,W
062F:  MOVWF  79
0630:  BCF    03.6
0631:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0BF8:  MOVF   55,W
0BF9:  MOVWF  59
0BFA:  MOVF   54,W
0BFB:  MOVWF  58
0BFC:  MOVF   59,W
0BFD:  MOVWF  7A
0BFE:  MOVF   58,W
0BFF:  MOVWF  04
0C00:  BCF    03.7
0C01:  BTFSC  7A.0
0C02:  BSF    03.7
0C03:  MOVF   00,F
0C04:  BTFSC  03.2
0C05:  GOTO   435
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0C06:  MOVF   57,W
0C07:  MOVWF  5B
0C08:  MOVF   56,W
0C09:  MOVWF  5A
0C0A:  MOVF   5B,W
0C0B:  MOVWF  7A
0C0C:  MOVF   5A,W
0C0D:  MOVWF  04
0C0E:  BCF    03.7
0C0F:  BTFSC  7A.0
0C10:  BSF    03.7
0C11:  MOVF   00,F
0C12:  BTFSC  03.2
0C13:  GOTO   431
....................          if (*sc1 == *sc2) 
0C14:  MOVF   59,W
0C15:  MOVWF  7A
0C16:  MOVF   58,W
0C17:  MOVWF  04
0C18:  BCF    03.7
0C19:  BTFSC  7A.0
0C1A:  BSF    03.7
0C1B:  MOVF   00,W
0C1C:  MOVWF  5C
0C1D:  MOVF   5B,W
0C1E:  MOVWF  7A
0C1F:  MOVF   5A,W
0C20:  MOVWF  04
0C21:  BCF    03.7
0C22:  BTFSC  7A.0
0C23:  BSF    03.7
0C24:  MOVF   00,W
0C25:  SUBWF  5C,W
0C26:  BTFSS  03.2
0C27:  GOTO   42D
....................             return(sc1); 
0C28:  MOVF   58,W
0C29:  MOVWF  78
0C2A:  MOVF   59,W
0C2B:  MOVWF  79
0C2C:  GOTO   438
0C2D:  INCF   5A,F
0C2E:  BTFSC  03.2
0C2F:  INCF   5B,F
0C30:  GOTO   40A
0C31:  INCF   58,F
0C32:  BTFSC  03.2
0C33:  INCF   59,F
0C34:  GOTO   3FC
....................    return(0); 
0C35:  MOVLW  00
0C36:  MOVWF  78
0C37:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0B85:  MOVF   55,W
0B86:  MOVWF  59
0B87:  MOVF   54,W
0B88:  MOVWF  58
0B89:  MOVF   59,W
0B8A:  MOVWF  7A
0B8B:  MOVF   58,W
0B8C:  MOVWF  04
0B8D:  BCF    03.7
0B8E:  BTFSC  7A.0
0B8F:  BSF    03.7
0B90:  MOVF   00,F
0B91:  BTFSC  03.2
0B92:  GOTO   3CA
....................       for (sc2 = s2; ; sc2++) 
0B93:  MOVF   57,W
0B94:  MOVWF  5B
0B95:  MOVF   56,W
0B96:  MOVWF  5A
....................     if (*sc2 == '\0') 
0B97:  MOVF   5B,W
0B98:  MOVWF  7A
0B99:  MOVF   5A,W
0B9A:  MOVWF  04
0B9B:  BCF    03.7
0B9C:  BTFSC  7A.0
0B9D:  BSF    03.7
0B9E:  MOVF   00,F
0B9F:  BTFSS  03.2
0BA0:  GOTO   3AE
....................        return(sc1 - s1); 
0BA1:  MOVF   54,W
0BA2:  SUBWF  58,W
0BA3:  MOVWF  77
0BA4:  MOVF   59,W
0BA5:  MOVWF  7A
0BA6:  MOVF   55,W
0BA7:  BTFSS  03.0
0BA8:  INCFSZ 55,W
0BA9:  SUBWF  7A,F
0BAA:  MOVF   77,W
0BAB:  MOVWF  78
0BAC:  GOTO   3D5
0BAD:  GOTO   3C2
....................          else if (*sc1 == *sc2) 
0BAE:  MOVF   59,W
0BAF:  MOVWF  7A
0BB0:  MOVF   58,W
0BB1:  MOVWF  04
0BB2:  BCF    03.7
0BB3:  BTFSC  7A.0
0BB4:  BSF    03.7
0BB5:  MOVF   00,W
0BB6:  MOVWF  5C
0BB7:  MOVF   5B,W
0BB8:  MOVWF  7A
0BB9:  MOVF   5A,W
0BBA:  MOVWF  04
0BBB:  BCF    03.7
0BBC:  BTFSC  7A.0
0BBD:  BSF    03.7
0BBE:  MOVF   00,W
0BBF:  SUBWF  5C,W
0BC0:  BTFSC  03.2
....................             break; 
0BC1:  GOTO   3C6
0BC2:  INCF   5A,F
0BC3:  BTFSC  03.2
0BC4:  INCF   5B,F
0BC5:  GOTO   397
0BC6:  INCF   58,F
0BC7:  BTFSC  03.2
0BC8:  INCF   59,F
0BC9:  GOTO   389
....................    return(sc1 - s1); 
0BCA:  MOVF   54,W
0BCB:  SUBWF  58,W
0BCC:  MOVWF  77
0BCD:  MOVF   59,W
0BCE:  MOVWF  7A
0BCF:  MOVF   55,W
0BD0:  BTFSS  03.0
0BD1:  INCFSZ 55,W
0BD2:  SUBWF  7A,F
0BD3:  MOVF   77,W
0BD4:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
102F:  BCF    03.6
1030:  CLRF   2B
1031:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0B6C:  BSF    03.6
0B6D:  MOVF   4C,W
0B6E:  IORWF  4D,W
0B6F:  BTFSC  03.2
0B70:  GOTO   375
0B71:  MOVF   4D,W
0B72:  MOVWF  7A
0B73:  MOVF   4C,W
0B74:  GOTO   37A
0B75:  BCF    03.6
0B76:  MOVF   2C,W
0B77:  MOVWF  7A
0B78:  MOVF   2B,W
0B79:  BSF    03.6
0B7A:  MOVWF  50
0B7B:  MOVF   7A,W
0B7C:  MOVWF  51
....................    beg += strspn(beg, s2); 
0B7D:  MOVF   51,W
0B7E:  MOVWF  55
0B7F:  MOVF   50,W
0B80:  MOVWF  54
0B81:  MOVF   4F,W
0B82:  MOVWF  57
0B83:  MOVF   4E,W
0B84:  MOVWF  56
*
0BD5:  MOVF   78,W
0BD6:  ADDWF  50,F
0BD7:  BTFSC  03.0
0BD8:  INCF   51,F
....................    if (*beg == '\0') 
0BD9:  MOVF   51,W
0BDA:  MOVWF  7A
0BDB:  MOVF   50,W
0BDC:  MOVWF  04
0BDD:  BCF    03.7
0BDE:  BTFSC  7A.0
0BDF:  BSF    03.7
0BE0:  MOVF   00,F
0BE1:  BTFSS  03.2
0BE2:  GOTO   3F0
....................    { 
....................       *save = ' '; 
0BE3:  BCF    03.6
0BE4:  MOVF   2B,W
0BE5:  MOVWF  04
0BE6:  BCF    03.7
0BE7:  BTFSC  2C.0
0BE8:  BSF    03.7
0BE9:  MOVLW  20
0BEA:  MOVWF  00
....................       return(0); 
0BEB:  MOVLW  00
0BEC:  MOVWF  78
0BED:  MOVWF  79
0BEE:  GOTO   45C
0BEF:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
0BF0:  MOVF   51,W
0BF1:  MOVWF  55
0BF2:  MOVF   50,W
0BF3:  MOVWF  54
0BF4:  MOVF   4F,W
0BF5:  MOVWF  57
0BF6:  MOVF   4E,W
0BF7:  MOVWF  56
*
0C38:  MOVF   79,W
0C39:  MOVWF  53
0C3A:  MOVF   78,W
0C3B:  MOVWF  52
....................    if (*end != '\0') 
0C3C:  MOVF   53,W
0C3D:  MOVWF  7A
0C3E:  MOVF   52,W
0C3F:  MOVWF  04
0C40:  BCF    03.7
0C41:  BTFSC  7A.0
0C42:  BSF    03.7
0C43:  MOVF   00,F
0C44:  BTFSC  03.2
0C45:  GOTO   44F
....................    { 
....................       *end = '\0'; 
0C46:  MOVF   52,W
0C47:  MOVWF  04
0C48:  BCF    03.7
0C49:  BTFSC  53.0
0C4A:  BSF    03.7
0C4B:  CLRF   00
....................       end++; 
0C4C:  INCF   52,F
0C4D:  BTFSC  03.2
0C4E:  INCF   53,F
....................    } 
....................    save = end; 
0C4F:  MOVF   53,W
0C50:  BCF    03.6
0C51:  MOVWF  2C
0C52:  BSF    03.6
0C53:  MOVF   52,W
0C54:  BCF    03.6
0C55:  MOVWF  2B
....................    return(beg); 
0C56:  BSF    03.6
0C57:  MOVF   50,W
0C58:  MOVWF  78
0C59:  MOVF   51,W
0C5A:  MOVWF  79
0C5B:  BCF    03.6
0C5C:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
074E:  MOVF   50,W
074F:  MOVWF  52
0750:  MOVF   4F,W
0751:  MOVWF  51
0752:  MOVF   52,W
0753:  MOVWF  7A
0754:  MOVF   51,W
0755:  MOVWF  04
0756:  BCF    03.7
0757:  BTFSC  7A.0
0758:  BSF    03.7
0759:  MOVF   00,F
075A:  BTFSC  03.2
075B:  GOTO   760
075C:  INCF   51,F
075D:  BTFSC  03.2
075E:  INCF   52,F
075F:  GOTO   752
....................    return(sc - s); 
0760:  MOVF   4F,W
0761:  SUBWF  51,W
0762:  MOVWF  77
0763:  MOVF   52,W
0764:  MOVWF  7A
0765:  MOVF   50,W
0766:  BTFSS  03.0
0767:  INCFSZ 50,W
0768:  SUBWF  7A,F
0769:  MOVF   77,W
076A:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0C5D:  BSF    03.6
0C5E:  CLRF   51
....................    sign = 0; 
0C5F:  CLRF   4F
....................    base = 10; 
0C60:  MOVLW  0A
0C61:  MOVWF  50
....................    result = 0; 
0C62:  CLRF   4E
....................  
....................    if (!s) 
0C63:  MOVF   4C,W
0C64:  IORWF  4D,W
0C65:  BTFSS  03.2
0C66:  GOTO   46A
....................       return 0; 
0C67:  MOVLW  00
0C68:  MOVWF  78
0C69:  GOTO   55D
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0C6A:  MOVF   51,W
0C6B:  INCF   51,F
0C6C:  ADDWF  4C,W
0C6D:  MOVWF  04
0C6E:  BCF    03.7
0C6F:  BTFSC  4D.0
0C70:  BSF    03.7
0C71:  MOVF   00,W
0C72:  MOVWF  52
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0C73:  MOVF   52,W
0C74:  SUBLW  2D
0C75:  BTFSS  03.2
0C76:  GOTO   483
....................    { 
....................       sign = 1;         // Set the sign to negative 
0C77:  MOVLW  01
0C78:  MOVWF  4F
....................       c = s[index++]; 
0C79:  MOVF   51,W
0C7A:  INCF   51,F
0C7B:  ADDWF  4C,W
0C7C:  MOVWF  04
0C7D:  BCF    03.7
0C7E:  BTFSC  4D.0
0C7F:  BSF    03.7
0C80:  MOVF   00,W
0C81:  MOVWF  52
....................    } 
0C82:  GOTO   490
....................    else if (c == '+') 
0C83:  MOVF   52,W
0C84:  SUBLW  2B
0C85:  BTFSS  03.2
0C86:  GOTO   490
....................    { 
....................       c = s[index++]; 
0C87:  MOVF   51,W
0C88:  INCF   51,F
0C89:  ADDWF  4C,W
0C8A:  MOVWF  04
0C8B:  BCF    03.7
0C8C:  BTFSC  4D.0
0C8D:  BSF    03.7
0C8E:  MOVF   00,W
0C8F:  MOVWF  52
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0C90:  MOVF   52,W
0C91:  SUBLW  2F
0C92:  BTFSC  03.0
0C93:  GOTO   553
0C94:  MOVF   52,W
0C95:  SUBLW  39
0C96:  BTFSS  03.0
0C97:  GOTO   553
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0C98:  MOVF   52,W
0C99:  SUBLW  30
0C9A:  BTFSS  03.2
0C9B:  GOTO   4BC
0C9C:  MOVF   51,W
0C9D:  ADDWF  4C,W
0C9E:  MOVWF  04
0C9F:  BCF    03.7
0CA0:  BTFSC  4D.0
0CA1:  BSF    03.7
0CA2:  MOVF   00,W
0CA3:  SUBLW  78
0CA4:  BTFSC  03.2
0CA5:  GOTO   4B0
0CA6:  MOVF   51,W
0CA7:  ADDWF  4C,W
0CA8:  MOVWF  04
0CA9:  BCF    03.7
0CAA:  BTFSC  4D.0
0CAB:  BSF    03.7
0CAC:  MOVF   00,W
0CAD:  SUBLW  58
0CAE:  BTFSS  03.2
0CAF:  GOTO   4BC
....................       { 
....................          base = 16; 
0CB0:  MOVLW  10
0CB1:  MOVWF  50
....................          index++; 
0CB2:  INCF   51,F
....................          c = s[index++]; 
0CB3:  MOVF   51,W
0CB4:  INCF   51,F
0CB5:  ADDWF  4C,W
0CB6:  MOVWF  04
0CB7:  BCF    03.7
0CB8:  BTFSC  4D.0
0CB9:  BSF    03.7
0CBA:  MOVF   00,W
0CBB:  MOVWF  52
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0CBC:  MOVF   50,W
0CBD:  SUBLW  0A
0CBE:  BTFSS  03.2
0CBF:  GOTO   501
....................       { 
....................          while (c >= '0' && c <= '9') 
0CC0:  MOVF   52,W
0CC1:  SUBLW  2F
0CC2:  BTFSC  03.0
0CC3:  GOTO   500
0CC4:  MOVF   52,W
0CC5:  SUBLW  39
0CC6:  BTFSS  03.0
0CC7:  GOTO   500
....................          { 
....................             result = 10*result + (c - '0'); 
0CC8:  MOVLW  0A
0CC9:  MOVWF  53
0CCA:  MOVF   4E,W
0CCB:  MOVWF  54
*
0CF0:  MOVF   78,W
0CF1:  MOVWF  53
0CF2:  MOVLW  30
0CF3:  SUBWF  52,W
0CF4:  ADDWF  53,W
0CF5:  MOVWF  4E
....................             c = s[index++]; 
0CF6:  MOVF   51,W
0CF7:  INCF   51,F
0CF8:  ADDWF  4C,W
0CF9:  MOVWF  04
0CFA:  BCF    03.7
0CFB:  BTFSC  4D.0
0CFC:  BSF    03.7
0CFD:  MOVF   00,W
0CFE:  MOVWF  52
0CFF:  GOTO   4C0
....................          } 
....................       } 
0D00:  GOTO   553
....................       else if (base == 16)    // The number is a hexa number 
0D01:  MOVF   50,W
0D02:  SUBLW  10
0D03:  BTFSS  03.2
0D04:  GOTO   553
....................       { 
....................          c = toupper(c); 
0D05:  MOVF   52,W
0D06:  SUBLW  60
0D07:  BTFSC  03.0
0D08:  GOTO   510
0D09:  MOVF   52,W
0D0A:  SUBLW  7A
0D0B:  BTFSS  03.0
0D0C:  GOTO   510
0D0D:  MOVF   52,W
0D0E:  ANDLW  DF
0D0F:  GOTO   511
0D10:  MOVF   52,W
0D11:  MOVWF  52
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0D12:  MOVF   52,W
0D13:  SUBLW  2F
0D14:  BTFSC  03.0
0D15:  GOTO   51A
0D16:  MOVF   52,W
0D17:  SUBLW  39
0D18:  BTFSC  03.0
0D19:  GOTO   522
0D1A:  MOVF   52,W
0D1B:  SUBLW  40
0D1C:  BTFSC  03.0
0D1D:  GOTO   553
0D1E:  MOVF   52,W
0D1F:  SUBLW  46
0D20:  BTFSS  03.0
0D21:  GOTO   553
....................          { 
....................             if (c >= '0' && c <= '9') 
0D22:  MOVF   52,W
0D23:  SUBLW  2F
0D24:  BTFSC  03.0
0D25:  GOTO   533
0D26:  MOVF   52,W
0D27:  SUBLW  39
0D28:  BTFSS  03.0
0D29:  GOTO   533
....................                result = (result << 4) + (c - '0'); 
0D2A:  SWAPF  4E,W
0D2B:  MOVWF  53
0D2C:  MOVLW  F0
0D2D:  ANDWF  53,F
0D2E:  MOVLW  30
0D2F:  SUBWF  52,W
0D30:  ADDWF  53,W
0D31:  MOVWF  4E
0D32:  GOTO   53C
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0D33:  SWAPF  4E,W
0D34:  MOVWF  53
0D35:  MOVLW  F0
0D36:  ANDWF  53,F
0D37:  MOVLW  41
0D38:  SUBWF  52,W
0D39:  ADDLW  0A
0D3A:  ADDWF  53,W
0D3B:  MOVWF  4E
....................  
....................             c = s[index++]; 
0D3C:  MOVF   51,W
0D3D:  INCF   51,F
0D3E:  ADDWF  4C,W
0D3F:  MOVWF  04
0D40:  BCF    03.7
0D41:  BTFSC  4D.0
0D42:  BSF    03.7
0D43:  MOVF   00,W
0D44:  MOVWF  52
....................             c = toupper(c); 
0D45:  MOVF   52,W
0D46:  SUBLW  60
0D47:  BTFSC  03.0
0D48:  GOTO   550
0D49:  MOVF   52,W
0D4A:  SUBLW  7A
0D4B:  BTFSS  03.0
0D4C:  GOTO   550
0D4D:  MOVF   52,W
0D4E:  ANDLW  DF
0D4F:  GOTO   551
0D50:  MOVF   52,W
0D51:  MOVWF  52
0D52:  GOTO   512
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0D53:  DECFSZ 4F,W
0D54:  GOTO   55B
0D55:  MOVF   50,W
0D56:  SUBLW  0A
0D57:  BTFSS  03.2
0D58:  GOTO   55B
....................        result = -result; 
0D59:  COMF   4E,F
0D5A:  INCF   4E,F
....................  
....................    return(result); 
0D5B:  MOVF   4E,W
0D5C:  MOVWF  78
0D5D:  BCF    03.6
0D5E:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03EE:  BSF    03.6
03EF:  CLRF   58
03F0:  CLRF   57
03F1:  CLRF   56
03F2:  MOVLW  01
03F3:  MOVWF  55
03F4:  CLRF   5A
03F5:  CLRF   5B
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03F6:  BTFSS  51.7
03F7:  GOTO   438
....................          sign=1;        // Check for negative number 
03F8:  MOVLW  01
03F9:  MOVWF  5A
....................          num*=-1; 
03FA:  MOVF   51,W
03FB:  MOVWF  60
03FC:  MOVF   50,W
03FD:  MOVWF  5F
03FE:  MOVF   4F,W
03FF:  MOVWF  5E
0400:  MOVF   4E,W
0401:  MOVWF  5D
0402:  MOVLW  FF
0403:  MOVWF  64
0404:  MOVWF  63
0405:  MOVWF  62
0406:  MOVWF  61
*
0430:  MOVF   7A,W
0431:  MOVWF  51
0432:  MOVF   79,W
0433:  MOVWF  50
0434:  MOVF   78,W
0435:  MOVWF  4F
0436:  MOVF   77,W
0437:  MOVWF  4E
....................      } 
....................  
....................      while(temp>0) { 
0438:  MOVF   55,F
0439:  BTFSS  03.2
043A:  GOTO   444
043B:  MOVF   56,F
043C:  BTFSS  03.2
043D:  GOTO   444
043E:  MOVF   57,F
043F:  BTFSS  03.2
0440:  GOTO   444
0441:  MOVF   58,F
0442:  BTFSC  03.2
0443:  GOTO   4C0
....................          temp=(num/base); 
0444:  BCF    03.1
0445:  MOVF   51,W
0446:  MOVWF  68
0447:  MOVF   50,W
0448:  MOVWF  67
0449:  MOVF   4F,W
044A:  MOVWF  66
044B:  MOVF   4E,W
044C:  MOVWF  65
044D:  CLRF   6C
044E:  CLRF   6B
044F:  CLRF   6A
0450:  MOVF   52,W
0451:  MOVWF  69
0452:  BCF    03.6
0453:  CALL   350
0454:  MOVF   7A,W
0455:  BSF    03.6
0456:  MOVWF  58
0457:  MOVF   79,W
0458:  MOVWF  57
0459:  MOVF   78,W
045A:  MOVWF  56
045B:  MOVF   77,W
045C:  MOVWF  55
....................          s[cnt]=(num%base)+'0';    // Conversion 
045D:  MOVF   5B,W
045E:  ADDWF  53,W
045F:  MOVWF  78
0460:  MOVF   54,W
0461:  MOVWF  7A
0462:  BTFSC  03.0
0463:  INCF   7A,F
0464:  MOVF   78,W
0465:  MOVWF  5D
0466:  MOVF   7A,W
0467:  MOVWF  5E
0468:  CLRF   60
0469:  MOVF   04,W
046A:  MOVWF  5F
046B:  BCF    60.0
046C:  BTFSC  03.7
046D:  BSF    60.0
046E:  BSF    03.1
046F:  MOVLW  61
0470:  MOVWF  04
0471:  BSF    03.7
0472:  MOVF   51,W
0473:  MOVWF  68
0474:  MOVF   50,W
0475:  MOVWF  67
0476:  MOVF   4F,W
0477:  MOVWF  66
0478:  MOVF   4E,W
0479:  MOVWF  65
047A:  CLRF   6C
047B:  CLRF   6B
047C:  CLRF   6A
047D:  MOVF   52,W
047E:  MOVWF  69
047F:  BCF    03.6
0480:  CALL   350
0481:  BSF    03.6
0482:  MOVF   5F,W
0483:  MOVWF  04
0484:  BCF    03.7
0485:  BTFSC  60.0
0486:  BSF    03.7
0487:  MOVLW  30
0488:  ADDWF  61,W
0489:  MOVWF  77
048A:  MOVF   62,W
048B:  MOVWF  78
048C:  MOVLW  00
048D:  BTFSC  03.0
048E:  MOVLW  01
048F:  ADDWF  78,F
0490:  MOVF   63,W
0491:  MOVWF  79
0492:  MOVLW  00
0493:  BTFSC  03.0
0494:  MOVLW  01
0495:  ADDWF  79,F
0496:  MOVF   64,W
0497:  MOVWF  7A
0498:  MOVLW  00
0499:  BTFSC  03.0
049A:  MOVLW  01
049B:  ADDWF  7A,F
049C:  MOVF   5D,W
049D:  MOVWF  04
049E:  BCF    03.7
049F:  BTFSC  5E.0
04A0:  BSF    03.7
04A1:  MOVF   77,W
04A2:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04A3:  MOVF   5B,W
04A4:  ADDWF  53,W
04A5:  MOVWF  04
04A6:  BCF    03.7
04A7:  BTFSC  54.0
04A8:  BSF    03.7
04A9:  MOVF   00,W
04AA:  SUBLW  39
04AB:  BTFSC  03.0
04AC:  GOTO   4B6
....................             s[cnt]+=0x7; 
04AD:  MOVF   5B,W
04AE:  ADDWF  53,W
04AF:  MOVWF  04
04B0:  BCF    03.7
04B1:  BTFSC  54.0
04B2:  BSF    03.7
04B3:  MOVLW  07
04B4:  ADDWF  00,W
04B5:  MOVWF  00
....................  
....................          cnt++; 
04B6:  INCF   5B,F
....................          num=temp; 
04B7:  MOVF   58,W
04B8:  MOVWF  51
04B9:  MOVF   57,W
04BA:  MOVWF  50
04BB:  MOVF   56,W
04BC:  MOVWF  4F
04BD:  MOVF   55,W
04BE:  MOVWF  4E
04BF:  GOTO   438
....................      } 
....................  
....................      if(sign==1) { 
04C0:  DECFSZ 5A,W
04C1:  GOTO   4CB
....................          s[cnt]=0x2D;      // Negative sign 
04C2:  MOVF   5B,W
04C3:  ADDWF  53,W
04C4:  MOVWF  04
04C5:  BCF    03.7
04C6:  BTFSC  54.0
04C7:  BSF    03.7
04C8:  MOVLW  2D
04C9:  MOVWF  00
....................          cnt++; 
04CA:  INCF   5B,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04CB:  CLRF   59
04CC:  BCF    03.0
04CD:  RRF    5B,W
04CE:  SUBWF  59,W
04CF:  BTFSC  03.0
04D0:  GOTO   501
....................  
....................          c=s[i]; 
04D1:  MOVF   59,W
04D2:  ADDWF  53,W
04D3:  MOVWF  04
04D4:  BCF    03.7
04D5:  BTFSC  54.0
04D6:  BSF    03.7
04D7:  MOVF   00,W
04D8:  MOVWF  5C
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04D9:  MOVF   59,W
04DA:  ADDWF  53,W
04DB:  MOVWF  78
04DC:  MOVF   54,W
04DD:  MOVWF  7A
04DE:  BTFSC  03.0
04DF:  INCF   7A,F
04E0:  MOVF   78,W
04E1:  MOVWF  5D
04E2:  MOVF   7A,W
04E3:  MOVWF  5E
04E4:  MOVF   59,W
04E5:  SUBWF  5B,W
04E6:  ADDLW  FF
04E7:  ADDWF  53,W
04E8:  MOVWF  04
04E9:  BCF    03.7
04EA:  BTFSC  54.0
04EB:  BSF    03.7
04EC:  MOVF   00,W
04ED:  MOVWF  5F
04EE:  MOVF   5D,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  5E.0
04F2:  BSF    03.7
04F3:  MOVF   5F,W
04F4:  MOVWF  00
....................          s[cnt-i-1]=c; 
04F5:  MOVF   59,W
04F6:  SUBWF  5B,W
04F7:  ADDLW  FF
04F8:  ADDWF  53,W
04F9:  MOVWF  04
04FA:  BCF    03.7
04FB:  BTFSC  54.0
04FC:  BSF    03.7
04FD:  MOVF   5C,W
04FE:  MOVWF  00
04FF:  INCF   59,F
0500:  GOTO   4CC
....................      } 
....................      s[cnt]='\0';     // End the string 
0501:  MOVF   5B,W
0502:  ADDWF  53,W
0503:  MOVWF  04
0504:  BCF    03.7
0505:  BTFSC  54.0
0506:  BSF    03.7
0507:  CLRF   00
....................      return s; 
0508:  MOVF   53,W
0509:  MOVWF  78
050A:  MOVF   54,W
050B:  MOVWF  79
050C:  BCF    03.6
050D:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0132:  MOVLW  51
0133:  MOVWF  04
0134:  BSF    03.7
0135:  MOVF   00,W
0136:  BTFSC  03.2
0137:  GOTO   145
0138:  MOVLW  06
0139:  MOVWF  78
013A:  CLRF   77
013B:  DECFSZ 77,F
013C:  GOTO   13B
013D:  DECFSZ 78,F
013E:  GOTO   13A
013F:  MOVLW  7B
0140:  MOVWF  77
0141:  DECFSZ 77,F
0142:  GOTO   141
0143:  DECFSZ 00,F
0144:  GOTO   138
0145:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01D9:  BSF    07.0
....................    output_float(LCD_DATA5); 
01DA:  BSF    07.1
....................    output_float(LCD_DATA6); 
01DB:  BSF    07.2
....................    output_float(LCD_DATA7); 
01DC:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01DD:  BCF    03.5
01DE:  BSF    09.2
01DF:  BSF    03.5
01E0:  BCF    09.2
....................    delay_cycles(1); 
01E1:  NOP
....................    lcd_output_enable(1); 
01E2:  BCF    03.5
01E3:  BSF    09.0
01E4:  BSF    03.5
01E5:  BCF    09.0
....................    delay_cycles(1); 
01E6:  NOP
....................    high = lcd_read_nibble(); 
01E7:  BCF    03.5
01E8:  CALL   18E
01E9:  MOVF   78,W
01EA:  BSF    03.6
01EB:  MOVWF  58
....................        
....................    lcd_output_enable(0); 
01EC:  BCF    03.6
01ED:  BCF    09.0
01EE:  BSF    03.5
01EF:  BCF    09.0
....................    delay_cycles(1); 
01F0:  NOP
....................    lcd_output_enable(1); 
01F1:  BCF    03.5
01F2:  BSF    09.0
01F3:  BSF    03.5
01F4:  BCF    09.0
....................    delay_us(1); 
01F5:  GOTO   1F6
01F6:  GOTO   1F7
01F7:  NOP
....................    low = lcd_read_nibble(); 
01F8:  BCF    03.5
01F9:  CALL   18E
01FA:  MOVF   78,W
01FB:  BSF    03.6
01FC:  MOVWF  57
....................        
....................    lcd_output_enable(0); 
01FD:  BCF    03.6
01FE:  BCF    09.0
01FF:  BSF    03.5
0200:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0201:  BCF    03.5
0202:  BCF    31.0
0203:  MOVF   31,W
0204:  BSF    03.5
0205:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0206:  BCF    03.5
0207:  BCF    31.1
0208:  MOVF   31,W
0209:  BSF    03.5
020A:  MOVWF  07
....................    output_drive(LCD_DATA6); 
020B:  BCF    03.5
020C:  BCF    31.2
020D:  MOVF   31,W
020E:  BSF    03.5
020F:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0210:  BCF    03.5
0211:  BCF    31.3
0212:  MOVF   31,W
0213:  BSF    03.5
0214:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0215:  BCF    03.5
0216:  BSF    03.6
0217:  SWAPF  58,W
0218:  MOVWF  77
0219:  MOVLW  F0
021A:  ANDWF  77,F
021B:  MOVF   77,W
021C:  IORWF  57,W
021D:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
018E:  BSF    03.6
018F:  CLRF   59
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0190:  BCF    03.6
0191:  BSF    31.0
0192:  MOVF   31,W
0193:  BSF    03.5
0194:  MOVWF  07
0195:  MOVLW  00
0196:  BCF    03.5
0197:  BTFSC  07.0
0198:  MOVLW  01
0199:  BSF    03.6
019A:  IORWF  59,F
....................    n |= input(LCD_DATA5) << 1; 
019B:  BCF    03.6
019C:  BSF    31.1
019D:  MOVF   31,W
019E:  BSF    03.5
019F:  MOVWF  07
01A0:  MOVLW  00
01A1:  BCF    03.5
01A2:  BTFSC  07.1
01A3:  MOVLW  01
01A4:  MOVWF  77
01A5:  BCF    03.0
01A6:  RLF    77,F
01A7:  MOVF   77,W
01A8:  BSF    03.6
01A9:  IORWF  59,F
....................    n |= input(LCD_DATA6) << 2; 
01AA:  BCF    03.6
01AB:  BSF    31.2
01AC:  MOVF   31,W
01AD:  BSF    03.5
01AE:  MOVWF  07
01AF:  MOVLW  00
01B0:  BCF    03.5
01B1:  BTFSC  07.2
01B2:  MOVLW  01
01B3:  MOVWF  77
01B4:  RLF    77,F
01B5:  RLF    77,F
01B6:  MOVLW  FC
01B7:  ANDWF  77,F
01B8:  MOVF   77,W
01B9:  BSF    03.6
01BA:  IORWF  59,F
....................    n |= input(LCD_DATA7) << 3; 
01BB:  BCF    03.6
01BC:  BSF    31.3
01BD:  MOVF   31,W
01BE:  BSF    03.5
01BF:  MOVWF  07
01C0:  MOVLW  00
01C1:  BCF    03.5
01C2:  BTFSC  07.3
01C3:  MOVLW  01
01C4:  MOVWF  77
01C5:  RLF    77,F
01C6:  RLF    77,F
01C7:  RLF    77,F
01C8:  MOVLW  F8
01C9:  ANDWF  77,F
01CA:  MOVF   77,W
01CB:  BSF    03.6
01CC:  IORWF  59,F
....................     
....................    return(n); 
01CD:  MOVF   59,W
01CE:  MOVWF  78
....................   #else 
01CF:  BCF    03.6
01D0:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0146:  BSF    03.6
0147:  BTFSC  58.0
0148:  GOTO   14D
0149:  BCF    03.6
014A:  BCF    07.0
014B:  GOTO   14F
014C:  BSF    03.6
014D:  BCF    03.6
014E:  BSF    07.0
014F:  BCF    31.0
0150:  MOVF   31,W
0151:  BSF    03.5
0152:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0153:  BCF    03.5
0154:  BSF    03.6
0155:  BTFSC  58.1
0156:  GOTO   15B
0157:  BCF    03.6
0158:  BCF    07.1
0159:  GOTO   15D
015A:  BSF    03.6
015B:  BCF    03.6
015C:  BSF    07.1
015D:  BCF    31.1
015E:  MOVF   31,W
015F:  BSF    03.5
0160:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0161:  BCF    03.5
0162:  BSF    03.6
0163:  BTFSC  58.2
0164:  GOTO   169
0165:  BCF    03.6
0166:  BCF    07.2
0167:  GOTO   16B
0168:  BSF    03.6
0169:  BCF    03.6
016A:  BSF    07.2
016B:  BCF    31.2
016C:  MOVF   31,W
016D:  BSF    03.5
016E:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
016F:  BCF    03.5
0170:  BSF    03.6
0171:  BTFSC  58.3
0172:  GOTO   177
0173:  BCF    03.6
0174:  BCF    07.3
0175:  GOTO   179
0176:  BSF    03.6
0177:  BCF    03.6
0178:  BSF    07.3
0179:  BCF    31.3
017A:  MOVF   31,W
017B:  BSF    03.5
017C:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
017D:  NOP
....................    lcd_output_enable(1); 
017E:  BCF    03.5
017F:  BSF    09.0
0180:  BSF    03.5
0181:  BCF    09.0
....................    delay_us(2); 
0182:  MOVLW  02
0183:  MOVWF  77
0184:  DECFSZ 77,F
0185:  GOTO   184
0186:  GOTO   187
0187:  NOP
....................    lcd_output_enable(0); 
0188:  BCF    03.5
0189:  BCF    09.0
018A:  BSF    03.5
018B:  BCF    09.0
018C:  BCF    03.5
018D:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01D1:  BSF    03.5
01D2:  BCF    09.0
....................    lcd_rs_tris(); 
01D3:  BCF    09.1
....................    lcd_rw_tris(); 
01D4:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01D5:  BCF    03.5
01D6:  BCF    09.1
01D7:  BSF    03.5
01D8:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
021E:  MOVF   78,W
021F:  MOVWF  57
0220:  BTFSS  57.7
0221:  GOTO   225
0222:  BSF    03.5
0223:  BCF    03.6
0224:  GOTO   1D9
....................    lcd_output_rs(address); 
0225:  MOVF   55,F
0226:  BTFSS  03.2
0227:  GOTO   22C
0228:  BCF    03.6
0229:  BCF    09.1
022A:  GOTO   22E
022B:  BSF    03.6
022C:  BCF    03.6
022D:  BSF    09.1
022E:  BSF    03.5
022F:  BCF    09.1
....................    delay_cycles(1); 
0230:  NOP
....................    lcd_output_rw(0); 
0231:  BCF    03.5
0232:  BCF    09.2
0233:  BSF    03.5
0234:  BCF    09.2
....................    delay_cycles(1); 
0235:  NOP
....................    lcd_output_enable(0); 
0236:  BCF    03.5
0237:  BCF    09.0
0238:  BSF    03.5
0239:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
023A:  BCF    03.5
023B:  BSF    03.6
023C:  SWAPF  56,W
023D:  MOVWF  57
023E:  MOVLW  0F
023F:  ANDWF  57,F
0240:  MOVF   57,W
0241:  MOVWF  58
0242:  BCF    03.6
0243:  CALL   146
....................    lcd_send_nibble(n & 0xf); 
0244:  BSF    03.6
0245:  MOVF   56,W
0246:  ANDLW  0F
0247:  MOVWF  57
0248:  MOVWF  58
0249:  BCF    03.6
024A:  CALL   146
024B:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
024C:  MOVLW  28
024D:  BSF    03.6
024E:  MOVWF  4D
024F:  MOVLW  0C
0250:  MOVWF  4E
0251:  MOVLW  01
0252:  MOVWF  4F
0253:  MOVLW  06
0254:  MOVWF  50
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0255:  BCF    03.6
0256:  BCF    09.0
0257:  BSF    03.5
0258:  BCF    09.0
....................    lcd_output_rs(0); 
0259:  BCF    03.5
025A:  BCF    09.1
025B:  BSF    03.5
025C:  BCF    09.1
....................    lcd_output_rw(0); 
025D:  BCF    03.5
025E:  BCF    09.2
025F:  BSF    03.5
0260:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0261:  BCF    03.5
0262:  BCF    31.0
0263:  MOVF   31,W
0264:  BSF    03.5
0265:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0266:  BCF    03.5
0267:  BCF    31.1
0268:  MOVF   31,W
0269:  BSF    03.5
026A:  MOVWF  07
....................    output_drive(LCD_DATA6); 
026B:  BCF    03.5
026C:  BCF    31.2
026D:  MOVF   31,W
026E:  BSF    03.5
026F:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0270:  BCF    03.5
0271:  BCF    31.3
0272:  MOVF   31,W
0273:  BSF    03.5
0274:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0275:  BCF    09.0
....................    lcd_rs_tris(); 
0276:  BCF    09.1
....................    lcd_rw_tris(); 
0277:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0278:  MOVLW  0F
0279:  BCF    03.5
027A:  BSF    03.6
027B:  MOVWF  51
027C:  BCF    03.6
027D:  CALL   132
....................    for(i=1;i<=3;++i) 
027E:  MOVLW  01
027F:  BSF    03.6
0280:  MOVWF  4C
0281:  MOVF   4C,W
0282:  SUBLW  03
0283:  BTFSS  03.0
0284:  GOTO   291
....................    { 
....................        lcd_send_nibble(3); 
0285:  MOVLW  03
0286:  MOVWF  58
0287:  BCF    03.6
0288:  CALL   146
....................        delay_ms(5); 
0289:  MOVLW  05
028A:  BSF    03.6
028B:  MOVWF  51
028C:  BCF    03.6
028D:  CALL   132
028E:  BSF    03.6
028F:  INCF   4C,F
0290:  GOTO   281
....................    } 
....................     
....................    lcd_send_nibble(2); 
0291:  MOVLW  02
0292:  MOVWF  58
0293:  BCF    03.6
0294:  CALL   146
....................    delay_ms(5); 
0295:  MOVLW  05
0296:  BSF    03.6
0297:  MOVWF  51
0298:  BCF    03.6
0299:  CALL   132
....................    for(i=0;i<=3;++i) 
029A:  BSF    03.6
029B:  CLRF   4C
029C:  MOVF   4C,W
029D:  SUBLW  03
029E:  BTFSS  03.0
029F:  GOTO   2AE
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02A0:  MOVLW  4D
02A1:  ADDWF  4C,W
02A2:  MOVWF  04
02A3:  BSF    03.7
02A4:  MOVF   00,W
02A5:  MOVWF  51
02A6:  CLRF   55
02A7:  MOVF   51,W
02A8:  MOVWF  56
02A9:  BCF    03.6
02AA:  CALL   1D1
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02AB:  BSF    03.6
02AC:  INCF   4C,F
02AD:  GOTO   29C
02AE:  BCF    03.6
02AF:  BCF    0A.3
02B0:  BSF    0A.4
02B1:  GOTO   194 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02B2:  BSF    03.6
02B3:  DECFSZ 52,W
02B4:  GOTO   2B6
02B5:  GOTO   2B9
....................       address=LCD_LINE_TWO; 
02B6:  MOVLW  40
02B7:  MOVWF  53
02B8:  GOTO   2BA
....................    else 
....................       address=0; 
02B9:  CLRF   53
....................       
....................    address+=x-1; 
02BA:  MOVLW  01
02BB:  SUBWF  51,W
02BC:  ADDWF  53,F
....................    lcd_send_byte(0,0x80|address); 
02BD:  MOVF   53,W
02BE:  IORLW  80
02BF:  MOVWF  54
02C0:  CLRF   55
02C1:  MOVF   54,W
02C2:  MOVWF  56
02C3:  BCF    03.6
02C4:  CALL   1D1
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02C5:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02C6:  BSF    03.6
02C7:  MOVF   50,W
02C8:  XORLW  07
02C9:  BCF    03.6
02CA:  BTFSC  03.2
02CB:  GOTO   2D6
02CC:  XORLW  0B
02CD:  BTFSC  03.2
02CE:  GOTO   2DD
02CF:  XORLW  06
02D0:  BTFSC  03.2
02D1:  GOTO   2E9
02D2:  XORLW  02
02D3:  BTFSC  03.2
02D4:  GOTO   2F1
02D5:  GOTO   2F8
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02D6:  MOVLW  01
02D7:  BSF    03.6
02D8:  MOVWF  51
02D9:  MOVWF  52
02DA:  BCF    03.6
02DB:  CALL   2B2
02DC:  GOTO   2FF
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02DD:  BSF    03.6
02DE:  CLRF   55
02DF:  MOVLW  01
02E0:  MOVWF  56
02E1:  BCF    03.6
02E2:  CALL   1D1
....................                      delay_ms(2); 
02E3:  MOVLW  02
02E4:  BSF    03.6
02E5:  MOVWF  51
02E6:  BCF    03.6
02E7:  CALL   132
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02E8:  GOTO   2FF
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02E9:  MOVLW  01
02EA:  BSF    03.6
02EB:  MOVWF  51
02EC:  MOVLW  02
02ED:  MOVWF  52
02EE:  BCF    03.6
02EF:  CALL   2B2
02F0:  GOTO   2FF
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02F1:  BSF    03.6
02F2:  CLRF   55
02F3:  MOVLW  10
02F4:  MOVWF  56
02F5:  BCF    03.6
02F6:  CALL   1D1
02F7:  GOTO   2FF
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02F8:  MOVLW  01
02F9:  BSF    03.6
02FA:  MOVWF  55
02FB:  MOVF   50,W
02FC:  MOVWF  56
02FD:  BCF    03.6
02FE:  CALL   1D1
....................      #endif 
....................    } 
02FF:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... CHAR KYTUCHAR[20]="HIHI"; 
*
1032:  MOVLW  48
1033:  MOVWF  41
1034:  MOVLW  49
1035:  MOVWF  42
1036:  MOVLW  48
1037:  MOVWF  43
1038:  MOVLW  49
1039:  MOVWF  44
103A:  CLRF   45
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 0, 1, 0, 1, 1}; 
103B:  MOVLW  D6
103C:  MOVWF  56
.................... INT1 TT_SENSOR[8]={1, 1, 1, 1, 0, 0, 0, 0}; 
103D:  MOVLW  0F
103E:  MOVWF  57
.................... CHAR *TT_DEVICE_CHAR[]="00000000"; 
103F:  MOVLW  30
1040:  MOVWF  5A
1041:  MOVWF  5B
1042:  MOVWF  5C
1043:  MOVWF  5D
1044:  MOVWF  5E
1045:  MOVWF  5F
1046:  MOVWF  60
1047:  MOVWF  61
1048:  CLRF   62
1049:  CLRF   59
104A:  MOVLW  5A
104B:  MOVWF  58
.................... CHAR *PACKAGE_NHIETDO[]={"*","ID_GW", "ID_NODE","LENGHT", "S_S" ,"TT_cambien","#"}; 
104C:  MOVLW  2A
104D:  BSF    03.5
104E:  MOVWF  20
104F:  CLRF   21
1050:  MOVLW  49
1051:  MOVWF  22
1052:  MOVLW  44
1053:  MOVWF  23
1054:  MOVLW  5F
1055:  MOVWF  24
1056:  MOVLW  47
1057:  MOVWF  25
1058:  MOVLW  57
1059:  MOVWF  26
105A:  CLRF   27
105B:  MOVLW  49
105C:  MOVWF  28
105D:  MOVLW  44
105E:  MOVWF  29
105F:  MOVLW  5F
1060:  MOVWF  2A
1061:  MOVLW  4E
1062:  MOVWF  2B
1063:  MOVLW  4F
1064:  MOVWF  2C
1065:  MOVLW  44
1066:  MOVWF  2D
1067:  MOVLW  45
1068:  MOVWF  2E
1069:  CLRF   2F
106A:  MOVLW  4C
106B:  MOVWF  30
106C:  MOVLW  45
106D:  MOVWF  31
106E:  MOVLW  4E
106F:  MOVWF  32
1070:  MOVLW  47
1071:  MOVWF  33
1072:  MOVLW  48
1073:  MOVWF  34
1074:  MOVLW  54
1075:  MOVWF  35
1076:  CLRF   36
1077:  MOVLW  53
1078:  MOVWF  37
1079:  MOVLW  5F
107A:  MOVWF  38
107B:  MOVLW  53
107C:  MOVWF  39
107D:  CLRF   3A
107E:  MOVLW  54
107F:  MOVWF  3B
1080:  MOVWF  3C
1081:  MOVLW  5F
1082:  MOVWF  3D
1083:  MOVLW  63
1084:  MOVWF  3E
1085:  MOVLW  61
1086:  MOVWF  3F
1087:  MOVLW  6D
1088:  MOVWF  40
1089:  MOVLW  62
108A:  MOVWF  41
108B:  MOVLW  69
108C:  MOVWF  42
108D:  MOVLW  65
108E:  MOVWF  43
108F:  MOVLW  6E
1090:  MOVWF  44
1091:  CLRF   45
1092:  MOVLW  23
1093:  MOVWF  46
1094:  CLRF   47
1095:  BCF    03.5
1096:  CLRF   64
1097:  MOVLW  A0
1098:  MOVWF  63
1099:  CLRF   66
109A:  MOVLW  A2
109B:  MOVWF  65
109C:  CLRF   68
109D:  MOVLW  A8
109E:  MOVWF  67
109F:  CLRF   6A
10A0:  MOVLW  B0
10A1:  MOVWF  69
10A2:  CLRF   6C
10A3:  MOVLW  B7
10A4:  MOVWF  6B
10A5:  CLRF   6E
10A6:  MOVLW  BB
10A7:  MOVWF  6D
10A8:  CLRF   70
10A9:  MOVLW  C6
10AA:  MOVWF  6F
....................  
.................... CHAR *PACKAGE_CONFIG[]={"*","ID_GW" ,"ID_NODE", "LENGHT","C_F", "DEVICE1234","SENSOR1234","#"}; 
10AB:  MOVLW  2A
10AC:  BSF    03.6
10AD:  MOVWF  10
10AE:  CLRF   11
10AF:  MOVLW  49
10B0:  MOVWF  12
10B1:  MOVLW  44
10B2:  MOVWF  13
10B3:  MOVLW  5F
10B4:  MOVWF  14
10B5:  MOVLW  47
10B6:  MOVWF  15
10B7:  MOVLW  57
10B8:  MOVWF  16
10B9:  CLRF   17
10BA:  MOVLW  49
10BB:  MOVWF  18
10BC:  MOVLW  44
10BD:  MOVWF  19
10BE:  MOVLW  5F
10BF:  MOVWF  1A
10C0:  MOVLW  4E
10C1:  MOVWF  1B
10C2:  MOVLW  4F
10C3:  MOVWF  1C
10C4:  MOVLW  44
10C5:  MOVWF  1D
10C6:  MOVLW  45
10C7:  MOVWF  1E
10C8:  CLRF   1F
10C9:  MOVLW  4C
10CA:  MOVWF  20
10CB:  MOVLW  45
10CC:  MOVWF  21
10CD:  MOVLW  4E
10CE:  MOVWF  22
10CF:  MOVLW  47
10D0:  MOVWF  23
10D1:  MOVLW  48
10D2:  MOVWF  24
10D3:  MOVLW  54
10D4:  MOVWF  25
10D5:  CLRF   26
10D6:  MOVLW  43
10D7:  MOVWF  27
10D8:  MOVLW  5F
10D9:  MOVWF  28
10DA:  MOVLW  46
10DB:  MOVWF  29
10DC:  CLRF   2A
10DD:  MOVLW  44
10DE:  MOVWF  2B
10DF:  MOVLW  45
10E0:  MOVWF  2C
10E1:  MOVLW  56
10E2:  MOVWF  2D
10E3:  MOVLW  49
10E4:  MOVWF  2E
10E5:  MOVLW  43
10E6:  MOVWF  2F
10E7:  MOVLW  45
10E8:  MOVWF  30
10E9:  MOVLW  31
10EA:  MOVWF  31
10EB:  MOVLW  32
10EC:  MOVWF  32
10ED:  MOVLW  33
10EE:  MOVWF  33
10EF:  MOVLW  34
10F0:  MOVWF  34
10F1:  CLRF   35
10F2:  MOVLW  53
10F3:  MOVWF  36
10F4:  MOVLW  45
10F5:  MOVWF  37
10F6:  MOVLW  4E
10F7:  MOVWF  38
10F8:  MOVLW  53
10F9:  MOVWF  39
10FA:  MOVLW  4F
10FB:  MOVWF  3A
10FC:  MOVLW  52
10FD:  MOVWF  3B
10FE:  MOVLW  31
10FF:  MOVWF  3C
1100:  MOVLW  32
1101:  MOVWF  3D
1102:  MOVLW  33
1103:  MOVWF  3E
1104:  MOVLW  34
1105:  MOVWF  3F
1106:  CLRF   40
1107:  MOVLW  23
1108:  MOVWF  41
1109:  CLRF   42
110A:  MOVLW  01
110B:  BSF    03.5
110C:  BCF    03.6
110D:  MOVWF  49
110E:  MOVLW  10
110F:  MOVWF  48
1110:  MOVLW  01
1111:  MOVWF  4B
1112:  MOVLW  12
1113:  MOVWF  4A
1114:  MOVLW  01
1115:  MOVWF  4D
1116:  MOVLW  18
1117:  MOVWF  4C
1118:  MOVLW  01
1119:  MOVWF  4F
111A:  MOVLW  20
111B:  MOVWF  4E
111C:  MOVLW  01
111D:  MOVWF  51
111E:  MOVLW  27
111F:  MOVWF  50
1120:  MOVLW  01
1121:  MOVWF  53
1122:  MOVLW  2B
1123:  MOVWF  52
1124:  MOVLW  01
1125:  MOVWF  55
1126:  MOVLW  36
1127:  MOVWF  54
1128:  MOVLW  01
1129:  MOVWF  57
112A:  MOVLW  41
112B:  MOVWF  56
....................  
.................... CHAR *ID_[]="00"; 
112C:  MOVLW  30
112D:  MOVWF  73
112E:  MOVWF  74
112F:  CLRF   75
1130:  CLRF   72
1131:  MOVLW  73
1132:  MOVWF  71
.................... //CHAR *ID_GW[]= "0000"; 
.................... UNSIGNED INT8 ID_GATEWAY[4] = {0,0,0,0}; 
1133:  CLRF   7B
1134:  CLRF   7C
1135:  CLRF   7D
1136:  CLRF   7E
.................... CHAR *TEMP_CHAR[]="00"; 
1137:  MOVLW  30
1138:  MOVWF  5A
1139:  MOVWF  5B
113A:  CLRF   5C
113B:  CLRF   59
113C:  MOVLW  DA
113D:  MOVWF  58
.................... CHAR *TEMP_CHAR2[]="00000000";  
113E:  MOVLW  30
113F:  MOVWF  5F
1140:  MOVWF  60
1141:  MOVWF  61
1142:  MOVWF  62
1143:  MOVWF  63
1144:  MOVWF  64
1145:  MOVWF  65
1146:  MOVWF  66
1147:  CLRF   67
1148:  CLRF   5E
1149:  MOVLW  DF
114A:  MOVWF  5D
.................... CHAR *TEMP_CHAR3[]="0000";  
114B:  MOVLW  30
114C:  MOVWF  6A
114D:  MOVWF  6B
114E:  MOVWF  6C
114F:  MOVWF  6D
1150:  CLRF   6E
1151:  CLRF   69
1152:  MOVLW  EA
1153:  MOVWF  68
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... CHAR NHIETDO1[]="27"; 
1154:  MOVLW  32
1155:  BCF    03.5
1156:  BSF    03.6
1157:  MOVWF  43
1158:  MOVLW  37
1159:  MOVWF  44
115A:  CLRF   45
.................... CHAR NHIETDO2[]="27"; 
115B:  MOVLW  32
115C:  MOVWF  46
115D:  MOVLW  37
115E:  MOVWF  47
115F:  CLRF   48
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    55.3
....................    TT_STT = 1; 
0808:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  51
080C:  MOVLW  02
080D:  MOVWF  52
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   2B2
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  51
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   132
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   300
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  55.5
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  4C
0831:  MOVLW  96
0832:  MOVWF  51
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   132
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 4C,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   51
083B:  CLRF   50
083C:  CLRF   4F
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  4E
0841:  MOVLW  0A
0842:  MOVWF  52
0843:  CLRF   54
0844:  MOVLW  71
0845:  MOVWF  53
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   3EE
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  51
084D:  MOVLW  02
084E:  MOVWF  52
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   2B2
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  51
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   132
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  71
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   50E
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  51
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   132
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    55.3
....................    TT_STT = 1; 
086F:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  51
0873:  MOVLW  02
0874:  MOVWF  52
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   2B2
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  51
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   132
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:           "); 
0880:  MOVLW  72
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   300
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  55.5
088A:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11A
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  4C
0898:  MOVLW  96
0899:  MOVWF  51
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   132
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 4C,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   51
08A2:  CLRF   50
08A3:  CLRF   4F
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  4E
08A8:  MOVLW  0A
08A9:  MOVWF  52
08AA:  CLRF   54
08AB:  MOVLW  D8
08AC:  MOVWF  53
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   3EE
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  51
08B4:  MOVLW  02
08B5:  MOVWF  52
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   2B2
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  51
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   132
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  D8
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   50E
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  51
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   132
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
08CE:  MOVLW  20
08CF:  BSF    03.6
08D0:  MOVWF  50
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   2C6
08D4:  BSF    0A.3
08D5:  MOVLW  3A
08D6:  BSF    03.6
08D7:  MOVWF  50
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   2C6
08DB:  BSF    0A.3
08DC:  MOVLW  20
08DD:  BSF    03.6
08DE:  MOVWF  50
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   2C6
08E2:  BSF    0A.3
....................          DELAY_MS (1); 
08E3:  MOVLW  01
08E4:  BSF    03.6
08E5:  MOVWF  51
08E6:  BCF    0A.3
08E7:  BCF    03.6
08E8:  CALL   132
08E9:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EA:  MOVF   3A,W
08EB:  BSF    03.6
08EC:  MOVWF  4E
08ED:  CLRF   50
08EE:  MOVLW  56
08EF:  MOVWF  4F
08F0:  BCF    0A.3
08F1:  BCF    03.6
08F2:  CALL   52B
08F3:  BSF    0A.3
08F4:  MOVLW  00
08F5:  BTFSC  78.0
08F6:  MOVLW  01
08F7:  BSF    03.6
08F8:  MOVWF  4C
08F9:  CLRF   51
08FA:  CLRF   50
08FB:  CLRF   4F
08FC:  MOVF   4C,W
08FD:  MOVWF  4E
08FE:  MOVLW  0A
08FF:  MOVWF  52
0900:  CLRF   54
0901:  MOVLW  D8
0902:  MOVWF  53
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   3EE
0906:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0907:  MOVLW  D8
0908:  MOVWF  04
0909:  BCF    03.7
090A:  BCF    0A.3
090B:  CALL   50E
090C:  BSF    0A.3
....................          DELAY_MS (1); 
090D:  MOVLW  01
090E:  BSF    03.6
090F:  MOVWF  51
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   132
0913:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0914:  BSF    03.5
0915:  BCF    08.0
0916:  MOVLW  01
0917:  BCF    03.5
0918:  XORWF  08,F
....................       } 
0919:  GOTO   174
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091A:  BSF    03.5
091B:  BSF    06.3
091C:  BCF    03.5
091D:  BTFSC  06.3
091E:  GOTO   174
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
091F:  MOVF   3A,W
0920:  BSF    03.6
0921:  MOVWF  4E
0922:  CLRF   50
0923:  MOVLW  56
0924:  MOVWF  4F
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   52B
0928:  BSF    0A.3
0929:  MOVLW  00
092A:  BTFSS  78.0
092B:  MOVLW  01
092C:  BSF    03.6
092D:  MOVWF  4C
092E:  BCF    03.6
092F:  MOVF   3A,W
0930:  BSF    03.6
0931:  MOVWF  4D
0932:  MOVF   4C,W
0933:  MOVWF  4E
0934:  CLRF   50
0935:  MOVLW  56
0936:  MOVWF  4F
0937:  BCF    0A.3
0938:  BCF    03.6
0939:  CALL   544
093A:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
093B:  MOVLW  0D
093C:  BSF    03.6
093D:  MOVWF  51
093E:  MOVLW  02
093F:  MOVWF  52
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   2B2
0943:  BSF    0A.3
....................          DELAY_MS (300); 
0944:  MOVLW  02
0945:  BSF    03.6
0946:  MOVWF  4C
0947:  MOVLW  96
0948:  MOVWF  51
0949:  BCF    0A.3
094A:  BCF    03.6
094B:  CALL   132
094C:  BSF    0A.3
094D:  BSF    03.6
094E:  DECFSZ 4C,F
094F:  GOTO   147
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0950:  BCF    03.6
0951:  MOVF   3A,W
0952:  BSF    03.6
0953:  MOVWF  4E
0954:  CLRF   50
0955:  MOVLW  56
0956:  MOVWF  4F
0957:  BCF    0A.3
0958:  BCF    03.6
0959:  CALL   52B
095A:  BSF    0A.3
095B:  MOVLW  00
095C:  BTFSC  78.0
095D:  MOVLW  01
095E:  BSF    03.6
095F:  MOVWF  4C
0960:  CLRF   51
0961:  CLRF   50
0962:  CLRF   4F
0963:  MOVF   4C,W
0964:  MOVWF  4E
0965:  MOVLW  0A
0966:  MOVWF  52
0967:  CLRF   54
0968:  MOVLW  D8
0969:  MOVWF  53
096A:  BCF    0A.3
096B:  BCF    03.6
096C:  CALL   3EE
096D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
096E:  MOVLW  D8
096F:  MOVWF  04
0970:  BCF    03.7
0971:  BCF    0A.3
0972:  CALL   50E
0973:  BSF    0A.3
....................       } 
0974:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0976:  BCF    55.3
....................    TT_STT = 1; 
0977:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
0978:  MOVLW  01
0979:  BSF    03.6
097A:  MOVWF  51
097B:  MOVLW  02
097C:  MOVWF  52
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   2B2
0980:  BSF    0A.3
....................    DELAY_MS (10);   
0981:  MOVLW  0A
0982:  BSF    03.6
0983:  MOVWF  51
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   132
0987:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
0988:  MOVLW  7C
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  MOVLW  00
098C:  MOVWF  0F
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   300
0990:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0991:  BTFSS  55.5
0992:  GOTO   27D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0993:  BSF    03.5
0994:  BSF    06.2
0995:  BCF    03.5
0996:  BTFSC  06.2
0997:  GOTO   222
....................       { 
....................          STT_SENSOR ++; 
0998:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0999:  MOVF   3B,W
099A:  SUBLW  03
099B:  BTFSS  03.0
099C:  CLRF   3B
....................          DELAY_MS (300); 
099D:  MOVLW  02
099E:  BSF    03.6
099F:  MOVWF  4C
09A0:  MOVLW  96
09A1:  MOVWF  51
09A2:  BCF    0A.3
09A3:  BCF    03.6
09A4:  CALL   132
09A5:  BSF    0A.3
09A6:  BSF    03.6
09A7:  DECFSZ 4C,F
09A8:  GOTO   1A0
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09A9:  CLRF   51
09AA:  CLRF   50
09AB:  CLRF   4F
09AC:  BCF    03.6
09AD:  MOVF   3B,W
09AE:  BSF    03.6
09AF:  MOVWF  4E
09B0:  MOVLW  0A
09B1:  MOVWF  52
09B2:  CLRF   54
09B3:  MOVLW  D8
09B4:  MOVWF  53
09B5:  BCF    0A.3
09B6:  BCF    03.6
09B7:  CALL   3EE
09B8:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09B9:  MOVLW  09
09BA:  BSF    03.6
09BB:  MOVWF  51
09BC:  MOVLW  02
09BD:  MOVWF  52
09BE:  BCF    0A.3
09BF:  BCF    03.6
09C0:  CALL   2B2
09C1:  BSF    0A.3
....................          DELAY_MS (10); 
09C2:  MOVLW  0A
09C3:  BSF    03.6
09C4:  MOVWF  51
09C5:  BCF    0A.3
09C6:  BCF    03.6
09C7:  CALL   132
09C8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09C9:  MOVLW  D8
09CA:  MOVWF  04
09CB:  BCF    03.7
09CC:  BCF    0A.3
09CD:  CALL   50E
09CE:  BSF    0A.3
....................          DELAY_MS (1); 
09CF:  MOVLW  01
09D0:  BSF    03.6
09D1:  MOVWF  51
09D2:  BCF    0A.3
09D3:  BCF    03.6
09D4:  CALL   132
09D5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
09D6:  MOVLW  20
09D7:  BSF    03.6
09D8:  MOVWF  50
09D9:  BCF    0A.3
09DA:  BCF    03.6
09DB:  CALL   2C6
09DC:  BSF    0A.3
09DD:  MOVLW  3A
09DE:  BSF    03.6
09DF:  MOVWF  50
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   2C6
09E3:  BSF    0A.3
09E4:  MOVLW  20
09E5:  BSF    03.6
09E6:  MOVWF  50
09E7:  BCF    0A.3
09E8:  BCF    03.6
09E9:  CALL   2C6
09EA:  BSF    0A.3
....................          DELAY_MS (1); 
09EB:  MOVLW  01
09EC:  BSF    03.6
09ED:  MOVWF  51
09EE:  BCF    0A.3
09EF:  BCF    03.6
09F0:  CALL   132
09F1:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F2:  MOVF   3B,W
09F3:  BSF    03.6
09F4:  MOVWF  4E
09F5:  CLRF   50
09F6:  MOVLW  57
09F7:  MOVWF  4F
09F8:  BCF    0A.3
09F9:  BCF    03.6
09FA:  CALL   52B
09FB:  BSF    0A.3
09FC:  MOVLW  00
09FD:  BTFSC  78.0
09FE:  MOVLW  01
09FF:  BSF    03.6
0A00:  MOVWF  4C
0A01:  CLRF   51
0A02:  CLRF   50
0A03:  CLRF   4F
0A04:  MOVF   4C,W
0A05:  MOVWF  4E
0A06:  MOVLW  0A
0A07:  MOVWF  52
0A08:  CLRF   54
0A09:  MOVLW  D8
0A0A:  MOVWF  53
0A0B:  BCF    0A.3
0A0C:  BCF    03.6
0A0D:  CALL   3EE
0A0E:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A0F:  MOVLW  D8
0A10:  MOVWF  04
0A11:  BCF    03.7
0A12:  BCF    0A.3
0A13:  CALL   50E
0A14:  BSF    0A.3
....................          DELAY_MS (1); 
0A15:  MOVLW  01
0A16:  BSF    03.6
0A17:  MOVWF  51
0A18:  BCF    0A.3
0A19:  BCF    03.6
0A1A:  CALL   132
0A1B:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A1C:  BSF    03.5
0A1D:  BCF    08.0
0A1E:  MOVLW  01
0A1F:  BCF    03.5
0A20:  XORWF  08,F
....................       } 
0A21:  GOTO   27C
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A22:  BSF    03.5
0A23:  BSF    06.3
0A24:  BCF    03.5
0A25:  BTFSC  06.3
0A26:  GOTO   27C
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A27:  MOVF   3B,W
0A28:  BSF    03.6
0A29:  MOVWF  4E
0A2A:  CLRF   50
0A2B:  MOVLW  57
0A2C:  MOVWF  4F
0A2D:  BCF    0A.3
0A2E:  BCF    03.6
0A2F:  CALL   52B
0A30:  BSF    0A.3
0A31:  MOVLW  00
0A32:  BTFSS  78.0
0A33:  MOVLW  01
0A34:  BSF    03.6
0A35:  MOVWF  4C
0A36:  BCF    03.6
0A37:  MOVF   3B,W
0A38:  BSF    03.6
0A39:  MOVWF  4D
0A3A:  MOVF   4C,W
0A3B:  MOVWF  4E
0A3C:  CLRF   50
0A3D:  MOVLW  57
0A3E:  MOVWF  4F
0A3F:  BCF    0A.3
0A40:  BCF    03.6
0A41:  CALL   544
0A42:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A43:  MOVLW  0D
0A44:  BSF    03.6
0A45:  MOVWF  51
0A46:  MOVLW  02
0A47:  MOVWF  52
0A48:  BCF    0A.3
0A49:  BCF    03.6
0A4A:  CALL   2B2
0A4B:  BSF    0A.3
....................          DELAY_MS (300); 
0A4C:  MOVLW  02
0A4D:  BSF    03.6
0A4E:  MOVWF  4C
0A4F:  MOVLW  96
0A50:  MOVWF  51
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   132
0A54:  BSF    0A.3
0A55:  BSF    03.6
0A56:  DECFSZ 4C,F
0A57:  GOTO   24F
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A58:  BCF    03.6
0A59:  MOVF   3B,W
0A5A:  BSF    03.6
0A5B:  MOVWF  4E
0A5C:  CLRF   50
0A5D:  MOVLW  57
0A5E:  MOVWF  4F
0A5F:  BCF    0A.3
0A60:  BCF    03.6
0A61:  CALL   52B
0A62:  BSF    0A.3
0A63:  MOVLW  00
0A64:  BTFSC  78.0
0A65:  MOVLW  01
0A66:  BSF    03.6
0A67:  MOVWF  4C
0A68:  CLRF   51
0A69:  CLRF   50
0A6A:  CLRF   4F
0A6B:  MOVF   4C,W
0A6C:  MOVWF  4E
0A6D:  MOVLW  0A
0A6E:  MOVWF  52
0A6F:  CLRF   54
0A70:  MOVLW  D8
0A71:  MOVWF  53
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   3EE
0A75:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A76:  MOVLW  D8
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  BCF    0A.3
0A7A:  CALL   50E
0A7B:  BSF    0A.3
....................       } 
0A7C:  GOTO   191
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0A7E:  BSF    03.6
0A7F:  CLRF   4C
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0A80:  CLRF   4D
0A81:  CLRF   4E
0A82:  MOVLW  D8
0A83:  MOVWF  04
0A84:  BCF    03.7
0A85:  MOVF   4D,W
0A86:  ADDWF  04,F
0A87:  MOVF   4E,W
0A88:  BCF    0A.3
0A89:  BCF    03.6
0A8A:  CALL   058
0A8B:  BSF    0A.3
0A8C:  MOVWF  00
0A8D:  IORLW  00
0A8E:  BTFSC  03.2
0A8F:  GOTO   295
0A90:  BSF    03.6
0A91:  INCF   4E,F
0A92:  INCF   4D,F
0A93:  GOTO   282
0A94:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0A95:  BCF    55.3
....................    TT_STT = 1; 
0A96:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
0A97:  MOVLW  01
0A98:  BSF    03.6
0A99:  MOVWF  51
0A9A:  MOVLW  02
0A9B:  MOVWF  52
0A9C:  BCF    0A.3
0A9D:  BCF    03.6
0A9E:  CALL   2B2
0A9F:  BSF    0A.3
....................    DELAY_MS (10); 
0AA0:  MOVLW  0A
0AA1:  BSF    03.6
0AA2:  MOVWF  51
0AA3:  BCF    0A.3
0AA4:  BCF    03.6
0AA5:  CALL   132
0AA6:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:  0000 "); 
0AA7:  MOVLW  85
0AA8:  BSF    03.6
0AA9:  MOVWF  0D
0AAA:  MOVLW  00
0AAB:  MOVWF  0F
0AAC:  BCF    0A.3
0AAD:  BCF    03.6
0AAE:  CALL   300
0AAF:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0AB0:  MOVLW  01
0AB1:  BSF    03.6
0AB2:  MOVWF  51
0AB3:  MOVWF  52
0AB4:  BCF    0A.3
0AB5:  BCF    03.6
0AB6:  CALL   2B2
0AB7:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "        _    "); 
0AB8:  MOVLW  8C
0AB9:  BSF    03.6
0ABA:  MOVWF  0D
0ABB:  MOVLW  00
0ABC:  MOVWF  0F
0ABD:  BCF    0A.3
0ABE:  BCF    03.6
0ABF:  CALL   300
0AC0:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0AC1:  BTFSS  55.5
0AC2:  GOTO   361
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0AC3:  BSF    03.5
0AC4:  BSF    06.2
0AC5:  BCF    03.5
0AC6:  BTFSC  06.2
0AC7:  GOTO   2ED
....................       { 
....................           
....................          NUM++; 
0AC8:  BSF    03.6
0AC9:  INCF   4C,F
....................          NUM = NUM % 4; 
0ACA:  MOVLW  03
0ACB:  ANDWF  4C,F
....................          LCD_GOTOXY (5 + NUM, 1); 
0ACC:  MOVLW  05
0ACD:  ADDWF  4C,W
0ACE:  MOVWF  4D
0ACF:  MOVWF  51
0AD0:  MOVLW  01
0AD1:  MOVWF  52
0AD2:  BCF    0A.3
0AD3:  BCF    03.6
0AD4:  CALL   2B2
0AD5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    "); 
0AD6:  MOVLW  93
0AD7:  BSF    03.6
0AD8:  MOVWF  0D
0AD9:  MOVLW  00
0ADA:  MOVWF  0F
0ADB:  BCF    0A.3
0ADC:  BCF    03.6
0ADD:  CALL   300
0ADE:  BSF    0A.3
....................          DELAY_MS (300);  
0ADF:  MOVLW  02
0AE0:  BSF    03.6
0AE1:  MOVWF  4D
0AE2:  MOVLW  96
0AE3:  MOVWF  51
0AE4:  BCF    0A.3
0AE5:  BCF    03.6
0AE6:  CALL   132
0AE7:  BSF    0A.3
0AE8:  BSF    03.6
0AE9:  DECFSZ 4D,F
0AEA:  GOTO   2E2
....................       } 
0AEB:  GOTO   35F
0AEC:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0AED:  BSF    03.5
0AEE:  BSF    06.3
0AEF:  BCF    03.5
0AF0:  BTFSC  06.3
0AF1:  GOTO   360
....................       { 
....................          ID_GATEWAY[NUM]++; 
0AF2:  MOVLW  7B
0AF3:  BSF    03.6
0AF4:  ADDWF  4C,W
0AF5:  MOVWF  04
0AF6:  BCF    03.7
0AF7:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0AF8:  MOVLW  7B
0AF9:  ADDWF  4C,W
0AFA:  MOVWF  78
0AFB:  CLRF   7A
0AFC:  BTFSC  03.0
0AFD:  INCF   7A,F
0AFE:  MOVF   78,W
0AFF:  MOVWF  4D
0B00:  MOVF   7A,W
0B01:  MOVWF  4E
0B02:  MOVLW  7B
0B03:  ADDWF  4C,W
0B04:  MOVWF  04
0B05:  BCF    03.7
0B06:  MOVF   00,W
0B07:  MOVWF  50
0B08:  MOVLW  0A
0B09:  MOVWF  51
*
0B1E:  MOVF   77,W
0B1F:  MOVWF  4F
0B20:  MOVF   4D,W
0B21:  MOVWF  04
0B22:  BCF    03.7
0B23:  BTFSC  4E.0
0B24:  BSF    03.7
0B25:  MOVF   4F,W
0B26:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0B27:  MOVLW  7B
0B28:  ADDWF  4C,W
0B29:  MOVWF  04
0B2A:  BCF    03.7
0B2B:  MOVF   00,W
0B2C:  MOVWF  4D
0B2D:  CLRF   51
0B2E:  CLRF   50
0B2F:  CLRF   4F
0B30:  MOVF   4D,W
0B31:  MOVWF  4E
0B32:  MOVLW  0A
0B33:  MOVWF  52
0B34:  CLRF   54
0B35:  MOVLW  D8
0B36:  MOVWF  53
0B37:  BCF    0A.3
0B38:  BCF    03.6
0B39:  CALL   3EE
0B3A:  BSF    0A.3
....................          LCD_GOTOXY (9 + NUM, 2); 
0B3B:  MOVLW  09
0B3C:  BSF    03.6
0B3D:  ADDWF  4C,W
0B3E:  MOVWF  4D
0B3F:  MOVWF  51
0B40:  MOVLW  02
0B41:  MOVWF  52
0B42:  BCF    0A.3
0B43:  BCF    03.6
0B44:  CALL   2B2
0B45:  BSF    0A.3
....................          DELAY_MS (10); 
0B46:  MOVLW  0A
0B47:  BSF    03.6
0B48:  MOVWF  51
0B49:  BCF    0A.3
0B4A:  BCF    03.6
0B4B:  CALL   132
0B4C:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0B4D:  MOVLW  D8
0B4E:  MOVWF  04
0B4F:  BCF    03.7
0B50:  BCF    0A.3
0B51:  CALL   50E
0B52:  BSF    0A.3
....................          DELAY_MS (300); 
0B53:  MOVLW  02
0B54:  BSF    03.6
0B55:  MOVWF  4D
0B56:  MOVLW  96
0B57:  MOVWF  51
0B58:  BCF    0A.3
0B59:  BCF    03.6
0B5A:  CALL   132
0B5B:  BSF    0A.3
0B5C:  BSF    03.6
0B5D:  DECFSZ 4D,F
0B5E:  GOTO   356
0B5F:  BCF    03.6
....................       } 
0B60:  GOTO   2C1
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
010C:  BCF    03.5
010D:  BCF    03.6
010E:  BCF    55.3
....................    TT_FUN = 0; 
010F:  BCF    55.4
....................    TT_STT = 0; 
0110:  BCF    55.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    55.3
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   361
0805:  ADDLW  04
0806:  GOTO   364
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   361
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0975:  GOTO   361
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A7D:  GOTO   361
....................  
....................       CASE 3: 
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
*
0B61:  BCF    0A.3
0B62:  BCF    0A.4
0B63:  GOTO   5E8 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0566:  BSF    55.4
....................    LCD_GOTOXY (1, 1) ; 
0567:  MOVLW  01
0568:  BSF    03.6
0569:  MOVWF  51
056A:  MOVWF  52
056B:  BCF    03.6
056C:  CALL   2B2
....................    DELAY_MS (10); 
056D:  MOVLW  0A
056E:  BSF    03.6
056F:  MOVWF  51
0570:  BCF    03.6
0571:  CALL   132
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0572:  MOVLW  98
0573:  BSF    03.6
0574:  MOVWF  0D
0575:  MOVLW  00
0576:  MOVWF  0F
0577:  BCF    03.6
0578:  CALL   300
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0579:  MOVLW  01
057A:  BSF    03.6
057B:  MOVWF  51
057C:  MOVLW  02
057D:  MOVWF  52
057E:  BCF    03.6
057F:  CALL   2B2
....................    DELAY_MS (10); 
0580:  MOVLW  0A
0581:  BSF    03.6
0582:  MOVWF  51
0583:  BCF    03.6
0584:  CALL   132
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0585:  MOVLW  A0
0586:  BSF    03.6
0587:  MOVWF  0D
0588:  MOVLW  00
0589:  MOVWF  0F
058A:  BCF    03.6
058B:  CALL   300
....................  
....................    WHILE (TT_FUN) 
058C:  BTFSS  55.4
058D:  GOTO   5E4
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
058E:  BSF    03.5
058F:  BSF    06.2
0590:  BCF    03.5
0591:  BTFSC  06.2
0592:  GOTO   5E3
....................       { 
....................          CONFIG_FUN ++; 
0593:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0594:  MOVLW  03
0595:  ANDWF  38,F
....................          DELAY_MS (300); 
0596:  MOVLW  02
0597:  BSF    03.6
0598:  MOVWF  4C
0599:  MOVLW  96
059A:  MOVWF  51
059B:  BCF    03.6
059C:  CALL   132
059D:  BSF    03.6
059E:  DECFSZ 4C,F
059F:  GOTO   599
....................  
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
05A0:  MOVLW  06
05A1:  MOVWF  51
05A2:  MOVLW  02
05A3:  MOVWF  52
05A4:  BCF    03.6
05A5:  CALL   2B2
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
05A6:  BSF    03.6
05A7:  CLRF   51
05A8:  CLRF   50
05A9:  CLRF   4F
05AA:  BCF    03.6
05AB:  MOVF   38,W
05AC:  BSF    03.6
05AD:  MOVWF  4E
05AE:  MOVLW  0A
05AF:  MOVWF  52
05B0:  CLRF   54
05B1:  MOVLW  D8
05B2:  MOVWF  53
05B3:  BCF    03.6
05B4:  CALL   3EE
....................          DELAY_MS (10); 
05B5:  MOVLW  0A
05B6:  BSF    03.6
05B7:  MOVWF  51
05B8:  BCF    03.6
05B9:  CALL   132
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05BA:  MOVLW  D8
05BB:  MOVWF  04
05BC:  BCF    03.7
05BD:  CALL   50E
....................  
....................          SWITCH (CONFIG_FUN) 
05BE:  MOVF   38,W
05BF:  ADDLW  FC
05C0:  BTFSC  03.0
05C1:  GOTO   5E3
05C2:  ADDLW  04
05C3:  GOTO   5EC
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID         "); 
05C4:  MOVLW  A8
05C5:  BSF    03.6
05C6:  MOVWF  0D
05C7:  MOVLW  00
05C8:  MOVWF  0F
05C9:  BCF    03.6
05CA:  CALL   300
....................             BREAK; 
05CB:  GOTO   5E3
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - DEVICES    "); 
05CC:  MOVLW  B0
05CD:  BSF    03.6
05CE:  MOVWF  0D
05CF:  MOVLW  00
05D0:  MOVWF  0F
05D1:  BCF    03.6
05D2:  CALL   300
....................             BREAK; 
05D3:  GOTO   5E3
....................              
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, " - SENSORS    "); 
05D4:  MOVLW  B8
05D5:  BSF    03.6
05D6:  MOVWF  0D
05D7:  MOVLW  00
05D8:  MOVWF  0F
05D9:  BCF    03.6
05DA:  CALL   300
....................             BREAK; 
05DB:  GOTO   5E3
....................              
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, " - ID - GW:    "); 
05DC:  MOVLW  C0
05DD:  BSF    03.6
05DE:  MOVWF  0D
05DF:  MOVLW  00
05E0:  MOVWF  0F
05E1:  BCF    03.6
05E2:  CALL   300
....................             BREAK; 
....................          } 
....................       } 
05E3:  GOTO   58C
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05E4:  BTFSC  55.3
05E5:  GOTO   5E9
....................    { 
....................       SELLECT_FUN (); 
05E6:  BSF    0A.3
05E7:  GOTO   000
05E8:  BCF    0A.3
....................    } 
05E9:  BCF    0A.3
05EA:  BSF    0A.4
05EB:  GOTO   1A2 (RETURN)
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    *TEMP_CHAR = '\0'; 
*
06AF:  CLRF   7A
06B0:  MOVLW  D8
06B1:  MOVWF  04
06B2:  BCF    03.7
06B3:  BTFSC  7A.0
06B4:  BSF    03.7
06B5:  CLRF   00
....................    *TT_DEVICE_CHAR = '\0'; 
06B6:  CLRF   7A
06B7:  MOVLW  58
06B8:  MOVWF  04
06B9:  BCF    03.7
06BA:  BTFSC  7A.0
06BB:  BSF    03.7
06BC:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
06BD:  BSF    03.6
06BE:  CLRF   4D
06BF:  MOVF   4D,W
06C0:  SUBLW  07
06C1:  BTFSS  03.0
06C2:  GOTO   6EA
....................    { 
....................       IF (TT_DEVICE[I]) 
06C3:  MOVF   4D,W
06C4:  MOVWF  4E
06C5:  CLRF   50
06C6:  MOVLW  56
06C7:  MOVWF  4F
06C8:  BCF    03.6
06C9:  CALL   52B
06CA:  BTFSS  78.0
06CB:  GOTO   6E7
....................       { 
....................          ITOA (I, 10, TEMP_CHAR); 
06CC:  BSF    03.6
06CD:  CLRF   51
06CE:  CLRF   50
06CF:  CLRF   4F
06D0:  MOVF   4D,W
06D1:  MOVWF  4E
06D2:  MOVLW  0A
06D3:  MOVWF  52
06D4:  CLRF   54
06D5:  MOVLW  D8
06D6:  MOVWF  53
06D7:  BCF    03.6
06D8:  CALL   3EE
....................          DELAY_MS (1); 
06D9:  MOVLW  01
06DA:  BSF    03.6
06DB:  MOVWF  51
06DC:  BCF    03.6
06DD:  CALL   132
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
06DE:  BSF    03.6
06DF:  CLRF   4F
06E0:  MOVLW  58
06E1:  MOVWF  4E
06E2:  CLRF   51
06E3:  MOVLW  D8
06E4:  MOVWF  50
06E5:  BCF    03.6
06E6:  CALL   5F4
....................       } 
06E7:  BSF    03.6
06E8:  INCF   4D,F
06E9:  GOTO   6BF
....................    } 
....................  
....................    // PACKAGE_CONFIG[6] = TT_DEVICE_CHAR; 
.................... } 
....................  
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    *TEMP_CHAR = '\0'; 
06EA:  CLRF   7A
06EB:  MOVLW  D8
06EC:  MOVWF  04
06ED:  BCF    03.7
06EE:  BTFSC  7A.0
06EF:  BSF    03.7
06F0:  CLRF   00
....................    *TEMP_CHAR2 = '\0'; 
06F1:  CLRF   7A
06F2:  MOVLW  DD
06F3:  MOVWF  04
06F4:  BCF    03.7
06F5:  BTFSC  7A.0
06F6:  BSF    03.7
06F7:  CLRF   00
....................    FOR (INT J = 0; J < 5; J++) 
06F8:  CLRF   4D
06F9:  MOVF   4D,W
06FA:  SUBLW  04
06FB:  BTFSS  03.0
06FC:  GOTO   724
....................    { 
....................       IF (TT_SENSOR[J]) 
06FD:  MOVF   4D,W
06FE:  MOVWF  4E
06FF:  CLRF   50
0700:  MOVLW  57
0701:  MOVWF  4F
0702:  BCF    03.6
0703:  CALL   52B
0704:  BTFSS  78.0
0705:  GOTO   721
....................       { 
....................          ITOA (J, 10, TEMP_CHAR); 
0706:  BSF    03.6
0707:  CLRF   51
0708:  CLRF   50
0709:  CLRF   4F
070A:  MOVF   4D,W
070B:  MOVWF  4E
070C:  MOVLW  0A
070D:  MOVWF  52
070E:  CLRF   54
070F:  MOVLW  D8
0710:  MOVWF  53
0711:  BCF    03.6
0712:  CALL   3EE
....................          DELAY_MS (1); 
0713:  MOVLW  01
0714:  BSF    03.6
0715:  MOVWF  51
0716:  BCF    03.6
0717:  CALL   132
....................          STRCAT (TEMP_CHAR2, TEMP_CHAR); 
0718:  BSF    03.6
0719:  CLRF   4F
071A:  MOVLW  DD
071B:  MOVWF  4E
071C:  CLRF   51
071D:  MOVLW  D8
071E:  MOVWF  50
071F:  BCF    03.6
0720:  CALL   5F4
....................       } 
0721:  BSF    03.6
0722:  INCF   4D,F
0723:  GOTO   6F9
....................    } 
....................  
....................    //PACKAGE_CONFIG[7] = TEMP_CHAR3; 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0650:  BCF    55.4
....................    TT_STT = 0; 
0651:  BCF    55.5
....................    *TEMP_CHAR3 = "\0"; 
0652:  CLRF   7A
0653:  MOVLW  E8
0654:  BSF    03.6
0655:  MOVWF  4D
0656:  MOVF   7A,W
0657:  MOVWF  4E
0658:  MOVF   4D,W
0659:  MOVWF  04
065A:  BCF    03.7
065B:  BTFSC  4E.0
065C:  BSF    03.7
065D:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
065E:  CLRF   4C
065F:  MOVF   4C,W
0660:  SUBLW  03
0661:  BTFSS  03.0
0662:  GOTO   686
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0663:  MOVLW  7B
0664:  ADDWF  4C,W
0665:  MOVWF  04
0666:  BCF    03.7
0667:  MOVF   00,W
0668:  MOVWF  4D
0669:  CLRF   51
066A:  CLRF   50
066B:  CLRF   4F
066C:  MOVF   4D,W
066D:  MOVWF  4E
066E:  MOVLW  0A
066F:  MOVWF  52
0670:  CLRF   54
0671:  MOVLW  D8
0672:  MOVWF  53
0673:  BCF    03.6
0674:  CALL   3EE
....................       DELAY_MS (1); 
0675:  MOVLW  01
0676:  BSF    03.6
0677:  MOVWF  51
0678:  BCF    03.6
0679:  CALL   132
....................       STRCAT (TEMP_CHAR3, TEMP_CHAR); 
067A:  BSF    03.6
067B:  CLRF   4F
067C:  MOVLW  E8
067D:  MOVWF  4E
067E:  CLRF   51
067F:  MOVLW  D8
0680:  MOVWF  50
0681:  BCF    03.6
0682:  CALL   5F4
0683:  BSF    03.6
0684:  INCF   4C,F
0685:  GOTO   65F
....................    }    
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR3; 
0686:  BSF    03.5
0687:  BCF    03.6
0688:  CLRF   4B
0689:  MOVLW  E8
068A:  MOVWF  4A
....................    DELAY_MS (2); 
068B:  MOVLW  02
068C:  BCF    03.5
068D:  BSF    03.6
068E:  MOVWF  51
068F:  BCF    03.6
0690:  CALL   132
....................    PACKAGE_CONFIG[2] = ID_; 
0691:  BSF    03.5
0692:  CLRF   4D
0693:  MOVLW  71
0694:  MOVWF  4C
....................    DELAY_MS (2); 
0695:  MOVLW  02
0696:  BCF    03.5
0697:  BSF    03.6
0698:  MOVWF  51
0699:  BCF    03.6
069A:  CALL   132
....................    TT_DEVICE_CHAR = ""; 
069B:  BSF    03.6
069C:  CLRF   4D
069D:  CLRF   4E
069E:  MOVLW  58
069F:  MOVWF  04
06A0:  BCF    03.7
06A1:  MOVF   4D,W
06A2:  ADDWF  04,F
06A3:  MOVF   4E,W
06A4:  BCF    03.6
06A5:  CALL   05E
06A6:  MOVWF  00
06A7:  IORLW  00
06A8:  BTFSC  03.2
06A9:  GOTO   6AF
06AA:  BSF    03.6
06AB:  INCF   4E,F
06AC:  INCF   4D,F
06AD:  GOTO   69E
06AE:  BCF    03.6
....................    XULYDEVICE_CF (); 
....................    XULYSENSOR_CF (); 
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
*
0724:  BSF    03.5
0725:  BCF    03.6
0726:  CLRF   53
0727:  MOVLW  58
0728:  MOVWF  52
....................    DELAY_MS (2); 
0729:  MOVLW  02
072A:  BCF    03.5
072B:  BSF    03.6
072C:  MOVWF  51
072D:  BCF    03.6
072E:  CALL   132
....................    PACKAGE_CONFIG[6] = TEMP_CHAR2; 
072F:  BSF    03.5
0730:  CLRF   55
0731:  MOVLW  DD
0732:  MOVWF  54
....................    //TINH DO DAI --> 
....................    LEN_PACKAGES = 0; 
0733:  CLRF   76
....................    PACKAGE_CONFIG[3] = "12"; //DO DAI CUA LENGHT C? ?? DAI = 2 
0734:  MOVLW  31
0735:  MOVWF  4E
0736:  MOVLW  32
0737:  MOVWF  4F
....................    FOR (J = 0; J < 9; J++) 
0738:  BCF    03.5
0739:  BSF    03.6
073A:  CLRF   4C
073B:  MOVF   4C,W
073C:  SUBLW  08
073D:  BTFSS  03.0
073E:  GOTO   76F
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
073F:  BCF    03.0
0740:  RLF    4C,W
0741:  ADDLW  C8
0742:  MOVWF  04
0743:  BCF    03.7
0744:  INCF   04,F
0745:  MOVF   00,W
0746:  MOVWF  4E
0747:  DECF   04,F
0748:  MOVF   00,W
0749:  MOVWF  4D
074A:  MOVF   4E,W
074B:  MOVWF  50
074C:  MOVF   4D,W
074D:  MOVWF  4F
*
076B:  MOVF   78,W
076C:  ADDWF  76,F
076D:  INCF   4C,F
076E:  GOTO   73B
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+7; //7 @ 
076F:  MOVLW  07
0770:  ADDWF  76,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0771:  CLRF   51
0772:  CLRF   50
0773:  CLRF   4F
0774:  MOVF   76,W
0775:  MOVWF  4E
0776:  MOVLW  0A
0777:  MOVWF  52
0778:  CLRF   54
0779:  MOVLW  D8
077A:  MOVWF  53
077B:  BCF    03.6
077C:  CALL   3EE
....................    PACKAGE_CONFIG[3] = TEMP_CHAR; 
077D:  BSF    03.5
077E:  CLRF   4F
077F:  MOVLW  D8
0780:  MOVWF  4E
....................     
....................    FOR ( J = 0; J < 8; J++) 
0781:  BCF    03.5
0782:  BSF    03.6
0783:  CLRF   4C
0784:  MOVF   4C,W
0785:  SUBLW  07
0786:  BTFSS  03.0
0787:  GOTO   7A0
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0788:  BCF    03.0
0789:  RLF    4C,W
078A:  ADDLW  C8
078B:  MOVWF  04
078C:  BCF    03.7
078D:  INCF   04,F
078E:  MOVF   00,W
078F:  MOVWF  4E
0790:  DECF   04,F
0791:  MOVF   00,W
0792:  MOVWF  4D
0793:  MOVWF  04
0794:  BCF    03.7
0795:  BTFSC  4E.0
0796:  BSF    03.7
0797:  BCF    03.6
0798:  CALL   632
....................       PRINTF ("@"); 
0799:  MOVLW  40
079A:  BTFSS  0C.4
079B:  GOTO   79A
079C:  MOVWF  19
079D:  BSF    03.6
079E:  INCF   4C,F
079F:  GOTO   784
....................    } 
....................  
....................    /* 
....................    LCD_GOTOXY (1, 1) ; 
....................    DELAY_MS (10); 
....................    FOR (J = 0; J < 9; J++) 
....................    { 
....................       PRINTF (LCD_PUTC, PACKAGE_CONFIG[J]); 
....................    } 
....................    */ 
....................  
....................    LCD_GOTOXY (1, 1) ; 
07A0:  MOVLW  01
07A1:  MOVWF  51
07A2:  MOVWF  52
07A3:  BCF    03.6
07A4:  CALL   2B2
....................    DELAY_MS (10); 
07A5:  MOVLW  0A
07A6:  BSF    03.6
07A7:  MOVWF  51
07A8:  BCF    03.6
07A9:  CALL   132
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
07AA:  MOVLW  C8
07AB:  BSF    03.6
07AC:  MOVWF  0D
07AD:  MOVLW  00
07AE:  MOVWF  0F
07AF:  BCF    03.6
07B0:  CALL   300
....................    LCD_GOTOXY (1, 2) ; 
07B1:  MOVLW  01
07B2:  BSF    03.6
07B3:  MOVWF  51
07B4:  MOVLW  02
07B5:  MOVWF  52
07B6:  BCF    03.6
07B7:  CALL   2B2
....................    DELAY_MS (10); 
07B8:  MOVLW  0A
07B9:  BSF    03.6
07BA:  MOVWF  51
07BB:  BCF    03.6
07BC:  CALL   132
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
07BD:  MOVLW  D2
07BE:  BSF    03.6
07BF:  MOVWF  0D
07C0:  MOVLW  00
07C1:  MOVWF  0F
07C2:  BCF    03.6
07C3:  CALL   300
....................    PACKAGE_NHIETDO[1] = ID_; 
07C4:  CLRF   66
07C5:  MOVLW  71
07C6:  MOVWF  65
....................    TT_CONFIG_DONE = 0; 
07C7:  BCF    55.3
07C8:  BCF    0A.3
07C9:  BSF    0A.4
07CA:  GOTO   1A8 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00DC:  BSF    03.5
00DD:  BSF    03.6
00DE:  CLRF   16
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00DF:  BCF    03.6
00E0:  BSF    06.1
00E1:  BCF    03.5
00E2:  BTFSC  06.1
00E3:  GOTO   0FB
....................    { 
....................       IF (TMR1IF) 
00E4:  BTFSS  0C.0
00E5:  GOTO   0F6
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00E6:  BSF    03.5
00E7:  BCF    08.2
00E8:  MOVLW  04
00E9:  BCF    03.5
00EA:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00EB:  BCF    0C.0
00EC:  CLRF   0E
00ED:  MOVLW  0B
00EE:  MOVWF  0F
00EF:  MOVLW  DC
00F0:  MOVWF  0E
00F1:  BSF    03.5
00F2:  BSF    03.6
00F3:  INCF   16,F
00F4:  BCF    03.5
00F5:  BCF    03.6
....................       } 
00F6:  BSF    03.5
00F7:  BSF    03.6
00F8:  GOTO   0DF
00F9:  BCF    03.5
00FA:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00FB:  BSF    03.5
00FC:  BSF    03.6
00FD:  MOVF   16,W
00FE:  SUBLW  14
00FF:  BTFSC  03.0
0100:  GOTO   10C
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0101:  MOVLW  02
0102:  BCF    03.5
0103:  BCF    03.6
0104:  XORWF  55,F
....................       TT_CONTROL = ~TT_CONTROL; 
0105:  MOVLW  04
0106:  XORWF  55,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0107:  BSF    55.3
....................       TT_FUN = 0; 
0108:  BCF    55.4
....................    } 
0109:  GOTO   111
010A:  BSF    03.5
010B:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
0111:  BCF    0B.1
0112:  BCF    0A.3
0113:  BCF    0A.4
0114:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0115:  MOVLW  41
0116:  ADDWF  3C,W
0117:  MOVWF  04
0118:  BCF    03.7
0119:  BTFSS  0C.5
011A:  GOTO   119
011B:  MOVF   1A,W
011C:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
011D:  MOVLW  41
011E:  ADDWF  3C,W
011F:  MOVWF  04
0120:  BCF    03.7
0121:  MOVF   00,W
0122:  SUBLW  2E
0123:  BTFSS  03.2
0124:  GOTO   12D
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0125:  MOVLW  41
0126:  ADDWF  3C,W
0127:  MOVWF  04
0128:  BCF    03.7
0129:  CLRF   00
....................        VT = 0; 
012A:  CLRF   3C
....................        TTNHAN = 1; 
012B:  BSF    55.0
....................     } 
012C:  GOTO   12E
....................  
....................     ELSE 
....................     VT++; 
012D:  INCF   3C,F
012E:  BCF    0C.5
012F:  BCF    0A.3
0130:  BCF    0A.4
0131:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07E3:  MOVLW  01
07E4:  BSF    03.6
07E5:  MOVWF  51
07E6:  MOVWF  52
07E7:  BCF    03.6
07E8:  CALL   2B2
....................     DELAY_MS (10); 
07E9:  MOVLW  0A
07EA:  BSF    03.6
07EB:  MOVWF  51
07EC:  BCF    03.6
07ED:  CALL   132
....................     PRINTF (LCD_PUTC, KYTUCHAR); 
07EE:  MOVLW  41
07EF:  MOVWF  04
07F0:  BCF    03.7
07F1:  CALL   50E
....................     DELAY_MS (1); 
07F2:  MOVLW  01
07F3:  BSF    03.6
07F4:  MOVWF  51
07F5:  BCF    03.6
07F6:  CALL   132
07F7:  BCF    0A.3
07F8:  BSF    0A.4
07F9:  GOTO   21D (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07CB:  BSF    03.6
07CC:  CLRF   4C
07CD:  MOVF   4C,W
07CE:  SUBLW  1E
07CF:  BTFSS  03.0
07D0:  GOTO   7DF
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07D1:  BSF    03.5
07D2:  BCF    03.6
07D3:  BCF    08.1
07D4:  MOVLW  02
07D5:  BCF    03.5
07D6:  XORWF  08,F
....................        DELAY_MS (100); 
07D7:  MOVLW  64
07D8:  BSF    03.6
07D9:  MOVWF  51
07DA:  BCF    03.6
07DB:  CALL   132
07DC:  BSF    03.6
07DD:  INCF   4C,F
07DE:  GOTO   7CD
....................     } 
07DF:  BCF    03.6
07E0:  BCF    0A.3
07E1:  BSF    0A.4
07E2:  GOTO   1AE (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  BSF    03.5
1004:  BSF    03.6
1005:  BSF    07.3
1006:  MOVLW  08
1007:  BCF    03.6
1008:  MOVWF  19
1009:  MOVLW  02
100A:  MOVWF  1A
100B:  MOVLW  A6
100C:  MOVWF  18
100D:  MOVLW  90
100E:  BCF    03.5
100F:  MOVWF  18
1010:  MOVLW  FF
1011:  MOVWF  31
1012:  CLRF   38
1013:  CLRF   39
1014:  CLRF   3A
1015:  CLRF   3B
1016:  CLRF   3C
1017:  CLRF   3D
1018:  BCF    55.0
1019:  BCF    55.1
101A:  BCF    55.2
101B:  BCF    55.3
101C:  BCF    55.4
101D:  BCF    55.5
101E:  CLRF   76
101F:  BSF    03.5
1020:  BSF    03.6
1021:  MOVF   09,W
1022:  ANDLW  C0
1023:  MOVWF  09
1024:  BCF    03.6
1025:  BCF    1F.4
1026:  BCF    1F.5
1027:  MOVLW  00
1028:  BSF    03.6
1029:  MOVWF  08
102A:  BCF    03.5
102B:  CLRF   07
102C:  CLRF   08
102D:  CLRF   09
102E:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
1160:  MOVLW  00
1161:  BSF    03.5
1162:  BCF    03.6
1163:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1164:  MOVLW  FF
1165:  MOVWF  06
....................     SET_TRIS_E (0); 
1166:  BCF    09.0
1167:  BCF    09.1
1168:  BCF    09.2
1169:  BCF    09.3
....................     SET_TRIS_C (0X80); 
116A:  MOVLW  80
116B:  MOVWF  07
116C:  BCF    03.5
116D:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
116E:  BSF    1F.6
116F:  BCF    1F.7
1170:  BSF    03.5
1171:  BSF    1F.7
1172:  BCF    03.5
1173:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
1174:  BSF    03.5
1175:  BSF    03.6
1176:  MOVF   09,W
1177:  ANDLW  C0
1178:  MOVWF  09
1179:  BCF    03.6
117A:  BCF    1F.4
117B:  BCF    1F.5
117C:  MOVLW  01
117D:  BSF    03.6
117E:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
117F:  BCF    03.5
1180:  BCF    03.6
1181:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1182:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1183:  BSF    0B.4
1184:  BSF    03.5
1185:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1186:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
1187:  MOVLW  C0
1188:  BCF    03.5
1189:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
118A:  MOVLW  35
118B:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
118C:  CLRF   0E
118D:  MOVLW  0B
118E:  MOVWF  0F
118F:  MOVLW  DC
1190:  MOVWF  0E
....................     TMR1IF = 0; 
1191:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1192:  BCF    0A.4
1193:  GOTO   24C
1194:  BSF    0A.4
....................     ID_NODE = 0; 
1195:  CLRF   39
....................     TT_CONFIG = 0; 
1196:  BCF    55.1
....................     TT_CONFIG_DONE = 0; 
1197:  BCF    55.3
....................     TT_CONTROL = 1; 
1198:  BSF    55.2
....................     OUTPUT_D (0X00); 
1199:  BSF    03.5
119A:  CLRF   08
119B:  BCF    03.5
119C:  CLRF   08
....................     TTNHAN = 0; 
119D:  BCF    55.0
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        //AN0 = ADC_READ (0) ; 
....................  
....................        IF (TT_CONFIG) 
119E:  BTFSS  55.1
119F:  GOTO   1A4
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
11A0:  BCF    0A.4
11A1:  GOTO   566
11A2:  BSF    0A.4
....................        } 
11A3:  GOTO   2C9
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
11A4:  BTFSS  55.3
11A5:  GOTO   1AA
....................        { 
....................           CONFIG_DONE (); 
11A6:  BCF    0A.4
11A7:  GOTO   650
11A8:  BSF    0A.4
....................        } 
11A9:  GOTO   2C9
....................  
....................         
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
11AA:  BTFSC  55.1
11AB:  GOTO   2C9
....................           { 
....................              CHUONG_TRINH_CON (); 
11AC:  BCF    0A.4
11AD:  GOTO   7CB
11AE:  BSF    0A.4
....................  
....................              IF (AN0 > 26) 
11AF:  MOVF   35,F
11B0:  BTFSS  03.2
11B1:  GOTO   1B6
11B2:  MOVF   34,W
11B3:  SUBLW  1A
11B4:  BTFSC  03.0
11B5:  GOTO   217
....................              { 
....................                 ITOA (AN0, 10, NHIETDO1); 
11B6:  BSF    03.6
11B7:  CLRF   51
11B8:  CLRF   50
11B9:  BCF    03.6
11BA:  MOVF   35,W
11BB:  BSF    03.6
11BC:  MOVWF  4F
11BD:  BCF    03.6
11BE:  MOVF   34,W
11BF:  BSF    03.6
11C0:  MOVWF  4E
11C1:  MOVLW  0A
11C2:  MOVWF  52
11C3:  MOVLW  01
11C4:  MOVWF  54
11C5:  MOVLW  43
11C6:  MOVWF  53
11C7:  BCF    0A.4
11C8:  BCF    03.6
11C9:  CALL   3EE
11CA:  BSF    0A.4
....................                 PACKAGE_NHIETDO[4] = NHIETDO1; 
11CB:  MOVLW  01
11CC:  MOVWF  6C
11CD:  MOVLW  43
11CE:  MOVWF  6B
....................                 ITOA (AN1, 10, NHIETDO2); 
11CF:  BSF    03.6
11D0:  CLRF   51
11D1:  CLRF   50
11D2:  BCF    03.6
11D3:  MOVF   37,W
11D4:  BSF    03.6
11D5:  MOVWF  4F
11D6:  BCF    03.6
11D7:  MOVF   36,W
11D8:  BSF    03.6
11D9:  MOVWF  4E
11DA:  MOVLW  0A
11DB:  MOVWF  52
11DC:  MOVLW  01
11DD:  MOVWF  54
11DE:  MOVLW  46
11DF:  MOVWF  53
11E0:  BCF    0A.4
11E1:  BCF    03.6
11E2:  CALL   3EE
11E3:  BSF    0A.4
....................                 PACKAGE_NHIETDO[5] = NHIETDO2; 
11E4:  MOVLW  01
11E5:  MOVWF  6E
11E6:  MOVLW  46
11E7:  MOVWF  6D
....................                  
....................                 FOR (INT I = 0; I < 8; I++) 
11E8:  BSF    03.6
11E9:  CLRF   49
11EA:  MOVF   49,W
11EB:  SUBLW  07
11EC:  BTFSS  03.0
11ED:  GOTO   20B
....................                 { 
....................                    PRINTF (PACKAGE_NHIETDO[I]); 
11EE:  BCF    03.0
11EF:  RLF    49,W
11F0:  ADDLW  63
11F1:  MOVWF  04
11F2:  BCF    03.7
11F3:  INCF   04,F
11F4:  MOVF   00,W
11F5:  MOVWF  4D
11F6:  DECF   04,F
11F7:  MOVF   00,W
11F8:  MOVWF  4C
11F9:  MOVWF  04
11FA:  BCF    03.7
11FB:  BTFSC  4D.0
11FC:  BSF    03.7
11FD:  BCF    0A.4
11FE:  BCF    03.6
11FF:  CALL   632
1200:  BSF    0A.4
....................                    DELAY_MS (1); 
1201:  MOVLW  01
1202:  BSF    03.6
1203:  MOVWF  51
1204:  BCF    0A.4
1205:  BCF    03.6
1206:  CALL   132
1207:  BSF    0A.4
1208:  BSF    03.6
1209:  INCF   49,F
120A:  GOTO   1EA
....................                 } 
....................  
....................                  
....................                 DELAY_MS (1000); 
120B:  MOVLW  04
120C:  MOVWF  4C
120D:  MOVLW  FA
120E:  MOVWF  51
120F:  BCF    0A.4
1210:  BCF    03.6
1211:  CALL   132
1212:  BSF    0A.4
1213:  BSF    03.6
1214:  DECFSZ 4C,F
1215:  GOTO   20D
1216:  BCF    03.6
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
1217:  BTFSS  55.0
1218:  GOTO   2C8
....................              { 
....................                 TTNHAN = 0; 
1219:  BCF    55.0
....................                 KYTU = 0; 
121A:  CLRF   3D
....................                 //TEMP_CHAR = 'K'; 
....................                 //ID_NODE_NHAN = KYTU[1] - 48; 
....................                 //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................                 //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................                 XUATLCD (); 
121B:  BCF    0A.4
121C:  GOTO   7E3
121D:  BSF    0A.4
....................                  
....................                 /* LAY TOKEN DAU TIEN */ 
....................                 TEMP_CHAR = "_"; 
121E:  BSF    03.6
121F:  CLRF   4C
1220:  CLRF   4D
1221:  MOVLW  D8
1222:  MOVWF  04
1223:  BCF    03.7
1224:  MOVF   4C,W
1225:  ADDWF  04,F
1226:  MOVF   4D,W
1227:  BCF    0A.4
1228:  BCF    03.6
1229:  CALL   063
122A:  BSF    0A.4
122B:  MOVWF  00
122C:  IORLW  00
122D:  BTFSC  03.2
122E:  GOTO   234
122F:  BSF    03.6
1230:  INCF   4D,F
1231:  INCF   4C,F
1232:  GOTO   221
1233:  BCF    03.6
....................                 CHAR * TOKEN; 
....................                 TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
1234:  BSF    03.6
1235:  CLRF   4D
1236:  MOVLW  41
1237:  MOVWF  4C
1238:  CLRF   4F
1239:  MOVLW  D8
123A:  MOVWF  4E
123B:  BCF    0A.4
123C:  BSF    0A.3
123D:  BCF    03.6
123E:  CALL   36C
123F:  BSF    0A.4
1240:  BCF    0A.3
1241:  MOVF   79,W
1242:  BSF    03.6
1243:  MOVWF  4B
1244:  MOVF   78,W
1245:  MOVWF  4A
....................                  
....................                 /* DUYET QUA CAC TOKEN CON LAI */ 
....................                  
....................                 LCD_GOTOXY (1, 2) ; 
1246:  MOVLW  01
1247:  MOVWF  51
1248:  MOVLW  02
1249:  MOVWF  52
124A:  BCF    0A.4
124B:  BCF    03.6
124C:  CALL   2B2
124D:  BSF    0A.4
....................                 WHILE (TOKEN != NULL) 
124E:  BSF    03.6
124F:  MOVF   4A,F
1250:  BTFSS  03.2
1251:  GOTO   255
1252:  MOVF   4B,F
1253:  BTFSC  03.2
1254:  GOTO   2A6
....................                 {                 
....................                    SWITCH(KYTU) 
1255:  BCF    03.6
1256:  MOVF   3D,W
1257:  BTFSC  03.2
1258:  GOTO   260
1259:  XORLW  01
125A:  BTFSC  03.2
125B:  GOTO   26E
125C:  XORLW  03
125D:  BTFSC  03.2
125E:  GOTO   27D
125F:  GOTO   28A
....................                    { 
....................                      CASE 0: 
....................                      ID_NODE_NHAN = ATOI(TOKEN);   
1260:  BSF    03.6
1261:  MOVF   4B,W
1262:  MOVWF  4D
1263:  MOVF   4A,W
1264:  MOVWF  4C
1265:  BCF    0A.4
1266:  BSF    0A.3
1267:  BCF    03.6
1268:  CALL   45D
1269:  BSF    0A.4
126A:  BCF    0A.3
126B:  MOVF   78,W
126C:  MOVWF  3E
....................                      BREAK; 
126D:  GOTO   28A
....................                 
....................                      CASE 1: 
....................                      ID_DEVICE_NHAN =  ATOI(TOKEN) + 64 ; 
126E:  BSF    03.6
126F:  MOVF   4B,W
1270:  MOVWF  4D
1271:  MOVF   4A,W
1272:  MOVWF  4C
1273:  BCF    0A.4
1274:  BSF    0A.3
1275:  BCF    03.6
1276:  CALL   45D
1277:  BSF    0A.4
1278:  BCF    0A.3
1279:  MOVLW  40
127A:  ADDWF  78,W
127B:  MOVWF  3F
....................                      BREAK; 
127C:  GOTO   28A
....................                 
....................                      CASE 2: 
....................                      TT_DEVICE_NHAN =  ATOI(TOKEN);                  
127D:  BSF    03.6
127E:  MOVF   4B,W
127F:  MOVWF  4D
1280:  MOVF   4A,W
1281:  MOVWF  4C
1282:  BCF    0A.4
1283:  BSF    0A.3
1284:  BCF    03.6
1285:  CALL   45D
1286:  BSF    0A.4
1287:  BCF    0A.3
1288:  MOVF   78,W
1289:  MOVWF  40
....................                      BREAK; 
....................                 
....................                     
....................                    } 
....................                   //PRINTF (LCD_PUTC, TOKEN);    
....................                   DELAY_MS (1);                       
128A:  MOVLW  01
128B:  BSF    03.6
128C:  MOVWF  51
128D:  BCF    0A.4
128E:  BCF    03.6
128F:  CALL   132
1290:  BSF    0A.4
....................                   TOKEN = STRTOK(NULL, TEMP_CHAR); 
1291:  BSF    03.6
1292:  CLRF   4D
1293:  CLRF   4C
1294:  CLRF   4F
1295:  MOVLW  D8
1296:  MOVWF  4E
1297:  BCF    0A.4
1298:  BSF    0A.3
1299:  BCF    03.6
129A:  CALL   36C
129B:  BSF    0A.4
129C:  BCF    0A.3
129D:  MOVF   79,W
129E:  BSF    03.6
129F:  MOVWF  4B
12A0:  MOVF   78,W
12A1:  MOVWF  4A
....................                   KYTU++;      
12A2:  BCF    03.6
12A3:  INCF   3D,F
12A4:  GOTO   24E
12A5:  BSF    03.6
....................                  
....................                 } 
....................                 IF (ID_NODE_NHAN == ID_NODE) 
12A6:  BCF    03.6
12A7:  MOVF   39,W
12A8:  SUBWF  3E,W
12A9:  BTFSS  03.2
12AA:  GOTO   2C8
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
12AB:  MOVF   40,F
12AC:  BTFSS  03.2
12AD:  GOTO   2B0
12AE:  MOVLW  00
12AF:  GOTO   2B1
12B0:  MOVLW  01
12B1:  MOVWF  77
12B2:  MOVF   3F,W
12B3:  BSF    03.6
12B4:  MOVWF  4D
12B5:  MOVF   77,W
12B6:  MOVWF  4E
12B7:  CLRF   50
12B8:  CLRF   4F
12B9:  BCF    0A.4
12BA:  BCF    03.6
12BB:  CALL   544
12BC:  BSF    0A.4
12BD:  MOVF   3F,W
12BE:  BSF    03.6
12BF:  MOVWF  4D
12C0:  CLRF   4E
12C1:  CLRF   50
12C2:  MOVLW  80
12C3:  MOVWF  4F
12C4:  BCF    0A.4
12C5:  BCF    03.6
12C6:  CALL   544
12C7:  BSF    0A.4
....................                 } 
....................              } 
12C8:  GOTO   1AA
....................           } 
....................        } 
12C9:  GOTO   19E
....................     } 
....................  } 
....................  
12CA:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
