CCS PCM C Compiler, Version 5.015, 5967               19-Oct-21 20:47

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3168 words (39%)
                           Largest free fragment is 2048
               RAM used:   204 (55%) at main() level
                           244 (66%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   27D
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   080
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0AF
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  20
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  20
0063:  RETLW  2A
0064:  RETLW  20
0065:  RETLW  00
0066:  BCF    0A.0
0067:  BCF    0A.1
0068:  BCF    0A.2
0069:  ADDWF  02,F
006A:  RETLW  00
006B:  DATA 49,22
006C:  DATA 3A,10
006D:  DATA 00,00
006E:  DATA C4,22
006F:  DATA D6,24
0070:  DATA C3,22
0071:  DATA 3A,10
0072:  DATA 00,01
0073:  DATA D3,22
0074:  DATA CE,29
0075:  DATA 4F,29
0076:  DATA 3A,10
0077:  DATA 00,01
0078:  DATA C3,27
0079:  DATA 4E,23
007A:  DATA C9,23
007B:  DATA 00,01
007C:  DATA C3,20
007D:  DATA D3,22
007E:  DATA 3A,10
007F:  DATA 00,00
*
027C:  MOVLW  8E
027D:  MOVWF  77
027E:  MOVF   40,W
027F:  MOVWF  78
0280:  MOVF   3F,W
0281:  MOVWF  79
0282:  CLRF   7A
0283:  MOVF   78,F
0284:  BTFSS  03.2
0285:  GOTO   290
0286:  MOVF   79,W
0287:  MOVWF  78
0288:  CLRF   79
0289:  MOVLW  08
028A:  SUBWF  77,F
028B:  MOVF   78,F
028C:  BTFSS  03.2
028D:  GOTO   290
028E:  CLRF   77
028F:  GOTO   298
0290:  BCF    03.0
0291:  BTFSC  78.7
0292:  GOTO   297
0293:  RLF    79,F
0294:  RLF    78,F
0295:  DECF   77,F
0296:  GOTO   290
0297:  BCF    78.7
*
02A8:  MOVF   3F,W
02A9:  BTFSC  03.2
02AA:  GOTO   36D
02AB:  MOVWF  4B
02AC:  MOVF   43,W
02AD:  BTFSC  03.2
02AE:  GOTO   36D
02AF:  SUBWF  4B,F
02B0:  BTFSS  03.0
02B1:  GOTO   2B7
02B2:  MOVLW  7F
02B3:  ADDWF  4B,F
02B4:  BTFSC  03.0
02B5:  GOTO   36D
02B6:  GOTO   2BD
02B7:  MOVLW  81
02B8:  SUBWF  4B,F
02B9:  BTFSS  03.0
02BA:  GOTO   36D
02BB:  BTFSC  03.2
02BC:  GOTO   36D
02BD:  MOVF   4B,W
02BE:  MOVWF  77
02BF:  CLRF   78
02C0:  CLRF   79
02C1:  CLRF   7A
02C2:  CLRF   4A
02C3:  MOVF   40,W
02C4:  MOVWF  49
02C5:  BSF    49.7
02C6:  MOVF   41,W
02C7:  MOVWF  48
02C8:  MOVF   42,W
02C9:  MOVWF  47
02CA:  MOVLW  19
02CB:  MOVWF  4B
02CC:  MOVF   46,W
02CD:  SUBWF  47,F
02CE:  BTFSC  03.0
02CF:  GOTO   2E0
02D0:  MOVLW  01
02D1:  SUBWF  48,F
02D2:  BTFSC  03.0
02D3:  GOTO   2E0
02D4:  SUBWF  49,F
02D5:  BTFSC  03.0
02D6:  GOTO   2E0
02D7:  SUBWF  4A,F
02D8:  BTFSC  03.0
02D9:  GOTO   2E0
02DA:  INCF   4A,F
02DB:  INCF   49,F
02DC:  INCF   48,F
02DD:  MOVF   46,W
02DE:  ADDWF  47,F
02DF:  GOTO   312
02E0:  MOVF   45,W
02E1:  SUBWF  48,F
02E2:  BTFSC  03.0
02E3:  GOTO   2FB
02E4:  MOVLW  01
02E5:  SUBWF  49,F
02E6:  BTFSC  03.0
02E7:  GOTO   2FB
02E8:  SUBWF  4A,F
02E9:  BTFSC  03.0
02EA:  GOTO   2FB
02EB:  INCF   4A,F
02EC:  INCF   49,F
02ED:  MOVF   45,W
02EE:  ADDWF  48,F
02EF:  MOVF   46,W
02F0:  ADDWF  47,F
02F1:  BTFSS  03.0
02F2:  GOTO   312
02F3:  INCF   48,F
02F4:  BTFSS  03.2
02F5:  GOTO   312
02F6:  INCF   49,F
02F7:  BTFSS  03.2
02F8:  GOTO   312
02F9:  INCF   4A,F
02FA:  GOTO   312
02FB:  MOVF   44,W
02FC:  IORLW  80
02FD:  SUBWF  49,F
02FE:  BTFSC  03.0
02FF:  GOTO   311
0300:  MOVLW  01
0301:  SUBWF  4A,F
0302:  BTFSC  03.0
0303:  GOTO   311
0304:  INCF   4A,F
0305:  MOVF   44,W
0306:  IORLW  80
0307:  ADDWF  49,F
0308:  MOVF   45,W
0309:  ADDWF  48,F
030A:  BTFSS  03.0
030B:  GOTO   2EF
030C:  INCF   49,F
030D:  BTFSS  03.2
030E:  GOTO   2EF
030F:  INCF   4A,F
0310:  GOTO   2EF
0311:  BSF    7A.0
0312:  DECFSZ 4B,F
0313:  GOTO   315
0314:  GOTO   320
0315:  BCF    03.0
0316:  RLF    47,F
0317:  RLF    48,F
0318:  RLF    49,F
0319:  RLF    4A,F
031A:  BCF    03.0
031B:  RLF    7A,F
031C:  RLF    79,F
031D:  RLF    78,F
031E:  RLF    4C,F
031F:  GOTO   2CC
0320:  BTFSS  4C.0
0321:  GOTO   328
0322:  BCF    03.0
0323:  RRF    78,F
0324:  RRF    79,F
0325:  RRF    7A,F
0326:  RRF    4C,F
0327:  GOTO   32B
0328:  DECF   77,F
0329:  BTFSC  03.2
032A:  GOTO   36D
032B:  BTFSC  4C.7
032C:  GOTO   354
032D:  BCF    03.0
032E:  RLF    47,F
032F:  RLF    48,F
0330:  RLF    49,F
0331:  RLF    4A,F
0332:  MOVF   46,W
0333:  SUBWF  47,F
0334:  BTFSC  03.0
0335:  GOTO   340
0336:  MOVLW  01
0337:  SUBWF  48,F
0338:  BTFSC  03.0
0339:  GOTO   340
033A:  SUBWF  49,F
033B:  BTFSC  03.0
033C:  GOTO   340
033D:  SUBWF  4A,F
033E:  BTFSS  03.0
033F:  GOTO   363
0340:  MOVF   45,W
0341:  SUBWF  48,F
0342:  BTFSC  03.0
0343:  GOTO   34B
0344:  MOVLW  01
0345:  SUBWF  49,F
0346:  BTFSC  03.0
0347:  GOTO   34B
0348:  SUBWF  4A,F
0349:  BTFSS  03.0
034A:  GOTO   363
034B:  MOVF   44,W
034C:  IORLW  80
034D:  SUBWF  49,F
034E:  BTFSC  03.0
034F:  GOTO   354
0350:  MOVLW  01
0351:  SUBWF  4A,F
0352:  BTFSS  03.0
0353:  GOTO   363
0354:  INCF   7A,F
0355:  BTFSS  03.2
0356:  GOTO   363
0357:  INCF   79,F
0358:  BTFSS  03.2
0359:  GOTO   363
035A:  INCF   78,F
035B:  BTFSS  03.2
035C:  GOTO   363
035D:  INCF   77,F
035E:  BTFSC  03.2
035F:  GOTO   36D
0360:  RRF    78,F
0361:  RRF    79,F
0362:  RRF    7A,F
0363:  MOVF   40,W
0364:  MOVWF  4B
0365:  MOVF   44,W
0366:  XORWF  4B,F
0367:  BTFSS  4B.7
0368:  GOTO   36B
0369:  BSF    78.7
036A:  GOTO   371
036B:  BCF    78.7
036C:  GOTO   371
036D:  CLRF   77
036E:  CLRF   78
036F:  CLRF   79
0370:  CLRF   7A
*
0379:  MOVLW  8E
037A:  MOVWF  77
037B:  MOVF   3F,W
037C:  SUBWF  77,F
037D:  MOVF   40,W
037E:  MOVWF  79
037F:  MOVF   41,W
0380:  MOVWF  78
0381:  BSF    79.7
0382:  MOVF   77,F
0383:  BTFSC  03.2
0384:  GOTO   390
0385:  BCF    03.0
0386:  MOVF   79,F
0387:  BTFSS  03.2
0388:  GOTO   38C
0389:  MOVF   78,F
038A:  BTFSC  03.2
038B:  GOTO   390
038C:  RRF    79,F
038D:  RRF    78,F
038E:  DECFSZ 77,F
038F:  GOTO   385
0390:  BTFSS  40.7
0391:  GOTO   397
0392:  COMF   78,F
0393:  COMF   79,F
0394:  INCF   78,F
0395:  BTFSC  03.2
0396:  INCF   79,F
*
03EF:  MOVF   0B,W
03F0:  BSF    03.6
03F1:  MOVWF  3D
03F2:  BCF    03.6
03F3:  BCF    0B.7
03F4:  BSF    03.5
03F5:  BSF    03.6
03F6:  BSF    0C.7
03F7:  BSF    0C.0
03F8:  NOP
03F9:  NOP
03FA:  BCF    03.5
03FB:  BTFSS  3D.7
03FC:  GOTO   400
03FD:  BCF    03.6
03FE:  BSF    0B.7
03FF:  BSF    03.6
0400:  MOVF   0C,W
0401:  ANDLW  7F
0402:  BTFSC  03.2
0403:  GOTO   43D
0404:  MOVWF  3D
0405:  MOVF   0D,W
0406:  MOVWF  3E
0407:  MOVF   0F,W
0408:  MOVWF  3F
0409:  MOVF   3D,W
040A:  MOVWF  40
040B:  BCF    03.6
040C:  CALL   3B5
040D:  BSF    03.6
040E:  MOVF   3E,W
040F:  MOVWF  0D
0410:  MOVF   3F,W
0411:  MOVWF  0F
0412:  BCF    03.6
0413:  MOVF   0B,W
0414:  BSF    03.6
0415:  MOVWF  40
0416:  BCF    03.6
0417:  BCF    0B.7
0418:  BSF    03.5
0419:  BSF    03.6
041A:  BSF    0C.7
041B:  BSF    0C.0
041C:  NOP
041D:  NOP
041E:  BCF    03.5
041F:  BTFSS  40.7
0420:  GOTO   424
0421:  BCF    03.6
0422:  BSF    0B.7
0423:  BSF    03.6
0424:  RLF    0C,W
0425:  RLF    0E,W
0426:  ANDLW  7F
0427:  BTFSC  03.2
0428:  GOTO   43D
0429:  MOVWF  3D
042A:  MOVF   0D,W
042B:  MOVWF  3E
042C:  MOVF   0F,W
042D:  MOVWF  3F
042E:  MOVF   3D,W
042F:  MOVWF  40
0430:  BCF    03.6
0431:  CALL   3B5
0432:  BSF    03.6
0433:  MOVF   3E,W
0434:  MOVWF  0D
0435:  MOVF   3F,W
0436:  MOVWF  0F
0437:  INCF   0D,F
0438:  BTFSC  03.2
0439:  INCF   0F,F
043A:  BCF    03.6
043B:  GOTO   3EF
043C:  BSF    03.6
043D:  BCF    03.6
043E:  RETURN
043F:  BTFSC  03.1
0440:  GOTO   444
0441:  MOVLW  5E
0442:  MOVWF  04
0443:  BSF    03.7
0444:  BSF    03.6
0445:  MOVF   59,W
0446:  XORWF  5D,W
0447:  ANDLW  80
0448:  MOVWF  63
0449:  BTFSS  59.7
044A:  GOTO   456
044B:  COMF   56,F
044C:  COMF   57,F
044D:  COMF   58,F
044E:  COMF   59,F
044F:  INCF   56,F
0450:  BTFSC  03.2
0451:  INCF   57,F
0452:  BTFSC  03.2
0453:  INCF   58,F
0454:  BTFSC  03.2
0455:  INCF   59,F
0456:  BTFSS  5D.7
0457:  GOTO   463
0458:  COMF   5A,F
0459:  COMF   5B,F
045A:  COMF   5C,F
045B:  COMF   5D,F
045C:  INCF   5A,F
045D:  BTFSC  03.2
045E:  INCF   5B,F
045F:  BTFSC  03.2
0460:  INCF   5C,F
0461:  BTFSC  03.2
0462:  INCF   5D,F
0463:  CLRF   77
0464:  CLRF   78
0465:  CLRF   79
0466:  CLRF   7A
0467:  CLRF   5E
0468:  CLRF   5F
0469:  CLRF   60
046A:  CLRF   61
046B:  MOVF   5D,W
046C:  IORWF  5C,W
046D:  IORWF  5B,W
046E:  IORWF  5A,W
046F:  BTFSC  03.2
0470:  GOTO   4A1
0471:  MOVLW  20
0472:  MOVWF  62
0473:  BCF    03.0
0474:  RLF    56,F
0475:  RLF    57,F
0476:  RLF    58,F
0477:  RLF    59,F
0478:  RLF    5E,F
0479:  RLF    5F,F
047A:  RLF    60,F
047B:  RLF    61,F
047C:  MOVF   5D,W
047D:  SUBWF  61,W
047E:  BTFSS  03.2
047F:  GOTO   48A
0480:  MOVF   5C,W
0481:  SUBWF  60,W
0482:  BTFSS  03.2
0483:  GOTO   48A
0484:  MOVF   5B,W
0485:  SUBWF  5F,W
0486:  BTFSS  03.2
0487:  GOTO   48A
0488:  MOVF   5A,W
0489:  SUBWF  5E,W
048A:  BTFSS  03.0
048B:  GOTO   49B
048C:  MOVF   5A,W
048D:  SUBWF  5E,F
048E:  MOVF   5B,W
048F:  BTFSS  03.0
0490:  INCFSZ 5B,W
0491:  SUBWF  5F,F
0492:  MOVF   5C,W
0493:  BTFSS  03.0
0494:  INCFSZ 5C,W
0495:  SUBWF  60,F
0496:  MOVF   5D,W
0497:  BTFSS  03.0
0498:  INCFSZ 5D,W
0499:  SUBWF  61,F
049A:  BSF    03.0
049B:  RLF    77,F
049C:  RLF    78,F
049D:  RLF    79,F
049E:  RLF    7A,F
049F:  DECFSZ 62,F
04A0:  GOTO   473
04A1:  BTFSS  63.7
04A2:  GOTO   4AE
04A3:  COMF   77,F
04A4:  COMF   78,F
04A5:  COMF   79,F
04A6:  COMF   7A,F
04A7:  INCF   77,F
04A8:  BTFSC  03.2
04A9:  INCF   78,F
04AA:  BTFSC  03.2
04AB:  INCF   79,F
04AC:  BTFSC  03.2
04AD:  INCF   7A,F
04AE:  MOVF   5E,W
04AF:  MOVWF  00
04B0:  INCF   04,F
04B1:  MOVF   5F,W
04B2:  MOVWF  00
04B3:  INCF   04,F
04B4:  MOVF   60,W
04B5:  MOVWF  00
04B6:  INCF   04,F
04B7:  MOVF   61,W
04B8:  MOVWF  00
04B9:  BCF    03.6
04BA:  RETURN
*
04D4:  MOVLW  20
04D5:  MOVWF  5A
04D6:  CLRF   56
04D7:  CLRF   57
04D8:  CLRF   58
04D9:  CLRF   59
04DA:  MOVF   51,W
04DB:  MOVWF  7A
04DC:  MOVF   50,W
04DD:  MOVWF  79
04DE:  MOVF   4F,W
04DF:  MOVWF  78
04E0:  MOVF   4E,W
04E1:  MOVWF  77
04E2:  BCF    03.0
04E3:  BTFSS  77.0
04E4:  GOTO   4F3
04E5:  MOVF   52,W
04E6:  ADDWF  56,F
04E7:  MOVF   53,W
04E8:  BTFSC  03.0
04E9:  INCFSZ 53,W
04EA:  ADDWF  57,F
04EB:  MOVF   54,W
04EC:  BTFSC  03.0
04ED:  INCFSZ 54,W
04EE:  ADDWF  58,F
04EF:  MOVF   55,W
04F0:  BTFSC  03.0
04F1:  INCFSZ 55,W
04F2:  ADDWF  59,F
04F3:  RRF    59,F
04F4:  RRF    58,F
04F5:  RRF    57,F
04F6:  RRF    56,F
04F7:  RRF    7A,F
04F8:  RRF    79,F
04F9:  RRF    78,F
04FA:  RRF    77,F
04FB:  DECFSZ 5A,F
04FC:  GOTO   4E2
*
05DB:  MOVF   00,F
05DC:  BTFSC  03.2
05DD:  GOTO   5F7
05DE:  BSF    03.6
05DF:  CLRF   3F
05E0:  MOVF   04,W
05E1:  MOVWF  3E
05E2:  BCF    3F.0
05E3:  BTFSC  03.7
05E4:  BSF    3F.0
05E5:  MOVF   00,W
05E6:  MOVWF  40
05E7:  BCF    03.6
05E8:  CALL   3B5
05E9:  BSF    03.6
05EA:  MOVF   3E,W
05EB:  MOVWF  04
05EC:  BCF    03.7
05ED:  BTFSC  3F.0
05EE:  BSF    03.7
05EF:  INCF   04,F
05F0:  BTFSS  03.2
05F1:  GOTO   5F5
05F2:  BCF    03.6
05F3:  INCF   05,F
05F4:  BSF    03.6
05F5:  BCF    03.6
05F6:  GOTO   5DB
05F7:  RETURN
05F8:  BSF    03.6
05F9:  MOVF   3F,W
05FA:  ANDLW  07
05FB:  MOVWF  77
05FC:  RRF    3F,W
05FD:  MOVWF  78
05FE:  RRF    78,F
05FF:  RRF    78,F
0600:  MOVLW  1F
0601:  ANDWF  78,F
0602:  MOVF   78,W
0603:  ADDWF  40,W
0604:  MOVWF  04
0605:  BCF    03.7
0606:  BTFSC  41.0
0607:  BSF    03.7
0608:  MOVF   00,W
0609:  MOVWF  78
060A:  INCF   77,F
060B:  GOTO   60D
060C:  RRF    78,F
060D:  DECFSZ 77,F
060E:  GOTO   60C
060F:  BCF    03.6
0610:  RETURN
0611:  BSF    03.6
0612:  MOVF   3E,W
0613:  ANDLW  07
0614:  MOVWF  77
0615:  RRF    3E,W
0616:  MOVWF  78
0617:  RRF    78,F
0618:  RRF    78,F
0619:  MOVLW  1F
061A:  ANDWF  78,F
061B:  MOVF   78,W
061C:  ADDWF  40,W
061D:  MOVWF  04
061E:  BCF    03.7
061F:  BTFSC  41.0
0620:  BSF    03.7
0621:  CLRF   78
0622:  INCF   78,F
0623:  INCF   77,F
0624:  GOTO   626
0625:  RLF    78,F
0626:  DECFSZ 77,F
0627:  GOTO   625
0628:  MOVF   3F,F
0629:  BTFSC  03.2
062A:  GOTO   62E
062B:  MOVF   78,W
062C:  IORWF  00,F
062D:  GOTO   631
062E:  COMF   78,F
062F:  MOVF   78,W
0630:  ANDWF  00,F
0631:  BCF    03.6
0632:  RETURN
*
06D4:  MOVF   00,F
06D5:  BTFSC  03.2
06D6:  GOTO   6F1
06D7:  BSF    03.6
06D8:  CLRF   41
06D9:  MOVF   04,W
06DA:  MOVWF  40
06DB:  BCF    41.0
06DC:  BTFSC  03.7
06DD:  BSF    41.0
06DE:  MOVF   00,W
06DF:  BCF    03.6
06E0:  BTFSS  0C.4
06E1:  GOTO   6E0
06E2:  MOVWF  19
06E3:  BSF    03.6
06E4:  MOVF   40,W
06E5:  MOVWF  04
06E6:  BCF    03.7
06E7:  BTFSC  41.0
06E8:  BSF    03.7
06E9:  INCF   04,F
06EA:  BTFSS  03.2
06EB:  GOTO   6EF
06EC:  BCF    03.6
06ED:  INCF   05,F
06EE:  BSF    03.6
06EF:  BCF    03.6
06F0:  GOTO   6D4
06F1:  RETURN
*
0A75:  BCF    0A.0
0A76:  BSF    0A.1
0A77:  BCF    0A.2
0A78:  ADDWF  02,F
0A79:  GOTO   007
0A7A:  GOTO   06E
0A7B:  GOTO   16F
0A7C:  GOTO   270
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0696:  BSF    03.6
0697:  MOVF   40,W
0698:  MOVWF  44
0699:  MOVF   3F,W
069A:  MOVWF  43
069B:  MOVF   44,W
069C:  MOVWF  7A
069D:  MOVF   43,W
069E:  MOVWF  04
069F:  BCF    03.7
06A0:  BTFSC  7A.0
06A1:  BSF    03.7
06A2:  MOVF   00,F
06A3:  BTFSC  03.2
06A4:  GOTO   6A9
06A5:  INCF   43,F
06A6:  BTFSC  03.2
06A7:  INCF   44,F
06A8:  GOTO   69B
....................    while(*s2 != '\0') 
06A9:  MOVF   42,W
06AA:  MOVWF  7A
06AB:  MOVF   41,W
06AC:  MOVWF  04
06AD:  BCF    03.7
06AE:  BTFSC  7A.0
06AF:  BSF    03.7
06B0:  MOVF   00,F
06B1:  BTFSC  03.2
06B2:  GOTO   6C8
....................    { 
....................       *s = *s2; 
06B3:  MOVF   41,W
06B4:  MOVWF  04
06B5:  BCF    03.7
06B6:  BTFSC  42.0
06B7:  BSF    03.7
06B8:  MOVF   00,W
06B9:  MOVWF  47
06BA:  MOVF   43,W
06BB:  MOVWF  04
06BC:  BCF    03.7
06BD:  BTFSC  44.0
06BE:  BSF    03.7
06BF:  MOVF   47,W
06C0:  MOVWF  00
....................       ++s; 
06C1:  INCF   43,F
06C2:  BTFSC  03.2
06C3:  INCF   44,F
....................       ++s2; 
06C4:  INCF   41,F
06C5:  BTFSC  03.2
06C6:  INCF   42,F
06C7:  GOTO   6A9
....................    } 
....................  
....................    *s = '\0'; 
06C8:  MOVF   43,W
06C9:  MOVWF  04
06CA:  BCF    03.7
06CB:  BTFSC  44.0
06CC:  BSF    03.7
06CD:  CLRF   00
....................    return(s1); 
06CE:  MOVF   3F,W
06CF:  MOVWF  78
06D0:  MOVF   40,W
06D1:  MOVWF  79
06D2:  BCF    03.6
06D3:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0AAA:  BCF    03.6
0AAB:  CLRF   2B
0AAC:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04BB:  BSF    03.6
04BC:  CLRF   49
04BD:  CLRF   48
04BE:  CLRF   47
04BF:  MOVLW  01
04C0:  MOVWF  46
04C1:  CLRF   4B
04C2:  CLRF   4C
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04C3:  BTFSS  42.7
04C4:  GOTO   505
....................          sign=1;        // Check for negative number 
04C5:  MOVLW  01
04C6:  MOVWF  4B
....................          num*=-1; 
04C7:  MOVF   42,W
04C8:  MOVWF  51
04C9:  MOVF   41,W
04CA:  MOVWF  50
04CB:  MOVF   40,W
04CC:  MOVWF  4F
04CD:  MOVF   3F,W
04CE:  MOVWF  4E
04CF:  MOVLW  FF
04D0:  MOVWF  55
04D1:  MOVWF  54
04D2:  MOVWF  53
04D3:  MOVWF  52
*
04FD:  MOVF   7A,W
04FE:  MOVWF  42
04FF:  MOVF   79,W
0500:  MOVWF  41
0501:  MOVF   78,W
0502:  MOVWF  40
0503:  MOVF   77,W
0504:  MOVWF  3F
....................      } 
....................  
....................      while(temp>0) { 
0505:  MOVF   46,F
0506:  BTFSS  03.2
0507:  GOTO   511
0508:  MOVF   47,F
0509:  BTFSS  03.2
050A:  GOTO   511
050B:  MOVF   48,F
050C:  BTFSS  03.2
050D:  GOTO   511
050E:  MOVF   49,F
050F:  BTFSC  03.2
0510:  GOTO   58D
....................          temp=(num/base); 
0511:  BCF    03.1
0512:  MOVF   42,W
0513:  MOVWF  59
0514:  MOVF   41,W
0515:  MOVWF  58
0516:  MOVF   40,W
0517:  MOVWF  57
0518:  MOVF   3F,W
0519:  MOVWF  56
051A:  CLRF   5D
051B:  CLRF   5C
051C:  CLRF   5B
051D:  MOVF   43,W
051E:  MOVWF  5A
051F:  BCF    03.6
0520:  CALL   43F
0521:  MOVF   7A,W
0522:  BSF    03.6
0523:  MOVWF  49
0524:  MOVF   79,W
0525:  MOVWF  48
0526:  MOVF   78,W
0527:  MOVWF  47
0528:  MOVF   77,W
0529:  MOVWF  46
....................          s[cnt]=(num%base)+'0';    // Conversion 
052A:  MOVF   4C,W
052B:  ADDWF  44,W
052C:  MOVWF  78
052D:  MOVF   45,W
052E:  MOVWF  7A
052F:  BTFSC  03.0
0530:  INCF   7A,F
0531:  MOVF   78,W
0532:  MOVWF  4E
0533:  MOVF   7A,W
0534:  MOVWF  4F
0535:  CLRF   51
0536:  MOVF   04,W
0537:  MOVWF  50
0538:  BCF    51.0
0539:  BTFSC  03.7
053A:  BSF    51.0
053B:  BSF    03.1
053C:  MOVLW  52
053D:  MOVWF  04
053E:  BSF    03.7
053F:  MOVF   42,W
0540:  MOVWF  59
0541:  MOVF   41,W
0542:  MOVWF  58
0543:  MOVF   40,W
0544:  MOVWF  57
0545:  MOVF   3F,W
0546:  MOVWF  56
0547:  CLRF   5D
0548:  CLRF   5C
0549:  CLRF   5B
054A:  MOVF   43,W
054B:  MOVWF  5A
054C:  BCF    03.6
054D:  CALL   43F
054E:  BSF    03.6
054F:  MOVF   50,W
0550:  MOVWF  04
0551:  BCF    03.7
0552:  BTFSC  51.0
0553:  BSF    03.7
0554:  MOVLW  30
0555:  ADDWF  52,W
0556:  MOVWF  77
0557:  MOVF   53,W
0558:  MOVWF  78
0559:  MOVLW  00
055A:  BTFSC  03.0
055B:  MOVLW  01
055C:  ADDWF  78,F
055D:  MOVF   54,W
055E:  MOVWF  79
055F:  MOVLW  00
0560:  BTFSC  03.0
0561:  MOVLW  01
0562:  ADDWF  79,F
0563:  MOVF   55,W
0564:  MOVWF  7A
0565:  MOVLW  00
0566:  BTFSC  03.0
0567:  MOVLW  01
0568:  ADDWF  7A,F
0569:  MOVF   4E,W
056A:  MOVWF  04
056B:  BCF    03.7
056C:  BTFSC  4F.0
056D:  BSF    03.7
056E:  MOVF   77,W
056F:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0570:  MOVF   4C,W
0571:  ADDWF  44,W
0572:  MOVWF  04
0573:  BCF    03.7
0574:  BTFSC  45.0
0575:  BSF    03.7
0576:  MOVF   00,W
0577:  SUBLW  39
0578:  BTFSC  03.0
0579:  GOTO   583
....................             s[cnt]+=0x7; 
057A:  MOVF   4C,W
057B:  ADDWF  44,W
057C:  MOVWF  04
057D:  BCF    03.7
057E:  BTFSC  45.0
057F:  BSF    03.7
0580:  MOVLW  07
0581:  ADDWF  00,W
0582:  MOVWF  00
....................  
....................          cnt++; 
0583:  INCF   4C,F
....................          num=temp; 
0584:  MOVF   49,W
0585:  MOVWF  42
0586:  MOVF   48,W
0587:  MOVWF  41
0588:  MOVF   47,W
0589:  MOVWF  40
058A:  MOVF   46,W
058B:  MOVWF  3F
058C:  GOTO   505
....................      } 
....................  
....................      if(sign==1) { 
058D:  DECFSZ 4B,W
058E:  GOTO   598
....................          s[cnt]=0x2D;      // Negative sign 
058F:  MOVF   4C,W
0590:  ADDWF  44,W
0591:  MOVWF  04
0592:  BCF    03.7
0593:  BTFSC  45.0
0594:  BSF    03.7
0595:  MOVLW  2D
0596:  MOVWF  00
....................          cnt++; 
0597:  INCF   4C,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0598:  CLRF   4A
0599:  BCF    03.0
059A:  RRF    4C,W
059B:  SUBWF  4A,W
059C:  BTFSC  03.0
059D:  GOTO   5CE
....................  
....................          c=s[i]; 
059E:  MOVF   4A,W
059F:  ADDWF  44,W
05A0:  MOVWF  04
05A1:  BCF    03.7
05A2:  BTFSC  45.0
05A3:  BSF    03.7
05A4:  MOVF   00,W
05A5:  MOVWF  4D
....................          s[i]=s[cnt-i-1];        // Reverse the number 
05A6:  MOVF   4A,W
05A7:  ADDWF  44,W
05A8:  MOVWF  78
05A9:  MOVF   45,W
05AA:  MOVWF  7A
05AB:  BTFSC  03.0
05AC:  INCF   7A,F
05AD:  MOVF   78,W
05AE:  MOVWF  4E
05AF:  MOVF   7A,W
05B0:  MOVWF  4F
05B1:  MOVF   4A,W
05B2:  SUBWF  4C,W
05B3:  ADDLW  FF
05B4:  ADDWF  44,W
05B5:  MOVWF  04
05B6:  BCF    03.7
05B7:  BTFSC  45.0
05B8:  BSF    03.7
05B9:  MOVF   00,W
05BA:  MOVWF  50
05BB:  MOVF   4E,W
05BC:  MOVWF  04
05BD:  BCF    03.7
05BE:  BTFSC  4F.0
05BF:  BSF    03.7
05C0:  MOVF   50,W
05C1:  MOVWF  00
....................          s[cnt-i-1]=c; 
05C2:  MOVF   4A,W
05C3:  SUBWF  4C,W
05C4:  ADDLW  FF
05C5:  ADDWF  44,W
05C6:  MOVWF  04
05C7:  BCF    03.7
05C8:  BTFSC  45.0
05C9:  BSF    03.7
05CA:  MOVF   4D,W
05CB:  MOVWF  00
05CC:  INCF   4A,F
05CD:  GOTO   599
....................      } 
....................      s[cnt]='\0';     // End the string 
05CE:  MOVF   4C,W
05CF:  ADDWF  44,W
05D0:  MOVWF  04
05D1:  BCF    03.7
05D2:  BTFSC  45.0
05D3:  BSF    03.7
05D4:  CLRF   00
....................      return s; 
05D5:  MOVF   44,W
05D6:  MOVWF  78
05D7:  MOVF   45,W
05D8:  MOVWF  79
05D9:  BCF    03.6
05DA:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S? NGUY?N 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S? NGUY?N D?I 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S? THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
00CD:  MOVLW  42
00CE:  MOVWF  04
00CF:  BSF    03.7
00D0:  MOVF   00,W
00D1:  BTFSC  03.2
00D2:  GOTO   0E0
00D3:  MOVLW  06
00D4:  MOVWF  78
00D5:  CLRF   77
00D6:  DECFSZ 77,F
00D7:  GOTO   0D6
00D8:  DECFSZ 78,F
00D9:  GOTO   0D5
00DA:  MOVLW  7B
00DB:  MOVWF  77
00DC:  DECFSZ 77,F
00DD:  GOTO   0DC
00DE:  DECFSZ 00,F
00DF:  GOTO   0D3
00E0:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0174:  BSF    07.0
....................    output_float(LCD_DATA5); 
0175:  BSF    07.1
....................    output_float(LCD_DATA6); 
0176:  BSF    07.2
....................    output_float(LCD_DATA7); 
0177:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0178:  BCF    03.5
0179:  BSF    09.2
017A:  BSF    03.5
017B:  BCF    09.2
....................    delay_cycles(1); 
017C:  NOP
....................    lcd_output_enable(1); 
017D:  BCF    03.5
017E:  BSF    09.0
017F:  BSF    03.5
0180:  BCF    09.0
....................    delay_cycles(1); 
0181:  NOP
....................    high = lcd_read_nibble(); 
0182:  BCF    03.5
0183:  CALL   129
0184:  MOVF   78,W
0185:  BSF    03.6
0186:  MOVWF  48
....................        
....................    lcd_output_enable(0); 
0187:  BCF    03.6
0188:  BCF    09.0
0189:  BSF    03.5
018A:  BCF    09.0
....................    delay_cycles(1); 
018B:  NOP
....................    lcd_output_enable(1); 
018C:  BCF    03.5
018D:  BSF    09.0
018E:  BSF    03.5
018F:  BCF    09.0
....................    delay_us(1); 
0190:  GOTO   191
0191:  GOTO   192
0192:  NOP
....................    low = lcd_read_nibble(); 
0193:  BCF    03.5
0194:  CALL   129
0195:  MOVF   78,W
0196:  BSF    03.6
0197:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
0198:  BCF    03.6
0199:  BCF    09.0
019A:  BSF    03.5
019B:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
019C:  BCF    03.5
019D:  BCF    31.0
019E:  MOVF   31,W
019F:  BSF    03.5
01A0:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01A1:  BCF    03.5
01A2:  BCF    31.1
01A3:  MOVF   31,W
01A4:  BSF    03.5
01A5:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01A6:  BCF    03.5
01A7:  BCF    31.2
01A8:  MOVF   31,W
01A9:  BSF    03.5
01AA:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01AB:  BCF    03.5
01AC:  BCF    31.3
01AD:  MOVF   31,W
01AE:  BSF    03.5
01AF:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01B0:  BCF    03.5
01B1:  BSF    03.6
01B2:  SWAPF  48,W
01B3:  MOVWF  77
01B4:  MOVLW  F0
01B5:  ANDWF  77,F
01B6:  MOVF   77,W
01B7:  IORWF  47,W
01B8:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0129:  BSF    03.6
012A:  CLRF   49
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
012B:  BCF    03.6
012C:  BSF    31.0
012D:  MOVF   31,W
012E:  BSF    03.5
012F:  MOVWF  07
0130:  MOVLW  00
0131:  BCF    03.5
0132:  BTFSC  07.0
0133:  MOVLW  01
0134:  BSF    03.6
0135:  IORWF  49,F
....................    n |= input(LCD_DATA5) << 1; 
0136:  BCF    03.6
0137:  BSF    31.1
0138:  MOVF   31,W
0139:  BSF    03.5
013A:  MOVWF  07
013B:  MOVLW  00
013C:  BCF    03.5
013D:  BTFSC  07.1
013E:  MOVLW  01
013F:  MOVWF  77
0140:  BCF    03.0
0141:  RLF    77,F
0142:  MOVF   77,W
0143:  BSF    03.6
0144:  IORWF  49,F
....................    n |= input(LCD_DATA6) << 2; 
0145:  BCF    03.6
0146:  BSF    31.2
0147:  MOVF   31,W
0148:  BSF    03.5
0149:  MOVWF  07
014A:  MOVLW  00
014B:  BCF    03.5
014C:  BTFSC  07.2
014D:  MOVLW  01
014E:  MOVWF  77
014F:  RLF    77,F
0150:  RLF    77,F
0151:  MOVLW  FC
0152:  ANDWF  77,F
0153:  MOVF   77,W
0154:  BSF    03.6
0155:  IORWF  49,F
....................    n |= input(LCD_DATA7) << 3; 
0156:  BCF    03.6
0157:  BSF    31.3
0158:  MOVF   31,W
0159:  BSF    03.5
015A:  MOVWF  07
015B:  MOVLW  00
015C:  BCF    03.5
015D:  BTFSC  07.3
015E:  MOVLW  01
015F:  MOVWF  77
0160:  RLF    77,F
0161:  RLF    77,F
0162:  RLF    77,F
0163:  MOVLW  F8
0164:  ANDWF  77,F
0165:  MOVF   77,W
0166:  BSF    03.6
0167:  IORWF  49,F
....................     
....................    return(n); 
0168:  MOVF   49,W
0169:  MOVWF  78
....................   #else 
016A:  BCF    03.6
016B:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00E1:  BSF    03.6
00E2:  BTFSC  48.0
00E3:  GOTO   0E8
00E4:  BCF    03.6
00E5:  BCF    07.0
00E6:  GOTO   0EA
00E7:  BSF    03.6
00E8:  BCF    03.6
00E9:  BSF    07.0
00EA:  BCF    31.0
00EB:  MOVF   31,W
00EC:  BSF    03.5
00ED:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00EE:  BCF    03.5
00EF:  BSF    03.6
00F0:  BTFSC  48.1
00F1:  GOTO   0F6
00F2:  BCF    03.6
00F3:  BCF    07.1
00F4:  GOTO   0F8
00F5:  BSF    03.6
00F6:  BCF    03.6
00F7:  BSF    07.1
00F8:  BCF    31.1
00F9:  MOVF   31,W
00FA:  BSF    03.5
00FB:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00FC:  BCF    03.5
00FD:  BSF    03.6
00FE:  BTFSC  48.2
00FF:  GOTO   104
0100:  BCF    03.6
0101:  BCF    07.2
0102:  GOTO   106
0103:  BSF    03.6
0104:  BCF    03.6
0105:  BSF    07.2
0106:  BCF    31.2
0107:  MOVF   31,W
0108:  BSF    03.5
0109:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
010A:  BCF    03.5
010B:  BSF    03.6
010C:  BTFSC  48.3
010D:  GOTO   112
010E:  BCF    03.6
010F:  BCF    07.3
0110:  GOTO   114
0111:  BSF    03.6
0112:  BCF    03.6
0113:  BSF    07.3
0114:  BCF    31.3
0115:  MOVF   31,W
0116:  BSF    03.5
0117:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0118:  NOP
....................    lcd_output_enable(1); 
0119:  BCF    03.5
011A:  BSF    09.0
011B:  BSF    03.5
011C:  BCF    09.0
....................    delay_us(2); 
011D:  MOVLW  02
011E:  MOVWF  77
011F:  DECFSZ 77,F
0120:  GOTO   11F
0121:  GOTO   122
0122:  NOP
....................    lcd_output_enable(0); 
0123:  BCF    03.5
0124:  BCF    09.0
0125:  BSF    03.5
0126:  BCF    09.0
0127:  BCF    03.5
0128:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
016C:  BSF    03.5
016D:  BCF    09.0
....................    lcd_rs_tris(); 
016E:  BCF    09.1
....................    lcd_rw_tris(); 
016F:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0170:  BCF    03.5
0171:  BCF    09.1
0172:  BSF    03.5
0173:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01B9:  MOVF   78,W
01BA:  MOVWF  47
01BB:  BTFSS  47.7
01BC:  GOTO   1C0
01BD:  BSF    03.5
01BE:  BCF    03.6
01BF:  GOTO   174
....................    lcd_output_rs(address); 
01C0:  MOVF   45,F
01C1:  BTFSS  03.2
01C2:  GOTO   1C7
01C3:  BCF    03.6
01C4:  BCF    09.1
01C5:  GOTO   1C9
01C6:  BSF    03.6
01C7:  BCF    03.6
01C8:  BSF    09.1
01C9:  BSF    03.5
01CA:  BCF    09.1
....................    delay_cycles(1); 
01CB:  NOP
....................    lcd_output_rw(0); 
01CC:  BCF    03.5
01CD:  BCF    09.2
01CE:  BSF    03.5
01CF:  BCF    09.2
....................    delay_cycles(1); 
01D0:  NOP
....................    lcd_output_enable(0); 
01D1:  BCF    03.5
01D2:  BCF    09.0
01D3:  BSF    03.5
01D4:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01D5:  BCF    03.5
01D6:  BSF    03.6
01D7:  SWAPF  46,W
01D8:  MOVWF  47
01D9:  MOVLW  0F
01DA:  ANDWF  47,F
01DB:  MOVF   47,W
01DC:  MOVWF  48
01DD:  BCF    03.6
01DE:  CALL   0E1
....................    lcd_send_nibble(n & 0xf); 
01DF:  BSF    03.6
01E0:  MOVF   46,W
01E1:  ANDLW  0F
01E2:  MOVWF  47
01E3:  MOVWF  48
01E4:  BCF    03.6
01E5:  CALL   0E1
01E6:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01E7:  MOVLW  28
01E8:  BSF    03.6
01E9:  MOVWF  3E
01EA:  MOVLW  0C
01EB:  MOVWF  3F
01EC:  MOVLW  01
01ED:  MOVWF  40
01EE:  MOVLW  06
01EF:  MOVWF  41
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01F0:  BCF    03.6
01F1:  BCF    09.0
01F2:  BSF    03.5
01F3:  BCF    09.0
....................    lcd_output_rs(0); 
01F4:  BCF    03.5
01F5:  BCF    09.1
01F6:  BSF    03.5
01F7:  BCF    09.1
....................    lcd_output_rw(0); 
01F8:  BCF    03.5
01F9:  BCF    09.2
01FA:  BSF    03.5
01FB:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01FC:  BCF    03.5
01FD:  BCF    31.0
01FE:  MOVF   31,W
01FF:  BSF    03.5
0200:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0201:  BCF    03.5
0202:  BCF    31.1
0203:  MOVF   31,W
0204:  BSF    03.5
0205:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0206:  BCF    03.5
0207:  BCF    31.2
0208:  MOVF   31,W
0209:  BSF    03.5
020A:  MOVWF  07
....................    output_drive(LCD_DATA7); 
020B:  BCF    03.5
020C:  BCF    31.3
020D:  MOVF   31,W
020E:  BSF    03.5
020F:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0210:  BCF    09.0
....................    lcd_rs_tris(); 
0211:  BCF    09.1
....................    lcd_rw_tris(); 
0212:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0213:  MOVLW  0F
0214:  BCF    03.5
0215:  BSF    03.6
0216:  MOVWF  42
0217:  BCF    03.6
0218:  CALL   0CD
....................    for(i=1;i<=3;++i) 
0219:  MOVLW  01
021A:  BSF    03.6
021B:  MOVWF  3D
021C:  MOVF   3D,W
021D:  SUBLW  03
021E:  BTFSS  03.0
021F:  GOTO   22C
....................    { 
....................        lcd_send_nibble(3); 
0220:  MOVLW  03
0221:  MOVWF  48
0222:  BCF    03.6
0223:  CALL   0E1
....................        delay_ms(5); 
0224:  MOVLW  05
0225:  BSF    03.6
0226:  MOVWF  42
0227:  BCF    03.6
0228:  CALL   0CD
0229:  BSF    03.6
022A:  INCF   3D,F
022B:  GOTO   21C
....................    } 
....................     
....................    lcd_send_nibble(2); 
022C:  MOVLW  02
022D:  MOVWF  48
022E:  BCF    03.6
022F:  CALL   0E1
....................    delay_ms(5); 
0230:  MOVLW  05
0231:  BSF    03.6
0232:  MOVWF  42
0233:  BCF    03.6
0234:  CALL   0CD
....................    for(i=0;i<=3;++i) 
0235:  BSF    03.6
0236:  CLRF   3D
0237:  MOVF   3D,W
0238:  SUBLW  03
0239:  BTFSS  03.0
023A:  GOTO   249
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
023B:  MOVLW  3E
023C:  ADDWF  3D,W
023D:  MOVWF  04
023E:  BSF    03.7
023F:  MOVF   00,W
0240:  MOVWF  42
0241:  CLRF   45
0242:  MOVF   42,W
0243:  MOVWF  46
0244:  BCF    03.6
0245:  CALL   16C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0246:  BSF    03.6
0247:  INCF   3D,F
0248:  GOTO   237
0249:  BCF    03.6
024A:  BSF    0A.3
024B:  BCF    0A.4
024C:  GOTO   3CC (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
03A1:  BSF    03.6
03A2:  DECFSZ 42,W
03A3:  GOTO   3A5
03A4:  GOTO   3A8
....................       address=LCD_LINE_TWO; 
03A5:  MOVLW  40
03A6:  MOVWF  43
03A7:  GOTO   3A9
....................    else 
....................       address=0; 
03A8:  CLRF   43
....................       
....................    address+=x-1; 
03A9:  MOVLW  01
03AA:  SUBWF  41,W
03AB:  ADDWF  43,F
....................    lcd_send_byte(0,0x80|address); 
03AC:  MOVF   43,W
03AD:  IORLW  80
03AE:  MOVWF  44
03AF:  CLRF   45
03B0:  MOVF   44,W
03B1:  MOVWF  46
03B2:  BCF    03.6
03B3:  CALL   16C
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03B4:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03B5:  BSF    03.6
03B6:  MOVF   40,W
03B7:  XORLW  07
03B8:  BCF    03.6
03B9:  BTFSC  03.2
03BA:  GOTO   3C5
03BB:  XORLW  0B
03BC:  BTFSC  03.2
03BD:  GOTO   3CC
03BE:  XORLW  06
03BF:  BTFSC  03.2
03C0:  GOTO   3D8
03C1:  XORLW  02
03C2:  BTFSC  03.2
03C3:  GOTO   3E0
03C4:  GOTO   3E7
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03C5:  MOVLW  01
03C6:  BSF    03.6
03C7:  MOVWF  41
03C8:  MOVWF  42
03C9:  BCF    03.6
03CA:  CALL   3A1
03CB:  GOTO   3EE
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03CC:  BSF    03.6
03CD:  CLRF   45
03CE:  MOVLW  01
03CF:  MOVWF  46
03D0:  BCF    03.6
03D1:  CALL   16C
....................                      delay_ms(2); 
03D2:  MOVLW  02
03D3:  BSF    03.6
03D4:  MOVWF  42
03D5:  BCF    03.6
03D6:  CALL   0CD
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03D7:  GOTO   3EE
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03D8:  MOVLW  01
03D9:  BSF    03.6
03DA:  MOVWF  41
03DB:  MOVLW  02
03DC:  MOVWF  42
03DD:  BCF    03.6
03DE:  CALL   3A1
03DF:  GOTO   3EE
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03E0:  BSF    03.6
03E1:  CLRF   45
03E2:  MOVLW  10
03E3:  MOVWF  46
03E4:  BCF    03.6
03E5:  CALL   16C
03E6:  GOTO   3EE
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03E7:  MOVLW  01
03E8:  BSF    03.6
03E9:  MOVWF  45
03EA:  MOVF   40,W
03EB:  MOVWF  46
03EC:  BCF    03.6
03ED:  CALL   16C
....................      #endif 
....................    } 
03EE:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_SELECT_FUN=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
0AAD:  CLRF   60
.................... INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
0AAE:  CLRF   61
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
0AAF:  MOVLW  20
0AB0:  MOVWF  64
0AB1:  CLRF   65
0AB2:  CLRF   63
0AB3:  MOVLW  64
0AB4:  MOVWF  62
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
0AB5:  MOVLW  20
0AB6:  MOVWF  68
0AB7:  CLRF   69
0AB8:  CLRF   67
0AB9:  MOVLW  68
0ABA:  MOVWF  66
.................... CHAR *PACKAGE[]={"S","ID", "S_S" ,"LENGHT","NHIETDO","CHECKSUM","#"}; 
0ABB:  MOVLW  53
0ABC:  BSF    03.5
0ABD:  MOVWF  2E
0ABE:  CLRF   2F
0ABF:  MOVLW  49
0AC0:  MOVWF  30
0AC1:  MOVLW  44
0AC2:  MOVWF  31
0AC3:  CLRF   32
0AC4:  MOVLW  53
0AC5:  MOVWF  33
0AC6:  MOVLW  5F
0AC7:  MOVWF  34
0AC8:  MOVLW  53
0AC9:  MOVWF  35
0ACA:  CLRF   36
0ACB:  MOVLW  4C
0ACC:  MOVWF  37
0ACD:  MOVLW  45
0ACE:  MOVWF  38
0ACF:  MOVLW  4E
0AD0:  MOVWF  39
0AD1:  MOVLW  47
0AD2:  MOVWF  3A
0AD3:  MOVLW  48
0AD4:  MOVWF  3B
0AD5:  MOVLW  54
0AD6:  MOVWF  3C
0AD7:  CLRF   3D
0AD8:  MOVLW  4E
0AD9:  MOVWF  3E
0ADA:  MOVLW  48
0ADB:  MOVWF  3F
0ADC:  MOVLW  49
0ADD:  MOVWF  40
0ADE:  MOVLW  45
0ADF:  MOVWF  41
0AE0:  MOVLW  54
0AE1:  MOVWF  42
0AE2:  MOVLW  44
0AE3:  MOVWF  43
0AE4:  MOVLW  4F
0AE5:  MOVWF  44
0AE6:  CLRF   45
0AE7:  MOVLW  43
0AE8:  MOVWF  46
0AE9:  MOVLW  48
0AEA:  MOVWF  47
0AEB:  MOVLW  45
0AEC:  MOVWF  48
0AED:  MOVLW  43
0AEE:  MOVWF  49
0AEF:  MOVLW  4B
0AF0:  MOVWF  4A
0AF1:  MOVLW  53
0AF2:  MOVWF  4B
0AF3:  MOVLW  55
0AF4:  MOVWF  4C
0AF5:  MOVLW  4D
0AF6:  MOVWF  4D
0AF7:  CLRF   4E
0AF8:  MOVLW  23
0AF9:  MOVWF  4F
0AFA:  CLRF   50
0AFB:  CLRF   21
0AFC:  MOVLW  AE
0AFD:  MOVWF  20
0AFE:  CLRF   23
0AFF:  MOVLW  B0
0B00:  MOVWF  22
0B01:  CLRF   25
0B02:  MOVLW  B3
0B03:  MOVWF  24
0B04:  CLRF   27
0B05:  MOVLW  B7
0B06:  MOVWF  26
0B07:  CLRF   29
0B08:  MOVLW  BE
0B09:  MOVWF  28
0B0A:  CLRF   2B
0B0B:  MOVLW  C6
0B0C:  MOVWF  2A
0B0D:  CLRF   2D
0B0E:  MOVLW  CF
0B0F:  MOVWF  2C
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE1234","SENSOR1234","#"}; 
0B10:  MOVLW  53
0B11:  BCF    03.5
0B12:  BSF    03.6
0B13:  MOVWF  10
0B14:  CLRF   11
0B15:  MOVLW  49
0B16:  MOVWF  12
0B17:  MOVLW  44
0B18:  MOVWF  13
0B19:  CLRF   14
0B1A:  MOVLW  43
0B1B:  MOVWF  15
0B1C:  MOVLW  5F
0B1D:  MOVWF  16
0B1E:  MOVLW  46
0B1F:  MOVWF  17
0B20:  CLRF   18
0B21:  MOVLW  4C
0B22:  MOVWF  19
0B23:  MOVLW  45
0B24:  MOVWF  1A
0B25:  MOVLW  4E
0B26:  MOVWF  1B
0B27:  MOVLW  47
0B28:  MOVWF  1C
0B29:  MOVLW  48
0B2A:  MOVWF  1D
0B2B:  MOVLW  54
0B2C:  MOVWF  1E
0B2D:  CLRF   1F
0B2E:  MOVLW  49
0B2F:  MOVWF  20
0B30:  MOVLW  44
0B31:  MOVWF  21
0B32:  MOVLW  5F
0B33:  MOVWF  22
0B34:  CLRF   23
0B35:  MOVLW  44
0B36:  MOVWF  24
0B37:  MOVLW  45
0B38:  MOVWF  25
0B39:  MOVLW  56
0B3A:  MOVWF  26
0B3B:  MOVLW  49
0B3C:  MOVWF  27
0B3D:  MOVLW  43
0B3E:  MOVWF  28
0B3F:  MOVLW  45
0B40:  MOVWF  29
0B41:  MOVLW  31
0B42:  MOVWF  2A
0B43:  MOVLW  32
0B44:  MOVWF  2B
0B45:  MOVLW  33
0B46:  MOVWF  2C
0B47:  MOVLW  34
0B48:  MOVWF  2D
0B49:  CLRF   2E
0B4A:  MOVLW  53
0B4B:  MOVWF  2F
0B4C:  MOVLW  45
0B4D:  MOVWF  30
0B4E:  MOVLW  4E
0B4F:  MOVWF  31
0B50:  MOVLW  53
0B51:  MOVWF  32
0B52:  MOVLW  4F
0B53:  MOVWF  33
0B54:  MOVLW  52
0B55:  MOVWF  34
0B56:  MOVLW  31
0B57:  MOVWF  35
0B58:  MOVLW  32
0B59:  MOVWF  36
0B5A:  MOVLW  33
0B5B:  MOVWF  37
0B5C:  MOVLW  34
0B5D:  MOVWF  38
0B5E:  CLRF   39
0B5F:  MOVLW  23
0B60:  MOVWF  3A
0B61:  CLRF   3B
0B62:  MOVLW  01
0B63:  BSF    03.5
0B64:  BCF    03.6
0B65:  MOVWF  52
0B66:  MOVLW  10
0B67:  MOVWF  51
0B68:  MOVLW  01
0B69:  MOVWF  54
0B6A:  MOVLW  12
0B6B:  MOVWF  53
0B6C:  MOVLW  01
0B6D:  MOVWF  56
0B6E:  MOVLW  15
0B6F:  MOVWF  55
0B70:  MOVLW  01
0B71:  MOVWF  58
0B72:  MOVLW  19
0B73:  MOVWF  57
0B74:  MOVLW  01
0B75:  MOVWF  5A
0B76:  MOVLW  20
0B77:  MOVWF  59
0B78:  MOVLW  01
0B79:  MOVWF  5C
0B7A:  MOVLW  24
0B7B:  MOVWF  5B
0B7C:  MOVLW  01
0B7D:  MOVWF  5E
0B7E:  MOVLW  2F
0B7F:  MOVWF  5D
0B80:  MOVLW  01
0B81:  MOVWF  60
0B82:  MOVLW  3A
0B83:  MOVWF  5F
.................... CHAR NHIETDO1[]="27"; 
0B84:  MOVLW  32
0B85:  BCF    03.5
0B86:  MOVWF  6A
0B87:  MOVLW  37
0B88:  MOVWF  6B
0B89:  CLRF   6C
.................... CHAR NHIETDO2[]="27"; 
0B8A:  MOVLW  32
0B8B:  MOVWF  6D
0B8C:  MOVLW  37
0B8D:  MOVWF  6E
0B8E:  CLRF   6F
.................... CHAR ID_[]="0"; 
0B8F:  MOVLW  30
0B90:  MOVWF  70
0B91:  CLRF   71
.................... CHAR TEMP_CHAR[]="0"; 
0B92:  MOVWF  72
0B93:  CLRF   73
.................... CHAR *TEMP_CHAR2[]="0"; 
0B94:  MOVWF  7B
0B95:  CLRF   7C
0B96:  CLRF   75
0B97:  MOVLW  7B
0B98:  MOVWF  74
....................    
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    5F.1
....................    TT_STT = 1; 
0808:  BSF    5F.4
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  41
080C:  MOVLW  02
080D:  MOVWF  42
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   3A1
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  42
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   0CD
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID: "); 
0819:  MOVLW  6B
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   3EF
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  5F.4
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  3D
0831:  MOVLW  96
0832:  MOVWF  42
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   0CD
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 3D,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   42
083B:  CLRF   41
083C:  CLRF   40
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  3F
0841:  MOVLW  0A
0842:  MOVWF  43
0843:  CLRF   45
0844:  MOVLW  70
0845:  MOVWF  44
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   4BB
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  41
084D:  MOVLW  02
084E:  MOVWF  42
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   3A1
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  42
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   0CD
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  70
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   5DB
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  42
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   0CD
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    5F.1
....................    TT_STT = 1; 
086F:  BSF    5F.4
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  41
0873:  MOVLW  02
0874:  MOVWF  42
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   3A1
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  42
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   0CD
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE: "); 
0880:  MOVLW  6E
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   3EF
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  5F.4
088A:  GOTO   16E
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   113
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  3D
0898:  MOVLW  96
0899:  MOVWF  42
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   0CD
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 3D,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   42
08A2:  CLRF   41
08A3:  CLRF   40
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  3F
08A8:  MOVLW  0A
08A9:  MOVWF  43
08AA:  CLRF   45
08AB:  MOVLW  72
08AC:  MOVWF  44
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   4BB
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  41
08B4:  MOVLW  02
08B5:  MOVWF  42
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   3A1
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  42
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   0CD
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  72
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   5DB
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  42
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   0CD
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ": "); 
08CE:  MOVLW  3A
08CF:  BSF    03.6
08D0:  MOVWF  40
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   3B5
08D4:  BSF    0A.3
08D5:  MOVLW  20
08D6:  BSF    03.6
08D7:  MOVWF  40
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   3B5
08DB:  BSF    0A.3
....................          DELAY_MS (1); 
08DC:  MOVLW  01
08DD:  BSF    03.6
08DE:  MOVWF  42
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   0CD
08E2:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08E3:  MOVF   3A,W
08E4:  BSF    03.6
08E5:  MOVWF  3F
08E6:  CLRF   41
08E7:  MOVLW  60
08E8:  MOVWF  40
08E9:  BCF    0A.3
08EA:  BCF    03.6
08EB:  CALL   5F8
08EC:  BSF    0A.3
08ED:  MOVLW  00
08EE:  BTFSC  78.0
08EF:  MOVLW  01
08F0:  BSF    03.6
08F1:  MOVWF  3D
08F2:  CLRF   42
08F3:  CLRF   41
08F4:  CLRF   40
08F5:  MOVF   3D,W
08F6:  MOVWF  3F
08F7:  MOVLW  0A
08F8:  MOVWF  43
08F9:  CLRF   45
08FA:  MOVLW  72
08FB:  MOVWF  44
08FC:  BCF    0A.3
08FD:  BCF    03.6
08FE:  CALL   4BB
08FF:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0900:  MOVLW  72
0901:  MOVWF  04
0902:  BCF    03.7
0903:  BCF    0A.3
0904:  CALL   5DB
0905:  BSF    0A.3
....................          DELAY_MS (1); 
0906:  MOVLW  01
0907:  BSF    03.6
0908:  MOVWF  42
0909:  BCF    0A.3
090A:  BCF    03.6
090B:  CALL   0CD
090C:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
090D:  BSF    03.5
090E:  BCF    08.0
090F:  MOVLW  01
0910:  BCF    03.5
0911:  XORWF  08,F
....................       } 
0912:  GOTO   16D
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0913:  BSF    03.5
0914:  BSF    06.3
0915:  BCF    03.5
0916:  BTFSC  06.3
0917:  GOTO   16D
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
0918:  MOVF   3A,W
0919:  BSF    03.6
091A:  MOVWF  3F
091B:  CLRF   41
091C:  MOVLW  60
091D:  MOVWF  40
091E:  BCF    0A.3
091F:  BCF    03.6
0920:  CALL   5F8
0921:  BSF    0A.3
0922:  MOVLW  00
0923:  BTFSS  78.0
0924:  MOVLW  01
0925:  BSF    03.6
0926:  MOVWF  3D
0927:  BCF    03.6
0928:  MOVF   3A,W
0929:  BSF    03.6
092A:  MOVWF  3E
092B:  MOVF   3D,W
092C:  MOVWF  3F
092D:  CLRF   41
092E:  MOVLW  60
092F:  MOVWF  40
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   611
0933:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0934:  MOVLW  0D
0935:  BSF    03.6
0936:  MOVWF  41
0937:  MOVLW  02
0938:  MOVWF  42
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   3A1
093C:  BSF    0A.3
....................          DELAY_MS (300); 
093D:  MOVLW  02
093E:  BSF    03.6
093F:  MOVWF  3D
0940:  MOVLW  96
0941:  MOVWF  42
0942:  BCF    0A.3
0943:  BCF    03.6
0944:  CALL   0CD
0945:  BSF    0A.3
0946:  BSF    03.6
0947:  DECFSZ 3D,F
0948:  GOTO   140
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0949:  BCF    03.6
094A:  MOVF   3A,W
094B:  BSF    03.6
094C:  MOVWF  3F
094D:  CLRF   41
094E:  MOVLW  60
094F:  MOVWF  40
0950:  BCF    0A.3
0951:  BCF    03.6
0952:  CALL   5F8
0953:  BSF    0A.3
0954:  MOVLW  00
0955:  BTFSC  78.0
0956:  MOVLW  01
0957:  BSF    03.6
0958:  MOVWF  3D
0959:  CLRF   42
095A:  CLRF   41
095B:  CLRF   40
095C:  MOVF   3D,W
095D:  MOVWF  3F
095E:  MOVLW  0A
095F:  MOVWF  43
0960:  CLRF   45
0961:  MOVLW  72
0962:  MOVWF  44
0963:  BCF    0A.3
0964:  BCF    03.6
0965:  CALL   4BB
0966:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0967:  MOVLW  72
0968:  MOVWF  04
0969:  BCF    03.7
096A:  BCF    0A.3
096B:  CALL   5DB
096C:  BSF    0A.3
....................       } 
096D:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
096F:  BCF    5F.1
....................    TT_STT = 1; 
0970:  BSF    5F.4
....................    LCD_GOTOXY (1, 2) ; 
0971:  MOVLW  01
0972:  BSF    03.6
0973:  MOVWF  41
0974:  MOVLW  02
0975:  MOVWF  42
0976:  BCF    0A.3
0977:  BCF    03.6
0978:  CALL   3A1
0979:  BSF    0A.3
....................    DELAY_MS (10); 
097A:  MOVLW  0A
097B:  BSF    03.6
097C:  MOVWF  42
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   0CD
0980:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR: "); 
0981:  MOVLW  73
0982:  BSF    03.6
0983:  MOVWF  0D
0984:  MOVLW  00
0985:  MOVWF  0F
0986:  BCF    0A.3
0987:  BCF    03.6
0988:  CALL   3EF
0989:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
098A:  BTFSS  5F.4
098B:  GOTO   26F
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
098C:  BSF    03.5
098D:  BSF    06.2
098E:  BCF    03.5
098F:  BTFSC  06.2
0990:  GOTO   214
....................       { 
....................          STT_SENSOR ++; 
0991:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0992:  MOVF   3B,W
0993:  SUBLW  03
0994:  BTFSS  03.0
0995:  CLRF   3B
....................          DELAY_MS (300); 
0996:  MOVLW  02
0997:  BSF    03.6
0998:  MOVWF  3D
0999:  MOVLW  96
099A:  MOVWF  42
099B:  BCF    0A.3
099C:  BCF    03.6
099D:  CALL   0CD
099E:  BSF    0A.3
099F:  BSF    03.6
09A0:  DECFSZ 3D,F
09A1:  GOTO   199
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09A2:  CLRF   42
09A3:  CLRF   41
09A4:  CLRF   40
09A5:  BCF    03.6
09A6:  MOVF   3B,W
09A7:  BSF    03.6
09A8:  MOVWF  3F
09A9:  MOVLW  0A
09AA:  MOVWF  43
09AB:  CLRF   45
09AC:  MOVLW  72
09AD:  MOVWF  44
09AE:  BCF    0A.3
09AF:  BCF    03.6
09B0:  CALL   4BB
09B1:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09B2:  MOVLW  09
09B3:  BSF    03.6
09B4:  MOVWF  41
09B5:  MOVLW  02
09B6:  MOVWF  42
09B7:  BCF    0A.3
09B8:  BCF    03.6
09B9:  CALL   3A1
09BA:  BSF    0A.3
....................          DELAY_MS (10); 
09BB:  MOVLW  0A
09BC:  BSF    03.6
09BD:  MOVWF  42
09BE:  BCF    0A.3
09BF:  BCF    03.6
09C0:  CALL   0CD
09C1:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09C2:  MOVLW  72
09C3:  MOVWF  04
09C4:  BCF    03.7
09C5:  BCF    0A.3
09C6:  CALL   5DB
09C7:  BSF    0A.3
....................          DELAY_MS (1); 
09C8:  MOVLW  01
09C9:  BSF    03.6
09CA:  MOVWF  42
09CB:  BCF    0A.3
09CC:  BCF    03.6
09CD:  CALL   0CD
09CE:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ": "); 
09CF:  MOVLW  3A
09D0:  BSF    03.6
09D1:  MOVWF  40
09D2:  BCF    0A.3
09D3:  BCF    03.6
09D4:  CALL   3B5
09D5:  BSF    0A.3
09D6:  MOVLW  20
09D7:  BSF    03.6
09D8:  MOVWF  40
09D9:  BCF    0A.3
09DA:  BCF    03.6
09DB:  CALL   3B5
09DC:  BSF    0A.3
....................          DELAY_MS (1); 
09DD:  MOVLW  01
09DE:  BSF    03.6
09DF:  MOVWF  42
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   0CD
09E3:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09E4:  MOVF   3B,W
09E5:  BSF    03.6
09E6:  MOVWF  3F
09E7:  CLRF   41
09E8:  MOVLW  61
09E9:  MOVWF  40
09EA:  BCF    0A.3
09EB:  BCF    03.6
09EC:  CALL   5F8
09ED:  BSF    0A.3
09EE:  MOVLW  00
09EF:  BTFSC  78.0
09F0:  MOVLW  01
09F1:  BSF    03.6
09F2:  MOVWF  3D
09F3:  CLRF   42
09F4:  CLRF   41
09F5:  CLRF   40
09F6:  MOVF   3D,W
09F7:  MOVWF  3F
09F8:  MOVLW  0A
09F9:  MOVWF  43
09FA:  CLRF   45
09FB:  MOVLW  72
09FC:  MOVWF  44
09FD:  BCF    0A.3
09FE:  BCF    03.6
09FF:  CALL   4BB
0A00:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A01:  MOVLW  72
0A02:  MOVWF  04
0A03:  BCF    03.7
0A04:  BCF    0A.3
0A05:  CALL   5DB
0A06:  BSF    0A.3
....................          DELAY_MS (1); 
0A07:  MOVLW  01
0A08:  BSF    03.6
0A09:  MOVWF  42
0A0A:  BCF    0A.3
0A0B:  BCF    03.6
0A0C:  CALL   0CD
0A0D:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A0E:  BSF    03.5
0A0F:  BCF    08.0
0A10:  MOVLW  01
0A11:  BCF    03.5
0A12:  XORWF  08,F
....................       } 
0A13:  GOTO   26E
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A14:  BSF    03.5
0A15:  BSF    06.3
0A16:  BCF    03.5
0A17:  BTFSC  06.3
0A18:  GOTO   26E
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A19:  MOVF   3B,W
0A1A:  BSF    03.6
0A1B:  MOVWF  3F
0A1C:  CLRF   41
0A1D:  MOVLW  61
0A1E:  MOVWF  40
0A1F:  BCF    0A.3
0A20:  BCF    03.6
0A21:  CALL   5F8
0A22:  BSF    0A.3
0A23:  MOVLW  00
0A24:  BTFSS  78.0
0A25:  MOVLW  01
0A26:  BSF    03.6
0A27:  MOVWF  3D
0A28:  BCF    03.6
0A29:  MOVF   3B,W
0A2A:  BSF    03.6
0A2B:  MOVWF  3E
0A2C:  MOVF   3D,W
0A2D:  MOVWF  3F
0A2E:  CLRF   41
0A2F:  MOVLW  61
0A30:  MOVWF  40
0A31:  BCF    0A.3
0A32:  BCF    03.6
0A33:  CALL   611
0A34:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A35:  MOVLW  0D
0A36:  BSF    03.6
0A37:  MOVWF  41
0A38:  MOVLW  02
0A39:  MOVWF  42
0A3A:  BCF    0A.3
0A3B:  BCF    03.6
0A3C:  CALL   3A1
0A3D:  BSF    0A.3
....................          DELAY_MS (300); 
0A3E:  MOVLW  02
0A3F:  BSF    03.6
0A40:  MOVWF  3D
0A41:  MOVLW  96
0A42:  MOVWF  42
0A43:  BCF    0A.3
0A44:  BCF    03.6
0A45:  CALL   0CD
0A46:  BSF    0A.3
0A47:  BSF    03.6
0A48:  DECFSZ 3D,F
0A49:  GOTO   241
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A4A:  BCF    03.6
0A4B:  MOVF   3B,W
0A4C:  BSF    03.6
0A4D:  MOVWF  3F
0A4E:  CLRF   41
0A4F:  MOVLW  61
0A50:  MOVWF  40
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   5F8
0A54:  BSF    0A.3
0A55:  MOVLW  00
0A56:  BTFSC  78.0
0A57:  MOVLW  01
0A58:  BSF    03.6
0A59:  MOVWF  3D
0A5A:  CLRF   42
0A5B:  CLRF   41
0A5C:  CLRF   40
0A5D:  MOVF   3D,W
0A5E:  MOVWF  3F
0A5F:  MOVLW  0A
0A60:  MOVWF  43
0A61:  CLRF   45
0A62:  MOVLW  72
0A63:  MOVWF  44
0A64:  BCF    0A.3
0A65:  BCF    03.6
0A66:  CALL   4BB
0A67:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A68:  MOVLW  72
0A69:  MOVWF  04
0A6A:  BCF    03.7
0A6B:  BCF    0A.3
0A6C:  CALL   5DB
0A6D:  BSF    0A.3
....................       } 
0A6E:  GOTO   18A
....................  
....................    } 
.................... } 
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0A70:  BCF    5F.1
....................    ID_NODE = 0; 
0A71:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00A7:  BCF    03.6
00A8:  BCF    5F.1
....................    TT_FUN = 0; 
00A9:  BCF    5F.3
....................    TT_STT = 0; 
00AA:  BCF    5F.4
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   272
0805:  ADDLW  04
0806:  GOTO   275
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   272
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
096E:  GOTO   272
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A6F:  GOTO   272
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
0A72:  BCF    0A.3
0A73:  BCF    0A.4
0A74:  GOTO   692 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0633:  BSF    5F.3
....................    LCD_GOTOXY (1, 1) ; 
0634:  MOVLW  01
0635:  BSF    03.6
0636:  MOVWF  41
0637:  MOVWF  42
0638:  BCF    03.6
0639:  CALL   3A1
....................    DELAY_MS (10); 
063A:  MOVLW  0A
063B:  BSF    03.6
063C:  MOVWF  42
063D:  BCF    03.6
063E:  CALL   0CD
....................    PRINTF (LCD_PUTC, "CONFIG"); 
063F:  MOVLW  78
0640:  BSF    03.6
0641:  MOVWF  0D
0642:  MOVLW  00
0643:  MOVWF  0F
0644:  BCF    03.6
0645:  CALL   3EF
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0646:  MOVLW  01
0647:  BSF    03.6
0648:  MOVWF  41
0649:  MOVLW  02
064A:  MOVWF  42
064B:  BCF    03.6
064C:  CALL   3A1
....................    DELAY_MS (10); 
064D:  MOVLW  0A
064E:  BSF    03.6
064F:  MOVWF  42
0650:  BCF    03.6
0651:  CALL   0CD
....................    PRINTF (LCD_PUTC, "CASE: "); 
0652:  MOVLW  7C
0653:  BSF    03.6
0654:  MOVWF  0D
0655:  MOVLW  00
0656:  MOVWF  0F
0657:  BCF    03.6
0658:  CALL   3EF
....................  
....................    WHILE (TT_FUN) 
0659:  BTFSS  5F.3
065A:  GOTO   68E
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
065B:  BSF    03.5
065C:  BSF    06.2
065D:  BCF    03.5
065E:  BTFSC  06.2
065F:  GOTO   68D
....................       { 
....................          CONFIG_FUN ++; 
0660:  INCF   38,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0661:  MOVF   38,W
0662:  SUBLW  03
0663:  BTFSS  03.0
0664:  CLRF   38
....................          DELAY_MS (300); 
0665:  MOVLW  02
0666:  BSF    03.6
0667:  MOVWF  3D
0668:  MOVLW  96
0669:  MOVWF  42
066A:  BCF    03.6
066B:  CALL   0CD
066C:  BSF    03.6
066D:  DECFSZ 3D,F
066E:  GOTO   668
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (9, 2) ; 
066F:  MOVLW  09
0670:  MOVWF  41
0671:  MOVLW  02
0672:  MOVWF  42
0673:  BCF    03.6
0674:  CALL   3A1
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0675:  BSF    03.6
0676:  CLRF   42
0677:  CLRF   41
0678:  CLRF   40
0679:  BCF    03.6
067A:  MOVF   38,W
067B:  BSF    03.6
067C:  MOVWF  3F
067D:  MOVLW  0A
067E:  MOVWF  43
067F:  CLRF   45
0680:  MOVLW  72
0681:  MOVWF  44
0682:  BCF    03.6
0683:  CALL   4BB
....................          DELAY_MS (10); 
0684:  MOVLW  0A
0685:  BSF    03.6
0686:  MOVWF  42
0687:  BCF    03.6
0688:  CALL   0CD
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0689:  MOVLW  72
068A:  MOVWF  04
068B:  BCF    03.7
068C:  CALL   5DB
....................       } 
068D:  GOTO   659
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
068E:  BTFSC  5F.1
068F:  GOTO   693
....................    { 
....................       SELLECT_FUN (); 
0690:  BSF    0A.3
0691:  GOTO   000
0692:  BCF    0A.3
....................    } 
0693:  BSF    0A.3
0694:  BCF    0A.4
0695:  GOTO   3E2 (RETURN)
....................  
.................... } 
....................  
.................... VOID XULYDEVICES() 
.................... { 
....................    TEMP_CHAR2 = " "; 
*
0708:  BSF    03.6
0709:  CLRF   3F
070A:  CLRF   40
070B:  MOVLW  74
070C:  MOVWF  04
070D:  BCF    03.7
070E:  MOVF   3F,W
070F:  ADDWF  04,F
0710:  MOVF   40,W
0711:  BCF    03.6
0712:  CALL   058
0713:  MOVWF  00
0714:  IORLW  00
0715:  BTFSC  03.2
0716:  GOTO   71C
0717:  BSF    03.6
0718:  INCF   40,F
0719:  INCF   3F,F
071A:  GOTO   70B
071B:  BCF    03.6
....................    FOR (INT I = 0; I < 8; I++) 
071C:  BSF    03.6
071D:  CLRF   3E
071E:  MOVF   3E,W
071F:  SUBLW  07
0720:  BTFSS  03.0
0721:  GOTO   749
....................    { 
....................       IF (TT_DEVICE[I]) 
0722:  MOVF   3E,W
0723:  MOVWF  3F
0724:  CLRF   41
0725:  MOVLW  60
0726:  MOVWF  40
0727:  BCF    03.6
0728:  CALL   5F8
0729:  BTFSS  78.0
072A:  GOTO   746
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
072B:  BSF    03.6
072C:  CLRF   42
072D:  CLRF   41
072E:  CLRF   40
072F:  MOVF   3E,W
0730:  MOVWF  3F
0731:  MOVLW  0A
0732:  MOVWF  43
0733:  CLRF   45
0734:  MOVLW  74
0735:  MOVWF  44
0736:  BCF    03.6
0737:  CALL   4BB
....................          DELAY_MS (1); 
0738:  MOVLW  01
0739:  BSF    03.6
073A:  MOVWF  42
073B:  BCF    03.6
073C:  CALL   0CD
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
073D:  BSF    03.6
073E:  CLRF   40
073F:  MOVLW  62
0740:  MOVWF  3F
0741:  CLRF   42
0742:  MOVLW  74
0743:  MOVWF  41
0744:  BCF    03.6
0745:  CALL   696
....................       } 
0746:  BSF    03.6
0747:  INCF   3E,F
0748:  GOTO   71E
....................    } 
....................  
....................    TEMP_CHAR2 = " * "; 
0749:  CLRF   3F
074A:  CLRF   40
074B:  MOVLW  74
074C:  MOVWF  04
074D:  BCF    03.7
074E:  MOVF   3F,W
074F:  ADDWF  04,F
0750:  MOVF   40,W
0751:  BCF    03.6
0752:  CALL   05E
0753:  MOVWF  00
0754:  IORLW  00
0755:  BTFSC  03.2
0756:  GOTO   75C
0757:  BSF    03.6
0758:  INCF   40,F
0759:  INCF   3F,F
075A:  GOTO   74B
075B:  BCF    03.6
....................    DELAY_MS (1); 
075C:  MOVLW  01
075D:  BSF    03.6
075E:  MOVWF  42
075F:  BCF    03.6
0760:  CALL   0CD
....................    STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0761:  BSF    03.6
0762:  CLRF   40
0763:  MOVLW  62
0764:  MOVWF  3F
0765:  CLRF   42
0766:  MOVLW  74
0767:  MOVWF  41
0768:  BCF    03.6
0769:  CALL   696
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
076A:  BSF    03.5
076B:  CLRF   5C
076C:  MOVLW  62
076D:  MOVWF  5B
....................  
....................    //ID 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
06F2:  BCF    5F.3
....................    TT_STT = 0; 
06F3:  BCF    5F.4
....................    TT_DEVICE_CHAR = ""; 
06F4:  BSF    03.6
06F5:  CLRF   3E
06F6:  CLRF   3F
06F7:  MOVLW  62
06F8:  MOVWF  04
06F9:  BCF    03.7
06FA:  MOVF   3E,W
06FB:  ADDWF  04,F
06FC:  MOVF   3F,W
06FD:  BCF    03.6
06FE:  CALL   066
06FF:  MOVWF  00
0700:  IORLW  00
0701:  BTFSC  03.2
0702:  GOTO   708
0703:  BSF    03.6
0704:  INCF   3F,F
0705:  INCF   3E,F
0706:  GOTO   6F7
0707:  BCF    03.6
....................     
....................    XULYDEVICES () ; 
....................    PACKAGE_CONFIG[1] = ID_; 
*
076E:  CLRF   54
076F:  MOVLW  70
0770:  MOVWF  53
....................    FOR (INT J = 0; J < 8; J++) 
0771:  BCF    03.5
0772:  BSF    03.6
0773:  CLRF   3D
0774:  MOVF   3D,W
0775:  SUBLW  07
0776:  BTFSS  03.0
0777:  GOTO   791
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0778:  BCF    03.0
0779:  RLF    3D,W
077A:  ADDLW  D1
077B:  MOVWF  04
077C:  BCF    03.7
077D:  INCF   04,F
077E:  MOVF   00,W
077F:  MOVWF  3F
0780:  DECF   04,F
0781:  MOVF   00,W
0782:  MOVWF  3E
0783:  MOVWF  04
0784:  BCF    03.7
0785:  BTFSC  3F.0
0786:  BSF    03.7
0787:  BCF    03.6
0788:  CALL   6D4
....................       DELAY_MS (1); 
0789:  MOVLW  01
078A:  BSF    03.6
078B:  MOVWF  42
078C:  BCF    03.6
078D:  CALL   0CD
078E:  BSF    03.6
078F:  INCF   3D,F
0790:  GOTO   774
....................    } 
....................  
....................    LCD_GOTOXY (1, 2) ; 
0791:  MOVLW  01
0792:  MOVWF  41
0793:  MOVLW  02
0794:  MOVWF  42
0795:  BCF    03.6
0796:  CALL   3A1
....................    DELAY_MS (10); 
0797:  MOVLW  0A
0798:  BSF    03.6
0799:  MOVWF  42
079A:  BCF    03.6
079B:  CALL   0CD
....................    PRINTF (LCD_PUTC, TT_DEVICE_CHAR); 
079C:  MOVLW  62
079D:  MOVWF  04
079E:  BCF    03.7
079F:  CALL   5DB
....................    PACKAGE[1] = ID_; 
07A0:  BSF    03.5
07A1:  CLRF   23
07A2:  MOVLW  70
07A3:  MOVWF  22
....................    TT_CONFIG_DONE = 0; 
07A4:  BCF    03.5
07A5:  BCF    5F.1
07A6:  BSF    0A.3
07A7:  BCF    0A.4
07A8:  GOTO   3E8 (RETURN)
.................... } 
....................  
.................... VOID QUET_PHIM() 
*
0080:  BSF    03.6
0081:  CLRF   64
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
0082:  BSF    03.5
0083:  BCF    03.6
0084:  BSF    06.1
0085:  BCF    03.5
0086:  BTFSC  06.1
0087:  GOTO   09B
....................    { 
....................       IF (TMR1IF) 
0088:  BTFSS  0C.0
0089:  GOTO   098
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
008A:  BSF    03.5
008B:  BCF    08.2
008C:  MOVLW  04
008D:  BCF    03.5
008E:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
008F:  BCF    0C.0
0090:  CLRF   0E
0091:  MOVLW  0B
0092:  MOVWF  0F
0093:  MOVLW  DC
0094:  MOVWF  0E
0095:  BSF    03.6
0096:  INCF   64,F
0097:  BCF    03.6
....................       } 
0098:  BSF    03.6
0099:  GOTO   082
009A:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 30) 
009B:  BSF    03.6
009C:  MOVF   64,W
009D:  SUBLW  1E
009E:  BTFSC  03.0
009F:  GOTO   0A7
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00A0:  MOVLW  01
00A1:  BCF    03.6
00A2:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00A3:  BSF    5F.1
....................       TT_FUN = 0; 
00A4:  BCF    5F.3
....................    } 
00A5:  GOTO   0AB
00A6:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
00AB:  BCF    0B.1
00AC:  BCF    0A.3
00AD:  BCF    0A.4
00AE:  GOTO   031
....................  #INT_RDA 
....................  
....................  VOID NGAT() 
....................  { 
....................     KYTU[VT] = GETCH (); 
00AF:  MOVLW  3C
00B0:  ADDWF  5A,W
00B1:  MOVWF  04
00B2:  BCF    03.7
00B3:  BTFSS  0C.5
00B4:  GOTO   0B3
00B5:  MOVF   1A,W
00B6:  MOVWF  00
....................  
....................     IF (KYTU[VT] == '.') 
00B7:  MOVLW  3C
00B8:  ADDWF  5A,W
00B9:  MOVWF  04
00BA:  BCF    03.7
00BB:  MOVF   00,W
00BC:  SUBLW  2E
00BD:  BTFSS  03.2
00BE:  GOTO   0C8
....................     { 
....................        KYTU[VT] = '\0'; 
00BF:  MOVLW  3C
00C0:  ADDWF  5A,W
00C1:  MOVWF  04
00C2:  BCF    03.7
00C3:  CLRF   00
....................        VT = 0; 
00C4:  CLRF   5A
....................        TTNHAN = 1; 
00C5:  MOVLW  01
00C6:  MOVWF  5B
....................     } 
00C7:  GOTO   0C9
....................  
....................     ELSE 
....................     VT++; 
00C8:  INCF   5A,F
00C9:  BCF    0C.5
00CA:  BCF    0A.3
00CB:  BCF    0A.4
00CC:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07C1:  MOVLW  01
07C2:  BSF    03.6
07C3:  MOVWF  41
07C4:  MOVWF  42
07C5:  BCF    03.6
07C6:  CALL   3A1
....................     DELAY_MS (10); 
07C7:  MOVLW  0A
07C8:  BSF    03.6
07C9:  MOVWF  42
07CA:  BCF    03.6
07CB:  CALL   0CD
....................     PRINTF (LCD_PUTC, KYTU); 
07CC:  MOVLW  3C
07CD:  MOVWF  04
07CE:  BCF    03.7
07CF:  CALL   5DB
....................     DELAY_MS (1); 
07D0:  MOVLW  01
07D1:  BSF    03.6
07D2:  MOVWF  42
07D3:  BCF    03.6
07D4:  CALL   0CD
07D5:  BSF    0A.3
07D6:  BCF    0A.4
07D7:  GOTO   464 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
024D:  BSF    03.6
024E:  RLF    3D,W
024F:  MOVWF  77
0250:  RLF    77,F
0251:  MOVLW  FC
0252:  ANDWF  77,F
0253:  BCF    03.6
0254:  MOVF   1F,W
0255:  ANDLW  C3
0256:  IORWF  77,W
0257:  MOVWF  1F
....................     KQADC = 0; 
0258:  CLRF   33
0259:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
025A:  BSF    03.6
025B:  CLRF   3E
025C:  MOVF   3E,W
025D:  SUBLW  63
025E:  BTFSS  03.0
025F:  GOTO   274
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0260:  BCF    03.6
0261:  BSF    1F.1
0262:  BTFSC  1F.1
0263:  GOTO   262
0264:  BSF    03.5
0265:  MOVF   1E,W
0266:  BCF    03.5
0267:  ADDWF  32,F
0268:  MOVF   1E,W
0269:  BTFSC  03.0
026A:  INCFSZ 1E,W
026B:  ADDWF  33,F
....................        DELAY_MS (1); 
026C:  MOVLW  01
026D:  BSF    03.6
026E:  MOVWF  42
026F:  BCF    03.6
0270:  CALL   0CD
0271:  BSF    03.6
0272:  INCF   3E,F
0273:  GOTO   25C
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0274:  BCF    03.6
0275:  MOVF   33,W
0276:  BSF    03.6
0277:  MOVWF  40
0278:  BCF    03.6
0279:  MOVF   32,W
027A:  BSF    03.6
027B:  MOVWF  3F
*
0298:  MOVF   7A,W
0299:  MOVWF  42
029A:  MOVF   79,W
029B:  MOVWF  41
029C:  MOVF   78,W
029D:  MOVWF  40
029E:  MOVF   77,W
029F:  MOVWF  3F
02A0:  MOVLW  9A
02A1:  MOVWF  46
02A2:  MOVLW  99
02A3:  MOVWF  45
02A4:  MOVLW  4C
02A5:  MOVWF  44
02A6:  MOVLW  86
02A7:  MOVWF  43
*
0371:  MOVF   7A,W
0372:  MOVWF  42
0373:  MOVF   79,W
0374:  MOVWF  41
0375:  MOVF   78,W
0376:  MOVWF  40
0377:  MOVF   77,W
0378:  MOVWF  3F
*
0397:  MOVF   79,W
0398:  BCF    03.6
0399:  MOVWF  33
039A:  MOVF   78,W
039B:  MOVWF  32
....................     RETURN KQADC; 
039C:  MOVF   32,W
039D:  MOVWF  78
039E:  BSF    0A.3
039F:  BCF    0A.4
03A0:  GOTO   3DA (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07A9:  BSF    03.6
07AA:  CLRF   3D
07AB:  MOVF   3D,W
07AC:  SUBLW  1E
07AD:  BTFSS  03.0
07AE:  GOTO   7BD
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07AF:  BSF    03.5
07B0:  BCF    03.6
07B1:  BCF    08.1
07B2:  MOVLW  02
07B3:  BCF    03.5
07B4:  XORWF  08,F
....................        DELAY_MS (100); 
07B5:  MOVLW  64
07B6:  BSF    03.6
07B7:  MOVWF  42
07B8:  BCF    03.6
07B9:  CALL   0CD
07BA:  BSF    03.6
07BB:  INCF   3D,F
07BC:  GOTO   7AB
....................     } 
07BD:  BCF    03.6
07BE:  BSF    0A.3
07BF:  BCF    0A.4
07C0:  GOTO   3EC (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
0A7D:  MOVF   03,W
0A7E:  ANDLW  1F
0A7F:  MOVWF  03
0A80:  BSF    03.5
0A81:  BSF    03.6
0A82:  BSF    07.3
0A83:  MOVLW  08
0A84:  BCF    03.6
0A85:  MOVWF  19
0A86:  MOVLW  02
0A87:  MOVWF  1A
0A88:  MOVLW  A6
0A89:  MOVWF  18
0A8A:  MOVLW  90
0A8B:  BCF    03.5
0A8C:  MOVWF  18
0A8D:  MOVLW  FF
0A8E:  MOVWF  31
0A8F:  CLRF   38
0A90:  CLRF   39
0A91:  CLRF   3A
0A92:  CLRF   3B
0A93:  CLRF   5A
0A94:  CLRF   5B
0A95:  BCF    5F.0
0A96:  BCF    5F.1
0A97:  BCF    5F.2
0A98:  BCF    5F.3
0A99:  BCF    5F.4
0A9A:  BSF    03.5
0A9B:  BSF    03.6
0A9C:  MOVF   09,W
0A9D:  ANDLW  C0
0A9E:  MOVWF  09
0A9F:  BCF    03.6
0AA0:  BCF    1F.4
0AA1:  BCF    1F.5
0AA2:  MOVLW  00
0AA3:  BSF    03.6
0AA4:  MOVWF  08
0AA5:  BCF    03.5
0AA6:  CLRF   07
0AA7:  CLRF   08
0AA8:  CLRF   09
0AA9:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0B99:  MOVLW  00
0B9A:  BSF    03.5
0B9B:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0B9C:  MOVLW  FF
0B9D:  MOVWF  06
....................     SET_TRIS_E (0); 
0B9E:  BCF    09.0
0B9F:  BCF    09.1
0BA0:  BCF    09.2
0BA1:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0BA2:  MOVLW  80
0BA3:  MOVWF  07
0BA4:  BCF    03.5
0BA5:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0BA6:  BSF    1F.6
0BA7:  BCF    1F.7
0BA8:  BSF    03.5
0BA9:  BSF    1F.7
0BAA:  BCF    03.5
0BAB:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0BAC:  BSF    03.5
0BAD:  BSF    03.6
0BAE:  MOVF   09,W
0BAF:  ANDLW  C0
0BB0:  MOVWF  09
0BB1:  BCF    03.6
0BB2:  BCF    1F.4
0BB3:  BCF    1F.5
0BB4:  MOVLW  01
0BB5:  BSF    03.6
0BB6:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0BB7:  BCF    03.5
0BB8:  BCF    03.6
0BB9:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0BBA:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0BBB:  BSF    0B.4
0BBC:  BSF    03.5
0BBD:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0BBE:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0BBF:  MOVLW  C0
0BC0:  BCF    03.5
0BC1:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0BC2:  MOVLW  35
0BC3:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0BC4:  CLRF   0E
0BC5:  MOVLW  0B
0BC6:  MOVWF  0F
0BC7:  MOVLW  DC
0BC8:  MOVWF  0E
....................     TMR1IF = 0; 
0BC9:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0BCA:  BCF    0A.3
0BCB:  GOTO   1E7
0BCC:  BSF    0A.3
....................     ID_NODE = 0; 
0BCD:  CLRF   39
....................     TT_CONFIG = 0; 
0BCE:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0BCF:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0BD0:  BSF    03.5
0BD1:  CLRF   08
0BD2:  BCF    03.5
0BD3:  CLRF   08
....................     TTNHAN = 0; 
0BD4:  CLRF   5B
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0BD5:  BSF    03.6
0BD6:  CLRF   3D
0BD7:  BCF    0A.3
0BD8:  BCF    03.6
0BD9:  GOTO   24D
0BDA:  BSF    0A.3
0BDB:  CLRF   35
0BDC:  MOVF   78,W
0BDD:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0BDE:  BTFSS  5F.0
0BDF:  GOTO   3E4
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0BE0:  BCF    0A.3
0BE1:  GOTO   633
0BE2:  BSF    0A.3
....................        } 
0BE3:  GOTO   486
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0BE4:  BTFSS  5F.1
0BE5:  GOTO   3EA
....................        { 
....................           CONFIG_DONE (); 
0BE6:  BCF    0A.3
0BE7:  GOTO   6F2
0BE8:  BSF    0A.3
....................        } 
0BE9:  GOTO   486
....................  
....................         
....................        ELSE 
....................        { 
....................            
....................            
....................           CHUONG_TRINH_CON (); 
0BEA:  BCF    0A.3
0BEB:  GOTO   7A9
0BEC:  BSF    0A.3
....................  
....................           IF (AN0 > 26) 
0BED:  MOVF   35,F
0BEE:  BTFSS  03.2
0BEF:  GOTO   3F4
0BF0:  MOVF   34,W
0BF1:  SUBLW  1A
0BF2:  BTFSC  03.0
0BF3:  GOTO   455
....................           { 
....................              ITOA (AN0, 10, NHIETDO1); 
0BF4:  BSF    03.6
0BF5:  CLRF   42
0BF6:  CLRF   41
0BF7:  BCF    03.6
0BF8:  MOVF   35,W
0BF9:  BSF    03.6
0BFA:  MOVWF  40
0BFB:  BCF    03.6
0BFC:  MOVF   34,W
0BFD:  BSF    03.6
0BFE:  MOVWF  3F
0BFF:  MOVLW  0A
0C00:  MOVWF  43
0C01:  CLRF   45
0C02:  MOVLW  6A
0C03:  MOVWF  44
0C04:  BCF    0A.3
0C05:  BCF    03.6
0C06:  CALL   4BB
0C07:  BSF    0A.3
....................              PACKAGE[4] = NHIETDO1; 
0C08:  BSF    03.5
0C09:  CLRF   29
0C0A:  MOVLW  6A
0C0B:  MOVWF  28
....................              ITOA (AN1, 10, NHIETDO2); 
0C0C:  BCF    03.5
0C0D:  BSF    03.6
0C0E:  CLRF   42
0C0F:  CLRF   41
0C10:  BCF    03.6
0C11:  MOVF   37,W
0C12:  BSF    03.6
0C13:  MOVWF  40
0C14:  BCF    03.6
0C15:  MOVF   36,W
0C16:  BSF    03.6
0C17:  MOVWF  3F
0C18:  MOVLW  0A
0C19:  MOVWF  43
0C1A:  CLRF   45
0C1B:  MOVLW  6D
0C1C:  MOVWF  44
0C1D:  BCF    0A.3
0C1E:  BCF    03.6
0C1F:  CALL   4BB
0C20:  BSF    0A.3
....................              PACKAGE[5] = NHIETDO2; 
0C21:  BSF    03.5
0C22:  CLRF   2B
0C23:  MOVLW  6D
0C24:  MOVWF  2A
....................               
....................              FOR (INT I = 0; I < 8; I++) 
0C25:  BCF    03.5
0C26:  BSF    03.6
0C27:  CLRF   3C
0C28:  MOVF   3C,W
0C29:  SUBLW  07
0C2A:  BTFSS  03.0
0C2B:  GOTO   449
....................              { 
....................                 PRINTF (PACKAGE[I]); 
0C2C:  BCF    03.0
0C2D:  RLF    3C,W
0C2E:  ADDLW  A0
0C2F:  MOVWF  04
0C30:  BCF    03.7
0C31:  INCF   04,F
0C32:  MOVF   00,W
0C33:  MOVWF  3E
0C34:  DECF   04,F
0C35:  MOVF   00,W
0C36:  MOVWF  3D
0C37:  MOVWF  04
0C38:  BCF    03.7
0C39:  BTFSC  3E.0
0C3A:  BSF    03.7
0C3B:  BCF    0A.3
0C3C:  BCF    03.6
0C3D:  CALL   6D4
0C3E:  BSF    0A.3
....................                 DELAY_MS (1); 
0C3F:  MOVLW  01
0C40:  BSF    03.6
0C41:  MOVWF  42
0C42:  BCF    0A.3
0C43:  BCF    03.6
0C44:  CALL   0CD
0C45:  BSF    0A.3
0C46:  BSF    03.6
0C47:  INCF   3C,F
0C48:  GOTO   428
....................              } 
....................  
....................              DELAY_MS (1000); 
0C49:  MOVLW  04
0C4A:  MOVWF  3D
0C4B:  MOVLW  FA
0C4C:  MOVWF  42
0C4D:  BCF    0A.3
0C4E:  BCF    03.6
0C4F:  CALL   0CD
0C50:  BSF    0A.3
0C51:  BSF    03.6
0C52:  DECFSZ 3D,F
0C53:  GOTO   44B
0C54:  BCF    03.6
....................           } 
....................  
....................           IF (TTNHAN == 1) 
0C55:  DECFSZ 5B,W
0C56:  GOTO   486
....................           { 
....................               
....................              TTNHAN = 0; 
0C57:  CLRF   5B
....................              //TEMP_CHAR = 'K'; 
....................              ID_NODE_NHAN = KYTU[1] - 48; 
0C58:  MOVLW  30
0C59:  SUBWF  3D,W
0C5A:  MOVWF  5C
....................              ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
0C5B:  MOVLW  30
0C5C:  SUBWF  3E,W
0C5D:  ADDLW  40
0C5E:  MOVWF  5D
....................              TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D  (D0 = 64) 
0C5F:  MOVLW  30
0C60:  SUBWF  3F,W
0C61:  MOVWF  5E
....................              XUATLCD (); 
0C62:  BCF    0A.3
0C63:  GOTO   7C1
0C64:  BSF    0A.3
....................  
....................              IF (ID_NODE_NHAN == ID_NODE) 
0C65:  MOVF   39,W
0C66:  SUBWF  5C,W
0C67:  BTFSS  03.2
0C68:  GOTO   486
....................              { 
....................                 OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0C69:  MOVF   5E,F
0C6A:  BTFSS  03.2
0C6B:  GOTO   46E
0C6C:  MOVLW  00
0C6D:  GOTO   46F
0C6E:  MOVLW  01
0C6F:  MOVWF  77
0C70:  MOVF   5D,W
0C71:  BSF    03.6
0C72:  MOVWF  3E
0C73:  MOVF   77,W
0C74:  MOVWF  3F
0C75:  CLRF   41
0C76:  CLRF   40
0C77:  BCF    0A.3
0C78:  BCF    03.6
0C79:  CALL   611
0C7A:  BSF    0A.3
0C7B:  MOVF   5D,W
0C7C:  BSF    03.6
0C7D:  MOVWF  3E
0C7E:  CLRF   3F
0C7F:  CLRF   41
0C80:  MOVLW  80
0C81:  MOVWF  40
0C82:  BCF    0A.3
0C83:  BCF    03.6
0C84:  CALL   611
0C85:  BSF    0A.3
....................              } 
....................           } 
....................  
....................            
....................        } 
0C86:  GOTO   3D5
....................     } 
....................  } 
....................  
0C87:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
