CCS PCM C Compiler, Version 5.015, 5967               25-Oct-21 01:56

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3963 words (48%)
                           Largest free fragment is 2048
               RAM used:   256 (70%) at main() level
                           296 (80%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   54D
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0DC
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   111
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  30
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 00,00
0072:  DATA C4,22
0073:  DATA D6,24
0074:  DATA C3,22
0075:  DATA 3A,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 00,01
007C:  DATA D3,22
007D:  DATA CE,29
007E:  DATA 4F,29
007F:  DATA 3A,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 00,01
0085:  DATA 49,22
0086:  DATA DF,23
0087:  DATA 57,1D
0088:  DATA 20,10
0089:  DATA 30,18
008A:  DATA 30,18
008B:  DATA 20,00
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 5F,10
0091:  DATA 20,10
0092:  DATA 20,00
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 5F,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA C3,27
0099:  DATA 4E,23
009A:  DATA C9,23
009B:  DATA 3A,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,00
00A0:  DATA C3,20
00A1:  DATA D3,22
00A2:  DATA 3A,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 20,00
00A8:  DATA A0,16
00A9:  DATA A0,24
00AA:  DATA 44,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 00,01
00B0:  DATA A0,16
00B1:  DATA 20,22
00B2:  DATA 45,2B
00B3:  DATA C9,21
00B4:  DATA C5,29
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 00,01
00B8:  DATA A0,16
00B9:  DATA A0,29
00BA:  DATA 45,27
00BB:  DATA D3,27
00BC:  DATA D2,29
00BD:  DATA 20,10
00BE:  DATA 20,10
00BF:  DATA 00,01
00C0:  DATA A0,16
00C1:  DATA A0,24
00C2:  DATA 44,10
00C3:  DATA 2D,10
00C4:  DATA C7,2B
00C5:  DATA 3A,10
00C6:  DATA 20,10
00C7:  DATA 20,00
00C8:  DATA C3,27
00C9:  DATA 4E,23
00CA:  DATA C9,23
00CB:  DATA 20,22
00CC:  DATA 4F,27
00CD:  DATA 45,10
00CE:  DATA 20,10
00CF:  DATA 20,10
00D0:  DATA 20,10
00D1:  DATA 20,00
00D2:  DATA C3,27
00D3:  DATA 4E,23
00D4:  DATA C9,23
00D5:  DATA 20,22
00D6:  DATA 4F,27
00D7:  DATA 45,10
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,00
*
02DE:  MOVLW  8E
02DF:  MOVWF  77
02E0:  MOVF   62,W
02E1:  MOVWF  78
02E2:  MOVF   61,W
02E3:  MOVWF  79
02E4:  CLRF   7A
02E5:  MOVF   78,F
02E6:  BTFSS  03.2
02E7:  GOTO   2F2
02E8:  MOVF   79,W
02E9:  MOVWF  78
02EA:  CLRF   79
02EB:  MOVLW  08
02EC:  SUBWF  77,F
02ED:  MOVF   78,F
02EE:  BTFSS  03.2
02EF:  GOTO   2F2
02F0:  CLRF   77
02F1:  GOTO   2FA
02F2:  BCF    03.0
02F3:  BTFSC  78.7
02F4:  GOTO   2F9
02F5:  RLF    79,F
02F6:  RLF    78,F
02F7:  DECF   77,F
02F8:  GOTO   2F2
02F9:  BCF    78.7
*
030A:  MOVF   61,W
030B:  BTFSC  03.2
030C:  GOTO   3CF
030D:  MOVWF  6D
030E:  MOVF   65,W
030F:  BTFSC  03.2
0310:  GOTO   3CF
0311:  SUBWF  6D,F
0312:  BTFSS  03.0
0313:  GOTO   319
0314:  MOVLW  7F
0315:  ADDWF  6D,F
0316:  BTFSC  03.0
0317:  GOTO   3CF
0318:  GOTO   31F
0319:  MOVLW  81
031A:  SUBWF  6D,F
031B:  BTFSS  03.0
031C:  GOTO   3CF
031D:  BTFSC  03.2
031E:  GOTO   3CF
031F:  MOVF   6D,W
0320:  MOVWF  77
0321:  CLRF   78
0322:  CLRF   79
0323:  CLRF   7A
0324:  CLRF   6C
0325:  MOVF   62,W
0326:  MOVWF  6B
0327:  BSF    6B.7
0328:  MOVF   63,W
0329:  MOVWF  6A
032A:  MOVF   64,W
032B:  MOVWF  69
032C:  MOVLW  19
032D:  MOVWF  6D
032E:  MOVF   68,W
032F:  SUBWF  69,F
0330:  BTFSC  03.0
0331:  GOTO   342
0332:  MOVLW  01
0333:  SUBWF  6A,F
0334:  BTFSC  03.0
0335:  GOTO   342
0336:  SUBWF  6B,F
0337:  BTFSC  03.0
0338:  GOTO   342
0339:  SUBWF  6C,F
033A:  BTFSC  03.0
033B:  GOTO   342
033C:  INCF   6C,F
033D:  INCF   6B,F
033E:  INCF   6A,F
033F:  MOVF   68,W
0340:  ADDWF  69,F
0341:  GOTO   374
0342:  MOVF   67,W
0343:  SUBWF  6A,F
0344:  BTFSC  03.0
0345:  GOTO   35D
0346:  MOVLW  01
0347:  SUBWF  6B,F
0348:  BTFSC  03.0
0349:  GOTO   35D
034A:  SUBWF  6C,F
034B:  BTFSC  03.0
034C:  GOTO   35D
034D:  INCF   6C,F
034E:  INCF   6B,F
034F:  MOVF   67,W
0350:  ADDWF  6A,F
0351:  MOVF   68,W
0352:  ADDWF  69,F
0353:  BTFSS  03.0
0354:  GOTO   374
0355:  INCF   6A,F
0356:  BTFSS  03.2
0357:  GOTO   374
0358:  INCF   6B,F
0359:  BTFSS  03.2
035A:  GOTO   374
035B:  INCF   6C,F
035C:  GOTO   374
035D:  MOVF   66,W
035E:  IORLW  80
035F:  SUBWF  6B,F
0360:  BTFSC  03.0
0361:  GOTO   373
0362:  MOVLW  01
0363:  SUBWF  6C,F
0364:  BTFSC  03.0
0365:  GOTO   373
0366:  INCF   6C,F
0367:  MOVF   66,W
0368:  IORLW  80
0369:  ADDWF  6B,F
036A:  MOVF   67,W
036B:  ADDWF  6A,F
036C:  BTFSS  03.0
036D:  GOTO   351
036E:  INCF   6B,F
036F:  BTFSS  03.2
0370:  GOTO   351
0371:  INCF   6C,F
0372:  GOTO   351
0373:  BSF    7A.0
0374:  DECFSZ 6D,F
0375:  GOTO   377
0376:  GOTO   382
0377:  BCF    03.0
0378:  RLF    69,F
0379:  RLF    6A,F
037A:  RLF    6B,F
037B:  RLF    6C,F
037C:  BCF    03.0
037D:  RLF    7A,F
037E:  RLF    79,F
037F:  RLF    78,F
0380:  RLF    6E,F
0381:  GOTO   32E
0382:  BTFSS  6E.0
0383:  GOTO   38A
0384:  BCF    03.0
0385:  RRF    78,F
0386:  RRF    79,F
0387:  RRF    7A,F
0388:  RRF    6E,F
0389:  GOTO   38D
038A:  DECF   77,F
038B:  BTFSC  03.2
038C:  GOTO   3CF
038D:  BTFSC  6E.7
038E:  GOTO   3B6
038F:  BCF    03.0
0390:  RLF    69,F
0391:  RLF    6A,F
0392:  RLF    6B,F
0393:  RLF    6C,F
0394:  MOVF   68,W
0395:  SUBWF  69,F
0396:  BTFSC  03.0
0397:  GOTO   3A2
0398:  MOVLW  01
0399:  SUBWF  6A,F
039A:  BTFSC  03.0
039B:  GOTO   3A2
039C:  SUBWF  6B,F
039D:  BTFSC  03.0
039E:  GOTO   3A2
039F:  SUBWF  6C,F
03A0:  BTFSS  03.0
03A1:  GOTO   3C5
03A2:  MOVF   67,W
03A3:  SUBWF  6A,F
03A4:  BTFSC  03.0
03A5:  GOTO   3AD
03A6:  MOVLW  01
03A7:  SUBWF  6B,F
03A8:  BTFSC  03.0
03A9:  GOTO   3AD
03AA:  SUBWF  6C,F
03AB:  BTFSS  03.0
03AC:  GOTO   3C5
03AD:  MOVF   66,W
03AE:  IORLW  80
03AF:  SUBWF  6B,F
03B0:  BTFSC  03.0
03B1:  GOTO   3B6
03B2:  MOVLW  01
03B3:  SUBWF  6C,F
03B4:  BTFSS  03.0
03B5:  GOTO   3C5
03B6:  INCF   7A,F
03B7:  BTFSS  03.2
03B8:  GOTO   3C5
03B9:  INCF   79,F
03BA:  BTFSS  03.2
03BB:  GOTO   3C5
03BC:  INCF   78,F
03BD:  BTFSS  03.2
03BE:  GOTO   3C5
03BF:  INCF   77,F
03C0:  BTFSC  03.2
03C1:  GOTO   3CF
03C2:  RRF    78,F
03C3:  RRF    79,F
03C4:  RRF    7A,F
03C5:  MOVF   62,W
03C6:  MOVWF  6D
03C7:  MOVF   66,W
03C8:  XORWF  6D,F
03C9:  BTFSS  6D.7
03CA:  GOTO   3CD
03CB:  BSF    78.7
03CC:  GOTO   3D3
03CD:  BCF    78.7
03CE:  GOTO   3D3
03CF:  CLRF   77
03D0:  CLRF   78
03D1:  CLRF   79
03D2:  CLRF   7A
*
03DB:  MOVLW  8E
03DC:  MOVWF  77
03DD:  MOVF   61,W
03DE:  SUBWF  77,F
03DF:  MOVF   62,W
03E0:  MOVWF  79
03E1:  MOVF   63,W
03E2:  MOVWF  78
03E3:  BSF    79.7
03E4:  MOVF   77,F
03E5:  BTFSC  03.2
03E6:  GOTO   3F2
03E7:  BCF    03.0
03E8:  MOVF   79,F
03E9:  BTFSS  03.2
03EA:  GOTO   3EE
03EB:  MOVF   78,F
03EC:  BTFSC  03.2
03ED:  GOTO   3F2
03EE:  RRF    79,F
03EF:  RRF    78,F
03F0:  DECFSZ 77,F
03F1:  GOTO   3E7
03F2:  BTFSS  62.7
03F3:  GOTO   3F9
03F4:  COMF   78,F
03F5:  COMF   79,F
03F6:  INCF   78,F
03F7:  BTFSC  03.2
03F8:  INCF   79,F
*
0451:  MOVF   0B,W
0452:  BSF    03.6
0453:  MOVWF  60
0454:  BCF    03.6
0455:  BCF    0B.7
0456:  BSF    03.5
0457:  BSF    03.6
0458:  BSF    0C.7
0459:  BSF    0C.0
045A:  NOP
045B:  NOP
045C:  BCF    03.5
045D:  BTFSS  60.7
045E:  GOTO   462
045F:  BCF    03.6
0460:  BSF    0B.7
0461:  BSF    03.6
0462:  MOVF   0C,W
0463:  ANDLW  7F
0464:  BTFSC  03.2
0465:  GOTO   49F
0466:  MOVWF  60
0467:  MOVF   0D,W
0468:  MOVWF  61
0469:  MOVF   0F,W
046A:  MOVWF  62
046B:  MOVF   60,W
046C:  MOVWF  63
046D:  BCF    03.6
046E:  CALL   417
046F:  BSF    03.6
0470:  MOVF   61,W
0471:  MOVWF  0D
0472:  MOVF   62,W
0473:  MOVWF  0F
0474:  BCF    03.6
0475:  MOVF   0B,W
0476:  BSF    03.6
0477:  MOVWF  63
0478:  BCF    03.6
0479:  BCF    0B.7
047A:  BSF    03.5
047B:  BSF    03.6
047C:  BSF    0C.7
047D:  BSF    0C.0
047E:  NOP
047F:  NOP
0480:  BCF    03.5
0481:  BTFSS  63.7
0482:  GOTO   486
0483:  BCF    03.6
0484:  BSF    0B.7
0485:  BSF    03.6
0486:  RLF    0C,W
0487:  RLF    0E,W
0488:  ANDLW  7F
0489:  BTFSC  03.2
048A:  GOTO   49F
048B:  MOVWF  60
048C:  MOVF   0D,W
048D:  MOVWF  61
048E:  MOVF   0F,W
048F:  MOVWF  62
0490:  MOVF   60,W
0491:  MOVWF  63
0492:  BCF    03.6
0493:  CALL   417
0494:  BSF    03.6
0495:  MOVF   61,W
0496:  MOVWF  0D
0497:  MOVF   62,W
0498:  MOVWF  0F
0499:  INCF   0D,F
049A:  BTFSC  03.2
049B:  INCF   0F,F
049C:  BCF    03.6
049D:  GOTO   451
049E:  BSF    03.6
049F:  BCF    03.6
04A0:  RETURN
04A1:  BTFSC  03.1
04A2:  GOTO   4A6
04A3:  MOVLW  A0
04A4:  MOVWF  04
04A5:  BSF    03.7
04A6:  BSF    03.5
04A7:  BSF    03.6
04A8:  MOVF   1B,W
04A9:  XORWF  1F,W
04AA:  ANDLW  80
04AB:  MOVWF  25
04AC:  BTFSS  1B.7
04AD:  GOTO   4B9
04AE:  COMF   18,F
04AF:  COMF   19,F
04B0:  COMF   1A,F
04B1:  COMF   1B,F
04B2:  INCF   18,F
04B3:  BTFSC  03.2
04B4:  INCF   19,F
04B5:  BTFSC  03.2
04B6:  INCF   1A,F
04B7:  BTFSC  03.2
04B8:  INCF   1B,F
04B9:  BTFSS  1F.7
04BA:  GOTO   4C6
04BB:  COMF   1C,F
04BC:  COMF   1D,F
04BD:  COMF   1E,F
04BE:  COMF   1F,F
04BF:  INCF   1C,F
04C0:  BTFSC  03.2
04C1:  INCF   1D,F
04C2:  BTFSC  03.2
04C3:  INCF   1E,F
04C4:  BTFSC  03.2
04C5:  INCF   1F,F
04C6:  CLRF   77
04C7:  CLRF   78
04C8:  CLRF   79
04C9:  CLRF   7A
04CA:  CLRF   20
04CB:  CLRF   21
04CC:  CLRF   22
04CD:  CLRF   23
04CE:  MOVF   1F,W
04CF:  IORWF  1E,W
04D0:  IORWF  1D,W
04D1:  IORWF  1C,W
04D2:  BTFSC  03.2
04D3:  GOTO   504
04D4:  MOVLW  20
04D5:  MOVWF  24
04D6:  BCF    03.0
04D7:  RLF    18,F
04D8:  RLF    19,F
04D9:  RLF    1A,F
04DA:  RLF    1B,F
04DB:  RLF    20,F
04DC:  RLF    21,F
04DD:  RLF    22,F
04DE:  RLF    23,F
04DF:  MOVF   1F,W
04E0:  SUBWF  23,W
04E1:  BTFSS  03.2
04E2:  GOTO   4ED
04E3:  MOVF   1E,W
04E4:  SUBWF  22,W
04E5:  BTFSS  03.2
04E6:  GOTO   4ED
04E7:  MOVF   1D,W
04E8:  SUBWF  21,W
04E9:  BTFSS  03.2
04EA:  GOTO   4ED
04EB:  MOVF   1C,W
04EC:  SUBWF  20,W
04ED:  BTFSS  03.0
04EE:  GOTO   4FE
04EF:  MOVF   1C,W
04F0:  SUBWF  20,F
04F1:  MOVF   1D,W
04F2:  BTFSS  03.0
04F3:  INCFSZ 1D,W
04F4:  SUBWF  21,F
04F5:  MOVF   1E,W
04F6:  BTFSS  03.0
04F7:  INCFSZ 1E,W
04F8:  SUBWF  22,F
04F9:  MOVF   1F,W
04FA:  BTFSS  03.0
04FB:  INCFSZ 1F,W
04FC:  SUBWF  23,F
04FD:  BSF    03.0
04FE:  RLF    77,F
04FF:  RLF    78,F
0500:  RLF    79,F
0501:  RLF    7A,F
0502:  DECFSZ 24,F
0503:  GOTO   4D6
0504:  BTFSS  25.7
0505:  GOTO   511
0506:  COMF   77,F
0507:  COMF   78,F
0508:  COMF   79,F
0509:  COMF   7A,F
050A:  INCF   77,F
050B:  BTFSC  03.2
050C:  INCF   78,F
050D:  BTFSC  03.2
050E:  INCF   79,F
050F:  BTFSC  03.2
0510:  INCF   7A,F
0511:  MOVF   20,W
0512:  MOVWF  00
0513:  INCF   04,F
0514:  MOVF   21,W
0515:  MOVWF  00
0516:  INCF   04,F
0517:  MOVF   22,W
0518:  MOVWF  00
0519:  INCF   04,F
051A:  MOVF   23,W
051B:  MOVWF  00
051C:  BCF    03.5
051D:  BCF    03.6
051E:  RETURN
*
053F:  MOVLW  20
0540:  MOVWF  1C
0541:  CLRF   18
0542:  CLRF   19
0543:  CLRF   1A
0544:  CLRF   1B
0545:  MOVF   13,W
0546:  MOVWF  7A
0547:  MOVF   12,W
0548:  MOVWF  79
0549:  MOVF   11,W
054A:  MOVWF  78
054B:  MOVF   10,W
054C:  MOVWF  77
054D:  BCF    03.0
054E:  BTFSS  77.0
054F:  GOTO   55E
0550:  MOVF   14,W
0551:  ADDWF  18,F
0552:  MOVF   15,W
0553:  BTFSC  03.0
0554:  INCFSZ 15,W
0555:  ADDWF  19,F
0556:  MOVF   16,W
0557:  BTFSC  03.0
0558:  INCFSZ 16,W
0559:  ADDWF  1A,F
055A:  MOVF   17,W
055B:  BTFSC  03.0
055C:  INCFSZ 17,W
055D:  ADDWF  1B,F
055E:  RRF    1B,F
055F:  RRF    1A,F
0560:  RRF    19,F
0561:  RRF    18,F
0562:  RRF    7A,F
0563:  RRF    79,F
0564:  RRF    78,F
0565:  RRF    77,F
0566:  DECFSZ 1C,F
0567:  GOTO   54D
*
0663:  MOVF   00,F
0664:  BTFSC  03.2
0665:  GOTO   67F
0666:  BSF    03.6
0667:  CLRF   61
0668:  MOVF   04,W
0669:  MOVWF  60
066A:  BCF    61.0
066B:  BTFSC  03.7
066C:  BSF    61.0
066D:  MOVF   00,W
066E:  MOVWF  63
066F:  BCF    03.6
0670:  CALL   417
0671:  BSF    03.6
0672:  MOVF   60,W
0673:  MOVWF  04
0674:  BCF    03.7
0675:  BTFSC  61.0
0676:  BSF    03.7
0677:  INCF   04,F
0678:  BTFSS  03.2
0679:  GOTO   67D
067A:  BCF    03.6
067B:  INCF   05,F
067C:  BSF    03.6
067D:  BCF    03.6
067E:  GOTO   663
067F:  RETURN
0680:  BSF    03.6
0681:  MOVF   61,W
0682:  ANDLW  07
0683:  MOVWF  77
0684:  RRF    61,W
0685:  MOVWF  78
0686:  RRF    78,F
0687:  RRF    78,F
0688:  MOVLW  1F
0689:  ANDWF  78,F
068A:  MOVF   78,W
068B:  ADDWF  62,W
068C:  MOVWF  04
068D:  BCF    03.7
068E:  BTFSC  63.0
068F:  BSF    03.7
0690:  MOVF   00,W
0691:  MOVWF  78
0692:  INCF   77,F
0693:  GOTO   695
0694:  RRF    78,F
0695:  DECFSZ 77,F
0696:  GOTO   694
0697:  BCF    03.6
0698:  RETURN
0699:  BSF    03.6
069A:  MOVF   60,W
069B:  ANDLW  07
069C:  MOVWF  77
069D:  RRF    60,W
069E:  MOVWF  78
069F:  RRF    78,F
06A0:  RRF    78,F
06A1:  MOVLW  1F
06A2:  ANDWF  78,F
06A3:  MOVF   78,W
06A4:  ADDWF  62,W
06A5:  MOVWF  04
06A6:  BCF    03.7
06A7:  BTFSC  63.0
06A8:  BSF    03.7
06A9:  CLRF   78
06AA:  INCF   78,F
06AB:  INCF   77,F
06AC:  GOTO   6AE
06AD:  RLF    78,F
06AE:  DECFSZ 77,F
06AF:  GOTO   6AD
06B0:  MOVF   61,F
06B1:  BTFSC  03.2
06B2:  GOTO   6B6
06B3:  MOVF   78,W
06B4:  IORWF  00,F
06B5:  GOTO   6B9
06B6:  COMF   78,F
06B7:  MOVF   78,W
06B8:  ANDWF  00,F
06B9:  BCF    03.6
06BA:  RETURN
*
0780:  BSF    0A.0
0781:  BSF    0A.1
0782:  BSF    0A.2
0783:  ADDWF  02,F
0784:  GOTO   758
0785:  GOTO   760
0786:  GOTO   768
0787:  GOTO   770
0788:  MOVF   00,F
0789:  BTFSC  03.2
078A:  GOTO   7A5
078B:  BSF    03.6
078C:  CLRF   63
078D:  MOVF   04,W
078E:  MOVWF  62
078F:  BCF    63.0
0790:  BTFSC  03.7
0791:  BSF    63.0
0792:  MOVF   00,W
0793:  BCF    03.6
0794:  BTFSS  0C.4
0795:  GOTO   794
0796:  MOVWF  19
0797:  BSF    03.6
0798:  MOVF   62,W
0799:  MOVWF  04
079A:  BCF    03.7
079B:  BTFSC  63.0
079C:  BSF    03.7
079D:  INCF   04,F
079E:  BTFSS  03.2
079F:  GOTO   7A3
07A0:  BCF    03.6
07A1:  INCF   05,F
07A2:  BSF    03.6
07A3:  BCF    03.6
07A4:  GOTO   788
07A5:  RETURN
*
0B27:  MOVF   64,W
0B28:  CLRF   78
0B29:  SUBWF  63,W
0B2A:  BTFSC  03.0
0B2B:  GOTO   32F
0B2C:  MOVF   63,W
0B2D:  MOVWF  77
0B2E:  GOTO   33B
0B2F:  CLRF   77
0B30:  MOVLW  08
0B31:  MOVWF  65
0B32:  RLF    63,F
0B33:  RLF    77,F
0B34:  MOVF   64,W
0B35:  SUBWF  77,W
0B36:  BTFSC  03.0
0B37:  MOVWF  77
0B38:  RLF    78,F
0B39:  DECFSZ 65,F
0B3A:  GOTO   332
*
0BB4:  BSF    0A.0
0BB5:  BSF    0A.1
0BB6:  BCF    0A.2
0BB7:  ADDWF  02,F
0BB8:  GOTO   007
0BB9:  GOTO   06E
0BBA:  GOTO   179
0BBB:  GOTO   284
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
06BB:  BSF    03.6
06BC:  MOVF   62,W
06BD:  MOVWF  66
06BE:  MOVF   61,W
06BF:  MOVWF  65
06C0:  MOVF   66,W
06C1:  MOVWF  7A
06C2:  MOVF   65,W
06C3:  MOVWF  04
06C4:  BCF    03.7
06C5:  BTFSC  7A.0
06C6:  BSF    03.7
06C7:  MOVF   00,F
06C8:  BTFSC  03.2
06C9:  GOTO   6CE
06CA:  INCF   65,F
06CB:  BTFSC  03.2
06CC:  INCF   66,F
06CD:  GOTO   6C0
....................    while(*s2 != '\0') 
06CE:  MOVF   64,W
06CF:  MOVWF  7A
06D0:  MOVF   63,W
06D1:  MOVWF  04
06D2:  BCF    03.7
06D3:  BTFSC  7A.0
06D4:  BSF    03.7
06D5:  MOVF   00,F
06D6:  BTFSC  03.2
06D7:  GOTO   6ED
....................    { 
....................       *s = *s2; 
06D8:  MOVF   63,W
06D9:  MOVWF  04
06DA:  BCF    03.7
06DB:  BTFSC  64.0
06DC:  BSF    03.7
06DD:  MOVF   00,W
06DE:  MOVWF  69
06DF:  MOVF   65,W
06E0:  MOVWF  04
06E1:  BCF    03.7
06E2:  BTFSC  66.0
06E3:  BSF    03.7
06E4:  MOVF   69,W
06E5:  MOVWF  00
....................       ++s; 
06E6:  INCF   65,F
06E7:  BTFSC  03.2
06E8:  INCF   66,F
....................       ++s2; 
06E9:  INCF   63,F
06EA:  BTFSC  03.2
06EB:  INCF   64,F
06EC:  GOTO   6CE
....................    } 
....................  
....................    *s = '\0'; 
06ED:  MOVF   65,W
06EE:  MOVWF  04
06EF:  BCF    03.7
06F0:  BTFSC  66.0
06F1:  BSF    03.7
06F2:  CLRF   00
....................    return(s1); 
06F3:  MOVF   61,W
06F4:  MOVWF  78
06F5:  MOVF   62,W
06F6:  MOVWF  79
06F7:  BCF    03.6
06F8:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0D7B:  BCF    03.6
0D7C:  CLRF   2B
0D7D:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0CBC:  MOVF   63,W
0CBD:  MOVWF  65
0CBE:  MOVF   62,W
0CBF:  MOVWF  64
0CC0:  MOVF   65,W
0CC1:  MOVWF  7A
0CC2:  MOVF   64,W
0CC3:  MOVWF  04
0CC4:  BCF    03.7
0CC5:  BTFSC  7A.0
0CC6:  BSF    03.7
0CC7:  MOVF   00,F
0CC8:  BTFSC  03.2
0CC9:  GOTO   4CE
0CCA:  INCF   64,F
0CCB:  BTFSC  03.2
0CCC:  INCF   65,F
0CCD:  GOTO   4C0
....................    return(sc - s); 
0CCE:  MOVF   62,W
0CCF:  SUBWF  64,W
0CD0:  MOVWF  77
0CD1:  MOVF   65,W
0CD2:  MOVWF  7A
0CD3:  MOVF   63,W
0CD4:  BTFSS  03.0
0CD5:  INCFSZ 63,W
0CD6:  SUBWF  7A,F
0CD7:  MOVF   77,W
0CD8:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
051F:  BSF    03.6
0520:  CLRF   6B
0521:  CLRF   6A
0522:  CLRF   69
0523:  MOVLW  01
0524:  MOVWF  68
0525:  CLRF   6D
0526:  CLRF   6E
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0527:  BTFSS  64.7
0528:  GOTO   571
....................          sign=1;        // Check for negative number 
0529:  MOVLW  01
052A:  MOVWF  6D
....................          num*=-1; 
052B:  MOVF   64,W
052C:  BSF    03.5
052D:  MOVWF  13
052E:  BCF    03.5
052F:  MOVF   63,W
0530:  BSF    03.5
0531:  MOVWF  12
0532:  BCF    03.5
0533:  MOVF   62,W
0534:  BSF    03.5
0535:  MOVWF  11
0536:  BCF    03.5
0537:  MOVF   61,W
0538:  BSF    03.5
0539:  MOVWF  10
053A:  MOVLW  FF
053B:  MOVWF  17
053C:  MOVWF  16
053D:  MOVWF  15
053E:  MOVWF  14
*
0568:  MOVF   7A,W
0569:  BCF    03.5
056A:  MOVWF  64
056B:  MOVF   79,W
056C:  MOVWF  63
056D:  MOVF   78,W
056E:  MOVWF  62
056F:  MOVF   77,W
0570:  MOVWF  61
....................      } 
....................  
....................      while(temp>0) { 
0571:  MOVF   68,F
0572:  BTFSS  03.2
0573:  GOTO   57D
0574:  MOVF   69,F
0575:  BTFSS  03.2
0576:  GOTO   57D
0577:  MOVF   6A,F
0578:  BTFSS  03.2
0579:  GOTO   57D
057A:  MOVF   6B,F
057B:  BTFSC  03.2
057C:  GOTO   611
....................          temp=(num/base); 
057D:  BCF    03.1
057E:  MOVF   64,W
057F:  BSF    03.5
0580:  MOVWF  1B
0581:  BCF    03.5
0582:  MOVF   63,W
0583:  BSF    03.5
0584:  MOVWF  1A
0585:  BCF    03.5
0586:  MOVF   62,W
0587:  BSF    03.5
0588:  MOVWF  19
0589:  BCF    03.5
058A:  MOVF   61,W
058B:  BSF    03.5
058C:  MOVWF  18
058D:  CLRF   1F
058E:  CLRF   1E
058F:  CLRF   1D
0590:  BCF    03.5
0591:  MOVF   65,W
0592:  BSF    03.5
0593:  MOVWF  1C
0594:  BCF    03.5
0595:  BCF    03.6
0596:  CALL   4A1
0597:  MOVF   7A,W
0598:  BSF    03.6
0599:  MOVWF  6B
059A:  MOVF   79,W
059B:  MOVWF  6A
059C:  MOVF   78,W
059D:  MOVWF  69
059E:  MOVF   77,W
059F:  MOVWF  68
....................          s[cnt]=(num%base)+'0';    // Conversion 
05A0:  MOVF   6E,W
05A1:  ADDWF  66,W
05A2:  MOVWF  78
05A3:  MOVF   67,W
05A4:  MOVWF  7A
05A5:  BTFSC  03.0
05A6:  INCF   7A,F
05A7:  MOVF   78,W
05A8:  BSF    03.5
05A9:  MOVWF  10
05AA:  MOVF   7A,W
05AB:  MOVWF  11
05AC:  CLRF   13
05AD:  MOVF   04,W
05AE:  MOVWF  12
05AF:  BCF    13.0
05B0:  BTFSC  03.7
05B1:  BSF    13.0
05B2:  BSF    03.1
05B3:  MOVLW  94
05B4:  MOVWF  04
05B5:  BSF    03.7
05B6:  BCF    03.5
05B7:  MOVF   64,W
05B8:  BSF    03.5
05B9:  MOVWF  1B
05BA:  BCF    03.5
05BB:  MOVF   63,W
05BC:  BSF    03.5
05BD:  MOVWF  1A
05BE:  BCF    03.5
05BF:  MOVF   62,W
05C0:  BSF    03.5
05C1:  MOVWF  19
05C2:  BCF    03.5
05C3:  MOVF   61,W
05C4:  BSF    03.5
05C5:  MOVWF  18
05C6:  CLRF   1F
05C7:  CLRF   1E
05C8:  CLRF   1D
05C9:  BCF    03.5
05CA:  MOVF   65,W
05CB:  BSF    03.5
05CC:  MOVWF  1C
05CD:  BCF    03.5
05CE:  BCF    03.6
05CF:  CALL   4A1
05D0:  BSF    03.5
05D1:  BSF    03.6
05D2:  MOVF   12,W
05D3:  MOVWF  04
05D4:  BCF    03.7
05D5:  BTFSC  13.0
05D6:  BSF    03.7
05D7:  MOVLW  30
05D8:  ADDWF  14,W
05D9:  MOVWF  77
05DA:  MOVF   15,W
05DB:  MOVWF  78
05DC:  MOVLW  00
05DD:  BTFSC  03.0
05DE:  MOVLW  01
05DF:  ADDWF  78,F
05E0:  MOVF   16,W
05E1:  MOVWF  79
05E2:  MOVLW  00
05E3:  BTFSC  03.0
05E4:  MOVLW  01
05E5:  ADDWF  79,F
05E6:  MOVF   17,W
05E7:  MOVWF  7A
05E8:  MOVLW  00
05E9:  BTFSC  03.0
05EA:  MOVLW  01
05EB:  ADDWF  7A,F
05EC:  MOVF   10,W
05ED:  MOVWF  04
05EE:  BCF    03.7
05EF:  BTFSC  11.0
05F0:  BSF    03.7
05F1:  MOVF   77,W
05F2:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
05F3:  BCF    03.5
05F4:  MOVF   6E,W
05F5:  ADDWF  66,W
05F6:  MOVWF  04
05F7:  BCF    03.7
05F8:  BTFSC  67.0
05F9:  BSF    03.7
05FA:  MOVF   00,W
05FB:  SUBLW  39
05FC:  BTFSC  03.0
05FD:  GOTO   607
....................             s[cnt]+=0x7; 
05FE:  MOVF   6E,W
05FF:  ADDWF  66,W
0600:  MOVWF  04
0601:  BCF    03.7
0602:  BTFSC  67.0
0603:  BSF    03.7
0604:  MOVLW  07
0605:  ADDWF  00,W
0606:  MOVWF  00
....................  
....................          cnt++; 
0607:  INCF   6E,F
....................          num=temp; 
0608:  MOVF   6B,W
0609:  MOVWF  64
060A:  MOVF   6A,W
060B:  MOVWF  63
060C:  MOVF   69,W
060D:  MOVWF  62
060E:  MOVF   68,W
060F:  MOVWF  61
0610:  GOTO   571
....................      } 
....................  
....................      if(sign==1) { 
0611:  DECFSZ 6D,W
0612:  GOTO   61C
....................          s[cnt]=0x2D;      // Negative sign 
0613:  MOVF   6E,W
0614:  ADDWF  66,W
0615:  MOVWF  04
0616:  BCF    03.7
0617:  BTFSC  67.0
0618:  BSF    03.7
0619:  MOVLW  2D
061A:  MOVWF  00
....................          cnt++; 
061B:  INCF   6E,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
061C:  CLRF   6C
061D:  BCF    03.0
061E:  RRF    6E,W
061F:  SUBWF  6C,W
0620:  BTFSC  03.0
0621:  GOTO   656
....................  
....................          c=s[i]; 
0622:  MOVF   6C,W
0623:  ADDWF  66,W
0624:  MOVWF  04
0625:  BCF    03.7
0626:  BTFSC  67.0
0627:  BSF    03.7
0628:  MOVF   00,W
0629:  MOVWF  6F
....................          s[i]=s[cnt-i-1];        // Reverse the number 
062A:  MOVF   6C,W
062B:  ADDWF  66,W
062C:  MOVWF  78
062D:  MOVF   67,W
062E:  MOVWF  7A
062F:  BTFSC  03.0
0630:  INCF   7A,F
0631:  MOVF   78,W
0632:  BSF    03.5
0633:  MOVWF  10
0634:  MOVF   7A,W
0635:  MOVWF  11
0636:  BCF    03.5
0637:  MOVF   6C,W
0638:  SUBWF  6E,W
0639:  ADDLW  FF
063A:  ADDWF  66,W
063B:  MOVWF  04
063C:  BCF    03.7
063D:  BTFSC  67.0
063E:  BSF    03.7
063F:  MOVF   00,W
0640:  BSF    03.5
0641:  MOVWF  12
0642:  MOVF   10,W
0643:  MOVWF  04
0644:  BCF    03.7
0645:  BTFSC  11.0
0646:  BSF    03.7
0647:  MOVF   12,W
0648:  MOVWF  00
....................          s[cnt-i-1]=c; 
0649:  BCF    03.5
064A:  MOVF   6C,W
064B:  SUBWF  6E,W
064C:  ADDLW  FF
064D:  ADDWF  66,W
064E:  MOVWF  04
064F:  BCF    03.7
0650:  BTFSC  67.0
0651:  BSF    03.7
0652:  MOVF   6F,W
0653:  MOVWF  00
0654:  INCF   6C,F
0655:  GOTO   61D
....................      } 
....................      s[cnt]='\0';     // End the string 
0656:  MOVF   6E,W
0657:  ADDWF  66,W
0658:  MOVWF  04
0659:  BCF    03.7
065A:  BTFSC  67.0
065B:  BSF    03.7
065C:  CLRF   00
....................      return s; 
065D:  MOVF   66,W
065E:  MOVWF  78
065F:  MOVF   67,W
0660:  MOVWF  79
0661:  BCF    03.6
0662:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
012F:  MOVLW  64
0130:  MOVWF  04
0131:  BSF    03.7
0132:  MOVF   00,W
0133:  BTFSC  03.2
0134:  GOTO   142
0135:  MOVLW  06
0136:  MOVWF  78
0137:  CLRF   77
0138:  DECFSZ 77,F
0139:  GOTO   138
013A:  DECFSZ 78,F
013B:  GOTO   137
013C:  MOVLW  7B
013D:  MOVWF  77
013E:  DECFSZ 77,F
013F:  GOTO   13E
0140:  DECFSZ 00,F
0141:  GOTO   135
0142:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01D6:  BSF    07.0
....................    output_float(LCD_DATA5); 
01D7:  BSF    07.1
....................    output_float(LCD_DATA6); 
01D8:  BSF    07.2
....................    output_float(LCD_DATA7); 
01D9:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01DA:  BCF    03.5
01DB:  BSF    09.2
01DC:  BSF    03.5
01DD:  BCF    09.2
....................    delay_cycles(1); 
01DE:  NOP
....................    lcd_output_enable(1); 
01DF:  BCF    03.5
01E0:  BSF    09.0
01E1:  BSF    03.5
01E2:  BCF    09.0
....................    delay_cycles(1); 
01E3:  NOP
....................    high = lcd_read_nibble(); 
01E4:  BCF    03.5
01E5:  CALL   18B
01E6:  MOVF   78,W
01E7:  BSF    03.6
01E8:  MOVWF  6B
....................        
....................    lcd_output_enable(0); 
01E9:  BCF    03.6
01EA:  BCF    09.0
01EB:  BSF    03.5
01EC:  BCF    09.0
....................    delay_cycles(1); 
01ED:  NOP
....................    lcd_output_enable(1); 
01EE:  BCF    03.5
01EF:  BSF    09.0
01F0:  BSF    03.5
01F1:  BCF    09.0
....................    delay_us(1); 
01F2:  GOTO   1F3
01F3:  GOTO   1F4
01F4:  NOP
....................    low = lcd_read_nibble(); 
01F5:  BCF    03.5
01F6:  CALL   18B
01F7:  MOVF   78,W
01F8:  BSF    03.6
01F9:  MOVWF  6A
....................        
....................    lcd_output_enable(0); 
01FA:  BCF    03.6
01FB:  BCF    09.0
01FC:  BSF    03.5
01FD:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01FE:  BCF    03.5
01FF:  BCF    31.0
0200:  MOVF   31,W
0201:  BSF    03.5
0202:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0203:  BCF    03.5
0204:  BCF    31.1
0205:  MOVF   31,W
0206:  BSF    03.5
0207:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0208:  BCF    03.5
0209:  BCF    31.2
020A:  MOVF   31,W
020B:  BSF    03.5
020C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
020D:  BCF    03.5
020E:  BCF    31.3
020F:  MOVF   31,W
0210:  BSF    03.5
0211:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0212:  BCF    03.5
0213:  BSF    03.6
0214:  SWAPF  6B,W
0215:  MOVWF  77
0216:  MOVLW  F0
0217:  ANDWF  77,F
0218:  MOVF   77,W
0219:  IORWF  6A,W
021A:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
018B:  BSF    03.6
018C:  CLRF   6C
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
018D:  BCF    03.6
018E:  BSF    31.0
018F:  MOVF   31,W
0190:  BSF    03.5
0191:  MOVWF  07
0192:  MOVLW  00
0193:  BCF    03.5
0194:  BTFSC  07.0
0195:  MOVLW  01
0196:  BSF    03.6
0197:  IORWF  6C,F
....................    n |= input(LCD_DATA5) << 1; 
0198:  BCF    03.6
0199:  BSF    31.1
019A:  MOVF   31,W
019B:  BSF    03.5
019C:  MOVWF  07
019D:  MOVLW  00
019E:  BCF    03.5
019F:  BTFSC  07.1
01A0:  MOVLW  01
01A1:  MOVWF  77
01A2:  BCF    03.0
01A3:  RLF    77,F
01A4:  MOVF   77,W
01A5:  BSF    03.6
01A6:  IORWF  6C,F
....................    n |= input(LCD_DATA6) << 2; 
01A7:  BCF    03.6
01A8:  BSF    31.2
01A9:  MOVF   31,W
01AA:  BSF    03.5
01AB:  MOVWF  07
01AC:  MOVLW  00
01AD:  BCF    03.5
01AE:  BTFSC  07.2
01AF:  MOVLW  01
01B0:  MOVWF  77
01B1:  RLF    77,F
01B2:  RLF    77,F
01B3:  MOVLW  FC
01B4:  ANDWF  77,F
01B5:  MOVF   77,W
01B6:  BSF    03.6
01B7:  IORWF  6C,F
....................    n |= input(LCD_DATA7) << 3; 
01B8:  BCF    03.6
01B9:  BSF    31.3
01BA:  MOVF   31,W
01BB:  BSF    03.5
01BC:  MOVWF  07
01BD:  MOVLW  00
01BE:  BCF    03.5
01BF:  BTFSC  07.3
01C0:  MOVLW  01
01C1:  MOVWF  77
01C2:  RLF    77,F
01C3:  RLF    77,F
01C4:  RLF    77,F
01C5:  MOVLW  F8
01C6:  ANDWF  77,F
01C7:  MOVF   77,W
01C8:  BSF    03.6
01C9:  IORWF  6C,F
....................     
....................    return(n); 
01CA:  MOVF   6C,W
01CB:  MOVWF  78
....................   #else 
01CC:  BCF    03.6
01CD:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0143:  BSF    03.6
0144:  BTFSC  6B.0
0145:  GOTO   14A
0146:  BCF    03.6
0147:  BCF    07.0
0148:  GOTO   14C
0149:  BSF    03.6
014A:  BCF    03.6
014B:  BSF    07.0
014C:  BCF    31.0
014D:  MOVF   31,W
014E:  BSF    03.5
014F:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0150:  BCF    03.5
0151:  BSF    03.6
0152:  BTFSC  6B.1
0153:  GOTO   158
0154:  BCF    03.6
0155:  BCF    07.1
0156:  GOTO   15A
0157:  BSF    03.6
0158:  BCF    03.6
0159:  BSF    07.1
015A:  BCF    31.1
015B:  MOVF   31,W
015C:  BSF    03.5
015D:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
015E:  BCF    03.5
015F:  BSF    03.6
0160:  BTFSC  6B.2
0161:  GOTO   166
0162:  BCF    03.6
0163:  BCF    07.2
0164:  GOTO   168
0165:  BSF    03.6
0166:  BCF    03.6
0167:  BSF    07.2
0168:  BCF    31.2
0169:  MOVF   31,W
016A:  BSF    03.5
016B:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
016C:  BCF    03.5
016D:  BSF    03.6
016E:  BTFSC  6B.3
016F:  GOTO   174
0170:  BCF    03.6
0171:  BCF    07.3
0172:  GOTO   176
0173:  BSF    03.6
0174:  BCF    03.6
0175:  BSF    07.3
0176:  BCF    31.3
0177:  MOVF   31,W
0178:  BSF    03.5
0179:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
017A:  NOP
....................    lcd_output_enable(1); 
017B:  BCF    03.5
017C:  BSF    09.0
017D:  BSF    03.5
017E:  BCF    09.0
....................    delay_us(2); 
017F:  MOVLW  02
0180:  MOVWF  77
0181:  DECFSZ 77,F
0182:  GOTO   181
0183:  GOTO   184
0184:  NOP
....................    lcd_output_enable(0); 
0185:  BCF    03.5
0186:  BCF    09.0
0187:  BSF    03.5
0188:  BCF    09.0
0189:  BCF    03.5
018A:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01CE:  BSF    03.5
01CF:  BCF    09.0
....................    lcd_rs_tris(); 
01D0:  BCF    09.1
....................    lcd_rw_tris(); 
01D1:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01D2:  BCF    03.5
01D3:  BCF    09.1
01D4:  BSF    03.5
01D5:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
021B:  MOVF   78,W
021C:  MOVWF  6A
021D:  BTFSS  6A.7
021E:  GOTO   222
021F:  BSF    03.5
0220:  BCF    03.6
0221:  GOTO   1D6
....................    lcd_output_rs(address); 
0222:  MOVF   68,F
0223:  BTFSS  03.2
0224:  GOTO   229
0225:  BCF    03.6
0226:  BCF    09.1
0227:  GOTO   22B
0228:  BSF    03.6
0229:  BCF    03.6
022A:  BSF    09.1
022B:  BSF    03.5
022C:  BCF    09.1
....................    delay_cycles(1); 
022D:  NOP
....................    lcd_output_rw(0); 
022E:  BCF    03.5
022F:  BCF    09.2
0230:  BSF    03.5
0231:  BCF    09.2
....................    delay_cycles(1); 
0232:  NOP
....................    lcd_output_enable(0); 
0233:  BCF    03.5
0234:  BCF    09.0
0235:  BSF    03.5
0236:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0237:  BCF    03.5
0238:  BSF    03.6
0239:  SWAPF  69,W
023A:  MOVWF  6A
023B:  MOVLW  0F
023C:  ANDWF  6A,F
023D:  MOVF   6A,W
023E:  MOVWF  6B
023F:  BCF    03.6
0240:  CALL   143
....................    lcd_send_nibble(n & 0xf); 
0241:  BSF    03.6
0242:  MOVF   69,W
0243:  ANDLW  0F
0244:  MOVWF  6A
0245:  MOVWF  6B
0246:  BCF    03.6
0247:  CALL   143
0248:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0249:  MOVLW  28
024A:  BSF    03.6
024B:  MOVWF  60
024C:  MOVLW  0C
024D:  MOVWF  61
024E:  MOVLW  01
024F:  MOVWF  62
0250:  MOVLW  06
0251:  MOVWF  63
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0252:  BCF    03.6
0253:  BCF    09.0
0254:  BSF    03.5
0255:  BCF    09.0
....................    lcd_output_rs(0); 
0256:  BCF    03.5
0257:  BCF    09.1
0258:  BSF    03.5
0259:  BCF    09.1
....................    lcd_output_rw(0); 
025A:  BCF    03.5
025B:  BCF    09.2
025C:  BSF    03.5
025D:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
025E:  BCF    03.5
025F:  BCF    31.0
0260:  MOVF   31,W
0261:  BSF    03.5
0262:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0263:  BCF    03.5
0264:  BCF    31.1
0265:  MOVF   31,W
0266:  BSF    03.5
0267:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0268:  BCF    03.5
0269:  BCF    31.2
026A:  MOVF   31,W
026B:  BSF    03.5
026C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
026D:  BCF    03.5
026E:  BCF    31.3
026F:  MOVF   31,W
0270:  BSF    03.5
0271:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0272:  BCF    09.0
....................    lcd_rs_tris(); 
0273:  BCF    09.1
....................    lcd_rw_tris(); 
0274:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0275:  MOVLW  0F
0276:  BCF    03.5
0277:  BSF    03.6
0278:  MOVWF  64
0279:  BCF    03.6
027A:  CALL   12F
....................    for(i=1;i<=3;++i) 
027B:  MOVLW  01
027C:  BSF    03.6
027D:  MOVWF  5F
027E:  MOVF   5F,W
027F:  SUBLW  03
0280:  BTFSS  03.0
0281:  GOTO   28E
....................    { 
....................        lcd_send_nibble(3); 
0282:  MOVLW  03
0283:  MOVWF  6B
0284:  BCF    03.6
0285:  CALL   143
....................        delay_ms(5); 
0286:  MOVLW  05
0287:  BSF    03.6
0288:  MOVWF  64
0289:  BCF    03.6
028A:  CALL   12F
028B:  BSF    03.6
028C:  INCF   5F,F
028D:  GOTO   27E
....................    } 
....................     
....................    lcd_send_nibble(2); 
028E:  MOVLW  02
028F:  MOVWF  6B
0290:  BCF    03.6
0291:  CALL   143
....................    delay_ms(5); 
0292:  MOVLW  05
0293:  BSF    03.6
0294:  MOVWF  64
0295:  BCF    03.6
0296:  CALL   12F
....................    for(i=0;i<=3;++i) 
0297:  BSF    03.6
0298:  CLRF   5F
0299:  MOVF   5F,W
029A:  SUBLW  03
029B:  BTFSS  03.0
029C:  GOTO   2AB
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
029D:  MOVLW  60
029E:  ADDWF  5F,W
029F:  MOVWF  04
02A0:  BSF    03.7
02A1:  MOVF   00,W
02A2:  MOVWF  64
02A3:  CLRF   68
02A4:  MOVF   64,W
02A5:  MOVWF  69
02A6:  BCF    03.6
02A7:  CALL   1CE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02A8:  BSF    03.6
02A9:  INCF   5F,F
02AA:  GOTO   299
02AB:  BCF    03.6
02AC:  BSF    0A.3
02AD:  BCF    0A.4
02AE:  GOTO   6E4 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0403:  BSF    03.6
0404:  DECFSZ 65,W
0405:  GOTO   407
0406:  GOTO   40A
....................       address=LCD_LINE_TWO; 
0407:  MOVLW  40
0408:  MOVWF  66
0409:  GOTO   40B
....................    else 
....................       address=0; 
040A:  CLRF   66
....................       
....................    address+=x-1; 
040B:  MOVLW  01
040C:  SUBWF  64,W
040D:  ADDWF  66,F
....................    lcd_send_byte(0,0x80|address); 
040E:  MOVF   66,W
040F:  IORLW  80
0410:  MOVWF  67
0411:  CLRF   68
0412:  MOVF   67,W
0413:  MOVWF  69
0414:  BCF    03.6
0415:  CALL   1CE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0416:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0417:  BSF    03.6
0418:  MOVF   63,W
0419:  XORLW  07
041A:  BCF    03.6
041B:  BTFSC  03.2
041C:  GOTO   427
041D:  XORLW  0B
041E:  BTFSC  03.2
041F:  GOTO   42E
0420:  XORLW  06
0421:  BTFSC  03.2
0422:  GOTO   43A
0423:  XORLW  02
0424:  BTFSC  03.2
0425:  GOTO   442
0426:  GOTO   449
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0427:  MOVLW  01
0428:  BSF    03.6
0429:  MOVWF  64
042A:  MOVWF  65
042B:  BCF    03.6
042C:  CALL   403
042D:  GOTO   450
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
042E:  BSF    03.6
042F:  CLRF   68
0430:  MOVLW  01
0431:  MOVWF  69
0432:  BCF    03.6
0433:  CALL   1CE
....................                      delay_ms(2); 
0434:  MOVLW  02
0435:  BSF    03.6
0436:  MOVWF  64
0437:  BCF    03.6
0438:  CALL   12F
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0439:  GOTO   450
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
043A:  MOVLW  01
043B:  BSF    03.6
043C:  MOVWF  64
043D:  MOVLW  02
043E:  MOVWF  65
043F:  BCF    03.6
0440:  CALL   403
0441:  GOTO   450
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0442:  BSF    03.6
0443:  CLRF   68
0444:  MOVLW  10
0445:  MOVWF  69
0446:  BCF    03.6
0447:  CALL   1CE
0448:  GOTO   450
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0449:  MOVLW  01
044A:  BSF    03.6
044B:  MOVWF  68
044C:  MOVF   63,W
044D:  MOVWF  69
044E:  BCF    03.6
044F:  CALL   1CE
....................      #endif 
....................    } 
0450:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... CHAR KYTUCHAR[20]="HIHI"; 
*
0D7E:  MOVLW  48
0D7F:  MOVWF  5F
0D80:  MOVLW  49
0D81:  MOVWF  60
0D82:  MOVLW  48
0D83:  MOVWF  61
0D84:  MOVLW  49
0D85:  MOVWF  62
0D86:  CLRF   63
.................... INT1 TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 0, 1, 0, 1, 1}; 
0D87:  MOVLW  D6
0D88:  MOVWF  74
.................... INT1 TT_SENSOR[8]={1, 1, 1, 1, 0, 0, 0, 0}; 
0D89:  MOVLW  0F
0D8A:  MOVWF  75
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
0D8B:  MOVLW  20
0D8C:  MOVWF  7D
0D8D:  CLRF   7E
0D8E:  CLRF   7C
0D8F:  MOVLW  7D
0D90:  MOVWF  7B
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
0D91:  MOVLW  20
0D92:  BSF    03.5
0D93:  MOVWF  22
0D94:  CLRF   23
0D95:  CLRF   21
0D96:  MOVLW  A2
0D97:  MOVWF  20
.................... CHAR *PACKAGE_NHIETDO[]={"*","ID_GW", "ID_NODE","LENGHT", "S_S" ,"TT_cambien","#"}; 
0D98:  MOVLW  2A
0D99:  MOVWF  32
0D9A:  CLRF   33
0D9B:  MOVLW  49
0D9C:  MOVWF  34
0D9D:  MOVLW  44
0D9E:  MOVWF  35
0D9F:  MOVLW  5F
0DA0:  MOVWF  36
0DA1:  MOVLW  47
0DA2:  MOVWF  37
0DA3:  MOVLW  57
0DA4:  MOVWF  38
0DA5:  CLRF   39
0DA6:  MOVLW  49
0DA7:  MOVWF  3A
0DA8:  MOVLW  44
0DA9:  MOVWF  3B
0DAA:  MOVLW  5F
0DAB:  MOVWF  3C
0DAC:  MOVLW  4E
0DAD:  MOVWF  3D
0DAE:  MOVLW  4F
0DAF:  MOVWF  3E
0DB0:  MOVLW  44
0DB1:  MOVWF  3F
0DB2:  MOVLW  45
0DB3:  MOVWF  40
0DB4:  CLRF   41
0DB5:  MOVLW  4C
0DB6:  MOVWF  42
0DB7:  MOVLW  45
0DB8:  MOVWF  43
0DB9:  MOVLW  4E
0DBA:  MOVWF  44
0DBB:  MOVLW  47
0DBC:  MOVWF  45
0DBD:  MOVLW  48
0DBE:  MOVWF  46
0DBF:  MOVLW  54
0DC0:  MOVWF  47
0DC1:  CLRF   48
0DC2:  MOVLW  53
0DC3:  MOVWF  49
0DC4:  MOVLW  5F
0DC5:  MOVWF  4A
0DC6:  MOVLW  53
0DC7:  MOVWF  4B
0DC8:  CLRF   4C
0DC9:  MOVLW  54
0DCA:  MOVWF  4D
0DCB:  MOVWF  4E
0DCC:  MOVLW  5F
0DCD:  MOVWF  4F
0DCE:  MOVLW  63
0DCF:  MOVWF  50
0DD0:  MOVLW  61
0DD1:  MOVWF  51
0DD2:  MOVLW  6D
0DD3:  MOVWF  52
0DD4:  MOVLW  62
0DD5:  MOVWF  53
0DD6:  MOVLW  69
0DD7:  MOVWF  54
0DD8:  MOVLW  65
0DD9:  MOVWF  55
0DDA:  MOVLW  6E
0DDB:  MOVWF  56
0DDC:  CLRF   57
0DDD:  MOVLW  23
0DDE:  MOVWF  58
0DDF:  CLRF   59
0DE0:  CLRF   25
0DE1:  MOVLW  B2
0DE2:  MOVWF  24
0DE3:  CLRF   27
0DE4:  MOVLW  B4
0DE5:  MOVWF  26
0DE6:  CLRF   29
0DE7:  MOVLW  BA
0DE8:  MOVWF  28
0DE9:  CLRF   2B
0DEA:  MOVLW  C2
0DEB:  MOVWF  2A
0DEC:  CLRF   2D
0DED:  MOVLW  C9
0DEE:  MOVWF  2C
0DEF:  CLRF   2F
0DF0:  MOVLW  CD
0DF1:  MOVWF  2E
0DF2:  CLRF   31
0DF3:  MOVLW  D8
0DF4:  MOVWF  30
....................  
.................... CHAR *PACKAGE_CONFIG[]={"*","ID_GW" ,"ID_NODE", "LENGHT","C_F", "DEVICE1234","SENSOR1234","#"}; 
0DF5:  MOVLW  2A
0DF6:  BCF    03.5
0DF7:  BSF    03.6
0DF8:  MOVWF  10
0DF9:  CLRF   11
0DFA:  MOVLW  49
0DFB:  MOVWF  12
0DFC:  MOVLW  44
0DFD:  MOVWF  13
0DFE:  MOVLW  5F
0DFF:  MOVWF  14
0E00:  MOVLW  47
0E01:  MOVWF  15
0E02:  MOVLW  57
0E03:  MOVWF  16
0E04:  CLRF   17
0E05:  MOVLW  49
0E06:  MOVWF  18
0E07:  MOVLW  44
0E08:  MOVWF  19
0E09:  MOVLW  5F
0E0A:  MOVWF  1A
0E0B:  MOVLW  4E
0E0C:  MOVWF  1B
0E0D:  MOVLW  4F
0E0E:  MOVWF  1C
0E0F:  MOVLW  44
0E10:  MOVWF  1D
0E11:  MOVLW  45
0E12:  MOVWF  1E
0E13:  CLRF   1F
0E14:  MOVLW  4C
0E15:  MOVWF  20
0E16:  MOVLW  45
0E17:  MOVWF  21
0E18:  MOVLW  4E
0E19:  MOVWF  22
0E1A:  MOVLW  47
0E1B:  MOVWF  23
0E1C:  MOVLW  48
0E1D:  MOVWF  24
0E1E:  MOVLW  54
0E1F:  MOVWF  25
0E20:  CLRF   26
0E21:  MOVLW  43
0E22:  MOVWF  27
0E23:  MOVLW  5F
0E24:  MOVWF  28
0E25:  MOVLW  46
0E26:  MOVWF  29
0E27:  CLRF   2A
0E28:  MOVLW  44
0E29:  MOVWF  2B
0E2A:  MOVLW  45
0E2B:  MOVWF  2C
0E2C:  MOVLW  56
0E2D:  MOVWF  2D
0E2E:  MOVLW  49
0E2F:  MOVWF  2E
0E30:  MOVLW  43
0E31:  MOVWF  2F
0E32:  MOVLW  45
0E33:  MOVWF  30
0E34:  MOVLW  31
0E35:  MOVWF  31
0E36:  MOVLW  32
0E37:  MOVWF  32
0E38:  MOVLW  33
0E39:  MOVWF  33
0E3A:  MOVLW  34
0E3B:  MOVWF  34
0E3C:  CLRF   35
0E3D:  MOVLW  53
0E3E:  MOVWF  36
0E3F:  MOVLW  45
0E40:  MOVWF  37
0E41:  MOVLW  4E
0E42:  MOVWF  38
0E43:  MOVLW  53
0E44:  MOVWF  39
0E45:  MOVLW  4F
0E46:  MOVWF  3A
0E47:  MOVLW  52
0E48:  MOVWF  3B
0E49:  MOVLW  31
0E4A:  MOVWF  3C
0E4B:  MOVLW  32
0E4C:  MOVWF  3D
0E4D:  MOVLW  33
0E4E:  MOVWF  3E
0E4F:  MOVLW  34
0E50:  MOVWF  3F
0E51:  CLRF   40
0E52:  MOVLW  23
0E53:  MOVWF  41
0E54:  CLRF   42
0E55:  MOVLW  01
0E56:  BSF    03.5
0E57:  BCF    03.6
0E58:  MOVWF  5B
0E59:  MOVLW  10
0E5A:  MOVWF  5A
0E5B:  MOVLW  01
0E5C:  MOVWF  5D
0E5D:  MOVLW  12
0E5E:  MOVWF  5C
0E5F:  MOVLW  01
0E60:  MOVWF  5F
0E61:  MOVLW  18
0E62:  MOVWF  5E
0E63:  MOVLW  01
0E64:  MOVWF  61
0E65:  MOVLW  20
0E66:  MOVWF  60
0E67:  MOVLW  01
0E68:  MOVWF  63
0E69:  MOVLW  27
0E6A:  MOVWF  62
0E6B:  MOVLW  01
0E6C:  MOVWF  65
0E6D:  MOVLW  2B
0E6E:  MOVWF  64
0E6F:  MOVLW  01
0E70:  MOVWF  67
0E71:  MOVLW  36
0E72:  MOVWF  66
0E73:  MOVLW  01
0E74:  MOVWF  69
0E75:  MOVLW  41
0E76:  MOVWF  68
....................  
.................... CHAR *ID_[]="0"; 
0E77:  MOVLW  30
0E78:  MOVWF  6C
0E79:  CLRF   6D
0E7A:  CLRF   6B
0E7B:  MOVLW  EC
0E7C:  MOVWF  6A
.................... CHAR *ID_GW[]= "0000"; 
0E7D:  MOVLW  30
0E7E:  BCF    03.5
0E7F:  BSF    03.6
0E80:  MOVWF  43
0E81:  MOVWF  44
0E82:  MOVWF  45
0E83:  MOVWF  46
0E84:  CLRF   47
0E85:  MOVLW  01
0E86:  BSF    03.5
0E87:  BCF    03.6
0E88:  MOVWF  6F
0E89:  MOVLW  43
0E8A:  MOVWF  6E
.................... UNSIGNED INT8 ID_GATEWAY[4] = {0,0,0,0}; 
0E8B:  BCF    03.5
0E8C:  BSF    03.6
0E8D:  CLRF   48
0E8E:  CLRF   49
0E8F:  CLRF   4A
0E90:  CLRF   4B
.................... CHAR *TEMP_CHAR[]="0"; 
0E91:  MOVLW  30
0E92:  MOVWF  4E
0E93:  CLRF   4F
0E94:  MOVLW  01
0E95:  MOVWF  4D
0E96:  MOVLW  4E
0E97:  MOVWF  4C
.................... CHAR *TEMP_CHAR2[]="0";  
0E98:  MOVLW  30
0E99:  MOVWF  52
0E9A:  CLRF   53
0E9B:  MOVLW  01
0E9C:  MOVWF  51
0E9D:  MOVLW  52
0E9E:  MOVWF  50
.................... CHAR *TEMP_CHAR3[]="0";  
0E9F:  MOVLW  30
0EA0:  MOVWF  56
0EA1:  CLRF   57
0EA2:  MOVLW  01
0EA3:  MOVWF  55
0EA4:  MOVLW  56
0EA5:  MOVWF  54
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... CHAR NHIETDO1[]="27"; 
0EA6:  MOVLW  32
0EA7:  MOVWF  58
0EA8:  MOVLW  37
0EA9:  MOVWF  59
0EAA:  CLRF   5A
.................... CHAR NHIETDO2[]="27"; 
0EAB:  MOVLW  32
0EAC:  MOVWF  5B
0EAD:  MOVLW  37
0EAE:  MOVWF  5C
0EAF:  CLRF   5D
....................  
....................  
.................... #INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    73.2
....................    TT_STT = 1; 
0808:  BSF    73.4
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  64
080C:  MOVLW  02
080D:  MOVWF  65
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   403
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  64
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   12F
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   451
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  73.4
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  5F
0831:  MOVLW  96
0832:  MOVWF  64
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   12F
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 5F,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   64
083B:  CLRF   63
083C:  CLRF   62
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  61
0841:  MOVLW  0A
0842:  MOVWF  65
0843:  CLRF   67
0844:  MOVLW  EA
0845:  MOVWF  66
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   51F
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  64
084D:  MOVLW  02
084E:  MOVWF  65
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   403
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  64
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   12F
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  EA
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   663
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  64
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   12F
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    73.2
....................    TT_STT = 1; 
086F:  BSF    73.4
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  64
0873:  MOVLW  02
0874:  MOVWF  65
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   403
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  64
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   12F
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:           "); 
0880:  MOVLW  72
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   451
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  73.4
088A:  GOTO   178
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11C
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  5F
0898:  MOVLW  96
0899:  MOVWF  64
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   12F
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 5F,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   64
08A2:  CLRF   63
08A3:  CLRF   62
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  61
08A8:  MOVLW  0A
08A9:  MOVWF  65
08AA:  MOVLW  01
08AB:  MOVWF  67
08AC:  MOVLW  4C
08AD:  MOVWF  66
08AE:  BCF    0A.3
08AF:  BCF    03.6
08B0:  CALL   51F
08B1:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B2:  MOVLW  09
08B3:  BSF    03.6
08B4:  MOVWF  64
08B5:  MOVLW  02
08B6:  MOVWF  65
08B7:  BCF    0A.3
08B8:  BCF    03.6
08B9:  CALL   403
08BA:  BSF    0A.3
....................          DELAY_MS (10); 
08BB:  MOVLW  0A
08BC:  BSF    03.6
08BD:  MOVWF  64
08BE:  BCF    0A.3
08BF:  BCF    03.6
08C0:  CALL   12F
08C1:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C2:  MOVLW  4C
08C3:  MOVWF  04
08C4:  BSF    03.7
08C5:  BCF    0A.3
08C6:  CALL   663
08C7:  BSF    0A.3
....................          DELAY_MS (1); 
08C8:  MOVLW  01
08C9:  BSF    03.6
08CA:  MOVWF  64
08CB:  BCF    0A.3
08CC:  BCF    03.6
08CD:  CALL   12F
08CE:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
08CF:  MOVLW  20
08D0:  BSF    03.6
08D1:  MOVWF  63
08D2:  BCF    0A.3
08D3:  BCF    03.6
08D4:  CALL   417
08D5:  BSF    0A.3
08D6:  MOVLW  3A
08D7:  BSF    03.6
08D8:  MOVWF  63
08D9:  BCF    0A.3
08DA:  BCF    03.6
08DB:  CALL   417
08DC:  BSF    0A.3
08DD:  MOVLW  20
08DE:  BSF    03.6
08DF:  MOVWF  63
08E0:  BCF    0A.3
08E1:  BCF    03.6
08E2:  CALL   417
08E3:  BSF    0A.3
....................          DELAY_MS (1); 
08E4:  MOVLW  01
08E5:  BSF    03.6
08E6:  MOVWF  64
08E7:  BCF    0A.3
08E8:  BCF    03.6
08E9:  CALL   12F
08EA:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EB:  MOVF   3A,W
08EC:  BSF    03.6
08ED:  MOVWF  61
08EE:  CLRF   63
08EF:  MOVLW  74
08F0:  MOVWF  62
08F1:  BCF    0A.3
08F2:  BCF    03.6
08F3:  CALL   680
08F4:  BSF    0A.3
08F5:  MOVLW  00
08F6:  BTFSC  78.0
08F7:  MOVLW  01
08F8:  BSF    03.6
08F9:  MOVWF  5F
08FA:  CLRF   64
08FB:  CLRF   63
08FC:  CLRF   62
08FD:  MOVF   5F,W
08FE:  MOVWF  61
08FF:  MOVLW  0A
0900:  MOVWF  65
0901:  MOVLW  01
0902:  MOVWF  67
0903:  MOVLW  4C
0904:  MOVWF  66
0905:  BCF    0A.3
0906:  BCF    03.6
0907:  CALL   51F
0908:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0909:  MOVLW  4C
090A:  MOVWF  04
090B:  BSF    03.7
090C:  BCF    0A.3
090D:  CALL   663
090E:  BSF    0A.3
....................          DELAY_MS (1); 
090F:  MOVLW  01
0910:  BSF    03.6
0911:  MOVWF  64
0912:  BCF    0A.3
0913:  BCF    03.6
0914:  CALL   12F
0915:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0916:  BSF    03.5
0917:  BCF    08.0
0918:  MOVLW  01
0919:  BCF    03.5
091A:  XORWF  08,F
....................       } 
091B:  GOTO   177
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091C:  BSF    03.5
091D:  BSF    06.3
091E:  BCF    03.5
091F:  BTFSC  06.3
0920:  GOTO   177
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
0921:  MOVF   3A,W
0922:  BSF    03.6
0923:  MOVWF  61
0924:  CLRF   63
0925:  MOVLW  74
0926:  MOVWF  62
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   680
092A:  BSF    0A.3
092B:  MOVLW  00
092C:  BTFSS  78.0
092D:  MOVLW  01
092E:  BSF    03.6
092F:  MOVWF  5F
0930:  BCF    03.6
0931:  MOVF   3A,W
0932:  BSF    03.6
0933:  MOVWF  60
0934:  MOVF   5F,W
0935:  MOVWF  61
0936:  CLRF   63
0937:  MOVLW  74
0938:  MOVWF  62
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   699
093C:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
093D:  MOVLW  0D
093E:  BSF    03.6
093F:  MOVWF  64
0940:  MOVLW  02
0941:  MOVWF  65
0942:  BCF    0A.3
0943:  BCF    03.6
0944:  CALL   403
0945:  BSF    0A.3
....................          DELAY_MS (300); 
0946:  MOVLW  02
0947:  BSF    03.6
0948:  MOVWF  5F
0949:  MOVLW  96
094A:  MOVWF  64
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   12F
094E:  BSF    0A.3
094F:  BSF    03.6
0950:  DECFSZ 5F,F
0951:  GOTO   149
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0952:  BCF    03.6
0953:  MOVF   3A,W
0954:  BSF    03.6
0955:  MOVWF  61
0956:  CLRF   63
0957:  MOVLW  74
0958:  MOVWF  62
0959:  BCF    0A.3
095A:  BCF    03.6
095B:  CALL   680
095C:  BSF    0A.3
095D:  MOVLW  00
095E:  BTFSC  78.0
095F:  MOVLW  01
0960:  BSF    03.6
0961:  MOVWF  5F
0962:  CLRF   64
0963:  CLRF   63
0964:  CLRF   62
0965:  MOVF   5F,W
0966:  MOVWF  61
0967:  MOVLW  0A
0968:  MOVWF  65
0969:  MOVLW  01
096A:  MOVWF  67
096B:  MOVLW  4C
096C:  MOVWF  66
096D:  BCF    0A.3
096E:  BCF    03.6
096F:  CALL   51F
0970:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0971:  MOVLW  4C
0972:  MOVWF  04
0973:  BSF    03.7
0974:  BCF    0A.3
0975:  CALL   663
0976:  BSF    0A.3
....................       } 
0977:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0979:  BCF    73.2
....................    TT_STT = 1; 
097A:  BSF    73.4
....................    LCD_GOTOXY (1, 2) ; 
097B:  MOVLW  01
097C:  BSF    03.6
097D:  MOVWF  64
097E:  MOVLW  02
097F:  MOVWF  65
0980:  BCF    0A.3
0981:  BCF    03.6
0982:  CALL   403
0983:  BSF    0A.3
....................    DELAY_MS (10);   
0984:  MOVLW  0A
0985:  BSF    03.6
0986:  MOVWF  64
0987:  BCF    0A.3
0988:  BCF    03.6
0989:  CALL   12F
098A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
098B:  MOVLW  7C
098C:  BSF    03.6
098D:  MOVWF  0D
098E:  MOVLW  00
098F:  MOVWF  0F
0990:  BCF    0A.3
0991:  BCF    03.6
0992:  CALL   451
0993:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0994:  BTFSS  73.4
0995:  GOTO   283
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0996:  BSF    03.5
0997:  BSF    06.2
0998:  BCF    03.5
0999:  BTFSC  06.2
099A:  GOTO   227
....................       { 
....................          STT_SENSOR ++; 
099B:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
099C:  MOVF   3B,W
099D:  SUBLW  03
099E:  BTFSS  03.0
099F:  CLRF   3B
....................          DELAY_MS (300); 
09A0:  MOVLW  02
09A1:  BSF    03.6
09A2:  MOVWF  5F
09A3:  MOVLW  96
09A4:  MOVWF  64
09A5:  BCF    0A.3
09A6:  BCF    03.6
09A7:  CALL   12F
09A8:  BSF    0A.3
09A9:  BSF    03.6
09AA:  DECFSZ 5F,F
09AB:  GOTO   1A3
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09AC:  CLRF   64
09AD:  CLRF   63
09AE:  CLRF   62
09AF:  BCF    03.6
09B0:  MOVF   3B,W
09B1:  BSF    03.6
09B2:  MOVWF  61
09B3:  MOVLW  0A
09B4:  MOVWF  65
09B5:  MOVLW  01
09B6:  MOVWF  67
09B7:  MOVLW  4C
09B8:  MOVWF  66
09B9:  BCF    0A.3
09BA:  BCF    03.6
09BB:  CALL   51F
09BC:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09BD:  MOVLW  09
09BE:  BSF    03.6
09BF:  MOVWF  64
09C0:  MOVLW  02
09C1:  MOVWF  65
09C2:  BCF    0A.3
09C3:  BCF    03.6
09C4:  CALL   403
09C5:  BSF    0A.3
....................          DELAY_MS (10); 
09C6:  MOVLW  0A
09C7:  BSF    03.6
09C8:  MOVWF  64
09C9:  BCF    0A.3
09CA:  BCF    03.6
09CB:  CALL   12F
09CC:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09CD:  MOVLW  4C
09CE:  MOVWF  04
09CF:  BSF    03.7
09D0:  BCF    0A.3
09D1:  CALL   663
09D2:  BSF    0A.3
....................          DELAY_MS (1); 
09D3:  MOVLW  01
09D4:  BSF    03.6
09D5:  MOVWF  64
09D6:  BCF    0A.3
09D7:  BCF    03.6
09D8:  CALL   12F
09D9:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
09DA:  MOVLW  20
09DB:  BSF    03.6
09DC:  MOVWF  63
09DD:  BCF    0A.3
09DE:  BCF    03.6
09DF:  CALL   417
09E0:  BSF    0A.3
09E1:  MOVLW  3A
09E2:  BSF    03.6
09E3:  MOVWF  63
09E4:  BCF    0A.3
09E5:  BCF    03.6
09E6:  CALL   417
09E7:  BSF    0A.3
09E8:  MOVLW  20
09E9:  BSF    03.6
09EA:  MOVWF  63
09EB:  BCF    0A.3
09EC:  BCF    03.6
09ED:  CALL   417
09EE:  BSF    0A.3
....................          DELAY_MS (1); 
09EF:  MOVLW  01
09F0:  BSF    03.6
09F1:  MOVWF  64
09F2:  BCF    0A.3
09F3:  BCF    03.6
09F4:  CALL   12F
09F5:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F6:  MOVF   3B,W
09F7:  BSF    03.6
09F8:  MOVWF  61
09F9:  CLRF   63
09FA:  MOVLW  75
09FB:  MOVWF  62
09FC:  BCF    0A.3
09FD:  BCF    03.6
09FE:  CALL   680
09FF:  BSF    0A.3
0A00:  MOVLW  00
0A01:  BTFSC  78.0
0A02:  MOVLW  01
0A03:  BSF    03.6
0A04:  MOVWF  5F
0A05:  CLRF   64
0A06:  CLRF   63
0A07:  CLRF   62
0A08:  MOVF   5F,W
0A09:  MOVWF  61
0A0A:  MOVLW  0A
0A0B:  MOVWF  65
0A0C:  MOVLW  01
0A0D:  MOVWF  67
0A0E:  MOVLW  4C
0A0F:  MOVWF  66
0A10:  BCF    0A.3
0A11:  BCF    03.6
0A12:  CALL   51F
0A13:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A14:  MOVLW  4C
0A15:  MOVWF  04
0A16:  BSF    03.7
0A17:  BCF    0A.3
0A18:  CALL   663
0A19:  BSF    0A.3
....................          DELAY_MS (1); 
0A1A:  MOVLW  01
0A1B:  BSF    03.6
0A1C:  MOVWF  64
0A1D:  BCF    0A.3
0A1E:  BCF    03.6
0A1F:  CALL   12F
0A20:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A21:  BSF    03.5
0A22:  BCF    08.0
0A23:  MOVLW  01
0A24:  BCF    03.5
0A25:  XORWF  08,F
....................       } 
0A26:  GOTO   282
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A27:  BSF    03.5
0A28:  BSF    06.3
0A29:  BCF    03.5
0A2A:  BTFSC  06.3
0A2B:  GOTO   282
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A2C:  MOVF   3B,W
0A2D:  BSF    03.6
0A2E:  MOVWF  61
0A2F:  CLRF   63
0A30:  MOVLW  75
0A31:  MOVWF  62
0A32:  BCF    0A.3
0A33:  BCF    03.6
0A34:  CALL   680
0A35:  BSF    0A.3
0A36:  MOVLW  00
0A37:  BTFSS  78.0
0A38:  MOVLW  01
0A39:  BSF    03.6
0A3A:  MOVWF  5F
0A3B:  BCF    03.6
0A3C:  MOVF   3B,W
0A3D:  BSF    03.6
0A3E:  MOVWF  60
0A3F:  MOVF   5F,W
0A40:  MOVWF  61
0A41:  CLRF   63
0A42:  MOVLW  75
0A43:  MOVWF  62
0A44:  BCF    0A.3
0A45:  BCF    03.6
0A46:  CALL   699
0A47:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A48:  MOVLW  0D
0A49:  BSF    03.6
0A4A:  MOVWF  64
0A4B:  MOVLW  02
0A4C:  MOVWF  65
0A4D:  BCF    0A.3
0A4E:  BCF    03.6
0A4F:  CALL   403
0A50:  BSF    0A.3
....................          DELAY_MS (300); 
0A51:  MOVLW  02
0A52:  BSF    03.6
0A53:  MOVWF  5F
0A54:  MOVLW  96
0A55:  MOVWF  64
0A56:  BCF    0A.3
0A57:  BCF    03.6
0A58:  CALL   12F
0A59:  BSF    0A.3
0A5A:  BSF    03.6
0A5B:  DECFSZ 5F,F
0A5C:  GOTO   254
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A5D:  BCF    03.6
0A5E:  MOVF   3B,W
0A5F:  BSF    03.6
0A60:  MOVWF  61
0A61:  CLRF   63
0A62:  MOVLW  75
0A63:  MOVWF  62
0A64:  BCF    0A.3
0A65:  BCF    03.6
0A66:  CALL   680
0A67:  BSF    0A.3
0A68:  MOVLW  00
0A69:  BTFSC  78.0
0A6A:  MOVLW  01
0A6B:  BSF    03.6
0A6C:  MOVWF  5F
0A6D:  CLRF   64
0A6E:  CLRF   63
0A6F:  CLRF   62
0A70:  MOVF   5F,W
0A71:  MOVWF  61
0A72:  MOVLW  0A
0A73:  MOVWF  65
0A74:  MOVLW  01
0A75:  MOVWF  67
0A76:  MOVLW  4C
0A77:  MOVWF  66
0A78:  BCF    0A.3
0A79:  BCF    03.6
0A7A:  CALL   51F
0A7B:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A7C:  MOVLW  4C
0A7D:  MOVWF  04
0A7E:  BSF    03.7
0A7F:  BCF    0A.3
0A80:  CALL   663
0A81:  BSF    0A.3
....................       } 
0A82:  GOTO   194
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0A84:  BSF    03.6
0A85:  CLRF   5F
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    ID_GW = "\0"; 
0A86:  CLRF   60
0A87:  CLRF   61
0A88:  MOVLW  EE
0A89:  MOVWF  04
0A8A:  BCF    03.7
0A8B:  MOVF   60,W
0A8C:  ADDWF  04,F
0A8D:  MOVF   61,W
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   058
0A91:  BSF    0A.3
0A92:  MOVWF  00
0A93:  IORLW  00
0A94:  BTFSC  03.2
0A95:  GOTO   29B
0A96:  BSF    03.6
0A97:  INCF   61,F
0A98:  INCF   60,F
0A99:  GOTO   288
0A9A:  BCF    03.6
....................    TEMP_CHAR3 = "0"; 
0A9B:  BSF    03.6
0A9C:  CLRF   60
0A9D:  CLRF   61
0A9E:  MOVLW  54
0A9F:  MOVWF  04
0AA0:  BSF    03.7
0AA1:  MOVF   60,W
0AA2:  ADDWF  04,F
0AA3:  MOVF   61,W
0AA4:  BCF    0A.3
0AA5:  BCF    03.6
0AA6:  CALL   05E
0AA7:  BSF    0A.3
0AA8:  MOVWF  00
0AA9:  IORLW  00
0AAA:  BTFSC  03.2
0AAB:  GOTO   2B1
0AAC:  BSF    03.6
0AAD:  INCF   61,F
0AAE:  INCF   60,F
0AAF:  GOTO   29E
0AB0:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0AB1:  BCF    73.2
....................    TT_STT = 1; 
0AB2:  BSF    73.4
....................    LCD_GOTOXY (1, 2) ; 
0AB3:  MOVLW  01
0AB4:  BSF    03.6
0AB5:  MOVWF  64
0AB6:  MOVLW  02
0AB7:  MOVWF  65
0AB8:  BCF    0A.3
0AB9:  BCF    03.6
0ABA:  CALL   403
0ABB:  BSF    0A.3
....................    DELAY_MS (10); 
0ABC:  MOVLW  0A
0ABD:  BSF    03.6
0ABE:  MOVWF  64
0ABF:  BCF    0A.3
0AC0:  BCF    03.6
0AC1:  CALL   12F
0AC2:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:  0000 "); 
0AC3:  MOVLW  85
0AC4:  BSF    03.6
0AC5:  MOVWF  0D
0AC6:  MOVLW  00
0AC7:  MOVWF  0F
0AC8:  BCF    0A.3
0AC9:  BCF    03.6
0ACA:  CALL   451
0ACB:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0ACC:  MOVLW  01
0ACD:  BSF    03.6
0ACE:  MOVWF  64
0ACF:  MOVWF  65
0AD0:  BCF    0A.3
0AD1:  BCF    03.6
0AD2:  CALL   403
0AD3:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "        _    "); 
0AD4:  MOVLW  8C
0AD5:  BSF    03.6
0AD6:  MOVWF  0D
0AD7:  MOVLW  00
0AD8:  MOVWF  0F
0AD9:  BCF    0A.3
0ADA:  BCF    03.6
0ADB:  CALL   451
0ADC:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0ADD:  BTFSS  73.4
0ADE:  GOTO   37F
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0ADF:  BSF    03.5
0AE0:  BSF    06.2
0AE1:  BCF    03.5
0AE2:  BTFSC  06.2
0AE3:  GOTO   309
....................       { 
....................           
....................          NUM++; 
0AE4:  BSF    03.6
0AE5:  INCF   5F,F
....................          NUM = NUM % 4; 
0AE6:  MOVLW  03
0AE7:  ANDWF  5F,F
....................          LCD_GOTOXY (5 + NUM, 1); 
0AE8:  MOVLW  05
0AE9:  ADDWF  5F,W
0AEA:  MOVWF  60
0AEB:  MOVWF  64
0AEC:  MOVLW  01
0AED:  MOVWF  65
0AEE:  BCF    0A.3
0AEF:  BCF    03.6
0AF0:  CALL   403
0AF1:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    "); 
0AF2:  MOVLW  93
0AF3:  BSF    03.6
0AF4:  MOVWF  0D
0AF5:  MOVLW  00
0AF6:  MOVWF  0F
0AF7:  BCF    0A.3
0AF8:  BCF    03.6
0AF9:  CALL   451
0AFA:  BSF    0A.3
....................          DELAY_MS (300);  
0AFB:  MOVLW  02
0AFC:  BSF    03.6
0AFD:  MOVWF  60
0AFE:  MOVLW  96
0AFF:  MOVWF  64
0B00:  BCF    0A.3
0B01:  BCF    03.6
0B02:  CALL   12F
0B03:  BSF    0A.3
0B04:  BSF    03.6
0B05:  DECFSZ 60,F
0B06:  GOTO   2FE
....................       } 
0B07:  GOTO   37D
0B08:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0B09:  BSF    03.5
0B0A:  BSF    06.3
0B0B:  BCF    03.5
0B0C:  BTFSC  06.3
0B0D:  GOTO   37E
....................       { 
....................          ID_GATEWAY[NUM]++; 
0B0E:  MOVLW  48
0B0F:  BSF    03.6
0B10:  ADDWF  5F,W
0B11:  MOVWF  04
0B12:  BSF    03.7
0B13:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0B14:  MOVLW  48
0B15:  ADDWF  5F,W
0B16:  MOVWF  78
0B17:  MOVLW  01
0B18:  MOVWF  7A
0B19:  BTFSC  03.0
0B1A:  INCF   7A,F
0B1B:  MOVF   78,W
0B1C:  MOVWF  60
0B1D:  MOVF   7A,W
0B1E:  MOVWF  61
0B1F:  MOVLW  48
0B20:  ADDWF  5F,W
0B21:  MOVWF  04
0B22:  BSF    03.7
0B23:  MOVF   00,W
0B24:  MOVWF  63
0B25:  MOVLW  0A
0B26:  MOVWF  64
*
0B3B:  MOVF   77,W
0B3C:  MOVWF  62
0B3D:  MOVF   60,W
0B3E:  MOVWF  04
0B3F:  BCF    03.7
0B40:  BTFSC  61.0
0B41:  BSF    03.7
0B42:  MOVF   62,W
0B43:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR3); 
0B44:  MOVLW  48
0B45:  ADDWF  5F,W
0B46:  MOVWF  04
0B47:  BSF    03.7
0B48:  MOVF   00,W
0B49:  MOVWF  60
0B4A:  CLRF   64
0B4B:  CLRF   63
0B4C:  CLRF   62
0B4D:  MOVF   60,W
0B4E:  MOVWF  61
0B4F:  MOVLW  0A
0B50:  MOVWF  65
0B51:  MOVLW  01
0B52:  MOVWF  67
0B53:  MOVLW  54
0B54:  MOVWF  66
0B55:  BCF    0A.3
0B56:  BCF    03.6
0B57:  CALL   51F
0B58:  BSF    0A.3
....................          LCD_GOTOXY (9 + NUM, 2); 
0B59:  MOVLW  09
0B5A:  BSF    03.6
0B5B:  ADDWF  5F,W
0B5C:  MOVWF  60
0B5D:  MOVWF  64
0B5E:  MOVLW  02
0B5F:  MOVWF  65
0B60:  BCF    0A.3
0B61:  BCF    03.6
0B62:  CALL   403
0B63:  BSF    0A.3
....................          DELAY_MS (10); 
0B64:  MOVLW  0A
0B65:  BSF    03.6
0B66:  MOVWF  64
0B67:  BCF    0A.3
0B68:  BCF    03.6
0B69:  CALL   12F
0B6A:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR3); 
0B6B:  MOVLW  54
0B6C:  MOVWF  04
0B6D:  BSF    03.7
0B6E:  BCF    0A.3
0B6F:  CALL   663
0B70:  BSF    0A.3
....................          DELAY_MS (300); 
0B71:  MOVLW  02
0B72:  BSF    03.6
0B73:  MOVWF  60
0B74:  MOVLW  96
0B75:  MOVWF  64
0B76:  BCF    0A.3
0B77:  BCF    03.6
0B78:  CALL   12F
0B79:  BSF    0A.3
0B7A:  BSF    03.6
0B7B:  DECFSZ 60,F
0B7C:  GOTO   374
0B7D:  BCF    03.6
....................       } 
0B7E:  GOTO   2DD
....................    } 
....................  
....................    FOR (NUM = 0; NUM < 4; NUM++) 
0B7F:  BSF    03.6
0B80:  CLRF   5F
0B81:  MOVF   5F,W
0B82:  SUBLW  03
0B83:  BTFSS  03.0
0B84:  GOTO   3B0
....................    { 
....................       ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR3); 
0B85:  MOVLW  48
0B86:  ADDWF  5F,W
0B87:  MOVWF  04
0B88:  BSF    03.7
0B89:  MOVF   00,W
0B8A:  MOVWF  60
0B8B:  CLRF   64
0B8C:  CLRF   63
0B8D:  CLRF   62
0B8E:  MOVF   60,W
0B8F:  MOVWF  61
0B90:  MOVLW  0A
0B91:  MOVWF  65
0B92:  MOVLW  01
0B93:  MOVWF  67
0B94:  MOVLW  54
0B95:  MOVWF  66
0B96:  BCF    0A.3
0B97:  BCF    03.6
0B98:  CALL   51F
0B99:  BSF    0A.3
....................       DELAY_MS (1); 
0B9A:  MOVLW  01
0B9B:  BSF    03.6
0B9C:  MOVWF  64
0B9D:  BCF    0A.3
0B9E:  BCF    03.6
0B9F:  CALL   12F
0BA0:  BSF    0A.3
....................       STRCAT (ID_GW, TEMP_CHAR3); 
0BA1:  BSF    03.6
0BA2:  CLRF   62
0BA3:  MOVLW  EE
0BA4:  MOVWF  61
0BA5:  MOVLW  01
0BA6:  MOVWF  64
0BA7:  MOVLW  54
0BA8:  MOVWF  63
0BA9:  BCF    0A.3
0BAA:  BCF    03.6
0BAB:  CALL   6BB
0BAC:  BSF    0A.3
0BAD:  BSF    03.6
0BAE:  INCF   5F,F
0BAF:  GOTO   381
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0108:  BCF    73.2
....................    TT_FUN = 0; 
0109:  BCF    73.3
....................    TT_STT = 0; 
010A:  BCF    73.4
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    73.2
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   3B1
0805:  ADDLW  04
0806:  GOTO   3B4
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   3B1
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0978:  GOTO   3B1
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A83:  GOTO   3B1
....................  
....................       CASE 3: 
....................       NHAPID_GW (); 
....................       BREAK; 
*
0BB0:  BCF    03.6
....................    } 
0BB1:  BCF    0A.3
0BB2:  BCF    0A.4
0BB3:  GOTO   77C (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
06F9:  BSF    73.3
....................    LCD_GOTOXY (1, 1) ; 
06FA:  MOVLW  01
06FB:  BSF    03.6
06FC:  MOVWF  64
06FD:  MOVWF  65
06FE:  BCF    03.6
06FF:  CALL   403
....................    DELAY_MS (10); 
0700:  MOVLW  0A
0701:  BSF    03.6
0702:  MOVWF  64
0703:  BCF    03.6
0704:  CALL   12F
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0705:  MOVLW  98
0706:  BSF    03.6
0707:  MOVWF  0D
0708:  MOVLW  00
0709:  MOVWF  0F
070A:  BCF    03.6
070B:  CALL   451
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
070C:  MOVLW  01
070D:  BSF    03.6
070E:  MOVWF  64
070F:  MOVLW  02
0710:  MOVWF  65
0711:  BCF    03.6
0712:  CALL   403
....................    DELAY_MS (10); 
0713:  MOVLW  0A
0714:  BSF    03.6
0715:  MOVWF  64
0716:  BCF    03.6
0717:  CALL   12F
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0718:  MOVLW  A0
0719:  BSF    03.6
071A:  MOVWF  0D
071B:  MOVLW  00
071C:  MOVWF  0F
071D:  BCF    03.6
071E:  CALL   451
....................  
....................    WHILE (TT_FUN) 
071F:  BTFSS  73.3
0720:  GOTO   778
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0721:  BSF    03.5
0722:  BSF    06.2
0723:  BCF    03.5
0724:  BTFSC  06.2
0725:  GOTO   777
....................       { 
....................          CONFIG_FUN ++; 
0726:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0727:  MOVLW  03
0728:  ANDWF  38,F
....................          DELAY_MS (300); 
0729:  MOVLW  02
072A:  BSF    03.6
072B:  MOVWF  5F
072C:  MOVLW  96
072D:  MOVWF  64
072E:  BCF    03.6
072F:  CALL   12F
0730:  BSF    03.6
0731:  DECFSZ 5F,F
0732:  GOTO   72C
....................  
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0733:  MOVLW  06
0734:  MOVWF  64
0735:  MOVLW  02
0736:  MOVWF  65
0737:  BCF    03.6
0738:  CALL   403
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0739:  BSF    03.6
073A:  CLRF   64
073B:  CLRF   63
073C:  CLRF   62
073D:  BCF    03.6
073E:  MOVF   38,W
073F:  BSF    03.6
0740:  MOVWF  61
0741:  MOVLW  0A
0742:  MOVWF  65
0743:  MOVLW  01
0744:  MOVWF  67
0745:  MOVLW  4C
0746:  MOVWF  66
0747:  BCF    03.6
0748:  CALL   51F
....................          DELAY_MS (10); 
0749:  MOVLW  0A
074A:  BSF    03.6
074B:  MOVWF  64
074C:  BCF    03.6
074D:  CALL   12F
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
074E:  MOVLW  4C
074F:  MOVWF  04
0750:  BSF    03.7
0751:  CALL   663
....................  
....................          SWITCH (CONFIG_FUN) 
0752:  MOVF   38,W
0753:  ADDLW  FC
0754:  BTFSC  03.0
0755:  GOTO   777
0756:  ADDLW  04
0757:  GOTO   780
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID         "); 
0758:  MOVLW  A8
0759:  BSF    03.6
075A:  MOVWF  0D
075B:  MOVLW  00
075C:  MOVWF  0F
075D:  BCF    03.6
075E:  CALL   451
....................             BREAK; 
075F:  GOTO   777
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - DEVICES    "); 
0760:  MOVLW  B0
0761:  BSF    03.6
0762:  MOVWF  0D
0763:  MOVLW  00
0764:  MOVWF  0F
0765:  BCF    03.6
0766:  CALL   451
....................             BREAK; 
0767:  GOTO   777
....................              
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, " - SENSORS    "); 
0768:  MOVLW  B8
0769:  BSF    03.6
076A:  MOVWF  0D
076B:  MOVLW  00
076C:  MOVWF  0F
076D:  BCF    03.6
076E:  CALL   451
....................             BREAK; 
076F:  GOTO   777
....................              
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, " - ID - GW:    "); 
0770:  MOVLW  C0
0771:  BSF    03.6
0772:  MOVWF  0D
0773:  MOVLW  00
0774:  MOVWF  0F
0775:  BCF    03.6
0776:  CALL   451
....................             BREAK; 
....................          } 
....................       } 
0777:  GOTO   71F
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0778:  BTFSC  73.2
0779:  GOTO   77D
....................    { 
....................       SELLECT_FUN (); 
077A:  BSF    0A.3
077B:  GOTO   000
077C:  BCF    0A.3
....................    } 
077D:  BSF    0A.3
077E:  BCF    0A.4
077F:  GOTO   6FB (RETURN)
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    * TEMP_CHAR2 = '\0'; 
*
0C02:  MOVLW  01
0C03:  MOVWF  7A
0C04:  MOVLW  50
0C05:  MOVWF  04
0C06:  BCF    03.7
0C07:  BTFSC  7A.0
0C08:  BSF    03.7
0C09:  CLRF   00
....................    * TT_DEVICE_CHAR = '\0'; 
0C0A:  CLRF   7A
0C0B:  MOVLW  7B
0C0C:  MOVWF  04
0C0D:  BCF    03.7
0C0E:  BTFSC  7A.0
0C0F:  BSF    03.7
0C10:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
0C11:  BSF    03.6
0C12:  CLRF   60
0C13:  MOVF   60,W
0C14:  SUBLW  07
0C15:  BTFSS  03.0
0C16:  GOTO   448
....................    { 
....................       IF (TT_DEVICE[I]) 
0C17:  MOVF   60,W
0C18:  MOVWF  61
0C19:  CLRF   63
0C1A:  MOVLW  74
0C1B:  MOVWF  62
0C1C:  BCF    0A.3
0C1D:  BCF    03.6
0C1E:  CALL   680
0C1F:  BSF    0A.3
0C20:  BTFSS  78.0
0C21:  GOTO   445
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
0C22:  BSF    03.6
0C23:  CLRF   64
0C24:  CLRF   63
0C25:  CLRF   62
0C26:  MOVF   60,W
0C27:  MOVWF  61
0C28:  MOVLW  0A
0C29:  MOVWF  65
0C2A:  MOVLW  01
0C2B:  MOVWF  67
0C2C:  MOVLW  50
0C2D:  MOVWF  66
0C2E:  BCF    0A.3
0C2F:  BCF    03.6
0C30:  CALL   51F
0C31:  BSF    0A.3
....................          DELAY_MS (1); 
0C32:  MOVLW  01
0C33:  BSF    03.6
0C34:  MOVWF  64
0C35:  BCF    0A.3
0C36:  BCF    03.6
0C37:  CALL   12F
0C38:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0C39:  BSF    03.6
0C3A:  CLRF   62
0C3B:  MOVLW  7B
0C3C:  MOVWF  61
0C3D:  MOVLW  01
0C3E:  MOVWF  64
0C3F:  MOVLW  50
0C40:  MOVWF  63
0C41:  BCF    0A.3
0C42:  BCF    03.6
0C43:  CALL   6BB
0C44:  BSF    0A.3
....................       } 
0C45:  BSF    03.6
0C46:  INCF   60,F
0C47:  GOTO   413
....................    } 
....................  
....................    // PACKAGE_CONFIG[6] = TT_DEVICE_CHAR; 
.................... } 
....................  
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    * TEMP_CHAR2 = '\0'; 
0C48:  MOVLW  01
0C49:  MOVWF  7A
0C4A:  MOVLW  50
0C4B:  MOVWF  04
0C4C:  BCF    03.7
0C4D:  BTFSC  7A.0
0C4E:  BSF    03.7
0C4F:  CLRF   00
....................    * TEMP_CHAR3 = '\0'; 
0C50:  MOVLW  01
0C51:  MOVWF  7A
0C52:  MOVLW  54
0C53:  MOVWF  04
0C54:  BCF    03.7
0C55:  BTFSC  7A.0
0C56:  BSF    03.7
0C57:  CLRF   00
....................    FOR (INT J = 0; J < 5; J++) 
0C58:  CLRF   60
0C59:  MOVF   60,W
0C5A:  SUBLW  04
0C5B:  BTFSS  03.0
0C5C:  GOTO   48F
....................    { 
....................       IF (TT_SENSOR[J]) 
0C5D:  MOVF   60,W
0C5E:  MOVWF  61
0C5F:  CLRF   63
0C60:  MOVLW  75
0C61:  MOVWF  62
0C62:  BCF    0A.3
0C63:  BCF    03.6
0C64:  CALL   680
0C65:  BSF    0A.3
0C66:  BTFSS  78.0
0C67:  GOTO   48C
....................       { 
....................          ITOA (J, 10, TEMP_CHAR2); 
0C68:  BSF    03.6
0C69:  CLRF   64
0C6A:  CLRF   63
0C6B:  CLRF   62
0C6C:  MOVF   60,W
0C6D:  MOVWF  61
0C6E:  MOVLW  0A
0C6F:  MOVWF  65
0C70:  MOVLW  01
0C71:  MOVWF  67
0C72:  MOVLW  50
0C73:  MOVWF  66
0C74:  BCF    0A.3
0C75:  BCF    03.6
0C76:  CALL   51F
0C77:  BSF    0A.3
....................          DELAY_MS (1); 
0C78:  MOVLW  01
0C79:  BSF    03.6
0C7A:  MOVWF  64
0C7B:  BCF    0A.3
0C7C:  BCF    03.6
0C7D:  CALL   12F
0C7E:  BSF    0A.3
....................          STRCAT (TEMP_CHAR3, TEMP_CHAR2); 
0C7F:  MOVLW  01
0C80:  BSF    03.6
0C81:  MOVWF  62
0C82:  MOVLW  54
0C83:  MOVWF  61
0C84:  MOVLW  01
0C85:  MOVWF  64
0C86:  MOVLW  50
0C87:  MOVWF  63
0C88:  BCF    0A.3
0C89:  BCF    03.6
0C8A:  CALL   6BB
0C8B:  BSF    0A.3
....................       } 
0C8C:  BSF    03.6
0C8D:  INCF   60,F
0C8E:  GOTO   459
....................    } 
....................  
....................    //PACKAGE_CONFIG[7] = TEMP_CHAR3; 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0BBC:  BCF    73.3
....................    TT_STT = 0; 
0BBD:  BCF    73.4
.................... PACKAGE_CONFIG[1] = ID_GW; 
0BBE:  BSF    03.5
0BBF:  CLRF   5D
0BC0:  MOVLW  EE
0BC1:  MOVWF  5C
....................    DELAY_MS (2); 
0BC2:  MOVLW  02
0BC3:  BCF    03.5
0BC4:  BSF    03.6
0BC5:  MOVWF  64
0BC6:  BCF    0A.3
0BC7:  BCF    03.6
0BC8:  CALL   12F
0BC9:  BSF    0A.3
....................    PACKAGE_CONFIG[2] = ID_; 
0BCA:  BSF    03.5
0BCB:  CLRF   5F
0BCC:  MOVLW  EA
0BCD:  MOVWF  5E
....................    DELAY_MS (2); 
0BCE:  MOVLW  02
0BCF:  BCF    03.5
0BD0:  BSF    03.6
0BD1:  MOVWF  64
0BD2:  BCF    0A.3
0BD3:  BCF    03.6
0BD4:  CALL   12F
0BD5:  BSF    0A.3
....................    TT_DEVICE_CHAR = ""; 
0BD6:  BSF    03.6
0BD7:  CLRF   60
0BD8:  CLRF   61
0BD9:  MOVLW  7B
0BDA:  MOVWF  04
0BDB:  BCF    03.7
0BDC:  MOVF   60,W
0BDD:  ADDWF  04,F
0BDE:  MOVF   61,W
0BDF:  BCF    0A.3
0BE0:  BCF    03.6
0BE1:  CALL   064
0BE2:  BSF    0A.3
0BE3:  MOVWF  00
0BE4:  IORLW  00
0BE5:  BTFSC  03.2
0BE6:  GOTO   3EC
0BE7:  BSF    03.6
0BE8:  INCF   61,F
0BE9:  INCF   60,F
0BEA:  GOTO   3D9
0BEB:  BCF    03.6
....................    TT_SENSOR_CHAR = ""; 
0BEC:  BSF    03.6
0BED:  CLRF   60
0BEE:  CLRF   61
0BEF:  MOVLW  A0
0BF0:  MOVWF  04
0BF1:  BCF    03.7
0BF2:  MOVF   60,W
0BF3:  ADDWF  04,F
0BF4:  MOVF   61,W
0BF5:  BCF    0A.3
0BF6:  BCF    03.6
0BF7:  CALL   064
0BF8:  BSF    0A.3
0BF9:  MOVWF  00
0BFA:  IORLW  00
0BFB:  BTFSC  03.2
0BFC:  GOTO   402
0BFD:  BSF    03.6
0BFE:  INCF   61,F
0BFF:  INCF   60,F
0C00:  GOTO   3EF
0C01:  BCF    03.6
....................    XULYDEVICE_CF (); 
....................    XULYSENSOR_CF (); 
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
*
0C8F:  BSF    03.5
0C90:  BCF    03.6
0C91:  CLRF   65
0C92:  MOVLW  7B
0C93:  MOVWF  64
....................    DELAY_MS (2); 
0C94:  MOVLW  02
0C95:  BCF    03.5
0C96:  BSF    03.6
0C97:  MOVWF  64
0C98:  BCF    0A.3
0C99:  BCF    03.6
0C9A:  CALL   12F
0C9B:  BSF    0A.3
....................    PACKAGE_CONFIG[6] = TEMP_CHAR3; 
0C9C:  MOVLW  01
0C9D:  BSF    03.5
0C9E:  MOVWF  67
0C9F:  MOVLW  54
0CA0:  MOVWF  66
....................    //TINH DO DAI --> 
....................    LEN_PACKAGES = 0; 
0CA1:  CLRF   76
....................    PACKAGE_CONFIG[3] = "12"; //DO DAI CUA LENGHT C? ?? DAI = 2 
0CA2:  MOVLW  31
0CA3:  MOVWF  60
0CA4:  MOVLW  32
0CA5:  MOVWF  61
....................    FOR (INT J = 0; J < 9; J++) 
0CA6:  BCF    03.5
0CA7:  BSF    03.6
0CA8:  CLRF   5F
0CA9:  MOVF   5F,W
0CAA:  SUBLW  08
0CAB:  BTFSS  03.0
0CAC:  GOTO   4DD
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
0CAD:  BCF    03.0
0CAE:  RLF    5F,W
0CAF:  ADDLW  DA
0CB0:  MOVWF  04
0CB1:  BCF    03.7
0CB2:  INCF   04,F
0CB3:  MOVF   00,W
0CB4:  MOVWF  61
0CB5:  DECF   04,F
0CB6:  MOVF   00,W
0CB7:  MOVWF  60
0CB8:  MOVF   61,W
0CB9:  MOVWF  63
0CBA:  MOVF   60,W
0CBB:  MOVWF  62
*
0CD9:  MOVF   78,W
0CDA:  ADDWF  76,F
0CDB:  INCF   5F,F
0CDC:  GOTO   4A9
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+6; //7 @ 
0CDD:  MOVLW  06
0CDE:  ADDWF  76,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0CDF:  CLRF   64
0CE0:  CLRF   63
0CE1:  CLRF   62
0CE2:  MOVF   76,W
0CE3:  MOVWF  61
0CE4:  MOVLW  0A
0CE5:  MOVWF  65
0CE6:  MOVLW  01
0CE7:  MOVWF  67
0CE8:  MOVLW  4C
0CE9:  MOVWF  66
0CEA:  BCF    0A.3
0CEB:  BCF    03.6
0CEC:  CALL   51F
0CED:  BSF    0A.3
....................    PACKAGE_CONFIG[3] = TEMP_CHAR; 
0CEE:  MOVLW  01
0CEF:  BSF    03.5
0CF0:  MOVWF  61
0CF1:  MOVLW  4C
0CF2:  MOVWF  60
....................     
....................    FOR ( J = 0; J < 8; J++) 
0CF3:  BCF    03.5
0CF4:  BSF    03.6
0CF5:  CLRF   5F
0CF6:  MOVF   5F,W
0CF7:  SUBLW  07
0CF8:  BTFSS  03.0
0CF9:  GOTO   514
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0CFA:  BCF    03.0
0CFB:  RLF    5F,W
0CFC:  ADDLW  DA
0CFD:  MOVWF  04
0CFE:  BCF    03.7
0CFF:  INCF   04,F
0D00:  MOVF   00,W
0D01:  MOVWF  61
0D02:  DECF   04,F
0D03:  MOVF   00,W
0D04:  MOVWF  60
0D05:  MOVWF  04
0D06:  BCF    03.7
0D07:  BTFSC  61.0
0D08:  BSF    03.7
0D09:  BCF    0A.3
0D0A:  BCF    03.6
0D0B:  CALL   788
0D0C:  BSF    0A.3
....................       PRINTF ("@"); 
0D0D:  MOVLW  40
0D0E:  BTFSS  0C.4
0D0F:  GOTO   50E
0D10:  MOVWF  19
0D11:  BSF    03.6
0D12:  INCF   5F,F
0D13:  GOTO   4F6
....................    } 
....................  
....................    /* 
....................    LCD_GOTOXY (1, 1) ; 
....................    DELAY_MS (10); 
....................    FOR (J = 0; J < 9; J++) 
....................    { 
....................       PRINTF (LCD_PUTC, PACKAGE_CONFIG[J]); 
....................    } 
....................    */ 
....................  
....................    LCD_GOTOXY (1, 1) ; 
0D14:  MOVLW  01
0D15:  MOVWF  64
0D16:  MOVWF  65
0D17:  BCF    0A.3
0D18:  BCF    03.6
0D19:  CALL   403
0D1A:  BSF    0A.3
....................    DELAY_MS (10); 
0D1B:  MOVLW  0A
0D1C:  BSF    03.6
0D1D:  MOVWF  64
0D1E:  BCF    0A.3
0D1F:  BCF    03.6
0D20:  CALL   12F
0D21:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0D22:  MOVLW  C8
0D23:  BSF    03.6
0D24:  MOVWF  0D
0D25:  MOVLW  00
0D26:  MOVWF  0F
0D27:  BCF    0A.3
0D28:  BCF    03.6
0D29:  CALL   451
0D2A:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0D2B:  MOVLW  01
0D2C:  BSF    03.6
0D2D:  MOVWF  64
0D2E:  MOVLW  02
0D2F:  MOVWF  65
0D30:  BCF    0A.3
0D31:  BCF    03.6
0D32:  CALL   403
0D33:  BSF    0A.3
....................    DELAY_MS (10); 
0D34:  MOVLW  0A
0D35:  BSF    03.6
0D36:  MOVWF  64
0D37:  BCF    0A.3
0D38:  BCF    03.6
0D39:  CALL   12F
0D3A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0D3B:  MOVLW  D2
0D3C:  BSF    03.6
0D3D:  MOVWF  0D
0D3E:  MOVLW  00
0D3F:  MOVWF  0F
0D40:  BCF    0A.3
0D41:  BCF    03.6
0D42:  CALL   451
0D43:  BSF    0A.3
....................    PACKAGE_NHIETDO[1] = ID_; 
0D44:  BSF    03.5
0D45:  CLRF   27
0D46:  MOVLW  EA
0D47:  MOVWF  26
....................    TT_CONFIG_DONE = 0; 
0D48:  BCF    73.2
0D49:  BCF    03.5
0D4A:  BSF    0A.3
0D4B:  BCF    0A.4
0D4C:  GOTO   700 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00DC:  BSF    03.5
00DD:  BSF    03.6
00DE:  CLRF   26
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00DF:  BCF    03.6
00E0:  BSF    06.1
00E1:  BCF    03.5
00E2:  BTFSC  06.1
00E3:  GOTO   0FB
....................    { 
....................       IF (TMR1IF) 
00E4:  BTFSS  0C.0
00E5:  GOTO   0F6
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00E6:  BSF    03.5
00E7:  BCF    08.2
00E8:  MOVLW  04
00E9:  BCF    03.5
00EA:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00EB:  BCF    0C.0
00EC:  CLRF   0E
00ED:  MOVLW  0B
00EE:  MOVWF  0F
00EF:  MOVLW  DC
00F0:  MOVWF  0E
00F1:  BSF    03.5
00F2:  BSF    03.6
00F3:  INCF   26,F
00F4:  BCF    03.5
00F5:  BCF    03.6
....................       } 
00F6:  BSF    03.5
00F7:  BSF    03.6
00F8:  GOTO   0DF
00F9:  BCF    03.5
00FA:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00FB:  BSF    03.5
00FC:  BSF    03.6
00FD:  MOVF   26,W
00FE:  SUBLW  14
00FF:  BTFSC  03.0
0100:  GOTO   108
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0101:  MOVLW  01
0102:  XORWF  73,F
....................       TT_CONTROL = ~TT_CONTROL; 
0103:  MOVLW  02
0104:  XORWF  73,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0105:  BSF    73.2
....................       TT_FUN = 0; 
0106:  BCF    73.3
....................    } 
0107:  GOTO   10B
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
010B:  BCF    03.5
010C:  BCF    03.6
010D:  BCF    0B.1
010E:  BCF    0A.3
010F:  BCF    0A.4
0110:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0111:  MOVLW  5F
0112:  ADDWF  5A,W
0113:  MOVWF  04
0114:  BCF    03.7
0115:  BTFSS  0C.5
0116:  GOTO   115
0117:  MOVF   1A,W
0118:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0119:  MOVLW  5F
011A:  ADDWF  5A,W
011B:  MOVWF  04
011C:  BCF    03.7
011D:  MOVF   00,W
011E:  SUBLW  2E
011F:  BTFSS  03.2
0120:  GOTO   12A
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0121:  MOVLW  5F
0122:  ADDWF  5A,W
0123:  MOVWF  04
0124:  BCF    03.7
0125:  CLRF   00
....................        VT = 0; 
0126:  CLRF   5A
....................        TTNHAN = 1; 
0127:  MOVLW  01
0128:  MOVWF  5B
....................     } 
0129:  GOTO   12B
....................  
....................     ELSE 
....................     VT++; 
012A:  INCF   5A,F
012B:  BCF    0C.5
012C:  BCF    0A.3
012D:  BCF    0A.4
012E:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07BE:  MOVLW  01
07BF:  BSF    03.6
07C0:  MOVWF  64
07C1:  MOVWF  65
07C2:  BCF    03.6
07C3:  CALL   403
....................     DELAY_MS (10); 
07C4:  MOVLW  0A
07C5:  BSF    03.6
07C6:  MOVWF  64
07C7:  BCF    03.6
07C8:  CALL   12F
....................     PRINTF (LCD_PUTC, KYTUCHAR); 
07C9:  MOVLW  5F
07CA:  MOVWF  04
07CB:  BCF    03.7
07CC:  CALL   663
....................     DELAY_MS (1); 
07CD:  MOVLW  01
07CE:  BSF    03.6
07CF:  MOVWF  64
07D0:  BCF    03.6
07D1:  CALL   12F
07D2:  BSF    0A.3
07D3:  BCF    0A.4
07D4:  GOTO   781 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
02AF:  BSF    03.6
02B0:  RLF    5F,W
02B1:  MOVWF  77
02B2:  RLF    77,F
02B3:  MOVLW  FC
02B4:  ANDWF  77,F
02B5:  BCF    03.6
02B6:  MOVF   1F,W
02B7:  ANDLW  C3
02B8:  IORWF  77,W
02B9:  MOVWF  1F
....................     KQADC = 0; 
02BA:  CLRF   33
02BB:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
02BC:  BSF    03.6
02BD:  CLRF   60
02BE:  MOVF   60,W
02BF:  SUBLW  63
02C0:  BTFSS  03.0
02C1:  GOTO   2D6
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
02C2:  BCF    03.6
02C3:  BSF    1F.1
02C4:  BTFSC  1F.1
02C5:  GOTO   2C4
02C6:  BSF    03.5
02C7:  MOVF   1E,W
02C8:  BCF    03.5
02C9:  ADDWF  32,F
02CA:  MOVF   1E,W
02CB:  BTFSC  03.0
02CC:  INCFSZ 1E,W
02CD:  ADDWF  33,F
....................        DELAY_MS (1); 
02CE:  MOVLW  01
02CF:  BSF    03.6
02D0:  MOVWF  64
02D1:  BCF    03.6
02D2:  CALL   12F
02D3:  BSF    03.6
02D4:  INCF   60,F
02D5:  GOTO   2BE
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
02D6:  BCF    03.6
02D7:  MOVF   33,W
02D8:  BSF    03.6
02D9:  MOVWF  62
02DA:  BCF    03.6
02DB:  MOVF   32,W
02DC:  BSF    03.6
02DD:  MOVWF  61
*
02FA:  MOVF   7A,W
02FB:  MOVWF  64
02FC:  MOVF   79,W
02FD:  MOVWF  63
02FE:  MOVF   78,W
02FF:  MOVWF  62
0300:  MOVF   77,W
0301:  MOVWF  61
0302:  MOVLW  9A
0303:  MOVWF  68
0304:  MOVLW  99
0305:  MOVWF  67
0306:  MOVLW  4C
0307:  MOVWF  66
0308:  MOVLW  86
0309:  MOVWF  65
*
03D3:  MOVF   7A,W
03D4:  MOVWF  64
03D5:  MOVF   79,W
03D6:  MOVWF  63
03D7:  MOVF   78,W
03D8:  MOVWF  62
03D9:  MOVF   77,W
03DA:  MOVWF  61
*
03F9:  MOVF   79,W
03FA:  BCF    03.6
03FB:  MOVWF  33
03FC:  MOVF   78,W
03FD:  MOVWF  32
....................     RETURN KQADC; 
03FE:  MOVF   32,W
03FF:  MOVWF  78
0400:  BSF    0A.3
0401:  BCF    0A.4
0402:  GOTO   6F3 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07A6:  BSF    03.6
07A7:  CLRF   5F
07A8:  MOVF   5F,W
07A9:  SUBLW  1E
07AA:  BTFSS  03.0
07AB:  GOTO   7BA
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07AC:  BSF    03.5
07AD:  BCF    03.6
07AE:  BCF    08.1
07AF:  MOVLW  02
07B0:  BCF    03.5
07B1:  XORWF  08,F
....................        DELAY_MS (100); 
07B2:  MOVLW  64
07B3:  BSF    03.6
07B4:  MOVWF  64
07B5:  BCF    03.6
07B6:  CALL   12F
07B7:  BSF    03.6
07B8:  INCF   5F,F
07B9:  GOTO   7A8
....................     } 
07BA:  BCF    03.6
07BB:  BSF    0A.3
07BC:  BCF    0A.4
07BD:  GOTO   705 (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
0D4D:  MOVF   03,W
0D4E:  ANDLW  1F
0D4F:  MOVWF  03
0D50:  BSF    03.5
0D51:  BSF    03.6
0D52:  BSF    07.3
0D53:  MOVLW  08
0D54:  BCF    03.6
0D55:  MOVWF  19
0D56:  MOVLW  02
0D57:  MOVWF  1A
0D58:  MOVLW  A6
0D59:  MOVWF  18
0D5A:  MOVLW  90
0D5B:  BCF    03.5
0D5C:  MOVWF  18
0D5D:  MOVLW  FF
0D5E:  MOVWF  31
0D5F:  CLRF   38
0D60:  CLRF   39
0D61:  CLRF   3A
0D62:  CLRF   3B
0D63:  CLRF   5A
0D64:  CLRF   5B
0D65:  BCF    73.0
0D66:  BCF    73.1
0D67:  BCF    73.2
0D68:  BCF    73.3
0D69:  BCF    73.4
0D6A:  CLRF   76
0D6B:  BSF    03.5
0D6C:  BSF    03.6
0D6D:  MOVF   09,W
0D6E:  ANDLW  C0
0D6F:  MOVWF  09
0D70:  BCF    03.6
0D71:  BCF    1F.4
0D72:  BCF    1F.5
0D73:  MOVLW  00
0D74:  BSF    03.6
0D75:  MOVWF  08
0D76:  BCF    03.5
0D77:  CLRF   07
0D78:  CLRF   08
0D79:  CLRF   09
0D7A:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0EB0:  MOVLW  00
0EB1:  BSF    03.5
0EB2:  BCF    03.6
0EB3:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0EB4:  MOVLW  FF
0EB5:  MOVWF  06
....................     SET_TRIS_E (0); 
0EB6:  BCF    09.0
0EB7:  BCF    09.1
0EB8:  BCF    09.2
0EB9:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0EBA:  MOVLW  80
0EBB:  MOVWF  07
0EBC:  BCF    03.5
0EBD:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0EBE:  BSF    1F.6
0EBF:  BCF    1F.7
0EC0:  BSF    03.5
0EC1:  BSF    1F.7
0EC2:  BCF    03.5
0EC3:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0EC4:  BSF    03.5
0EC5:  BSF    03.6
0EC6:  MOVF   09,W
0EC7:  ANDLW  C0
0EC8:  MOVWF  09
0EC9:  BCF    03.6
0ECA:  BCF    1F.4
0ECB:  BCF    1F.5
0ECC:  MOVLW  01
0ECD:  BSF    03.6
0ECE:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0ECF:  BCF    03.5
0ED0:  BCF    03.6
0ED1:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0ED2:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0ED3:  BSF    0B.4
0ED4:  BSF    03.5
0ED5:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0ED6:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0ED7:  MOVLW  C0
0ED8:  BCF    03.5
0ED9:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0EDA:  MOVLW  35
0EDB:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0EDC:  CLRF   0E
0EDD:  MOVLW  0B
0EDE:  MOVWF  0F
0EDF:  MOVLW  DC
0EE0:  MOVWF  0E
....................     TMR1IF = 0; 
0EE1:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0EE2:  BCF    0A.3
0EE3:  GOTO   249
0EE4:  BSF    0A.3
....................     ID_NODE = 0; 
0EE5:  CLRF   39
....................     TT_CONFIG = 0; 
0EE6:  BCF    73.0
....................     TT_CONFIG_DONE = 0; 
0EE7:  BCF    73.2
....................     TT_CONTROL=1; 
0EE8:  BSF    73.1
....................     OUTPUT_D (0X00); 
0EE9:  BSF    03.5
0EEA:  CLRF   08
0EEB:  BCF    03.5
0EEC:  CLRF   08
....................     TTNHAN = 0; 
0EED:  CLRF   5B
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0EEE:  BSF    03.6
0EEF:  CLRF   5F
0EF0:  BCF    0A.3
0EF1:  BCF    03.6
0EF2:  GOTO   2AF
0EF3:  BSF    0A.3
0EF4:  CLRF   35
0EF5:  MOVF   78,W
0EF6:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0EF7:  BTFSS  73.0
0EF8:  GOTO   6FD
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0EF9:  BCF    0A.3
0EFA:  GOTO   6F9
0EFB:  BSF    0A.3
....................        } 
0EFC:  GOTO   7A4
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0EFD:  BTFSS  73.2
0EFE:  GOTO   701
....................        { 
....................           CONFIG_DONE (); 
0EFF:  GOTO   3BC
....................        } 
0F00:  GOTO   7A4
....................  
....................         
....................        ELSE 
....................        { 
....................  
....................           WHILE (!TT_CONFIG) 
0F01:  BTFSC  73.0
0F02:  GOTO   7A4
....................           { 
....................              CHUONG_TRINH_CON (); 
0F03:  BCF    0A.3
0F04:  GOTO   7A6
0F05:  BSF    0A.3
....................  
....................              IF (AN0 > 26) 
0F06:  MOVF   35,F
0F07:  BTFSS  03.2
0F08:  GOTO   70D
0F09:  MOVF   34,W
0F0A:  SUBLW  1A
0F0B:  BTFSC  03.0
0F0C:  GOTO   772
....................              { 
....................                 ITOA (AN0, 10, NHIETDO1); 
0F0D:  BSF    03.6
0F0E:  CLRF   64
0F0F:  CLRF   63
0F10:  BCF    03.6
0F11:  MOVF   35,W
0F12:  BSF    03.6
0F13:  MOVWF  62
0F14:  BCF    03.6
0F15:  MOVF   34,W
0F16:  BSF    03.6
0F17:  MOVWF  61
0F18:  MOVLW  0A
0F19:  MOVWF  65
0F1A:  MOVLW  01
0F1B:  MOVWF  67
0F1C:  MOVLW  58
0F1D:  MOVWF  66
0F1E:  BCF    0A.3
0F1F:  BCF    03.6
0F20:  CALL   51F
0F21:  BSF    0A.3
....................                 PACKAGE_NHIETDO[4] = NHIETDO1; 
0F22:  MOVLW  01
0F23:  BSF    03.5
0F24:  MOVWF  2D
0F25:  MOVLW  58
0F26:  MOVWF  2C
....................                 ITOA (AN1, 10, NHIETDO2); 
0F27:  BCF    03.5
0F28:  BSF    03.6
0F29:  CLRF   64
0F2A:  CLRF   63
0F2B:  BCF    03.6
0F2C:  MOVF   37,W
0F2D:  BSF    03.6
0F2E:  MOVWF  62
0F2F:  BCF    03.6
0F30:  MOVF   36,W
0F31:  BSF    03.6
0F32:  MOVWF  61
0F33:  MOVLW  0A
0F34:  MOVWF  65
0F35:  MOVLW  01
0F36:  MOVWF  67
0F37:  MOVLW  5B
0F38:  MOVWF  66
0F39:  BCF    0A.3
0F3A:  BCF    03.6
0F3B:  CALL   51F
0F3C:  BSF    0A.3
....................                 PACKAGE_NHIETDO[5] = NHIETDO2; 
0F3D:  MOVLW  01
0F3E:  BSF    03.5
0F3F:  MOVWF  2F
0F40:  MOVLW  5B
0F41:  MOVWF  2E
....................                  
....................                 FOR (INT I = 0; I < 8; I++) 
0F42:  BCF    03.5
0F43:  BSF    03.6
0F44:  CLRF   5E
0F45:  MOVF   5E,W
0F46:  SUBLW  07
0F47:  BTFSS  03.0
0F48:  GOTO   766
....................                 { 
....................                    PRINTF (PACKAGE_NHIETDO[I]); 
0F49:  BCF    03.0
0F4A:  RLF    5E,W
0F4B:  ADDLW  A4
0F4C:  MOVWF  04
0F4D:  BCF    03.7
0F4E:  INCF   04,F
0F4F:  MOVF   00,W
0F50:  MOVWF  60
0F51:  DECF   04,F
0F52:  MOVF   00,W
0F53:  MOVWF  5F
0F54:  MOVWF  04
0F55:  BCF    03.7
0F56:  BTFSC  60.0
0F57:  BSF    03.7
0F58:  BCF    0A.3
0F59:  BCF    03.6
0F5A:  CALL   788
0F5B:  BSF    0A.3
....................                    DELAY_MS (1); 
0F5C:  MOVLW  01
0F5D:  BSF    03.6
0F5E:  MOVWF  64
0F5F:  BCF    0A.3
0F60:  BCF    03.6
0F61:  CALL   12F
0F62:  BSF    0A.3
0F63:  BSF    03.6
0F64:  INCF   5E,F
0F65:  GOTO   745
....................                 } 
....................  
....................                  
....................                 DELAY_MS (1000); 
0F66:  MOVLW  04
0F67:  MOVWF  5F
0F68:  MOVLW  FA
0F69:  MOVWF  64
0F6A:  BCF    0A.3
0F6B:  BCF    03.6
0F6C:  CALL   12F
0F6D:  BSF    0A.3
0F6E:  BSF    03.6
0F6F:  DECFSZ 5F,F
0F70:  GOTO   768
0F71:  BCF    03.6
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
0F72:  DECFSZ 5B,W
0F73:  GOTO   7A3
....................              { 
....................                 TTNHAN = 0; 
0F74:  CLRF   5B
....................                 //TEMP_CHAR = 'K'; 
....................                 ID_NODE_NHAN = KYTU[1] - 48; 
0F75:  MOVLW  30
0F76:  SUBWF  3D,W
0F77:  MOVWF  5C
....................                 ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
0F78:  MOVLW  30
0F79:  SUBWF  3E,W
0F7A:  ADDLW  40
0F7B:  MOVWF  5D
....................                 TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
0F7C:  MOVLW  30
0F7D:  SUBWF  3F,W
0F7E:  MOVWF  5E
....................                 XUATLCD (); 
0F7F:  BCF    0A.3
0F80:  GOTO   7BE
0F81:  BSF    0A.3
....................                  
....................                 IF (ID_NODE_NHAN == ID_NODE) 
0F82:  MOVF   39,W
0F83:  SUBWF  5C,W
0F84:  BTFSS  03.2
0F85:  GOTO   7A3
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0F86:  MOVF   5E,F
0F87:  BTFSS  03.2
0F88:  GOTO   78B
0F89:  MOVLW  00
0F8A:  GOTO   78C
0F8B:  MOVLW  01
0F8C:  MOVWF  77
0F8D:  MOVF   5D,W
0F8E:  BSF    03.6
0F8F:  MOVWF  60
0F90:  MOVF   77,W
0F91:  MOVWF  61
0F92:  CLRF   63
0F93:  CLRF   62
0F94:  BCF    0A.3
0F95:  BCF    03.6
0F96:  CALL   699
0F97:  BSF    0A.3
0F98:  MOVF   5D,W
0F99:  BSF    03.6
0F9A:  MOVWF  60
0F9B:  CLRF   61
0F9C:  CLRF   63
0F9D:  MOVLW  80
0F9E:  MOVWF  62
0F9F:  BCF    0A.3
0FA0:  BCF    03.6
0FA1:  CALL   699
0FA2:  BSF    0A.3
....................                 } 
....................              } 
0FA3:  GOTO   701
....................           } 
....................        } 
0FA4:  GOTO   6EE
....................     } 
....................  } 
....................  
0FA5:  SLEEP
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
