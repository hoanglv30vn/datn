CCS PCM C Compiler, Version 5.015, 5967               24-Oct-21 00:03

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3581 words (44%)
                           Largest free fragment is 2048
               RAM used:   220 (60%) at main() level
                           265 (72%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   427
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0BC
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0F3
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  31
005D:  RETLW  32
005E:  RETLW  33
005F:  RETLW  34
0060:  RETLW  00
0061:  BCF    0A.0
0062:  BCF    0A.1
0063:  BCF    0A.2
0064:  ADDWF  02,F
0065:  RETLW  00
0066:  DATA 49,22
0067:  DATA 3A,10
0068:  DATA 20,10
0069:  DATA 20,10
006A:  DATA 20,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 00,00
006F:  DATA C4,22
0070:  DATA D6,24
0071:  DATA C3,22
0072:  DATA 3A,10
0073:  DATA 20,10
0074:  DATA 20,10
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 00,01
0078:  DATA D3,22
0079:  DATA CE,29
007A:  DATA 4F,29
007B:  DATA 3A,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 20,10
007F:  DATA 20,10
0080:  DATA 00,01
0081:  DATA 49,22
0082:  DATA DF,23
0083:  DATA 57,1D
0084:  DATA 20,10
0085:  DATA 31,19
0086:  DATA 33,1A
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 00,01
008A:  DATA C3,27
008B:  DATA 4E,23
008C:  DATA C9,23
008D:  DATA 3A,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 00,01
0093:  DATA C3,20
0094:  DATA D3,22
0095:  DATA 3A,10
0096:  DATA 20,10
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 00,01
009C:  DATA 2D,10
009D:  DATA 49,22
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,00
00A1:  DATA 2D,10
00A2:  DATA C4,22
00A3:  DATA D6,24
00A4:  DATA C3,22
00A5:  DATA 53,00
00A6:  DATA 2D,10
00A7:  DATA D3,22
00A8:  DATA CE,29
00A9:  DATA 4F,29
00AA:  DATA 53,00
00AB:  DATA 2D,10
00AC:  DATA D2,22
00AD:  DATA D3,22
00AE:  DATA 54,10
00AF:  DATA 20,00
00B0:  DATA C3,27
00B1:  DATA 4E,23
00B2:  DATA C9,23
00B3:  DATA 20,22
00B4:  DATA 4F,27
00B5:  DATA 45,00
00B6:  DATA C3,27
00B7:  DATA 4E,23
00B8:  DATA C9,23
00B9:  DATA 20,22
00BA:  DATA 4F,27
00BB:  DATA 45,00
*
02C0:  MOVLW  8E
02C1:  MOVWF  77
02C2:  MOVF   4D,W
02C3:  MOVWF  78
02C4:  MOVF   4C,W
02C5:  MOVWF  79
02C6:  CLRF   7A
02C7:  MOVF   78,F
02C8:  BTFSS  03.2
02C9:  GOTO   2D4
02CA:  MOVF   79,W
02CB:  MOVWF  78
02CC:  CLRF   79
02CD:  MOVLW  08
02CE:  SUBWF  77,F
02CF:  MOVF   78,F
02D0:  BTFSS  03.2
02D1:  GOTO   2D4
02D2:  CLRF   77
02D3:  GOTO   2DC
02D4:  BCF    03.0
02D5:  BTFSC  78.7
02D6:  GOTO   2DB
02D7:  RLF    79,F
02D8:  RLF    78,F
02D9:  DECF   77,F
02DA:  GOTO   2D4
02DB:  BCF    78.7
*
02EC:  MOVF   4C,W
02ED:  BTFSC  03.2
02EE:  GOTO   3B1
02EF:  MOVWF  58
02F0:  MOVF   50,W
02F1:  BTFSC  03.2
02F2:  GOTO   3B1
02F3:  SUBWF  58,F
02F4:  BTFSS  03.0
02F5:  GOTO   2FB
02F6:  MOVLW  7F
02F7:  ADDWF  58,F
02F8:  BTFSC  03.0
02F9:  GOTO   3B1
02FA:  GOTO   301
02FB:  MOVLW  81
02FC:  SUBWF  58,F
02FD:  BTFSS  03.0
02FE:  GOTO   3B1
02FF:  BTFSC  03.2
0300:  GOTO   3B1
0301:  MOVF   58,W
0302:  MOVWF  77
0303:  CLRF   78
0304:  CLRF   79
0305:  CLRF   7A
0306:  CLRF   57
0307:  MOVF   4D,W
0308:  MOVWF  56
0309:  BSF    56.7
030A:  MOVF   4E,W
030B:  MOVWF  55
030C:  MOVF   4F,W
030D:  MOVWF  54
030E:  MOVLW  19
030F:  MOVWF  58
0310:  MOVF   53,W
0311:  SUBWF  54,F
0312:  BTFSC  03.0
0313:  GOTO   324
0314:  MOVLW  01
0315:  SUBWF  55,F
0316:  BTFSC  03.0
0317:  GOTO   324
0318:  SUBWF  56,F
0319:  BTFSC  03.0
031A:  GOTO   324
031B:  SUBWF  57,F
031C:  BTFSC  03.0
031D:  GOTO   324
031E:  INCF   57,F
031F:  INCF   56,F
0320:  INCF   55,F
0321:  MOVF   53,W
0322:  ADDWF  54,F
0323:  GOTO   356
0324:  MOVF   52,W
0325:  SUBWF  55,F
0326:  BTFSC  03.0
0327:  GOTO   33F
0328:  MOVLW  01
0329:  SUBWF  56,F
032A:  BTFSC  03.0
032B:  GOTO   33F
032C:  SUBWF  57,F
032D:  BTFSC  03.0
032E:  GOTO   33F
032F:  INCF   57,F
0330:  INCF   56,F
0331:  MOVF   52,W
0332:  ADDWF  55,F
0333:  MOVF   53,W
0334:  ADDWF  54,F
0335:  BTFSS  03.0
0336:  GOTO   356
0337:  INCF   55,F
0338:  BTFSS  03.2
0339:  GOTO   356
033A:  INCF   56,F
033B:  BTFSS  03.2
033C:  GOTO   356
033D:  INCF   57,F
033E:  GOTO   356
033F:  MOVF   51,W
0340:  IORLW  80
0341:  SUBWF  56,F
0342:  BTFSC  03.0
0343:  GOTO   355
0344:  MOVLW  01
0345:  SUBWF  57,F
0346:  BTFSC  03.0
0347:  GOTO   355
0348:  INCF   57,F
0349:  MOVF   51,W
034A:  IORLW  80
034B:  ADDWF  56,F
034C:  MOVF   52,W
034D:  ADDWF  55,F
034E:  BTFSS  03.0
034F:  GOTO   333
0350:  INCF   56,F
0351:  BTFSS  03.2
0352:  GOTO   333
0353:  INCF   57,F
0354:  GOTO   333
0355:  BSF    7A.0
0356:  DECFSZ 58,F
0357:  GOTO   359
0358:  GOTO   364
0359:  BCF    03.0
035A:  RLF    54,F
035B:  RLF    55,F
035C:  RLF    56,F
035D:  RLF    57,F
035E:  BCF    03.0
035F:  RLF    7A,F
0360:  RLF    79,F
0361:  RLF    78,F
0362:  RLF    59,F
0363:  GOTO   310
0364:  BTFSS  59.0
0365:  GOTO   36C
0366:  BCF    03.0
0367:  RRF    78,F
0368:  RRF    79,F
0369:  RRF    7A,F
036A:  RRF    59,F
036B:  GOTO   36F
036C:  DECF   77,F
036D:  BTFSC  03.2
036E:  GOTO   3B1
036F:  BTFSC  59.7
0370:  GOTO   398
0371:  BCF    03.0
0372:  RLF    54,F
0373:  RLF    55,F
0374:  RLF    56,F
0375:  RLF    57,F
0376:  MOVF   53,W
0377:  SUBWF  54,F
0378:  BTFSC  03.0
0379:  GOTO   384
037A:  MOVLW  01
037B:  SUBWF  55,F
037C:  BTFSC  03.0
037D:  GOTO   384
037E:  SUBWF  56,F
037F:  BTFSC  03.0
0380:  GOTO   384
0381:  SUBWF  57,F
0382:  BTFSS  03.0
0383:  GOTO   3A7
0384:  MOVF   52,W
0385:  SUBWF  55,F
0386:  BTFSC  03.0
0387:  GOTO   38F
0388:  MOVLW  01
0389:  SUBWF  56,F
038A:  BTFSC  03.0
038B:  GOTO   38F
038C:  SUBWF  57,F
038D:  BTFSS  03.0
038E:  GOTO   3A7
038F:  MOVF   51,W
0390:  IORLW  80
0391:  SUBWF  56,F
0392:  BTFSC  03.0
0393:  GOTO   398
0394:  MOVLW  01
0395:  SUBWF  57,F
0396:  BTFSS  03.0
0397:  GOTO   3A7
0398:  INCF   7A,F
0399:  BTFSS  03.2
039A:  GOTO   3A7
039B:  INCF   79,F
039C:  BTFSS  03.2
039D:  GOTO   3A7
039E:  INCF   78,F
039F:  BTFSS  03.2
03A0:  GOTO   3A7
03A1:  INCF   77,F
03A2:  BTFSC  03.2
03A3:  GOTO   3B1
03A4:  RRF    78,F
03A5:  RRF    79,F
03A6:  RRF    7A,F
03A7:  MOVF   4D,W
03A8:  MOVWF  58
03A9:  MOVF   51,W
03AA:  XORWF  58,F
03AB:  BTFSS  58.7
03AC:  GOTO   3AF
03AD:  BSF    78.7
03AE:  GOTO   3B5
03AF:  BCF    78.7
03B0:  GOTO   3B5
03B1:  CLRF   77
03B2:  CLRF   78
03B3:  CLRF   79
03B4:  CLRF   7A
*
03BD:  MOVLW  8E
03BE:  MOVWF  77
03BF:  MOVF   4C,W
03C0:  SUBWF  77,F
03C1:  MOVF   4D,W
03C2:  MOVWF  79
03C3:  MOVF   4E,W
03C4:  MOVWF  78
03C5:  BSF    79.7
03C6:  MOVF   77,F
03C7:  BTFSC  03.2
03C8:  GOTO   3D4
03C9:  BCF    03.0
03CA:  MOVF   79,F
03CB:  BTFSS  03.2
03CC:  GOTO   3D0
03CD:  MOVF   78,F
03CE:  BTFSC  03.2
03CF:  GOTO   3D4
03D0:  RRF    79,F
03D1:  RRF    78,F
03D2:  DECFSZ 77,F
03D3:  GOTO   3C9
03D4:  BTFSS  4D.7
03D5:  GOTO   3DB
03D6:  COMF   78,F
03D7:  COMF   79,F
03D8:  INCF   78,F
03D9:  BTFSC  03.2
03DA:  INCF   79,F
*
0433:  MOVF   0B,W
0434:  BSF    03.6
0435:  MOVWF  4B
0436:  BCF    03.6
0437:  BCF    0B.7
0438:  BSF    03.5
0439:  BSF    03.6
043A:  BSF    0C.7
043B:  BSF    0C.0
043C:  NOP
043D:  NOP
043E:  BCF    03.5
043F:  BTFSS  4B.7
0440:  GOTO   444
0441:  BCF    03.6
0442:  BSF    0B.7
0443:  BSF    03.6
0444:  MOVF   0C,W
0445:  ANDLW  7F
0446:  BTFSC  03.2
0447:  GOTO   481
0448:  MOVWF  4B
0449:  MOVF   0D,W
044A:  MOVWF  4C
044B:  MOVF   0F,W
044C:  MOVWF  4D
044D:  MOVF   4B,W
044E:  MOVWF  4F
044F:  BCF    03.6
0450:  CALL   3F9
0451:  BSF    03.6
0452:  MOVF   4C,W
0453:  MOVWF  0D
0454:  MOVF   4D,W
0455:  MOVWF  0F
0456:  BCF    03.6
0457:  MOVF   0B,W
0458:  BSF    03.6
0459:  MOVWF  4E
045A:  BCF    03.6
045B:  BCF    0B.7
045C:  BSF    03.5
045D:  BSF    03.6
045E:  BSF    0C.7
045F:  BSF    0C.0
0460:  NOP
0461:  NOP
0462:  BCF    03.5
0463:  BTFSS  4E.7
0464:  GOTO   468
0465:  BCF    03.6
0466:  BSF    0B.7
0467:  BSF    03.6
0468:  RLF    0C,W
0469:  RLF    0E,W
046A:  ANDLW  7F
046B:  BTFSC  03.2
046C:  GOTO   481
046D:  MOVWF  4B
046E:  MOVF   0D,W
046F:  MOVWF  4C
0470:  MOVF   0F,W
0471:  MOVWF  4D
0472:  MOVF   4B,W
0473:  MOVWF  4F
0474:  BCF    03.6
0475:  CALL   3F9
0476:  BSF    03.6
0477:  MOVF   4C,W
0478:  MOVWF  0D
0479:  MOVF   4D,W
047A:  MOVWF  0F
047B:  INCF   0D,F
047C:  BTFSC  03.2
047D:  INCF   0F,F
047E:  BCF    03.6
047F:  GOTO   433
0480:  BSF    03.6
0481:  BCF    03.6
0482:  RETURN
0483:  BTFSC  03.1
0484:  GOTO   488
0485:  MOVLW  90
0486:  MOVWF  04
0487:  BSF    03.7
0488:  BSF    03.6
0489:  MOVF   66,W
048A:  XORWF  6A,W
048B:  ANDLW  80
048C:  BSF    03.5
048D:  MOVWF  15
048E:  BCF    03.5
048F:  BTFSS  66.7
0490:  GOTO   49C
0491:  COMF   63,F
0492:  COMF   64,F
0493:  COMF   65,F
0494:  COMF   66,F
0495:  INCF   63,F
0496:  BTFSC  03.2
0497:  INCF   64,F
0498:  BTFSC  03.2
0499:  INCF   65,F
049A:  BTFSC  03.2
049B:  INCF   66,F
049C:  BTFSS  6A.7
049D:  GOTO   4A9
049E:  COMF   67,F
049F:  COMF   68,F
04A0:  COMF   69,F
04A1:  COMF   6A,F
04A2:  INCF   67,F
04A3:  BTFSC  03.2
04A4:  INCF   68,F
04A5:  BTFSC  03.2
04A6:  INCF   69,F
04A7:  BTFSC  03.2
04A8:  INCF   6A,F
04A9:  CLRF   77
04AA:  CLRF   78
04AB:  CLRF   79
04AC:  CLRF   7A
04AD:  BSF    03.5
04AE:  CLRF   10
04AF:  CLRF   11
04B0:  CLRF   12
04B1:  CLRF   13
04B2:  BCF    03.5
04B3:  MOVF   6A,W
04B4:  IORWF  69,W
04B5:  IORWF  68,W
04B6:  IORWF  67,W
04B7:  BTFSC  03.2
04B8:  GOTO   505
04B9:  MOVLW  20
04BA:  BSF    03.5
04BB:  MOVWF  14
04BC:  BCF    03.0
04BD:  BCF    03.5
04BE:  RLF    63,F
04BF:  RLF    64,F
04C0:  RLF    65,F
04C1:  RLF    66,F
04C2:  BSF    03.5
04C3:  RLF    10,F
04C4:  RLF    11,F
04C5:  RLF    12,F
04C6:  RLF    13,F
04C7:  BCF    03.5
04C8:  MOVF   6A,W
04C9:  BSF    03.5
04CA:  SUBWF  13,W
04CB:  BTFSS  03.2
04CC:  GOTO   4DD
04CD:  BCF    03.5
04CE:  MOVF   69,W
04CF:  BSF    03.5
04D0:  SUBWF  12,W
04D1:  BTFSS  03.2
04D2:  GOTO   4DD
04D3:  BCF    03.5
04D4:  MOVF   68,W
04D5:  BSF    03.5
04D6:  SUBWF  11,W
04D7:  BTFSS  03.2
04D8:  GOTO   4DD
04D9:  BCF    03.5
04DA:  MOVF   67,W
04DB:  BSF    03.5
04DC:  SUBWF  10,W
04DD:  BTFSS  03.0
04DE:  GOTO   4FE
04DF:  BCF    03.5
04E0:  MOVF   67,W
04E1:  BSF    03.5
04E2:  SUBWF  10,F
04E3:  BCF    03.5
04E4:  MOVF   68,W
04E5:  BTFSS  03.0
04E6:  INCFSZ 68,W
04E7:  GOTO   4E9
04E8:  GOTO   4EC
04E9:  BSF    03.5
04EA:  SUBWF  11,F
04EB:  BCF    03.5
04EC:  MOVF   69,W
04ED:  BTFSS  03.0
04EE:  INCFSZ 69,W
04EF:  GOTO   4F1
04F0:  GOTO   4F4
04F1:  BSF    03.5
04F2:  SUBWF  12,F
04F3:  BCF    03.5
04F4:  MOVF   6A,W
04F5:  BTFSS  03.0
04F6:  INCFSZ 6A,W
04F7:  GOTO   4F9
04F8:  GOTO   4FC
04F9:  BSF    03.5
04FA:  SUBWF  13,F
04FB:  BCF    03.5
04FC:  BSF    03.0
04FD:  BSF    03.5
04FE:  RLF    77,F
04FF:  RLF    78,F
0500:  RLF    79,F
0501:  RLF    7A,F
0502:  DECFSZ 14,F
0503:  GOTO   4BC
0504:  BCF    03.5
0505:  BSF    03.5
0506:  BTFSS  15.7
0507:  GOTO   513
0508:  COMF   77,F
0509:  COMF   78,F
050A:  COMF   79,F
050B:  COMF   7A,F
050C:  INCF   77,F
050D:  BTFSC  03.2
050E:  INCF   78,F
050F:  BTFSC  03.2
0510:  INCF   79,F
0511:  BTFSC  03.2
0512:  INCF   7A,F
0513:  MOVF   10,W
0514:  MOVWF  00
0515:  INCF   04,F
0516:  MOVF   11,W
0517:  MOVWF  00
0518:  INCF   04,F
0519:  MOVF   12,W
051A:  MOVWF  00
051B:  INCF   04,F
051C:  MOVF   13,W
051D:  MOVWF  00
051E:  BCF    03.5
051F:  BCF    03.6
0520:  RETURN
*
053A:  MOVLW  20
053B:  MOVWF  67
053C:  CLRF   63
053D:  CLRF   64
053E:  CLRF   65
053F:  CLRF   66
0540:  MOVF   5E,W
0541:  MOVWF  7A
0542:  MOVF   5D,W
0543:  MOVWF  79
0544:  MOVF   5C,W
0545:  MOVWF  78
0546:  MOVF   5B,W
0547:  MOVWF  77
0548:  BCF    03.0
0549:  BTFSS  77.0
054A:  GOTO   559
054B:  MOVF   5F,W
054C:  ADDWF  63,F
054D:  MOVF   60,W
054E:  BTFSC  03.0
054F:  INCFSZ 60,W
0550:  ADDWF  64,F
0551:  MOVF   61,W
0552:  BTFSC  03.0
0553:  INCFSZ 61,W
0554:  ADDWF  65,F
0555:  MOVF   62,W
0556:  BTFSC  03.0
0557:  INCFSZ 62,W
0558:  ADDWF  66,F
0559:  RRF    66,F
055A:  RRF    65,F
055B:  RRF    64,F
055C:  RRF    63,F
055D:  RRF    7A,F
055E:  RRF    79,F
055F:  RRF    78,F
0560:  RRF    77,F
0561:  DECFSZ 67,F
0562:  GOTO   548
*
0641:  MOVF   00,F
0642:  BTFSC  03.2
0643:  GOTO   65D
0644:  BSF    03.6
0645:  CLRF   4E
0646:  MOVF   04,W
0647:  MOVWF  4D
0648:  BCF    4E.0
0649:  BTFSC  03.7
064A:  BSF    4E.0
064B:  MOVF   00,W
064C:  MOVWF  4F
064D:  BCF    03.6
064E:  CALL   3F9
064F:  BSF    03.6
0650:  MOVF   4D,W
0651:  MOVWF  04
0652:  BCF    03.7
0653:  BTFSC  4E.0
0654:  BSF    03.7
0655:  INCF   04,F
0656:  BTFSS  03.2
0657:  GOTO   65B
0658:  BCF    03.6
0659:  INCF   05,F
065A:  BSF    03.6
065B:  BCF    03.6
065C:  GOTO   641
065D:  RETURN
065E:  BSF    03.6
065F:  MOVF   4C,W
0660:  ANDLW  07
0661:  MOVWF  77
0662:  RRF    4C,W
0663:  MOVWF  78
0664:  RRF    78,F
0665:  RRF    78,F
0666:  MOVLW  1F
0667:  ANDWF  78,F
0668:  MOVF   78,W
0669:  ADDWF  4D,W
066A:  MOVWF  04
066B:  BCF    03.7
066C:  BTFSC  4E.0
066D:  BSF    03.7
066E:  MOVF   00,W
066F:  MOVWF  78
0670:  INCF   77,F
0671:  GOTO   673
0672:  RRF    78,F
0673:  DECFSZ 77,F
0674:  GOTO   672
0675:  BCF    03.6
0676:  RETURN
0677:  BSF    03.6
0678:  MOVF   4B,W
0679:  ANDLW  07
067A:  MOVWF  77
067B:  RRF    4B,W
067C:  MOVWF  78
067D:  RRF    78,F
067E:  RRF    78,F
067F:  MOVLW  1F
0680:  ANDWF  78,F
0681:  MOVF   78,W
0682:  ADDWF  4D,W
0683:  MOVWF  04
0684:  BCF    03.7
0685:  BTFSC  4E.0
0686:  BSF    03.7
0687:  CLRF   78
0688:  INCF   78,F
0689:  INCF   77,F
068A:  GOTO   68C
068B:  RLF    78,F
068C:  DECFSZ 77,F
068D:  GOTO   68B
068E:  MOVF   4C,F
068F:  BTFSC  03.2
0690:  GOTO   694
0691:  MOVF   78,W
0692:  IORWF  00,F
0693:  GOTO   697
0694:  COMF   78,F
0695:  MOVF   78,W
0696:  ANDWF  00,F
0697:  BCF    03.6
0698:  RETURN
*
071F:  BSF    0A.0
0720:  BSF    0A.1
0721:  BSF    0A.2
0722:  ADDWF  02,F
0723:  GOTO   6F7
0724:  GOTO   6FF
0725:  GOTO   707
0726:  GOTO   70F
*
0765:  MOVF   00,F
0766:  BTFSC  03.2
0767:  GOTO   782
0768:  BSF    03.6
0769:  CLRF   4E
076A:  MOVF   04,W
076B:  MOVWF  4D
076C:  BCF    4E.0
076D:  BTFSC  03.7
076E:  BSF    4E.0
076F:  MOVF   00,W
0770:  BCF    03.6
0771:  BTFSS  0C.4
0772:  GOTO   771
0773:  MOVWF  19
0774:  BSF    03.6
0775:  MOVF   4D,W
0776:  MOVWF  04
0777:  BCF    03.7
0778:  BTFSC  4E.0
0779:  BSF    03.7
077A:  INCF   04,F
077B:  BTFSS  03.2
077C:  GOTO   780
077D:  BCF    03.6
077E:  INCF   05,F
077F:  BSF    03.6
0780:  BCF    03.6
0781:  GOTO   765
0782:  RETURN
*
0AC1:  BCF    0A.0
0AC2:  BSF    0A.1
0AC3:  BCF    0A.2
0AC4:  ADDWF  02,F
0AC5:  GOTO   007
0AC6:  GOTO   06E
0AC7:  GOTO   176
0AC8:  GOTO   27E
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0727:  BSF    03.6
0728:  MOVF   4D,W
0729:  MOVWF  51
072A:  MOVF   4C,W
072B:  MOVWF  50
072C:  MOVF   51,W
072D:  MOVWF  7A
072E:  MOVF   50,W
072F:  MOVWF  04
0730:  BCF    03.7
0731:  BTFSC  7A.0
0732:  BSF    03.7
0733:  MOVF   00,F
0734:  BTFSC  03.2
0735:  GOTO   73A
0736:  INCF   50,F
0737:  BTFSC  03.2
0738:  INCF   51,F
0739:  GOTO   72C
....................    while(*s2 != '\0') 
073A:  MOVF   4F,W
073B:  MOVWF  7A
073C:  MOVF   4E,W
073D:  MOVWF  04
073E:  BCF    03.7
073F:  BTFSC  7A.0
0740:  BSF    03.7
0741:  MOVF   00,F
0742:  BTFSC  03.2
0743:  GOTO   759
....................    { 
....................       *s = *s2; 
0744:  MOVF   4E,W
0745:  MOVWF  04
0746:  BCF    03.7
0747:  BTFSC  4F.0
0748:  BSF    03.7
0749:  MOVF   00,W
074A:  MOVWF  54
074B:  MOVF   50,W
074C:  MOVWF  04
074D:  BCF    03.7
074E:  BTFSC  51.0
074F:  BSF    03.7
0750:  MOVF   54,W
0751:  MOVWF  00
....................       ++s; 
0752:  INCF   50,F
0753:  BTFSC  03.2
0754:  INCF   51,F
....................       ++s2; 
0755:  INCF   4E,F
0756:  BTFSC  03.2
0757:  INCF   4F,F
0758:  GOTO   73A
....................    } 
....................  
....................    *s = '\0'; 
0759:  MOVF   50,W
075A:  MOVWF  04
075B:  BCF    03.7
075C:  BTFSC  51.0
075D:  BSF    03.7
075E:  CLRF   00
....................    return(s1); 
075F:  MOVF   4C,W
0760:  MOVWF  78
0761:  MOVF   4D,W
0762:  MOVWF  79
0763:  BCF    03.6
0764:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0C53:  BCF    03.6
0C54:  CLRF   2B
0C55:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0521:  BSF    03.6
0522:  CLRF   56
0523:  CLRF   55
0524:  CLRF   54
0525:  MOVLW  01
0526:  MOVWF  53
0527:  CLRF   58
0528:  CLRF   59
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0529:  BTFSS  4F.7
052A:  GOTO   56B
....................          sign=1;        // Check for negative number 
052B:  MOVLW  01
052C:  MOVWF  58
....................          num*=-1; 
052D:  MOVF   4F,W
052E:  MOVWF  5E
052F:  MOVF   4E,W
0530:  MOVWF  5D
0531:  MOVF   4D,W
0532:  MOVWF  5C
0533:  MOVF   4C,W
0534:  MOVWF  5B
0535:  MOVLW  FF
0536:  MOVWF  62
0537:  MOVWF  61
0538:  MOVWF  60
0539:  MOVWF  5F
*
0563:  MOVF   7A,W
0564:  MOVWF  4F
0565:  MOVF   79,W
0566:  MOVWF  4E
0567:  MOVF   78,W
0568:  MOVWF  4D
0569:  MOVF   77,W
056A:  MOVWF  4C
....................      } 
....................  
....................      while(temp>0) { 
056B:  MOVF   53,F
056C:  BTFSS  03.2
056D:  GOTO   577
056E:  MOVF   54,F
056F:  BTFSS  03.2
0570:  GOTO   577
0571:  MOVF   55,F
0572:  BTFSS  03.2
0573:  GOTO   577
0574:  MOVF   56,F
0575:  BTFSC  03.2
0576:  GOTO   5F3
....................          temp=(num/base); 
0577:  BCF    03.1
0578:  MOVF   4F,W
0579:  MOVWF  66
057A:  MOVF   4E,W
057B:  MOVWF  65
057C:  MOVF   4D,W
057D:  MOVWF  64
057E:  MOVF   4C,W
057F:  MOVWF  63
0580:  CLRF   6A
0581:  CLRF   69
0582:  CLRF   68
0583:  MOVF   50,W
0584:  MOVWF  67
0585:  BCF    03.6
0586:  CALL   483
0587:  MOVF   7A,W
0588:  BSF    03.6
0589:  MOVWF  56
058A:  MOVF   79,W
058B:  MOVWF  55
058C:  MOVF   78,W
058D:  MOVWF  54
058E:  MOVF   77,W
058F:  MOVWF  53
....................          s[cnt]=(num%base)+'0';    // Conversion 
0590:  MOVF   59,W
0591:  ADDWF  51,W
0592:  MOVWF  78
0593:  MOVF   52,W
0594:  MOVWF  7A
0595:  BTFSC  03.0
0596:  INCF   7A,F
0597:  MOVF   78,W
0598:  MOVWF  5B
0599:  MOVF   7A,W
059A:  MOVWF  5C
059B:  CLRF   5E
059C:  MOVF   04,W
059D:  MOVWF  5D
059E:  BCF    5E.0
059F:  BTFSC  03.7
05A0:  BSF    5E.0
05A1:  BSF    03.1
05A2:  MOVLW  5F
05A3:  MOVWF  04
05A4:  BSF    03.7
05A5:  MOVF   4F,W
05A6:  MOVWF  66
05A7:  MOVF   4E,W
05A8:  MOVWF  65
05A9:  MOVF   4D,W
05AA:  MOVWF  64
05AB:  MOVF   4C,W
05AC:  MOVWF  63
05AD:  CLRF   6A
05AE:  CLRF   69
05AF:  CLRF   68
05B0:  MOVF   50,W
05B1:  MOVWF  67
05B2:  BCF    03.6
05B3:  CALL   483
05B4:  BSF    03.6
05B5:  MOVF   5D,W
05B6:  MOVWF  04
05B7:  BCF    03.7
05B8:  BTFSC  5E.0
05B9:  BSF    03.7
05BA:  MOVLW  30
05BB:  ADDWF  5F,W
05BC:  MOVWF  77
05BD:  MOVF   60,W
05BE:  MOVWF  78
05BF:  MOVLW  00
05C0:  BTFSC  03.0
05C1:  MOVLW  01
05C2:  ADDWF  78,F
05C3:  MOVF   61,W
05C4:  MOVWF  79
05C5:  MOVLW  00
05C6:  BTFSC  03.0
05C7:  MOVLW  01
05C8:  ADDWF  79,F
05C9:  MOVF   62,W
05CA:  MOVWF  7A
05CB:  MOVLW  00
05CC:  BTFSC  03.0
05CD:  MOVLW  01
05CE:  ADDWF  7A,F
05CF:  MOVF   5B,W
05D0:  MOVWF  04
05D1:  BCF    03.7
05D2:  BTFSC  5C.0
05D3:  BSF    03.7
05D4:  MOVF   77,W
05D5:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
05D6:  MOVF   59,W
05D7:  ADDWF  51,W
05D8:  MOVWF  04
05D9:  BCF    03.7
05DA:  BTFSC  52.0
05DB:  BSF    03.7
05DC:  MOVF   00,W
05DD:  SUBLW  39
05DE:  BTFSC  03.0
05DF:  GOTO   5E9
....................             s[cnt]+=0x7; 
05E0:  MOVF   59,W
05E1:  ADDWF  51,W
05E2:  MOVWF  04
05E3:  BCF    03.7
05E4:  BTFSC  52.0
05E5:  BSF    03.7
05E6:  MOVLW  07
05E7:  ADDWF  00,W
05E8:  MOVWF  00
....................  
....................          cnt++; 
05E9:  INCF   59,F
....................          num=temp; 
05EA:  MOVF   56,W
05EB:  MOVWF  4F
05EC:  MOVF   55,W
05ED:  MOVWF  4E
05EE:  MOVF   54,W
05EF:  MOVWF  4D
05F0:  MOVF   53,W
05F1:  MOVWF  4C
05F2:  GOTO   56B
....................      } 
....................  
....................      if(sign==1) { 
05F3:  DECFSZ 58,W
05F4:  GOTO   5FE
....................          s[cnt]=0x2D;      // Negative sign 
05F5:  MOVF   59,W
05F6:  ADDWF  51,W
05F7:  MOVWF  04
05F8:  BCF    03.7
05F9:  BTFSC  52.0
05FA:  BSF    03.7
05FB:  MOVLW  2D
05FC:  MOVWF  00
....................          cnt++; 
05FD:  INCF   59,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
05FE:  CLRF   57
05FF:  BCF    03.0
0600:  RRF    59,W
0601:  SUBWF  57,W
0602:  BTFSC  03.0
0603:  GOTO   634
....................  
....................          c=s[i]; 
0604:  MOVF   57,W
0605:  ADDWF  51,W
0606:  MOVWF  04
0607:  BCF    03.7
0608:  BTFSC  52.0
0609:  BSF    03.7
060A:  MOVF   00,W
060B:  MOVWF  5A
....................          s[i]=s[cnt-i-1];        // Reverse the number 
060C:  MOVF   57,W
060D:  ADDWF  51,W
060E:  MOVWF  78
060F:  MOVF   52,W
0610:  MOVWF  7A
0611:  BTFSC  03.0
0612:  INCF   7A,F
0613:  MOVF   78,W
0614:  MOVWF  5B
0615:  MOVF   7A,W
0616:  MOVWF  5C
0617:  MOVF   57,W
0618:  SUBWF  59,W
0619:  ADDLW  FF
061A:  ADDWF  51,W
061B:  MOVWF  04
061C:  BCF    03.7
061D:  BTFSC  52.0
061E:  BSF    03.7
061F:  MOVF   00,W
0620:  MOVWF  5D
0621:  MOVF   5B,W
0622:  MOVWF  04
0623:  BCF    03.7
0624:  BTFSC  5C.0
0625:  BSF    03.7
0626:  MOVF   5D,W
0627:  MOVWF  00
....................          s[cnt-i-1]=c; 
0628:  MOVF   57,W
0629:  SUBWF  59,W
062A:  ADDLW  FF
062B:  ADDWF  51,W
062C:  MOVWF  04
062D:  BCF    03.7
062E:  BTFSC  52.0
062F:  BSF    03.7
0630:  MOVF   5A,W
0631:  MOVWF  00
0632:  INCF   57,F
0633:  GOTO   5FF
....................      } 
....................      s[cnt]='\0';     // End the string 
0634:  MOVF   59,W
0635:  ADDWF  51,W
0636:  MOVWF  04
0637:  BCF    03.7
0638:  BTFSC  52.0
0639:  BSF    03.7
063A:  CLRF   00
....................      return s; 
063B:  MOVF   51,W
063C:  MOVWF  78
063D:  MOVF   52,W
063E:  MOVWF  79
063F:  BCF    03.6
0640:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#INCLUDE <CONFIG_NODE.C> 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0111:  MOVLW  50
0112:  MOVWF  04
0113:  BSF    03.7
0114:  MOVF   00,W
0115:  BTFSC  03.2
0116:  GOTO   124
0117:  MOVLW  06
0118:  MOVWF  78
0119:  CLRF   77
011A:  DECFSZ 77,F
011B:  GOTO   11A
011C:  DECFSZ 78,F
011D:  GOTO   119
011E:  MOVLW  7B
011F:  MOVWF  77
0120:  DECFSZ 77,F
0121:  GOTO   120
0122:  DECFSZ 00,F
0123:  GOTO   117
0124:  RETURN
....................  
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
....................  
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01B8:  BSF    07.0
....................    output_float(LCD_DATA5); 
01B9:  BSF    07.1
....................    output_float(LCD_DATA6); 
01BA:  BSF    07.2
....................    output_float(LCD_DATA7); 
01BB:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01BC:  BCF    03.5
01BD:  BSF    09.2
01BE:  BSF    03.5
01BF:  BCF    09.2
....................    delay_cycles(1); 
01C0:  NOP
....................    lcd_output_enable(1); 
01C1:  BCF    03.5
01C2:  BSF    09.0
01C3:  BSF    03.5
01C4:  BCF    09.0
....................    delay_cycles(1); 
01C5:  NOP
....................    high = lcd_read_nibble(); 
01C6:  BCF    03.5
01C7:  CALL   16D
01C8:  MOVF   78,W
01C9:  BSF    03.6
01CA:  MOVWF  57
....................        
....................    lcd_output_enable(0); 
01CB:  BCF    03.6
01CC:  BCF    09.0
01CD:  BSF    03.5
01CE:  BCF    09.0
....................    delay_cycles(1); 
01CF:  NOP
....................    lcd_output_enable(1); 
01D0:  BCF    03.5
01D1:  BSF    09.0
01D2:  BSF    03.5
01D3:  BCF    09.0
....................    delay_us(1); 
01D4:  GOTO   1D5
01D5:  GOTO   1D6
01D6:  NOP
....................    low = lcd_read_nibble(); 
01D7:  BCF    03.5
01D8:  CALL   16D
01D9:  MOVF   78,W
01DA:  BSF    03.6
01DB:  MOVWF  56
....................        
....................    lcd_output_enable(0); 
01DC:  BCF    03.6
01DD:  BCF    09.0
01DE:  BSF    03.5
01DF:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01E0:  BCF    03.5
01E1:  BCF    31.0
01E2:  MOVF   31,W
01E3:  BSF    03.5
01E4:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01E5:  BCF    03.5
01E6:  BCF    31.1
01E7:  MOVF   31,W
01E8:  BSF    03.5
01E9:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01EA:  BCF    03.5
01EB:  BCF    31.2
01EC:  MOVF   31,W
01ED:  BSF    03.5
01EE:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01EF:  BCF    03.5
01F0:  BCF    31.3
01F1:  MOVF   31,W
01F2:  BSF    03.5
01F3:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01F4:  BCF    03.5
01F5:  BSF    03.6
01F6:  SWAPF  57,W
01F7:  MOVWF  77
01F8:  MOVLW  F0
01F9:  ANDWF  77,F
01FA:  MOVF   77,W
01FB:  IORWF  56,W
01FC:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
016D:  BSF    03.6
016E:  CLRF   58
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
016F:  BCF    03.6
0170:  BSF    31.0
0171:  MOVF   31,W
0172:  BSF    03.5
0173:  MOVWF  07
0174:  MOVLW  00
0175:  BCF    03.5
0176:  BTFSC  07.0
0177:  MOVLW  01
0178:  BSF    03.6
0179:  IORWF  58,F
....................    n |= input(LCD_DATA5) << 1; 
017A:  BCF    03.6
017B:  BSF    31.1
017C:  MOVF   31,W
017D:  BSF    03.5
017E:  MOVWF  07
017F:  MOVLW  00
0180:  BCF    03.5
0181:  BTFSC  07.1
0182:  MOVLW  01
0183:  MOVWF  77
0184:  BCF    03.0
0185:  RLF    77,F
0186:  MOVF   77,W
0187:  BSF    03.6
0188:  IORWF  58,F
....................    n |= input(LCD_DATA6) << 2; 
0189:  BCF    03.6
018A:  BSF    31.2
018B:  MOVF   31,W
018C:  BSF    03.5
018D:  MOVWF  07
018E:  MOVLW  00
018F:  BCF    03.5
0190:  BTFSC  07.2
0191:  MOVLW  01
0192:  MOVWF  77
0193:  RLF    77,F
0194:  RLF    77,F
0195:  MOVLW  FC
0196:  ANDWF  77,F
0197:  MOVF   77,W
0198:  BSF    03.6
0199:  IORWF  58,F
....................    n |= input(LCD_DATA7) << 3; 
019A:  BCF    03.6
019B:  BSF    31.3
019C:  MOVF   31,W
019D:  BSF    03.5
019E:  MOVWF  07
019F:  MOVLW  00
01A0:  BCF    03.5
01A1:  BTFSC  07.3
01A2:  MOVLW  01
01A3:  MOVWF  77
01A4:  RLF    77,F
01A5:  RLF    77,F
01A6:  RLF    77,F
01A7:  MOVLW  F8
01A8:  ANDWF  77,F
01A9:  MOVF   77,W
01AA:  BSF    03.6
01AB:  IORWF  58,F
....................     
....................    return(n); 
01AC:  MOVF   58,W
01AD:  MOVWF  78
....................   #else 
01AE:  BCF    03.6
01AF:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0125:  BSF    03.6
0126:  BTFSC  57.0
0127:  GOTO   12C
0128:  BCF    03.6
0129:  BCF    07.0
012A:  GOTO   12E
012B:  BSF    03.6
012C:  BCF    03.6
012D:  BSF    07.0
012E:  BCF    31.0
012F:  MOVF   31,W
0130:  BSF    03.5
0131:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0132:  BCF    03.5
0133:  BSF    03.6
0134:  BTFSC  57.1
0135:  GOTO   13A
0136:  BCF    03.6
0137:  BCF    07.1
0138:  GOTO   13C
0139:  BSF    03.6
013A:  BCF    03.6
013B:  BSF    07.1
013C:  BCF    31.1
013D:  MOVF   31,W
013E:  BSF    03.5
013F:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0140:  BCF    03.5
0141:  BSF    03.6
0142:  BTFSC  57.2
0143:  GOTO   148
0144:  BCF    03.6
0145:  BCF    07.2
0146:  GOTO   14A
0147:  BSF    03.6
0148:  BCF    03.6
0149:  BSF    07.2
014A:  BCF    31.2
014B:  MOVF   31,W
014C:  BSF    03.5
014D:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
014E:  BCF    03.5
014F:  BSF    03.6
0150:  BTFSC  57.3
0151:  GOTO   156
0152:  BCF    03.6
0153:  BCF    07.3
0154:  GOTO   158
0155:  BSF    03.6
0156:  BCF    03.6
0157:  BSF    07.3
0158:  BCF    31.3
0159:  MOVF   31,W
015A:  BSF    03.5
015B:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
015C:  NOP
....................    lcd_output_enable(1); 
015D:  BCF    03.5
015E:  BSF    09.0
015F:  BSF    03.5
0160:  BCF    09.0
....................    delay_us(2); 
0161:  MOVLW  02
0162:  MOVWF  77
0163:  DECFSZ 77,F
0164:  GOTO   163
0165:  GOTO   166
0166:  NOP
....................    lcd_output_enable(0); 
0167:  BCF    03.5
0168:  BCF    09.0
0169:  BSF    03.5
016A:  BCF    09.0
016B:  BCF    03.5
016C:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01B0:  BSF    03.5
01B1:  BCF    09.0
....................    lcd_rs_tris(); 
01B2:  BCF    09.1
....................    lcd_rw_tris(); 
01B3:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01B4:  BCF    03.5
01B5:  BCF    09.1
01B6:  BSF    03.5
01B7:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01FD:  MOVF   78,W
01FE:  MOVWF  56
01FF:  BTFSS  56.7
0200:  GOTO   204
0201:  BSF    03.5
0202:  BCF    03.6
0203:  GOTO   1B8
....................    lcd_output_rs(address); 
0204:  MOVF   54,F
0205:  BTFSS  03.2
0206:  GOTO   20B
0207:  BCF    03.6
0208:  BCF    09.1
0209:  GOTO   20D
020A:  BSF    03.6
020B:  BCF    03.6
020C:  BSF    09.1
020D:  BSF    03.5
020E:  BCF    09.1
....................    delay_cycles(1); 
020F:  NOP
....................    lcd_output_rw(0); 
0210:  BCF    03.5
0211:  BCF    09.2
0212:  BSF    03.5
0213:  BCF    09.2
....................    delay_cycles(1); 
0214:  NOP
....................    lcd_output_enable(0); 
0215:  BCF    03.5
0216:  BCF    09.0
0217:  BSF    03.5
0218:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0219:  BCF    03.5
021A:  BSF    03.6
021B:  SWAPF  55,W
021C:  MOVWF  56
021D:  MOVLW  0F
021E:  ANDWF  56,F
021F:  MOVF   56,W
0220:  MOVWF  57
0221:  BCF    03.6
0222:  CALL   125
....................    lcd_send_nibble(n & 0xf); 
0223:  BSF    03.6
0224:  MOVF   55,W
0225:  ANDLW  0F
0226:  MOVWF  56
0227:  MOVWF  57
0228:  BCF    03.6
0229:  CALL   125
022A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
022B:  MOVLW  28
022C:  BSF    03.6
022D:  MOVWF  4B
022E:  MOVLW  0C
022F:  MOVWF  4C
0230:  MOVLW  01
0231:  MOVWF  4D
0232:  MOVLW  06
0233:  MOVWF  4E
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0234:  BCF    03.6
0235:  BCF    09.0
0236:  BSF    03.5
0237:  BCF    09.0
....................    lcd_output_rs(0); 
0238:  BCF    03.5
0239:  BCF    09.1
023A:  BSF    03.5
023B:  BCF    09.1
....................    lcd_output_rw(0); 
023C:  BCF    03.5
023D:  BCF    09.2
023E:  BSF    03.5
023F:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0240:  BCF    03.5
0241:  BCF    31.0
0242:  MOVF   31,W
0243:  BSF    03.5
0244:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0245:  BCF    03.5
0246:  BCF    31.1
0247:  MOVF   31,W
0248:  BSF    03.5
0249:  MOVWF  07
....................    output_drive(LCD_DATA6); 
024A:  BCF    03.5
024B:  BCF    31.2
024C:  MOVF   31,W
024D:  BSF    03.5
024E:  MOVWF  07
....................    output_drive(LCD_DATA7); 
024F:  BCF    03.5
0250:  BCF    31.3
0251:  MOVF   31,W
0252:  BSF    03.5
0253:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0254:  BCF    09.0
....................    lcd_rs_tris(); 
0255:  BCF    09.1
....................    lcd_rw_tris(); 
0256:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0257:  MOVLW  0F
0258:  BCF    03.5
0259:  BSF    03.6
025A:  MOVWF  50
025B:  BCF    03.6
025C:  CALL   111
....................    for(i=1;i<=3;++i) 
025D:  MOVLW  01
025E:  BSF    03.6
025F:  MOVWF  4A
0260:  MOVF   4A,W
0261:  SUBLW  03
0262:  BTFSS  03.0
0263:  GOTO   270
....................    { 
....................        lcd_send_nibble(3); 
0264:  MOVLW  03
0265:  MOVWF  57
0266:  BCF    03.6
0267:  CALL   125
....................        delay_ms(5); 
0268:  MOVLW  05
0269:  BSF    03.6
026A:  MOVWF  50
026B:  BCF    03.6
026C:  CALL   111
026D:  BSF    03.6
026E:  INCF   4A,F
026F:  GOTO   260
....................    } 
....................     
....................    lcd_send_nibble(2); 
0270:  MOVLW  02
0271:  MOVWF  57
0272:  BCF    03.6
0273:  CALL   125
....................    delay_ms(5); 
0274:  MOVLW  05
0275:  BSF    03.6
0276:  MOVWF  50
0277:  BCF    03.6
0278:  CALL   111
....................    for(i=0;i<=3;++i) 
0279:  BSF    03.6
027A:  CLRF   4A
027B:  MOVF   4A,W
027C:  SUBLW  03
027D:  BTFSS  03.0
027E:  GOTO   28D
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
027F:  MOVLW  4B
0280:  ADDWF  4A,W
0281:  MOVWF  04
0282:  BSF    03.7
0283:  MOVF   00,W
0284:  MOVWF  4F
0285:  CLRF   54
0286:  MOVF   4F,W
0287:  MOVWF  55
0288:  BCF    03.6
0289:  CALL   1B0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
028A:  BSF    03.6
028B:  INCF   4A,F
028C:  GOTO   27B
028D:  BCF    03.6
028E:  BSF    0A.3
028F:  BCF    0A.4
0290:  GOTO   592 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
03E5:  BSF    03.6
03E6:  DECFSZ 51,W
03E7:  GOTO   3E9
03E8:  GOTO   3EC
....................       address=LCD_LINE_TWO; 
03E9:  MOVLW  40
03EA:  MOVWF  52
03EB:  GOTO   3ED
....................    else 
....................       address=0; 
03EC:  CLRF   52
....................       
....................    address+=x-1; 
03ED:  MOVLW  01
03EE:  SUBWF  50,W
03EF:  ADDWF  52,F
....................    lcd_send_byte(0,0x80|address); 
03F0:  MOVF   52,W
03F1:  IORLW  80
03F2:  MOVWF  53
03F3:  CLRF   54
03F4:  MOVF   53,W
03F5:  MOVWF  55
03F6:  BCF    03.6
03F7:  CALL   1B0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03F8:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03F9:  BSF    03.6
03FA:  MOVF   4F,W
03FB:  XORLW  07
03FC:  BCF    03.6
03FD:  BTFSC  03.2
03FE:  GOTO   409
03FF:  XORLW  0B
0400:  BTFSC  03.2
0401:  GOTO   410
0402:  XORLW  06
0403:  BTFSC  03.2
0404:  GOTO   41C
0405:  XORLW  02
0406:  BTFSC  03.2
0407:  GOTO   424
0408:  GOTO   42B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0409:  MOVLW  01
040A:  BSF    03.6
040B:  MOVWF  50
040C:  MOVWF  51
040D:  BCF    03.6
040E:  CALL   3E5
040F:  GOTO   432
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0410:  BSF    03.6
0411:  CLRF   54
0412:  MOVLW  01
0413:  MOVWF  55
0414:  BCF    03.6
0415:  CALL   1B0
....................                      delay_ms(2); 
0416:  MOVLW  02
0417:  BSF    03.6
0418:  MOVWF  50
0419:  BCF    03.6
041A:  CALL   111
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
041B:  GOTO   432
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
041C:  MOVLW  01
041D:  BSF    03.6
041E:  MOVWF  50
041F:  MOVLW  02
0420:  MOVWF  51
0421:  BCF    03.6
0422:  CALL   3E5
0423:  GOTO   432
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0424:  BSF    03.6
0425:  CLRF   54
0426:  MOVLW  10
0427:  MOVWF  55
0428:  BCF    03.6
0429:  CALL   1B0
042A:  GOTO   432
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
042B:  MOVLW  01
042C:  BSF    03.6
042D:  MOVWF  54
042E:  MOVF   4F,W
042F:  MOVWF  55
0430:  BCF    03.6
0431:  CALL   1B0
....................      #endif 
....................    } 
0432:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 0, 1, 0, 1, 1}; 
*
0C56:  MOVLW  D6
0C57:  MOVWF  60
.................... INT1 TT_SENSOR[8]={1, 1, 1, 1, 0, 0, 0, 0}; 
0C58:  MOVLW  0F
0C59:  MOVWF  61
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
0C5A:  MOVLW  20
0C5B:  MOVWF  64
0C5C:  CLRF   65
0C5D:  CLRF   63
0C5E:  MOVLW  64
0C5F:  MOVWF  62
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
0C60:  MOVLW  20
0C61:  MOVWF  68
0C62:  CLRF   69
0C63:  CLRF   67
0C64:  MOVLW  68
0C65:  MOVWF  66
.................... CHAR *PACKAGE_NHIETDO[]={"*","ID", "S_S" ,"LENGHT","NHIETDO","#"}; 
0C66:  MOVLW  2A
0C67:  BSF    03.5
0C68:  MOVWF  20
0C69:  CLRF   21
0C6A:  MOVLW  49
0C6B:  MOVWF  22
0C6C:  MOVLW  44
0C6D:  MOVWF  23
0C6E:  CLRF   24
0C6F:  MOVLW  53
0C70:  MOVWF  25
0C71:  MOVLW  5F
0C72:  MOVWF  26
0C73:  MOVLW  53
0C74:  MOVWF  27
0C75:  CLRF   28
0C76:  MOVLW  4C
0C77:  MOVWF  29
0C78:  MOVLW  45
0C79:  MOVWF  2A
0C7A:  MOVLW  4E
0C7B:  MOVWF  2B
0C7C:  MOVLW  47
0C7D:  MOVWF  2C
0C7E:  MOVLW  48
0C7F:  MOVWF  2D
0C80:  MOVLW  54
0C81:  MOVWF  2E
0C82:  CLRF   2F
0C83:  MOVLW  4E
0C84:  MOVWF  30
0C85:  MOVLW  48
0C86:  MOVWF  31
0C87:  MOVLW  49
0C88:  MOVWF  32
0C89:  MOVLW  45
0C8A:  MOVWF  33
0C8B:  MOVLW  54
0C8C:  MOVWF  34
0C8D:  MOVLW  44
0C8E:  MOVWF  35
0C8F:  MOVLW  4F
0C90:  MOVWF  36
0C91:  CLRF   37
0C92:  MOVLW  23
0C93:  MOVWF  38
0C94:  CLRF   39
0C95:  BCF    03.5
0C96:  CLRF   6B
0C97:  MOVLW  A0
0C98:  MOVWF  6A
0C99:  CLRF   6D
0C9A:  MOVLW  A2
0C9B:  MOVWF  6C
0C9C:  CLRF   6F
0C9D:  MOVLW  A5
0C9E:  MOVWF  6E
0C9F:  CLRF   71
0CA0:  MOVLW  A9
0CA1:  MOVWF  70
0CA2:  CLRF   73
0CA3:  MOVLW  B0
0CA4:  MOVWF  72
0CA5:  CLRF   75
0CA6:  MOVLW  B8
0CA7:  MOVWF  74
.................... CHAR *PACKAGE_CONFIG[]={"*","ID_GW" ,"ID_NODE", "LENGHT","C_F","ID_CU", "DEVICE1234","SENSOR1234","#"}; 
0CA8:  MOVLW  2A
0CA9:  BSF    03.6
0CAA:  MOVWF  10
0CAB:  CLRF   11
0CAC:  MOVLW  49
0CAD:  MOVWF  12
0CAE:  MOVLW  44
0CAF:  MOVWF  13
0CB0:  MOVLW  5F
0CB1:  MOVWF  14
0CB2:  MOVLW  47
0CB3:  MOVWF  15
0CB4:  MOVLW  57
0CB5:  MOVWF  16
0CB6:  CLRF   17
0CB7:  MOVLW  49
0CB8:  MOVWF  18
0CB9:  MOVLW  44
0CBA:  MOVWF  19
0CBB:  MOVLW  5F
0CBC:  MOVWF  1A
0CBD:  MOVLW  4E
0CBE:  MOVWF  1B
0CBF:  MOVLW  4F
0CC0:  MOVWF  1C
0CC1:  MOVLW  44
0CC2:  MOVWF  1D
0CC3:  MOVLW  45
0CC4:  MOVWF  1E
0CC5:  CLRF   1F
0CC6:  MOVLW  4C
0CC7:  MOVWF  20
0CC8:  MOVLW  45
0CC9:  MOVWF  21
0CCA:  MOVLW  4E
0CCB:  MOVWF  22
0CCC:  MOVLW  47
0CCD:  MOVWF  23
0CCE:  MOVLW  48
0CCF:  MOVWF  24
0CD0:  MOVLW  54
0CD1:  MOVWF  25
0CD2:  CLRF   26
0CD3:  MOVLW  43
0CD4:  MOVWF  27
0CD5:  MOVLW  5F
0CD6:  MOVWF  28
0CD7:  MOVLW  46
0CD8:  MOVWF  29
0CD9:  CLRF   2A
0CDA:  MOVLW  49
0CDB:  MOVWF  2B
0CDC:  MOVLW  44
0CDD:  MOVWF  2C
0CDE:  MOVLW  5F
0CDF:  MOVWF  2D
0CE0:  MOVLW  43
0CE1:  MOVWF  2E
0CE2:  MOVLW  55
0CE3:  MOVWF  2F
0CE4:  CLRF   30
0CE5:  MOVLW  44
0CE6:  MOVWF  31
0CE7:  MOVLW  45
0CE8:  MOVWF  32
0CE9:  MOVLW  56
0CEA:  MOVWF  33
0CEB:  MOVLW  49
0CEC:  MOVWF  34
0CED:  MOVLW  43
0CEE:  MOVWF  35
0CEF:  MOVLW  45
0CF0:  MOVWF  36
0CF1:  MOVLW  31
0CF2:  MOVWF  37
0CF3:  MOVLW  32
0CF4:  MOVWF  38
0CF5:  MOVLW  33
0CF6:  MOVWF  39
0CF7:  MOVLW  34
0CF8:  MOVWF  3A
0CF9:  CLRF   3B
0CFA:  MOVLW  53
0CFB:  MOVWF  3C
0CFC:  MOVLW  45
0CFD:  MOVWF  3D
0CFE:  MOVLW  4E
0CFF:  MOVWF  3E
0D00:  MOVLW  53
0D01:  MOVWF  3F
0D02:  MOVLW  4F
0D03:  MOVWF  40
0D04:  MOVLW  52
0D05:  MOVWF  41
0D06:  MOVLW  31
0D07:  MOVWF  42
0D08:  MOVLW  32
0D09:  MOVWF  43
0D0A:  MOVLW  33
0D0B:  MOVWF  44
0D0C:  MOVLW  34
0D0D:  MOVWF  45
0D0E:  CLRF   46
0D0F:  MOVLW  23
0D10:  MOVWF  47
0D11:  CLRF   48
0D12:  MOVLW  01
0D13:  BSF    03.5
0D14:  BCF    03.6
0D15:  MOVWF  3B
0D16:  MOVLW  10
0D17:  MOVWF  3A
0D18:  MOVLW  01
0D19:  MOVWF  3D
0D1A:  MOVLW  12
0D1B:  MOVWF  3C
0D1C:  MOVLW  01
0D1D:  MOVWF  3F
0D1E:  MOVLW  18
0D1F:  MOVWF  3E
0D20:  MOVLW  01
0D21:  MOVWF  41
0D22:  MOVLW  20
0D23:  MOVWF  40
0D24:  MOVLW  01
0D25:  MOVWF  43
0D26:  MOVLW  27
0D27:  MOVWF  42
0D28:  MOVLW  01
0D29:  MOVWF  45
0D2A:  MOVLW  2B
0D2B:  MOVWF  44
0D2C:  MOVLW  01
0D2D:  MOVWF  47
0D2E:  MOVLW  31
0D2F:  MOVWF  46
0D30:  MOVLW  01
0D31:  MOVWF  49
0D32:  MOVLW  3C
0D33:  MOVWF  48
0D34:  MOVLW  01
0D35:  MOVWF  4B
0D36:  MOVLW  47
0D37:  MOVWF  4A
.................... CHAR NHIETDO1[]="27"; 
0D38:  MOVLW  32
0D39:  MOVWF  7B
0D3A:  MOVLW  37
0D3B:  MOVWF  7C
0D3C:  CLRF   7D
.................... CHAR NHIETDO2[]="27"; 
0D3D:  MOVLW  32
0D3E:  MOVWF  4C
0D3F:  MOVLW  37
0D40:  MOVWF  4D
0D41:  CLRF   4E
.................... CHAR *ID_[]="0"; 
0D42:  MOVLW  30
0D43:  MOVWF  51
0D44:  CLRF   52
0D45:  CLRF   50
0D46:  MOVLW  D1
0D47:  MOVWF  4F
.................... CHAR *ID_GW[] = "0"; 
0D48:  MOVLW  30
0D49:  MOVWF  55
0D4A:  CLRF   56
0D4B:  CLRF   54
0D4C:  MOVLW  D5
0D4D:  MOVWF  53
.................... CHAR *TEMP_CHAR[]="0"; 
0D4E:  MOVLW  30
0D4F:  MOVWF  59
0D50:  CLRF   5A
0D51:  CLRF   58
0D52:  MOVLW  D9
0D53:  MOVWF  57
.................... CHAR *TEMP_CHAR2[]="0";  
0D54:  MOVLW  30
0D55:  MOVWF  5D
0D56:  CLRF   5E
0D57:  CLRF   5C
0D58:  MOVLW  DD
0D59:  MOVWF  5B
.................... CHAR *TEMP_CHAR3[]="0";  
0D5A:  MOVLW  30
0D5B:  MOVWF  61
0D5C:  CLRF   62
0D5D:  CLRF   60
0D5E:  MOVLW  E1
0D5F:  MOVWF  5F
.................... //--------------------------------------------------------------------// 
....................  
....................  
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    5F.1
....................    TT_STT = 1; 
0808:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  50
080C:  MOVLW  02
080D:  MOVWF  51
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   3E5
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  50
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   111
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  66
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   433
0821:  BSF    0A.3
....................    WHILE (TT_STT) 
0822:  BTFSS  5F.3
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  4A
0831:  MOVLW  96
0832:  MOVWF  50
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   111
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 4A,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   4F
083B:  CLRF   4E
083C:  CLRF   4D
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  4C
0841:  MOVLW  0A
0842:  MOVWF  50
0843:  CLRF   52
0844:  MOVLW  CF
0845:  MOVWF  51
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   521
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  50
084D:  MOVLW  02
084E:  MOVWF  51
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   3E5
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  50
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   111
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  CF
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   641
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  50
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   111
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    }     
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    5F.1
....................    TT_STT = 1; 
086F:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  50
0873:  MOVLW  02
0874:  MOVWF  51
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   3E5
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  50
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   111
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:         "); 
0880:  MOVLW  6F
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   433
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  5F.3
088A:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11A
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  4A
0898:  MOVLW  96
0899:  MOVWF  50
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   111
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 4A,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   4F
08A2:  CLRF   4E
08A3:  CLRF   4D
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  4C
08A8:  MOVLW  0A
08A9:  MOVWF  50
08AA:  CLRF   52
08AB:  MOVLW  D7
08AC:  MOVWF  51
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   521
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  50
08B4:  MOVLW  02
08B5:  MOVWF  51
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   3E5
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  50
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   111
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  D7
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   641
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  50
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   111
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
08CE:  MOVLW  20
08CF:  BSF    03.6
08D0:  MOVWF  4F
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   3F9
08D4:  BSF    0A.3
08D5:  MOVLW  3A
08D6:  BSF    03.6
08D7:  MOVWF  4F
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   3F9
08DB:  BSF    0A.3
08DC:  MOVLW  20
08DD:  BSF    03.6
08DE:  MOVWF  4F
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   3F9
08E2:  BSF    0A.3
....................          DELAY_MS (1); 
08E3:  MOVLW  01
08E4:  BSF    03.6
08E5:  MOVWF  50
08E6:  BCF    0A.3
08E7:  BCF    03.6
08E8:  CALL   111
08E9:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EA:  MOVF   3A,W
08EB:  BSF    03.6
08EC:  MOVWF  4C
08ED:  CLRF   4E
08EE:  MOVLW  60
08EF:  MOVWF  4D
08F0:  BCF    0A.3
08F1:  BCF    03.6
08F2:  CALL   65E
08F3:  BSF    0A.3
08F4:  MOVLW  00
08F5:  BTFSC  78.0
08F6:  MOVLW  01
08F7:  BSF    03.6
08F8:  MOVWF  4A
08F9:  CLRF   4F
08FA:  CLRF   4E
08FB:  CLRF   4D
08FC:  MOVF   4A,W
08FD:  MOVWF  4C
08FE:  MOVLW  0A
08FF:  MOVWF  50
0900:  CLRF   52
0901:  MOVLW  D7
0902:  MOVWF  51
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   521
0906:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0907:  MOVLW  D7
0908:  MOVWF  04
0909:  BCF    03.7
090A:  BCF    0A.3
090B:  CALL   641
090C:  BSF    0A.3
....................          DELAY_MS (1); 
090D:  MOVLW  01
090E:  BSF    03.6
090F:  MOVWF  50
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   111
0913:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0914:  BSF    03.5
0915:  BCF    08.0
0916:  MOVLW  01
0917:  BCF    03.5
0918:  XORWF  08,F
....................       } 
0919:  GOTO   174
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091A:  BSF    03.5
091B:  BSF    06.3
091C:  BCF    03.5
091D:  BTFSC  06.3
091E:  GOTO   174
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
091F:  MOVF   3A,W
0920:  BSF    03.6
0921:  MOVWF  4C
0922:  CLRF   4E
0923:  MOVLW  60
0924:  MOVWF  4D
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   65E
0928:  BSF    0A.3
0929:  MOVLW  00
092A:  BTFSS  78.0
092B:  MOVLW  01
092C:  BSF    03.6
092D:  MOVWF  4A
092E:  BCF    03.6
092F:  MOVF   3A,W
0930:  BSF    03.6
0931:  MOVWF  4B
0932:  MOVF   4A,W
0933:  MOVWF  4C
0934:  CLRF   4E
0935:  MOVLW  60
0936:  MOVWF  4D
0937:  BCF    0A.3
0938:  BCF    03.6
0939:  CALL   677
093A:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
093B:  MOVLW  0D
093C:  BSF    03.6
093D:  MOVWF  50
093E:  MOVLW  02
093F:  MOVWF  51
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   3E5
0943:  BSF    0A.3
....................          DELAY_MS (300); 
0944:  MOVLW  02
0945:  BSF    03.6
0946:  MOVWF  4A
0947:  MOVLW  96
0948:  MOVWF  50
0949:  BCF    0A.3
094A:  BCF    03.6
094B:  CALL   111
094C:  BSF    0A.3
094D:  BSF    03.6
094E:  DECFSZ 4A,F
094F:  GOTO   147
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0950:  BCF    03.6
0951:  MOVF   3A,W
0952:  BSF    03.6
0953:  MOVWF  4C
0954:  CLRF   4E
0955:  MOVLW  60
0956:  MOVWF  4D
0957:  BCF    0A.3
0958:  BCF    03.6
0959:  CALL   65E
095A:  BSF    0A.3
095B:  MOVLW  00
095C:  BTFSC  78.0
095D:  MOVLW  01
095E:  BSF    03.6
095F:  MOVWF  4A
0960:  CLRF   4F
0961:  CLRF   4E
0962:  CLRF   4D
0963:  MOVF   4A,W
0964:  MOVWF  4C
0965:  MOVLW  0A
0966:  MOVWF  50
0967:  CLRF   52
0968:  MOVLW  D7
0969:  MOVWF  51
096A:  BCF    0A.3
096B:  BCF    03.6
096C:  CALL   521
096D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
096E:  MOVLW  D7
096F:  MOVWF  04
0970:  BCF    03.7
0971:  BCF    0A.3
0972:  CALL   641
0973:  BSF    0A.3
....................       } 
0974:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0976:  BCF    5F.1
....................    TT_STT = 1; 
0977:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0978:  MOVLW  01
0979:  BSF    03.6
097A:  MOVWF  50
097B:  MOVLW  02
097C:  MOVWF  51
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   3E5
0980:  BSF    0A.3
....................    DELAY_MS (10); 
0981:  MOVLW  0A
0982:  BSF    03.6
0983:  MOVWF  50
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   111
0987:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
0988:  MOVLW  78
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  MOVLW  00
098C:  MOVWF  0F
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   433
0990:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0991:  BTFSS  5F.3
0992:  GOTO   27D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0993:  BSF    03.5
0994:  BSF    06.2
0995:  BCF    03.5
0996:  BTFSC  06.2
0997:  GOTO   222
....................       { 
....................          STT_SENSOR ++; 
0998:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0999:  MOVF   3B,W
099A:  SUBLW  03
099B:  BTFSS  03.0
099C:  CLRF   3B
....................          DELAY_MS (300); 
099D:  MOVLW  02
099E:  BSF    03.6
099F:  MOVWF  4A
09A0:  MOVLW  96
09A1:  MOVWF  50
09A2:  BCF    0A.3
09A3:  BCF    03.6
09A4:  CALL   111
09A5:  BSF    0A.3
09A6:  BSF    03.6
09A7:  DECFSZ 4A,F
09A8:  GOTO   1A0
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09A9:  CLRF   4F
09AA:  CLRF   4E
09AB:  CLRF   4D
09AC:  BCF    03.6
09AD:  MOVF   3B,W
09AE:  BSF    03.6
09AF:  MOVWF  4C
09B0:  MOVLW  0A
09B1:  MOVWF  50
09B2:  CLRF   52
09B3:  MOVLW  D7
09B4:  MOVWF  51
09B5:  BCF    0A.3
09B6:  BCF    03.6
09B7:  CALL   521
09B8:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09B9:  MOVLW  09
09BA:  BSF    03.6
09BB:  MOVWF  50
09BC:  MOVLW  02
09BD:  MOVWF  51
09BE:  BCF    0A.3
09BF:  BCF    03.6
09C0:  CALL   3E5
09C1:  BSF    0A.3
....................          DELAY_MS (10); 
09C2:  MOVLW  0A
09C3:  BSF    03.6
09C4:  MOVWF  50
09C5:  BCF    0A.3
09C6:  BCF    03.6
09C7:  CALL   111
09C8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09C9:  MOVLW  D7
09CA:  MOVWF  04
09CB:  BCF    03.7
09CC:  BCF    0A.3
09CD:  CALL   641
09CE:  BSF    0A.3
....................          DELAY_MS (1); 
09CF:  MOVLW  01
09D0:  BSF    03.6
09D1:  MOVWF  50
09D2:  BCF    0A.3
09D3:  BCF    03.6
09D4:  CALL   111
09D5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
09D6:  MOVLW  20
09D7:  BSF    03.6
09D8:  MOVWF  4F
09D9:  BCF    0A.3
09DA:  BCF    03.6
09DB:  CALL   3F9
09DC:  BSF    0A.3
09DD:  MOVLW  3A
09DE:  BSF    03.6
09DF:  MOVWF  4F
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   3F9
09E3:  BSF    0A.3
09E4:  MOVLW  20
09E5:  BSF    03.6
09E6:  MOVWF  4F
09E7:  BCF    0A.3
09E8:  BCF    03.6
09E9:  CALL   3F9
09EA:  BSF    0A.3
....................          DELAY_MS (1); 
09EB:  MOVLW  01
09EC:  BSF    03.6
09ED:  MOVWF  50
09EE:  BCF    0A.3
09EF:  BCF    03.6
09F0:  CALL   111
09F1:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F2:  MOVF   3B,W
09F3:  BSF    03.6
09F4:  MOVWF  4C
09F5:  CLRF   4E
09F6:  MOVLW  61
09F7:  MOVWF  4D
09F8:  BCF    0A.3
09F9:  BCF    03.6
09FA:  CALL   65E
09FB:  BSF    0A.3
09FC:  MOVLW  00
09FD:  BTFSC  78.0
09FE:  MOVLW  01
09FF:  BSF    03.6
0A00:  MOVWF  4A
0A01:  CLRF   4F
0A02:  CLRF   4E
0A03:  CLRF   4D
0A04:  MOVF   4A,W
0A05:  MOVWF  4C
0A06:  MOVLW  0A
0A07:  MOVWF  50
0A08:  CLRF   52
0A09:  MOVLW  D7
0A0A:  MOVWF  51
0A0B:  BCF    0A.3
0A0C:  BCF    03.6
0A0D:  CALL   521
0A0E:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A0F:  MOVLW  D7
0A10:  MOVWF  04
0A11:  BCF    03.7
0A12:  BCF    0A.3
0A13:  CALL   641
0A14:  BSF    0A.3
....................          DELAY_MS (1); 
0A15:  MOVLW  01
0A16:  BSF    03.6
0A17:  MOVWF  50
0A18:  BCF    0A.3
0A19:  BCF    03.6
0A1A:  CALL   111
0A1B:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A1C:  BSF    03.5
0A1D:  BCF    08.0
0A1E:  MOVLW  01
0A1F:  BCF    03.5
0A20:  XORWF  08,F
....................       } 
0A21:  GOTO   27C
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A22:  BSF    03.5
0A23:  BSF    06.3
0A24:  BCF    03.5
0A25:  BTFSC  06.3
0A26:  GOTO   27C
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A27:  MOVF   3B,W
0A28:  BSF    03.6
0A29:  MOVWF  4C
0A2A:  CLRF   4E
0A2B:  MOVLW  61
0A2C:  MOVWF  4D
0A2D:  BCF    0A.3
0A2E:  BCF    03.6
0A2F:  CALL   65E
0A30:  BSF    0A.3
0A31:  MOVLW  00
0A32:  BTFSS  78.0
0A33:  MOVLW  01
0A34:  BSF    03.6
0A35:  MOVWF  4A
0A36:  BCF    03.6
0A37:  MOVF   3B,W
0A38:  BSF    03.6
0A39:  MOVWF  4B
0A3A:  MOVF   4A,W
0A3B:  MOVWF  4C
0A3C:  CLRF   4E
0A3D:  MOVLW  61
0A3E:  MOVWF  4D
0A3F:  BCF    0A.3
0A40:  BCF    03.6
0A41:  CALL   677
0A42:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A43:  MOVLW  0D
0A44:  BSF    03.6
0A45:  MOVWF  50
0A46:  MOVLW  02
0A47:  MOVWF  51
0A48:  BCF    0A.3
0A49:  BCF    03.6
0A4A:  CALL   3E5
0A4B:  BSF    0A.3
....................          DELAY_MS (300); 
0A4C:  MOVLW  02
0A4D:  BSF    03.6
0A4E:  MOVWF  4A
0A4F:  MOVLW  96
0A50:  MOVWF  50
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   111
0A54:  BSF    0A.3
0A55:  BSF    03.6
0A56:  DECFSZ 4A,F
0A57:  GOTO   24F
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A58:  BCF    03.6
0A59:  MOVF   3B,W
0A5A:  BSF    03.6
0A5B:  MOVWF  4C
0A5C:  CLRF   4E
0A5D:  MOVLW  61
0A5E:  MOVWF  4D
0A5F:  BCF    0A.3
0A60:  BCF    03.6
0A61:  CALL   65E
0A62:  BSF    0A.3
0A63:  MOVLW  00
0A64:  BTFSC  78.0
0A65:  MOVLW  01
0A66:  BSF    03.6
0A67:  MOVWF  4A
0A68:  CLRF   4F
0A69:  CLRF   4E
0A6A:  CLRF   4D
0A6B:  MOVF   4A,W
0A6C:  MOVWF  4C
0A6D:  MOVLW  0A
0A6E:  MOVWF  50
0A6F:  CLRF   52
0A70:  MOVLW  D7
0A71:  MOVWF  51
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   521
0A75:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A76:  MOVLW  D7
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  BCF    0A.3
0A7A:  CALL   641
0A7B:  BSF    0A.3
....................       } 
0A7C:  GOTO   191
....................  
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0A7E:  BCF    5F.1
....................    TT_STT = 1; 
0A7F:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0A80:  MOVLW  01
0A81:  BSF    03.6
0A82:  MOVWF  50
0A83:  MOVLW  02
0A84:  MOVWF  51
0A85:  BCF    0A.3
0A86:  BCF    03.6
0A87:  CALL   3E5
0A88:  BSF    0A.3
....................    DELAY_MS (10); 
0A89:  MOVLW  0A
0A8A:  BSF    03.6
0A8B:  MOVWF  50
0A8C:  BCF    0A.3
0A8D:  BCF    03.6
0A8E:  CALL   111
0A8F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:  1234    "); 
0A90:  MOVLW  81
0A91:  BSF    03.6
0A92:  MOVWF  0D
0A93:  MOVLW  00
0A94:  MOVWF  0F
0A95:  BCF    0A.3
0A96:  BCF    03.6
0A97:  CALL   433
0A98:  BSF    0A.3
....................    ID_GW = "1234"; 
0A99:  BSF    03.6
0A9A:  CLRF   4A
0A9B:  CLRF   4B
0A9C:  MOVLW  D3
0A9D:  MOVWF  04
0A9E:  BCF    03.7
0A9F:  MOVF   4A,W
0AA0:  ADDWF  04,F
0AA1:  MOVF   4B,W
0AA2:  BCF    0A.3
0AA3:  BCF    03.6
0AA4:  CALL   058
0AA5:  BSF    0A.3
0AA6:  MOVWF  00
0AA7:  IORLW  00
0AA8:  BTFSC  03.2
0AA9:  GOTO   2AF
0AAA:  BSF    03.6
0AAB:  INCF   4B,F
0AAC:  INCF   4A,F
0AAD:  GOTO   29C
0AAE:  BCF    03.6
....................    WHILE (TT_STT) 
0AAF:  BTFSS  5F.3
0AB0:  GOTO   2BE
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0AB1:  BSF    03.5
0AB2:  BSF    06.2
0AB3:  BCF    03.5
0AB4:  BTFSC  06.2
0AB5:  GOTO   2B8
....................       { 
....................          TT_CONFIG_DONE = 0; 
0AB6:  BCF    5F.1
....................       } 
0AB7:  GOTO   2BD
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0AB8:  BSF    03.5
0AB9:  BSF    06.3
0ABA:  BCF    03.5
0ABB:  BTFSS  06.3
....................       { 
....................          TT_CONFIG_DONE = 0; 
0ABC:  BCF    5F.1
....................       } 
0ABD:  GOTO   2AF
....................  
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00EA:  BCF    03.5
00EB:  BCF    03.6
00EC:  BCF    5F.1
....................    TT_FUN = 0; 
00ED:  BCF    5F.2
....................    TT_STT = 0; 
00EE:  BCF    5F.3
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   2BE
0805:  ADDLW  04
0806:  GOTO   2C1
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   2BE
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0975:  GOTO   2BE
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A7D:  GOTO   2BE
....................  
....................       CASE 3: 
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
*
0ABE:  BCF    0A.3
0ABF:  BCF    0A.4
0AC0:  GOTO   71B (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0699:  BSF    5F.2
....................    LCD_GOTOXY (1, 1) ; 
069A:  MOVLW  01
069B:  BSF    03.6
069C:  MOVWF  50
069D:  MOVWF  51
069E:  BCF    03.6
069F:  CALL   3E5
....................    DELAY_MS (10); 
06A0:  MOVLW  0A
06A1:  BSF    03.6
06A2:  MOVWF  50
06A3:  BCF    03.6
06A4:  CALL   111
....................    PRINTF (LCD_PUTC, "CONFIG:         "); 
06A5:  MOVLW  8A
06A6:  BSF    03.6
06A7:  MOVWF  0D
06A8:  MOVLW  00
06A9:  MOVWF  0F
06AA:  BCF    03.6
06AB:  CALL   433
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
06AC:  MOVLW  01
06AD:  BSF    03.6
06AE:  MOVWF  50
06AF:  MOVLW  02
06B0:  MOVWF  51
06B1:  BCF    03.6
06B2:  CALL   3E5
....................    DELAY_MS (10); 
06B3:  MOVLW  0A
06B4:  BSF    03.6
06B5:  MOVWF  50
06B6:  BCF    03.6
06B7:  CALL   111
....................    PRINTF (LCD_PUTC, "CASE:           "); 
06B8:  MOVLW  93
06B9:  BSF    03.6
06BA:  MOVWF  0D
06BB:  MOVLW  00
06BC:  MOVWF  0F
06BD:  BCF    03.6
06BE:  CALL   433
....................  
....................    WHILE (TT_FUN) 
06BF:  BTFSS  5F.2
06C0:  GOTO   717
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
06C1:  BSF    03.5
06C2:  BSF    06.2
06C3:  BCF    03.5
06C4:  BTFSC  06.2
06C5:  GOTO   716
....................       { 
....................          CONFIG_FUN ++;          
06C6:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
06C7:  MOVLW  03
06C8:  ANDWF  38,F
....................          DELAY_MS (300);          
06C9:  MOVLW  02
06CA:  BSF    03.6
06CB:  MOVWF  4A
06CC:  MOVLW  96
06CD:  MOVWF  50
06CE:  BCF    03.6
06CF:  CALL   111
06D0:  BSF    03.6
06D1:  DECFSZ 4A,F
06D2:  GOTO   6CC
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
06D3:  MOVLW  06
06D4:  MOVWF  50
06D5:  MOVLW  02
06D6:  MOVWF  51
06D7:  BCF    03.6
06D8:  CALL   3E5
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
06D9:  BSF    03.6
06DA:  CLRF   4F
06DB:  CLRF   4E
06DC:  CLRF   4D
06DD:  BCF    03.6
06DE:  MOVF   38,W
06DF:  BSF    03.6
06E0:  MOVWF  4C
06E1:  MOVLW  0A
06E2:  MOVWF  50
06E3:  CLRF   52
06E4:  MOVLW  D7
06E5:  MOVWF  51
06E6:  BCF    03.6
06E7:  CALL   521
....................          DELAY_MS (10); 
06E8:  MOVLW  0A
06E9:  BSF    03.6
06EA:  MOVWF  50
06EB:  BCF    03.6
06EC:  CALL   111
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06ED:  MOVLW  D7
06EE:  MOVWF  04
06EF:  BCF    03.7
06F0:  CALL   641
....................          SWITCH (CONFIG_FUN) 
06F1:  MOVF   38,W
06F2:  ADDLW  FC
06F3:  BTFSC  03.0
06F4:  GOTO   716
06F5:  ADDLW  04
06F6:  GOTO   71F
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, "- ID     "); 
06F7:  MOVLW  9C
06F8:  BSF    03.6
06F9:  MOVWF  0D
06FA:  MOVLW  00
06FB:  MOVWF  0F
06FC:  BCF    03.6
06FD:  CALL   433
....................             BREAK;       
06FE:  GOTO   716
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, "- DEVICES"); 
06FF:  MOVLW  A1
0700:  BSF    03.6
0701:  MOVWF  0D
0702:  MOVLW  00
0703:  MOVWF  0F
0704:  BCF    03.6
0705:  CALL   433
....................             BREAK; 
0706:  GOTO   716
....................        
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, "- SENSORS"); 
0707:  MOVLW  A6
0708:  BSF    03.6
0709:  MOVWF  0D
070A:  MOVLW  00
070B:  MOVWF  0F
070C:  BCF    03.6
070D:  CALL   433
....................             BREAK; 
070E:  GOTO   716
....................        
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, "- RESET  "); 
070F:  MOVLW  AB
0710:  BSF    03.6
0711:  MOVWF  0D
0712:  MOVLW  00
0713:  MOVWF  0F
0714:  BCF    03.6
0715:  CALL   433
....................             BREAK;  
....................          } 
....................       } 
0716:  GOTO   6BF
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0717:  BTFSC  5F.1
0718:  GOTO   71C
....................    { 
....................       SELLECT_FUN (); 
0719:  BSF    0A.3
071A:  GOTO   000
071B:  BCF    0A.3
....................    } 
071C:  BSF    0A.3
071D:  BCF    0A.4
071E:  GOTO   5A8 (RETURN)
....................  
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    *TEMP_CHAR2 = '\0'; 
*
0B0F:  CLRF   7A
0B10:  MOVLW  DB
0B11:  MOVWF  04
0B12:  BCF    03.7
0B13:  BTFSC  7A.0
0B14:  BSF    03.7
0B15:  CLRF   00
....................    *TT_DEVICE_CHAR = '\0'; 
0B16:  CLRF   7A
0B17:  MOVLW  62
0B18:  MOVWF  04
0B19:  BCF    03.7
0B1A:  BTFSC  7A.0
0B1B:  BSF    03.7
0B1C:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
0B1D:  BSF    03.6
0B1E:  CLRF   4B
0B1F:  MOVF   4B,W
0B20:  SUBLW  07
0B21:  BTFSS  03.0
0B22:  GOTO   352
....................    { 
....................       IF (TT_DEVICE[I]) 
0B23:  MOVF   4B,W
0B24:  MOVWF  4C
0B25:  CLRF   4E
0B26:  MOVLW  60
0B27:  MOVWF  4D
0B28:  BCF    0A.3
0B29:  BCF    03.6
0B2A:  CALL   65E
0B2B:  BSF    0A.3
0B2C:  BTFSS  78.0
0B2D:  GOTO   34F
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
0B2E:  BSF    03.6
0B2F:  CLRF   4F
0B30:  CLRF   4E
0B31:  CLRF   4D
0B32:  MOVF   4B,W
0B33:  MOVWF  4C
0B34:  MOVLW  0A
0B35:  MOVWF  50
0B36:  CLRF   52
0B37:  MOVLW  DB
0B38:  MOVWF  51
0B39:  BCF    0A.3
0B3A:  BCF    03.6
0B3B:  CALL   521
0B3C:  BSF    0A.3
....................          DELAY_MS (1); 
0B3D:  MOVLW  01
0B3E:  BSF    03.6
0B3F:  MOVWF  50
0B40:  BCF    0A.3
0B41:  BCF    03.6
0B42:  CALL   111
0B43:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0B44:  BSF    03.6
0B45:  CLRF   4D
0B46:  MOVLW  62
0B47:  MOVWF  4C
0B48:  CLRF   4F
0B49:  MOVLW  DB
0B4A:  MOVWF  4E
0B4B:  BCF    0A.3
0B4C:  BCF    03.6
0B4D:  CALL   727
0B4E:  BSF    0A.3
....................       } 
0B4F:  BSF    03.6
0B50:  INCF   4B,F
0B51:  GOTO   31F
....................    } 
.................... //   PACKAGE_CONFIG[6] = TT_DEVICE_CHAR;      
.................... } 
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    *TEMP_CHAR2 = '\0'; 
0B52:  CLRF   7A
0B53:  MOVLW  DB
0B54:  MOVWF  04
0B55:  BCF    03.7
0B56:  BTFSC  7A.0
0B57:  BSF    03.7
0B58:  CLRF   00
....................    *TEMP_CHAR3 = '\0';   
0B59:  CLRF   7A
0B5A:  MOVLW  DF
0B5B:  MOVWF  04
0B5C:  BCF    03.7
0B5D:  BTFSC  7A.0
0B5E:  BSF    03.7
0B5F:  CLRF   00
....................   
....................    FOR (INT J = 0; J < 5; J++) 
0B60:  CLRF   4B
0B61:  MOVF   4B,W
0B62:  SUBLW  04
0B63:  BTFSS  03.0
0B64:  GOTO   394
....................    { 
....................       IF (TT_SENSOR[J]) 
0B65:  MOVF   4B,W
0B66:  MOVWF  4C
0B67:  CLRF   4E
0B68:  MOVLW  61
0B69:  MOVWF  4D
0B6A:  BCF    0A.3
0B6B:  BCF    03.6
0B6C:  CALL   65E
0B6D:  BSF    0A.3
0B6E:  BTFSS  78.0
0B6F:  GOTO   391
....................       { 
....................          ITOA (J, 10, TEMP_CHAR2); 
0B70:  BSF    03.6
0B71:  CLRF   4F
0B72:  CLRF   4E
0B73:  CLRF   4D
0B74:  MOVF   4B,W
0B75:  MOVWF  4C
0B76:  MOVLW  0A
0B77:  MOVWF  50
0B78:  CLRF   52
0B79:  MOVLW  DB
0B7A:  MOVWF  51
0B7B:  BCF    0A.3
0B7C:  BCF    03.6
0B7D:  CALL   521
0B7E:  BSF    0A.3
....................          DELAY_MS (1); 
0B7F:  MOVLW  01
0B80:  BSF    03.6
0B81:  MOVWF  50
0B82:  BCF    0A.3
0B83:  BCF    03.6
0B84:  CALL   111
0B85:  BSF    0A.3
....................          STRCAT (TEMP_CHAR3, TEMP_CHAR2);         
0B86:  BSF    03.6
0B87:  CLRF   4D
0B88:  MOVLW  DF
0B89:  MOVWF  4C
0B8A:  CLRF   4F
0B8B:  MOVLW  DB
0B8C:  MOVWF  4E
0B8D:  BCF    0A.3
0B8E:  BCF    03.6
0B8F:  CALL   727
0B90:  BSF    0A.3
....................       } 
0B91:  BSF    03.6
0B92:  INCF   4B,F
0B93:  GOTO   361
....................    }   
....................    //PACKAGE_CONFIG[7] = TEMP_CHAR3;  
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................  
....................    TT_FUN = 0; 
*
0AC9:  BCF    5F.2
....................    TT_STT = 0; 
0ACA:  BCF    5F.3
....................    PACKAGE_CONFIG[1] = ID_GW;  
0ACB:  BSF    03.5
0ACC:  CLRF   3D
0ACD:  MOVLW  D3
0ACE:  MOVWF  3C
....................    DELAY_MS(2); 
0ACF:  MOVLW  02
0AD0:  BCF    03.5
0AD1:  BSF    03.6
0AD2:  MOVWF  50
0AD3:  BCF    0A.3
0AD4:  BCF    03.6
0AD5:  CALL   111
0AD6:  BSF    0A.3
....................    PACKAGE_CONFIG[2] = ID_;    
0AD7:  BSF    03.5
0AD8:  CLRF   3F
0AD9:  MOVLW  CF
0ADA:  MOVWF  3E
....................    DELAY_MS(2); 
0ADB:  MOVLW  02
0ADC:  BCF    03.5
0ADD:  BSF    03.6
0ADE:  MOVWF  50
0ADF:  BCF    0A.3
0AE0:  BCF    03.6
0AE1:  CALL   111
0AE2:  BSF    0A.3
....................    TT_DEVICE_CHAR = ""; 
0AE3:  BSF    03.6
0AE4:  CLRF   4B
0AE5:  CLRF   4C
0AE6:  MOVLW  62
0AE7:  MOVWF  04
0AE8:  BCF    03.7
0AE9:  MOVF   4B,W
0AEA:  ADDWF  04,F
0AEB:  MOVF   4C,W
0AEC:  BCF    0A.3
0AED:  BCF    03.6
0AEE:  CALL   061
0AEF:  BSF    0A.3
0AF0:  MOVWF  00
0AF1:  IORLW  00
0AF2:  BTFSC  03.2
0AF3:  GOTO   2F9
0AF4:  BSF    03.6
0AF5:  INCF   4C,F
0AF6:  INCF   4B,F
0AF7:  GOTO   2E6
0AF8:  BCF    03.6
....................    TT_SENSOR_CHAR = "";    
0AF9:  BSF    03.6
0AFA:  CLRF   4B
0AFB:  CLRF   4C
0AFC:  MOVLW  66
0AFD:  MOVWF  04
0AFE:  BCF    03.7
0AFF:  MOVF   4B,W
0B00:  ADDWF  04,F
0B01:  MOVF   4C,W
0B02:  BCF    0A.3
0B03:  BCF    03.6
0B04:  CALL   061
0B05:  BSF    0A.3
0B06:  MOVWF  00
0B07:  IORLW  00
0B08:  BTFSC  03.2
0B09:  GOTO   30F
0B0A:  BSF    03.6
0B0B:  INCF   4C,F
0B0C:  INCF   4B,F
0B0D:  GOTO   2FC
0B0E:  BCF    03.6
....................    XULYDEVICE_CF(); 
....................    XULYSENSOR_CF(); 
....................    PACKAGE_CONFIG[6] = TT_DEVICE_CHAR;   
*
0B94:  BSF    03.5
0B95:  BCF    03.6
0B96:  CLRF   47
0B97:  MOVLW  62
0B98:  MOVWF  46
....................    DELAY_MS(2); 
0B99:  MOVLW  02
0B9A:  BCF    03.5
0B9B:  BSF    03.6
0B9C:  MOVWF  50
0B9D:  BCF    0A.3
0B9E:  BCF    03.6
0B9F:  CALL   111
0BA0:  BSF    0A.3
....................    PACKAGE_CONFIG[7] = TEMP_CHAR3;  
0BA1:  BSF    03.5
0BA2:  CLRF   49
0BA3:  MOVLW  DF
0BA4:  MOVWF  48
....................     
....................    
....................  
....................     
....................    FOR (INT J = 0; J < 9; J++) 
0BA5:  BCF    03.5
0BA6:  BSF    03.6
0BA7:  CLRF   4A
0BA8:  MOVF   4A,W
0BA9:  SUBLW  08
0BAA:  BTFSS  03.0
0BAB:  GOTO   3C6
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0BAC:  BCF    03.0
0BAD:  RLF    4A,W
0BAE:  ADDLW  BA
0BAF:  MOVWF  04
0BB0:  BCF    03.7
0BB1:  INCF   04,F
0BB2:  MOVF   00,W
0BB3:  MOVWF  4C
0BB4:  DECF   04,F
0BB5:  MOVF   00,W
0BB6:  MOVWF  4B
0BB7:  MOVWF  04
0BB8:  BCF    03.7
0BB9:  BTFSC  4C.0
0BBA:  BSF    03.7
0BBB:  BCF    0A.3
0BBC:  BCF    03.6
0BBD:  CALL   765
0BBE:  BSF    0A.3
....................       PRINTF ("@"); 
0BBF:  MOVLW  40
0BC0:  BTFSS  0C.4
0BC1:  GOTO   3C0
0BC2:  MOVWF  19
0BC3:  BSF    03.6
0BC4:  INCF   4A,F
0BC5:  GOTO   3A8
....................    } 
....................     
....................    LCD_GOTOXY (1, 1) ; 
0BC6:  MOVLW  01
0BC7:  MOVWF  50
0BC8:  MOVWF  51
0BC9:  BCF    0A.3
0BCA:  BCF    03.6
0BCB:  CALL   3E5
0BCC:  BSF    0A.3
....................    DELAY_MS (10);    
0BCD:  MOVLW  0A
0BCE:  BSF    03.6
0BCF:  MOVWF  50
0BD0:  BCF    0A.3
0BD1:  BCF    03.6
0BD2:  CALL   111
0BD3:  BSF    0A.3
....................    FOR ( J = 0; J < 9; J++) 
0BD4:  BSF    03.6
0BD5:  CLRF   4A
0BD6:  MOVF   4A,W
0BD7:  SUBLW  08
0BD8:  BTFSS  03.0
0BD9:  GOTO   3F0
....................    { 
....................       PRINTF (LCD_PUTC, PACKAGE_CONFIG[J]); 
0BDA:  BCF    03.0
0BDB:  RLF    4A,W
0BDC:  ADDLW  BA
0BDD:  MOVWF  04
0BDE:  BCF    03.7
0BDF:  INCF   04,F
0BE0:  MOVF   00,W
0BE1:  MOVWF  4C
0BE2:  DECF   04,F
0BE3:  MOVF   00,W
0BE4:  MOVWF  4B
0BE5:  MOVWF  04
0BE6:  BCF    03.7
0BE7:  BTFSC  4C.0
0BE8:  BSF    03.7
0BE9:  BCF    0A.3
0BEA:  BCF    03.6
0BEB:  CALL   641
0BEC:  BSF    0A.3
0BED:  BSF    03.6
0BEE:  INCF   4A,F
0BEF:  GOTO   3D6
....................    }    
....................  
....................    LCD_GOTOXY (1, 1) ; 
0BF0:  MOVLW  01
0BF1:  MOVWF  50
0BF2:  MOVWF  51
0BF3:  BCF    0A.3
0BF4:  BCF    03.6
0BF5:  CALL   3E5
0BF6:  BSF    0A.3
....................    DELAY_MS (10); 
0BF7:  MOVLW  0A
0BF8:  BSF    03.6
0BF9:  MOVWF  50
0BFA:  BCF    0A.3
0BFB:  BCF    03.6
0BFC:  CALL   111
0BFD:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE"); 
0BFE:  MOVLW  B0
0BFF:  BSF    03.6
0C00:  MOVWF  0D
0C01:  MOVLW  00
0C02:  MOVWF  0F
0C03:  BCF    0A.3
0C04:  BCF    03.6
0C05:  CALL   433
0C06:  BSF    0A.3
....................  
....................    LCD_GOTOXY (1, 2) ; 
0C07:  MOVLW  01
0C08:  BSF    03.6
0C09:  MOVWF  50
0C0A:  MOVLW  02
0C0B:  MOVWF  51
0C0C:  BCF    0A.3
0C0D:  BCF    03.6
0C0E:  CALL   3E5
0C0F:  BSF    0A.3
....................    DELAY_MS (10); 
0C10:  MOVLW  0A
0C11:  BSF    03.6
0C12:  MOVWF  50
0C13:  BCF    0A.3
0C14:  BCF    03.6
0C15:  CALL   111
0C16:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE");    
0C17:  MOVLW  B6
0C18:  BSF    03.6
0C19:  MOVWF  0D
0C1A:  MOVLW  00
0C1B:  MOVWF  0F
0C1C:  BCF    0A.3
0C1D:  BCF    03.6
0C1E:  CALL   433
0C1F:  BSF    0A.3
....................    PACKAGE_NHIETDO[1] = ID_; 
0C20:  CLRF   6D
0C21:  MOVLW  CF
0C22:  MOVWF  6C
....................    TT_CONFIG_DONE = 0; 
0C23:  BCF    5F.1
0C24:  BSF    0A.3
0C25:  BCF    0A.4
0C26:  GOTO   5AD (RETURN)
.................... } 
....................  
....................  
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID QUET_PHIM() 
*
00BC:  BSF    03.5
00BD:  BSF    03.6
00BE:  CLRF   16
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00BF:  BCF    03.6
00C0:  BSF    06.1
00C1:  BCF    03.5
00C2:  BTFSC  06.1
00C3:  GOTO   0DB
....................    { 
....................       IF (TMR1IF) 
00C4:  BTFSS  0C.0
00C5:  GOTO   0D6
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00C6:  BSF    03.5
00C7:  BCF    08.2
00C8:  MOVLW  04
00C9:  BCF    03.5
00CA:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00CB:  BCF    0C.0
00CC:  CLRF   0E
00CD:  MOVLW  0B
00CE:  MOVWF  0F
00CF:  MOVLW  DC
00D0:  MOVWF  0E
00D1:  BSF    03.5
00D2:  BSF    03.6
00D3:  INCF   16,F
00D4:  BCF    03.5
00D5:  BCF    03.6
....................       } 
00D6:  BSF    03.5
00D7:  BSF    03.6
00D8:  GOTO   0BF
00D9:  BCF    03.5
00DA:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00DB:  BSF    03.5
00DC:  BSF    03.6
00DD:  MOVF   16,W
00DE:  SUBLW  14
00DF:  BTFSC  03.0
00E0:  GOTO   0EA
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00E1:  MOVLW  01
00E2:  BCF    03.5
00E3:  BCF    03.6
00E4:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00E5:  BSF    5F.1
....................       TT_FUN = 0; 
00E6:  BCF    5F.2
....................    } 
00E7:  GOTO   0EF
00E8:  BSF    03.5
00E9:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
00EF:  BCF    0B.1
00F0:  BCF    0A.3
00F1:  BCF    0A.4
00F2:  GOTO   031
....................  #INT_RDA 
....................  
....................  VOID NGAT() 
....................  { 
....................     KYTU[VT] = GETCH (); 
00F3:  MOVLW  3C
00F4:  ADDWF  5A,W
00F5:  MOVWF  04
00F6:  BCF    03.7
00F7:  BTFSS  0C.5
00F8:  GOTO   0F7
00F9:  MOVF   1A,W
00FA:  MOVWF  00
....................  
....................     IF (KYTU[VT] == '.') 
00FB:  MOVLW  3C
00FC:  ADDWF  5A,W
00FD:  MOVWF  04
00FE:  BCF    03.7
00FF:  MOVF   00,W
0100:  SUBLW  2E
0101:  BTFSS  03.2
0102:  GOTO   10C
....................     { 
....................        KYTU[VT] = '\0'; 
0103:  MOVLW  3C
0104:  ADDWF  5A,W
0105:  MOVWF  04
0106:  BCF    03.7
0107:  CLRF   00
....................        VT = 0; 
0108:  CLRF   5A
....................        TTNHAN = 1; 
0109:  MOVLW  01
010A:  MOVWF  5B
....................     } 
010B:  GOTO   10D
....................  
....................     ELSE 
....................     VT++; 
010C:  INCF   5A,F
010D:  BCF    0C.5
010E:  BCF    0A.3
010F:  BCF    0A.4
0110:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
079B:  MOVLW  01
079C:  BSF    03.6
079D:  MOVWF  50
079E:  MOVWF  51
079F:  BCF    03.6
07A0:  CALL   3E5
....................     DELAY_MS (10); 
07A1:  MOVLW  0A
07A2:  BSF    03.6
07A3:  MOVWF  50
07A4:  BCF    03.6
07A5:  CALL   111
....................     PRINTF (LCD_PUTC, KYTU); 
07A6:  MOVLW  3C
07A7:  MOVWF  04
07A8:  BCF    03.7
07A9:  CALL   641
....................     DELAY_MS (1); 
07AA:  MOVLW  01
07AB:  BSF    03.6
07AC:  MOVWF  50
07AD:  BCF    03.6
07AE:  CALL   111
07AF:  BSF    0A.3
07B0:  BCF    0A.4
07B1:  GOTO   626 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
0291:  BSF    03.6
0292:  RLF    4A,W
0293:  MOVWF  77
0294:  RLF    77,F
0295:  MOVLW  FC
0296:  ANDWF  77,F
0297:  BCF    03.6
0298:  MOVF   1F,W
0299:  ANDLW  C3
029A:  IORWF  77,W
029B:  MOVWF  1F
....................     KQADC = 0; 
029C:  CLRF   33
029D:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
029E:  BSF    03.6
029F:  CLRF   4B
02A0:  MOVF   4B,W
02A1:  SUBLW  63
02A2:  BTFSS  03.0
02A3:  GOTO   2B8
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
02A4:  BCF    03.6
02A5:  BSF    1F.1
02A6:  BTFSC  1F.1
02A7:  GOTO   2A6
02A8:  BSF    03.5
02A9:  MOVF   1E,W
02AA:  BCF    03.5
02AB:  ADDWF  32,F
02AC:  MOVF   1E,W
02AD:  BTFSC  03.0
02AE:  INCFSZ 1E,W
02AF:  ADDWF  33,F
....................        DELAY_MS (1); 
02B0:  MOVLW  01
02B1:  BSF    03.6
02B2:  MOVWF  50
02B3:  BCF    03.6
02B4:  CALL   111
02B5:  BSF    03.6
02B6:  INCF   4B,F
02B7:  GOTO   2A0
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
02B8:  BCF    03.6
02B9:  MOVF   33,W
02BA:  BSF    03.6
02BB:  MOVWF  4D
02BC:  BCF    03.6
02BD:  MOVF   32,W
02BE:  BSF    03.6
02BF:  MOVWF  4C
*
02DC:  MOVF   7A,W
02DD:  MOVWF  4F
02DE:  MOVF   79,W
02DF:  MOVWF  4E
02E0:  MOVF   78,W
02E1:  MOVWF  4D
02E2:  MOVF   77,W
02E3:  MOVWF  4C
02E4:  MOVLW  9A
02E5:  MOVWF  53
02E6:  MOVLW  99
02E7:  MOVWF  52
02E8:  MOVLW  4C
02E9:  MOVWF  51
02EA:  MOVLW  86
02EB:  MOVWF  50
*
03B5:  MOVF   7A,W
03B6:  MOVWF  4F
03B7:  MOVF   79,W
03B8:  MOVWF  4E
03B9:  MOVF   78,W
03BA:  MOVWF  4D
03BB:  MOVF   77,W
03BC:  MOVWF  4C
*
03DB:  MOVF   79,W
03DC:  BCF    03.6
03DD:  MOVWF  33
03DE:  MOVF   78,W
03DF:  MOVWF  32
....................     RETURN KQADC; 
03E0:  MOVF   32,W
03E1:  MOVWF  78
03E2:  BSF    0A.3
03E3:  BCF    0A.4
03E4:  GOTO   5A0 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0783:  BSF    03.6
0784:  CLRF   4A
0785:  MOVF   4A,W
0786:  SUBLW  1E
0787:  BTFSS  03.0
0788:  GOTO   797
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
0789:  BSF    03.5
078A:  BCF    03.6
078B:  BCF    08.1
078C:  MOVLW  02
078D:  BCF    03.5
078E:  XORWF  08,F
....................        DELAY_MS (100); 
078F:  MOVLW  64
0790:  BSF    03.6
0791:  MOVWF  50
0792:  BCF    03.6
0793:  CALL   111
0794:  BSF    03.6
0795:  INCF   4A,F
0796:  GOTO   785
....................     } 
0797:  BCF    03.6
0798:  BSF    0A.3
0799:  BCF    0A.4
079A:  GOTO   5B2 (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
0C27:  MOVF   03,W
0C28:  ANDLW  1F
0C29:  MOVWF  03
0C2A:  BSF    03.5
0C2B:  BSF    03.6
0C2C:  BSF    07.3
0C2D:  MOVLW  08
0C2E:  BCF    03.6
0C2F:  MOVWF  19
0C30:  MOVLW  02
0C31:  MOVWF  1A
0C32:  MOVLW  A6
0C33:  MOVWF  18
0C34:  MOVLW  90
0C35:  BCF    03.5
0C36:  MOVWF  18
0C37:  MOVLW  FF
0C38:  MOVWF  31
0C39:  CLRF   38
0C3A:  CLRF   39
0C3B:  CLRF   3A
0C3C:  CLRF   3B
0C3D:  CLRF   5A
0C3E:  CLRF   5B
0C3F:  BCF    5F.0
0C40:  BCF    5F.1
0C41:  BCF    5F.2
0C42:  BCF    5F.3
0C43:  BSF    03.5
0C44:  BSF    03.6
0C45:  MOVF   09,W
0C46:  ANDLW  C0
0C47:  MOVWF  09
0C48:  BCF    03.6
0C49:  BCF    1F.4
0C4A:  BCF    1F.5
0C4B:  MOVLW  00
0C4C:  BSF    03.6
0C4D:  MOVWF  08
0C4E:  BCF    03.5
0C4F:  CLRF   07
0C50:  CLRF   08
0C51:  CLRF   09
0C52:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0D60:  MOVLW  00
0D61:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0D62:  MOVLW  FF
0D63:  MOVWF  06
....................     SET_TRIS_E (0); 
0D64:  BCF    09.0
0D65:  BCF    09.1
0D66:  BCF    09.2
0D67:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0D68:  MOVLW  80
0D69:  MOVWF  07
0D6A:  BCF    03.5
0D6B:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0D6C:  BSF    1F.6
0D6D:  BCF    1F.7
0D6E:  BSF    03.5
0D6F:  BSF    1F.7
0D70:  BCF    03.5
0D71:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0D72:  BSF    03.5
0D73:  BSF    03.6
0D74:  MOVF   09,W
0D75:  ANDLW  C0
0D76:  MOVWF  09
0D77:  BCF    03.6
0D78:  BCF    1F.4
0D79:  BCF    1F.5
0D7A:  MOVLW  01
0D7B:  BSF    03.6
0D7C:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0D7D:  BCF    03.5
0D7E:  BCF    03.6
0D7F:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0D80:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0D81:  BSF    0B.4
0D82:  BSF    03.5
0D83:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0D84:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0D85:  MOVLW  C0
0D86:  BCF    03.5
0D87:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0D88:  MOVLW  35
0D89:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0D8A:  CLRF   0E
0D8B:  MOVLW  0B
0D8C:  MOVWF  0F
0D8D:  MOVLW  DC
0D8E:  MOVWF  0E
....................     TMR1IF = 0; 
0D8F:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0D90:  BCF    0A.3
0D91:  GOTO   22B
0D92:  BSF    0A.3
....................     ID_NODE = 0; 
0D93:  CLRF   39
....................     TT_CONFIG = 0; 
0D94:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0D95:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0D96:  BSF    03.5
0D97:  CLRF   08
0D98:  BCF    03.5
0D99:  CLRF   08
....................     TTNHAN = 0; 
0D9A:  CLRF   5B
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0D9B:  BSF    03.6
0D9C:  CLRF   4A
0D9D:  BCF    0A.3
0D9E:  BCF    03.6
0D9F:  GOTO   291
0DA0:  BSF    0A.3
0DA1:  CLRF   35
0DA2:  MOVF   78,W
0DA3:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0DA4:  BTFSS  5F.0
0DA5:  GOTO   5AA
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0DA6:  BCF    0A.3
0DA7:  GOTO   699
0DA8:  BSF    0A.3
....................        } 
0DA9:  GOTO   649
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0DAA:  BTFSS  5F.1
0DAB:  GOTO   5AE
....................        { 
....................           CONFIG_DONE (); 
0DAC:  GOTO   2C9
....................        } 
0DAD:  GOTO   649
....................  
....................         
....................        ELSE 
....................        {                    
....................             WHILE(!TT_CONFIG) 
0DAE:  BTFSC  5F.0
0DAF:  GOTO   649
....................             { 
....................                 CHUONG_TRINH_CON (); 
0DB0:  BCF    0A.3
0DB1:  GOTO   783
0DB2:  BSF    0A.3
....................                 IF (AN0 > 26) 
0DB3:  MOVF   35,F
0DB4:  BTFSS  03.2
0DB5:  GOTO   5BA
0DB6:  MOVF   34,W
0DB7:  SUBLW  1A
0DB8:  BTFSC  03.0
0DB9:  GOTO   617
....................                 { 
....................                    ITOA (AN0, 10, NHIETDO1); 
0DBA:  BSF    03.6
0DBB:  CLRF   4F
0DBC:  CLRF   4E
0DBD:  BCF    03.6
0DBE:  MOVF   35,W
0DBF:  BSF    03.6
0DC0:  MOVWF  4D
0DC1:  BCF    03.6
0DC2:  MOVF   34,W
0DC3:  BSF    03.6
0DC4:  MOVWF  4C
0DC5:  MOVLW  0A
0DC6:  MOVWF  50
0DC7:  CLRF   52
0DC8:  MOVLW  7B
0DC9:  MOVWF  51
0DCA:  BCF    0A.3
0DCB:  BCF    03.6
0DCC:  CALL   521
0DCD:  BSF    0A.3
....................                    PACKAGE_NHIETDO[4] = NHIETDO1; 
0DCE:  CLRF   73
0DCF:  MOVLW  7B
0DD0:  MOVWF  72
....................                    ITOA (AN1, 10, NHIETDO2); 
0DD1:  BSF    03.6
0DD2:  CLRF   4F
0DD3:  CLRF   4E
0DD4:  BCF    03.6
0DD5:  MOVF   37,W
0DD6:  BSF    03.6
0DD7:  MOVWF  4D
0DD8:  BCF    03.6
0DD9:  MOVF   36,W
0DDA:  BSF    03.6
0DDB:  MOVWF  4C
0DDC:  MOVLW  0A
0DDD:  MOVWF  50
0DDE:  CLRF   52
0DDF:  MOVLW  CC
0DE0:  MOVWF  51
0DE1:  BCF    0A.3
0DE2:  BCF    03.6
0DE3:  CALL   521
0DE4:  BSF    0A.3
....................                    PACKAGE_NHIETDO[5] = NHIETDO2; 
0DE5:  CLRF   75
0DE6:  MOVLW  CC
0DE7:  MOVWF  74
....................                     
....................                    FOR (INT I = 0; I < 8; I++) 
0DE8:  BSF    03.6
0DE9:  CLRF   49
0DEA:  MOVF   49,W
0DEB:  SUBLW  07
0DEC:  BTFSS  03.0
0DED:  GOTO   60B
....................                    { 
....................                       PRINTF (PACKAGE_NHIETDO[I]); 
0DEE:  BCF    03.0
0DEF:  RLF    49,W
0DF0:  ADDLW  6A
0DF1:  MOVWF  04
0DF2:  BCF    03.7
0DF3:  INCF   04,F
0DF4:  MOVF   00,W
0DF5:  MOVWF  4B
0DF6:  DECF   04,F
0DF7:  MOVF   00,W
0DF8:  MOVWF  4A
0DF9:  MOVWF  04
0DFA:  BCF    03.7
0DFB:  BTFSC  4B.0
0DFC:  BSF    03.7
0DFD:  BCF    0A.3
0DFE:  BCF    03.6
0DFF:  CALL   765
0E00:  BSF    0A.3
....................                       DELAY_MS (1); 
0E01:  MOVLW  01
0E02:  BSF    03.6
0E03:  MOVWF  50
0E04:  BCF    0A.3
0E05:  BCF    03.6
0E06:  CALL   111
0E07:  BSF    0A.3
0E08:  BSF    03.6
0E09:  INCF   49,F
0E0A:  GOTO   5EA
....................                    } 
....................        
....................                    DELAY_MS (1000); 
0E0B:  MOVLW  04
0E0C:  MOVWF  4A
0E0D:  MOVLW  FA
0E0E:  MOVWF  50
0E0F:  BCF    0A.3
0E10:  BCF    03.6
0E11:  CALL   111
0E12:  BSF    0A.3
0E13:  BSF    03.6
0E14:  DECFSZ 4A,F
0E15:  GOTO   60D
0E16:  BCF    03.6
....................                 } 
....................        
....................                 IF (TTNHAN == 1) 
0E17:  DECFSZ 5B,W
0E18:  GOTO   648
....................                 {              
....................                    TTNHAN = 0; 
0E19:  CLRF   5B
....................                    //TEMP_CHAR = 'K'; 
....................                    ID_NODE_NHAN = KYTU[1] - 48; 
0E1A:  MOVLW  30
0E1B:  SUBWF  3D,W
0E1C:  MOVWF  5C
....................                    ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
0E1D:  MOVLW  30
0E1E:  SUBWF  3E,W
0E1F:  ADDLW  40
0E20:  MOVWF  5D
....................                    TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D  (D0 = 64) 
0E21:  MOVLW  30
0E22:  SUBWF  3F,W
0E23:  MOVWF  5E
....................                    XUATLCD (); 
0E24:  BCF    0A.3
0E25:  GOTO   79B
0E26:  BSF    0A.3
....................        
....................                    IF (ID_NODE_NHAN == ID_NODE) 
0E27:  MOVF   39,W
0E28:  SUBWF  5C,W
0E29:  BTFSS  03.2
0E2A:  GOTO   648
....................                    { 
....................                       OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0E2B:  MOVF   5E,F
0E2C:  BTFSS  03.2
0E2D:  GOTO   630
0E2E:  MOVLW  00
0E2F:  GOTO   631
0E30:  MOVLW  01
0E31:  MOVWF  77
0E32:  MOVF   5D,W
0E33:  BSF    03.6
0E34:  MOVWF  4B
0E35:  MOVF   77,W
0E36:  MOVWF  4C
0E37:  CLRF   4E
0E38:  CLRF   4D
0E39:  BCF    0A.3
0E3A:  BCF    03.6
0E3B:  CALL   677
0E3C:  BSF    0A.3
0E3D:  MOVF   5D,W
0E3E:  BSF    03.6
0E3F:  MOVWF  4B
0E40:  CLRF   4C
0E41:  CLRF   4E
0E42:  MOVLW  80
0E43:  MOVWF  4D
0E44:  BCF    0A.3
0E45:  BCF    03.6
0E46:  CALL   677
0E47:  BSF    0A.3
....................                    } 
....................                 }           
0E48:  GOTO   5AE
....................               
....................             } 
....................        } 
0E49:  GOTO   59B
....................     } 
....................  } 
....................  
0E4A:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
