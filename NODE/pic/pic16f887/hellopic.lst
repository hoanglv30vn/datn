CCS PCM C Compiler, Version 5.015, 5967               25-Oct-21 02:19

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4482 words (55%)
                           Largest free fragment is 2048
               RAM used:   258 (70%) at main() level
                           305 (83%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0E2
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   117
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  30
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  BCF    0A.0
006A:  BCF    0A.1
006B:  BCF    0A.2
006C:  ADDWF  02,F
006D:  RETLW  5F
006E:  RETLW  00
006F:  DATA 49,22
0070:  DATA 3A,10
0071:  DATA 20,10
0072:  DATA 20,10
0073:  DATA 20,10
0074:  DATA 20,10
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 00,00
0078:  DATA C4,22
0079:  DATA D6,24
007A:  DATA C3,22
007B:  DATA 3A,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 20,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 00,01
0082:  DATA D3,22
0083:  DATA CE,29
0084:  DATA 4F,29
0085:  DATA 3A,10
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 00,01
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 20,10
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 20,00
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 5F,10
0097:  DATA 20,10
0098:  DATA 20,00
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 5F,10
009C:  DATA 20,10
009D:  DATA 20,00
009E:  DATA C3,27
009F:  DATA 4E,23
00A0:  DATA C9,23
00A1:  DATA 3A,10
00A2:  DATA 20,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,00
00A6:  DATA C3,20
00A7:  DATA D3,22
00A8:  DATA 3A,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,00
00AE:  DATA A0,16
00AF:  DATA A0,24
00B0:  DATA 44,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,10
00B5:  DATA 00,01
00B6:  DATA A0,16
00B7:  DATA 20,22
00B8:  DATA 45,2B
00B9:  DATA C9,21
00BA:  DATA C5,29
00BB:  DATA 20,10
00BC:  DATA 20,10
00BD:  DATA 00,01
00BE:  DATA A0,16
00BF:  DATA A0,29
00C0:  DATA 45,27
00C1:  DATA D3,27
00C2:  DATA D2,29
00C3:  DATA 20,10
00C4:  DATA 20,10
00C5:  DATA 00,01
00C6:  DATA A0,16
00C7:  DATA A0,24
00C8:  DATA 44,10
00C9:  DATA 2D,10
00CA:  DATA C7,2B
00CB:  DATA 3A,10
00CC:  DATA 20,10
00CD:  DATA 20,00
00CE:  DATA C3,27
00CF:  DATA 4E,23
00D0:  DATA C9,23
00D1:  DATA 20,22
00D2:  DATA 4F,27
00D3:  DATA 45,10
00D4:  DATA 20,10
00D5:  DATA 20,10
00D6:  DATA 20,10
00D7:  DATA 20,00
00D8:  DATA C3,27
00D9:  DATA 4E,23
00DA:  DATA C9,23
00DB:  DATA 20,22
00DC:  DATA 4F,27
00DD:  DATA 45,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 20,10
00E1:  DATA 20,00
*
02EE:  MOVLW  8E
02EF:  MOVWF  77
02F0:  MOVF   66,W
02F1:  MOVWF  78
02F2:  MOVF   65,W
02F3:  MOVWF  79
02F4:  CLRF   7A
02F5:  MOVF   78,F
02F6:  BTFSS  03.2
02F7:  GOTO   302
02F8:  MOVF   79,W
02F9:  MOVWF  78
02FA:  CLRF   79
02FB:  MOVLW  08
02FC:  SUBWF  77,F
02FD:  MOVF   78,F
02FE:  BTFSS  03.2
02FF:  GOTO   302
0300:  CLRF   77
0301:  GOTO   30A
0302:  BCF    03.0
0303:  BTFSC  78.7
0304:  GOTO   309
0305:  RLF    79,F
0306:  RLF    78,F
0307:  DECF   77,F
0308:  GOTO   302
0309:  BCF    78.7
*
031A:  MOVF   65,W
031B:  BTFSC  03.2
031C:  GOTO   40C
031D:  BSF    03.5
031E:  MOVWF  14
031F:  BCF    03.5
0320:  MOVF   69,W
0321:  BTFSC  03.2
0322:  GOTO   40C
0323:  BSF    03.5
0324:  SUBWF  14,F
0325:  BTFSS  03.0
0326:  GOTO   32E
0327:  MOVLW  7F
0328:  ADDWF  14,F
0329:  BTFSS  03.0
032A:  GOTO   32D
032B:  BCF    03.5
032C:  GOTO   40C
032D:  GOTO   338
032E:  MOVLW  81
032F:  SUBWF  14,F
0330:  BTFSC  03.0
0331:  GOTO   334
0332:  BCF    03.5
0333:  GOTO   40C
0334:  BTFSS  03.2
0335:  GOTO   338
0336:  BCF    03.5
0337:  GOTO   40C
0338:  MOVF   14,W
0339:  MOVWF  77
033A:  CLRF   78
033B:  CLRF   79
033C:  CLRF   7A
033D:  CLRF   13
033E:  BCF    03.5
033F:  MOVF   66,W
0340:  BSF    03.5
0341:  MOVWF  12
0342:  BSF    12.7
0343:  BCF    03.5
0344:  MOVF   67,W
0345:  BSF    03.5
0346:  MOVWF  11
0347:  BCF    03.5
0348:  MOVF   68,W
0349:  BSF    03.5
034A:  MOVWF  10
034B:  MOVLW  19
034C:  MOVWF  14
034D:  BCF    03.5
034E:  MOVF   6C,W
034F:  BSF    03.5
0350:  SUBWF  10,F
0351:  BTFSC  03.0
0352:  GOTO   365
0353:  MOVLW  01
0354:  SUBWF  11,F
0355:  BTFSC  03.0
0356:  GOTO   365
0357:  SUBWF  12,F
0358:  BTFSC  03.0
0359:  GOTO   365
035A:  SUBWF  13,F
035B:  BTFSC  03.0
035C:  GOTO   365
035D:  INCF   13,F
035E:  INCF   12,F
035F:  INCF   11,F
0360:  BCF    03.5
0361:  MOVF   6C,W
0362:  BSF    03.5
0363:  ADDWF  10,F
0364:  GOTO   3A3
0365:  BCF    03.5
0366:  MOVF   6B,W
0367:  BSF    03.5
0368:  SUBWF  11,F
0369:  BTFSC  03.0
036A:  GOTO   386
036B:  MOVLW  01
036C:  SUBWF  12,F
036D:  BTFSC  03.0
036E:  GOTO   386
036F:  SUBWF  13,F
0370:  BTFSC  03.0
0371:  GOTO   386
0372:  INCF   13,F
0373:  INCF   12,F
0374:  BCF    03.5
0375:  MOVF   6B,W
0376:  BSF    03.5
0377:  ADDWF  11,F
0378:  BCF    03.5
0379:  MOVF   6C,W
037A:  BSF    03.5
037B:  ADDWF  10,F
037C:  BTFSS  03.0
037D:  GOTO   3A3
037E:  INCF   11,F
037F:  BTFSS  03.2
0380:  GOTO   3A3
0381:  INCF   12,F
0382:  BTFSS  03.2
0383:  GOTO   3A3
0384:  INCF   13,F
0385:  GOTO   3A3
0386:  BCF    03.5
0387:  MOVF   6A,W
0388:  IORLW  80
0389:  BSF    03.5
038A:  SUBWF  12,F
038B:  BTFSC  03.0
038C:  GOTO   3A2
038D:  MOVLW  01
038E:  SUBWF  13,F
038F:  BTFSC  03.0
0390:  GOTO   3A2
0391:  INCF   13,F
0392:  BCF    03.5
0393:  MOVF   6A,W
0394:  IORLW  80
0395:  BSF    03.5
0396:  ADDWF  12,F
0397:  BCF    03.5
0398:  MOVF   6B,W
0399:  BSF    03.5
039A:  ADDWF  11,F
039B:  BTFSS  03.0
039C:  GOTO   378
039D:  INCF   12,F
039E:  BTFSS  03.2
039F:  GOTO   378
03A0:  INCF   13,F
03A1:  GOTO   378
03A2:  BSF    7A.0
03A3:  DECFSZ 14,F
03A4:  GOTO   3A6
03A5:  GOTO   3B1
03A6:  BCF    03.0
03A7:  RLF    10,F
03A8:  RLF    11,F
03A9:  RLF    12,F
03AA:  RLF    13,F
03AB:  BCF    03.0
03AC:  RLF    7A,F
03AD:  RLF    79,F
03AE:  RLF    78,F
03AF:  RLF    15,F
03B0:  GOTO   34D
03B1:  BTFSS  15.0
03B2:  GOTO   3B9
03B3:  BCF    03.0
03B4:  RRF    78,F
03B5:  RRF    79,F
03B6:  RRF    7A,F
03B7:  RRF    15,F
03B8:  GOTO   3BD
03B9:  DECFSZ 77,F
03BA:  GOTO   3BD
03BB:  BCF    03.5
03BC:  GOTO   40C
03BD:  BTFSC  15.7
03BE:  GOTO   3EC
03BF:  BCF    03.0
03C0:  RLF    10,F
03C1:  RLF    11,F
03C2:  RLF    12,F
03C3:  RLF    13,F
03C4:  BCF    03.5
03C5:  MOVF   6C,W
03C6:  BSF    03.5
03C7:  SUBWF  10,F
03C8:  BTFSC  03.0
03C9:  GOTO   3D4
03CA:  MOVLW  01
03CB:  SUBWF  11,F
03CC:  BTFSC  03.0
03CD:  GOTO   3D4
03CE:  SUBWF  12,F
03CF:  BTFSC  03.0
03D0:  GOTO   3D4
03D1:  SUBWF  13,F
03D2:  BTFSS  03.0
03D3:  GOTO   3FD
03D4:  BCF    03.5
03D5:  MOVF   6B,W
03D6:  BSF    03.5
03D7:  SUBWF  11,F
03D8:  BTFSC  03.0
03D9:  GOTO   3E1
03DA:  MOVLW  01
03DB:  SUBWF  12,F
03DC:  BTFSC  03.0
03DD:  GOTO   3E1
03DE:  SUBWF  13,F
03DF:  BTFSS  03.0
03E0:  GOTO   3FD
03E1:  BCF    03.5
03E2:  MOVF   6A,W
03E3:  IORLW  80
03E4:  BSF    03.5
03E5:  SUBWF  12,F
03E6:  BTFSC  03.0
03E7:  GOTO   3EC
03E8:  MOVLW  01
03E9:  SUBWF  13,F
03EA:  BTFSS  03.0
03EB:  GOTO   3FD
03EC:  INCF   7A,F
03ED:  BTFSS  03.2
03EE:  GOTO   3FD
03EF:  INCF   79,F
03F0:  BTFSS  03.2
03F1:  GOTO   3FD
03F2:  INCF   78,F
03F3:  BTFSS  03.2
03F4:  GOTO   3FD
03F5:  INCF   77,F
03F6:  BTFSS  03.2
03F7:  GOTO   3FA
03F8:  BCF    03.5
03F9:  GOTO   40C
03FA:  RRF    78,F
03FB:  RRF    79,F
03FC:  RRF    7A,F
03FD:  BCF    03.5
03FE:  MOVF   66,W
03FF:  BSF    03.5
0400:  MOVWF  14
0401:  BCF    03.5
0402:  MOVF   6A,W
0403:  BSF    03.5
0404:  XORWF  14,F
0405:  BTFSS  14.7
0406:  GOTO   409
0407:  BSF    78.7
0408:  GOTO   411
0409:  BCF    78.7
040A:  GOTO   411
040B:  BCF    03.5
040C:  CLRF   77
040D:  CLRF   78
040E:  CLRF   79
040F:  CLRF   7A
0410:  BSF    03.5
*
041A:  MOVLW  8E
041B:  MOVWF  77
041C:  MOVF   65,W
041D:  SUBWF  77,F
041E:  MOVF   66,W
041F:  MOVWF  79
0420:  MOVF   67,W
0421:  MOVWF  78
0422:  BSF    79.7
0423:  MOVF   77,F
0424:  BTFSC  03.2
0425:  GOTO   431
0426:  BCF    03.0
0427:  MOVF   79,F
0428:  BTFSS  03.2
0429:  GOTO   42D
042A:  MOVF   78,F
042B:  BTFSC  03.2
042C:  GOTO   431
042D:  RRF    79,F
042E:  RRF    78,F
042F:  DECFSZ 77,F
0430:  GOTO   426
0431:  BTFSS  66.7
0432:  GOTO   438
0433:  COMF   78,F
0434:  COMF   79,F
0435:  INCF   78,F
0436:  BTFSC  03.2
0437:  INCF   79,F
*
0490:  MOVF   0B,W
0491:  BSF    03.6
0492:  MOVWF  64
0493:  BCF    03.6
0494:  BCF    0B.7
0495:  BSF    03.5
0496:  BSF    03.6
0497:  BSF    0C.7
0498:  BSF    0C.0
0499:  NOP
049A:  NOP
049B:  BCF    03.5
049C:  BTFSS  64.7
049D:  GOTO   4A1
049E:  BCF    03.6
049F:  BSF    0B.7
04A0:  BSF    03.6
04A1:  MOVF   0C,W
04A2:  ANDLW  7F
04A3:  BTFSC  03.2
04A4:  GOTO   4DE
04A5:  MOVWF  64
04A6:  MOVF   0D,W
04A7:  MOVWF  65
04A8:  MOVF   0F,W
04A9:  MOVWF  66
04AA:  MOVF   64,W
04AB:  MOVWF  67
04AC:  BCF    03.6
04AD:  CALL   456
04AE:  BSF    03.6
04AF:  MOVF   65,W
04B0:  MOVWF  0D
04B1:  MOVF   66,W
04B2:  MOVWF  0F
04B3:  BCF    03.6
04B4:  MOVF   0B,W
04B5:  BSF    03.6
04B6:  MOVWF  67
04B7:  BCF    03.6
04B8:  BCF    0B.7
04B9:  BSF    03.5
04BA:  BSF    03.6
04BB:  BSF    0C.7
04BC:  BSF    0C.0
04BD:  NOP
04BE:  NOP
04BF:  BCF    03.5
04C0:  BTFSS  67.7
04C1:  GOTO   4C5
04C2:  BCF    03.6
04C3:  BSF    0B.7
04C4:  BSF    03.6
04C5:  RLF    0C,W
04C6:  RLF    0E,W
04C7:  ANDLW  7F
04C8:  BTFSC  03.2
04C9:  GOTO   4DE
04CA:  MOVWF  64
04CB:  MOVF   0D,W
04CC:  MOVWF  65
04CD:  MOVF   0F,W
04CE:  MOVWF  66
04CF:  MOVF   64,W
04D0:  MOVWF  67
04D1:  BCF    03.6
04D2:  CALL   456
04D3:  BSF    03.6
04D4:  MOVF   65,W
04D5:  MOVWF  0D
04D6:  MOVF   66,W
04D7:  MOVWF  0F
04D8:  INCF   0D,F
04D9:  BTFSC  03.2
04DA:  INCF   0F,F
04DB:  BCF    03.6
04DC:  GOTO   490
04DD:  BSF    03.6
04DE:  BCF    03.6
04DF:  RETURN
04E0:  BTFSC  03.1
04E1:  GOTO   4E5
04E2:  MOVLW  A4
04E3:  MOVWF  04
04E4:  BSF    03.7
04E5:  BSF    03.5
04E6:  BSF    03.6
04E7:  MOVF   1F,W
04E8:  XORWF  23,W
04E9:  ANDLW  80
04EA:  MOVWF  29
04EB:  BTFSS  1F.7
04EC:  GOTO   4F8
04ED:  COMF   1C,F
04EE:  COMF   1D,F
04EF:  COMF   1E,F
04F0:  COMF   1F,F
04F1:  INCF   1C,F
04F2:  BTFSC  03.2
04F3:  INCF   1D,F
04F4:  BTFSC  03.2
04F5:  INCF   1E,F
04F6:  BTFSC  03.2
04F7:  INCF   1F,F
04F8:  BTFSS  23.7
04F9:  GOTO   505
04FA:  COMF   20,F
04FB:  COMF   21,F
04FC:  COMF   22,F
04FD:  COMF   23,F
04FE:  INCF   20,F
04FF:  BTFSC  03.2
0500:  INCF   21,F
0501:  BTFSC  03.2
0502:  INCF   22,F
0503:  BTFSC  03.2
0504:  INCF   23,F
0505:  CLRF   77
0506:  CLRF   78
0507:  CLRF   79
0508:  CLRF   7A
0509:  CLRF   24
050A:  CLRF   25
050B:  CLRF   26
050C:  CLRF   27
050D:  MOVF   23,W
050E:  IORWF  22,W
050F:  IORWF  21,W
0510:  IORWF  20,W
0511:  BTFSC  03.2
0512:  GOTO   543
0513:  MOVLW  20
0514:  MOVWF  28
0515:  BCF    03.0
0516:  RLF    1C,F
0517:  RLF    1D,F
0518:  RLF    1E,F
0519:  RLF    1F,F
051A:  RLF    24,F
051B:  RLF    25,F
051C:  RLF    26,F
051D:  RLF    27,F
051E:  MOVF   23,W
051F:  SUBWF  27,W
0520:  BTFSS  03.2
0521:  GOTO   52C
0522:  MOVF   22,W
0523:  SUBWF  26,W
0524:  BTFSS  03.2
0525:  GOTO   52C
0526:  MOVF   21,W
0527:  SUBWF  25,W
0528:  BTFSS  03.2
0529:  GOTO   52C
052A:  MOVF   20,W
052B:  SUBWF  24,W
052C:  BTFSS  03.0
052D:  GOTO   53D
052E:  MOVF   20,W
052F:  SUBWF  24,F
0530:  MOVF   21,W
0531:  BTFSS  03.0
0532:  INCFSZ 21,W
0533:  SUBWF  25,F
0534:  MOVF   22,W
0535:  BTFSS  03.0
0536:  INCFSZ 22,W
0537:  SUBWF  26,F
0538:  MOVF   23,W
0539:  BTFSS  03.0
053A:  INCFSZ 23,W
053B:  SUBWF  27,F
053C:  BSF    03.0
053D:  RLF    77,F
053E:  RLF    78,F
053F:  RLF    79,F
0540:  RLF    7A,F
0541:  DECFSZ 28,F
0542:  GOTO   515
0543:  BTFSS  29.7
0544:  GOTO   550
0545:  COMF   77,F
0546:  COMF   78,F
0547:  COMF   79,F
0548:  COMF   7A,F
0549:  INCF   77,F
054A:  BTFSC  03.2
054B:  INCF   78,F
054C:  BTFSC  03.2
054D:  INCF   79,F
054E:  BTFSC  03.2
054F:  INCF   7A,F
0550:  MOVF   24,W
0551:  MOVWF  00
0552:  INCF   04,F
0553:  MOVF   25,W
0554:  MOVWF  00
0555:  INCF   04,F
0556:  MOVF   26,W
0557:  MOVWF  00
0558:  INCF   04,F
0559:  MOVF   27,W
055A:  MOVWF  00
055B:  BCF    03.5
055C:  BCF    03.6
055D:  RETURN
*
0582:  MOVLW  20
0583:  MOVWF  20
0584:  CLRF   1C
0585:  CLRF   1D
0586:  CLRF   1E
0587:  CLRF   1F
0588:  MOVF   17,W
0589:  MOVWF  7A
058A:  MOVF   16,W
058B:  MOVWF  79
058C:  MOVF   15,W
058D:  MOVWF  78
058E:  MOVF   14,W
058F:  MOVWF  77
0590:  BCF    03.0
0591:  BTFSS  77.0
0592:  GOTO   5A1
0593:  MOVF   18,W
0594:  ADDWF  1C,F
0595:  MOVF   19,W
0596:  BTFSC  03.0
0597:  INCFSZ 19,W
0598:  ADDWF  1D,F
0599:  MOVF   1A,W
059A:  BTFSC  03.0
059B:  INCFSZ 1A,W
059C:  ADDWF  1E,F
059D:  MOVF   1B,W
059E:  BTFSC  03.0
059F:  INCFSZ 1B,W
05A0:  ADDWF  1F,F
05A1:  RRF    1F,F
05A2:  RRF    1E,F
05A3:  RRF    1D,F
05A4:  RRF    1C,F
05A5:  RRF    7A,F
05A6:  RRF    79,F
05A7:  RRF    78,F
05A8:  RRF    77,F
05A9:  DECFSZ 20,F
05AA:  GOTO   590
*
06B4:  MOVF   00,F
06B5:  BTFSC  03.2
06B6:  GOTO   6D0
06B7:  BSF    03.6
06B8:  CLRF   65
06B9:  MOVF   04,W
06BA:  MOVWF  64
06BB:  BCF    65.0
06BC:  BTFSC  03.7
06BD:  BSF    65.0
06BE:  MOVF   00,W
06BF:  MOVWF  67
06C0:  BCF    03.6
06C1:  CALL   456
06C2:  BSF    03.6
06C3:  MOVF   64,W
06C4:  MOVWF  04
06C5:  BCF    03.7
06C6:  BTFSC  65.0
06C7:  BSF    03.7
06C8:  INCF   04,F
06C9:  BTFSS  03.2
06CA:  GOTO   6CE
06CB:  BCF    03.6
06CC:  INCF   05,F
06CD:  BSF    03.6
06CE:  BCF    03.6
06CF:  GOTO   6B4
06D0:  RETURN
06D1:  BSF    03.6
06D2:  MOVF   65,W
06D3:  ANDLW  07
06D4:  MOVWF  77
06D5:  RRF    65,W
06D6:  MOVWF  78
06D7:  RRF    78,F
06D8:  RRF    78,F
06D9:  MOVLW  1F
06DA:  ANDWF  78,F
06DB:  MOVF   78,W
06DC:  ADDWF  66,W
06DD:  MOVWF  04
06DE:  BCF    03.7
06DF:  BTFSC  67.0
06E0:  BSF    03.7
06E1:  MOVF   00,W
06E2:  MOVWF  78
06E3:  INCF   77,F
06E4:  GOTO   6E6
06E5:  RRF    78,F
06E6:  DECFSZ 77,F
06E7:  GOTO   6E5
06E8:  BCF    03.6
06E9:  RETURN
06EA:  BSF    03.6
06EB:  MOVF   64,W
06EC:  ANDLW  07
06ED:  MOVWF  77
06EE:  RRF    64,W
06EF:  MOVWF  78
06F0:  RRF    78,F
06F1:  RRF    78,F
06F2:  MOVLW  1F
06F3:  ANDWF  78,F
06F4:  MOVF   78,W
06F5:  ADDWF  66,W
06F6:  MOVWF  04
06F7:  BCF    03.7
06F8:  BTFSC  67.0
06F9:  BSF    03.7
06FA:  CLRF   78
06FB:  INCF   78,F
06FC:  INCF   77,F
06FD:  GOTO   6FF
06FE:  RLF    78,F
06FF:  DECFSZ 77,F
0700:  GOTO   6FE
0701:  MOVF   65,F
0702:  BTFSC  03.2
0703:  GOTO   707
0704:  MOVF   78,W
0705:  IORWF  00,F
0706:  GOTO   70A
0707:  COMF   78,F
0708:  MOVF   78,W
0709:  ANDWF  00,F
070A:  BCF    03.6
070B:  RETURN
*
07D1:  BSF    0A.0
07D2:  BSF    0A.1
07D3:  BSF    0A.2
07D4:  ADDWF  02,F
07D5:  GOTO   7A9
07D6:  GOTO   7B1
07D7:  GOTO   7B9
07D8:  GOTO   7C1
07D9:  MOVF   00,F
07DA:  BTFSC  03.2
07DB:  GOTO   7F6
07DC:  BSF    03.6
07DD:  CLRF   67
07DE:  MOVF   04,W
07DF:  MOVWF  66
07E0:  BCF    67.0
07E1:  BTFSC  03.7
07E2:  BSF    67.0
07E3:  MOVF   00,W
07E4:  BCF    03.6
07E5:  BTFSS  0C.4
07E6:  GOTO   7E5
07E7:  MOVWF  19
07E8:  BSF    03.6
07E9:  MOVF   66,W
07EA:  MOVWF  04
07EB:  BCF    03.7
07EC:  BTFSC  67.0
07ED:  BSF    03.7
07EE:  INCF   04,F
07EF:  BTFSS  03.2
07F0:  GOTO   7F4
07F1:  BCF    03.6
07F2:  INCF   05,F
07F3:  BSF    03.6
07F4:  BCF    03.6
07F5:  GOTO   7D9
07F6:  RETURN
*
0B27:  MOVF   68,W
0B28:  CLRF   78
0B29:  SUBWF  67,W
0B2A:  BTFSC  03.0
0B2B:  GOTO   32F
0B2C:  MOVF   67,W
0B2D:  MOVWF  77
0B2E:  GOTO   33B
0B2F:  CLRF   77
0B30:  MOVLW  08
0B31:  MOVWF  69
0B32:  RLF    67,F
0B33:  RLF    77,F
0B34:  MOVF   68,W
0B35:  SUBWF  77,W
0B36:  BTFSC  03.0
0B37:  MOVWF  77
0B38:  RLF    78,F
0B39:  DECFSZ 69,F
0B3A:  GOTO   332
*
0BB5:  BSF    0A.0
0BB6:  BSF    0A.1
0BB7:  BCF    0A.2
0BB8:  ADDWF  02,F
0BB9:  GOTO   007
0BBA:  GOTO   06E
0BBB:  GOTO   179
0BBC:  GOTO   284
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
070C:  BSF    03.6
070D:  MOVF   66,W
070E:  MOVWF  6A
070F:  MOVF   65,W
0710:  MOVWF  69
0711:  MOVF   6A,W
0712:  MOVWF  7A
0713:  MOVF   69,W
0714:  MOVWF  04
0715:  BCF    03.7
0716:  BTFSC  7A.0
0717:  BSF    03.7
0718:  MOVF   00,F
0719:  BTFSC  03.2
071A:  GOTO   71F
071B:  INCF   69,F
071C:  BTFSC  03.2
071D:  INCF   6A,F
071E:  GOTO   711
....................    while(*s2 != '\0') 
071F:  MOVF   68,W
0720:  MOVWF  7A
0721:  MOVF   67,W
0722:  MOVWF  04
0723:  BCF    03.7
0724:  BTFSC  7A.0
0725:  BSF    03.7
0726:  MOVF   00,F
0727:  BTFSC  03.2
0728:  GOTO   73E
....................    { 
....................       *s = *s2; 
0729:  MOVF   67,W
072A:  MOVWF  04
072B:  BCF    03.7
072C:  BTFSC  68.0
072D:  BSF    03.7
072E:  MOVF   00,W
072F:  MOVWF  6D
0730:  MOVF   69,W
0731:  MOVWF  04
0732:  BCF    03.7
0733:  BTFSC  6A.0
0734:  BSF    03.7
0735:  MOVF   6D,W
0736:  MOVWF  00
....................       ++s; 
0737:  INCF   69,F
0738:  BTFSC  03.2
0739:  INCF   6A,F
....................       ++s2; 
073A:  INCF   67,F
073B:  BTFSC  03.2
073C:  INCF   68,F
073D:  GOTO   71F
....................    } 
....................  
....................    *s = '\0'; 
073E:  MOVF   69,W
073F:  MOVWF  04
0740:  BCF    03.7
0741:  BTFSC  6A.0
0742:  BSF    03.7
0743:  CLRF   00
....................    return(s1); 
0744:  MOVF   65,W
0745:  MOVWF  78
0746:  MOVF   66,W
0747:  MOVWF  79
0748:  BCF    03.6
0749:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0E28:  MOVF   6C,W
0E29:  BSF    03.5
0E2A:  MOVWF  11
0E2B:  BCF    03.5
0E2C:  MOVF   6B,W
0E2D:  BSF    03.5
0E2E:  MOVWF  10
0E2F:  MOVF   11,W
0E30:  MOVWF  7A
0E31:  MOVF   10,W
0E32:  MOVWF  04
0E33:  BCF    03.7
0E34:  BTFSC  7A.0
0E35:  BSF    03.7
0E36:  MOVF   00,F
0E37:  BTFSC  03.2
0E38:  GOTO   672
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0E39:  BCF    03.5
0E3A:  MOVF   6E,W
0E3B:  BSF    03.5
0E3C:  MOVWF  13
0E3D:  BCF    03.5
0E3E:  MOVF   6D,W
0E3F:  BSF    03.5
0E40:  MOVWF  12
0E41:  MOVF   13,W
0E42:  MOVWF  7A
0E43:  MOVF   12,W
0E44:  MOVWF  04
0E45:  BCF    03.7
0E46:  BTFSC  7A.0
0E47:  BSF    03.7
0E48:  MOVF   00,F
0E49:  BTFSC  03.2
0E4A:  GOTO   66E
....................          if (*sc1 == *sc2) 
0E4B:  MOVF   11,W
0E4C:  MOVWF  7A
0E4D:  MOVF   10,W
0E4E:  MOVWF  04
0E4F:  BCF    03.7
0E50:  BTFSC  7A.0
0E51:  BSF    03.7
0E52:  MOVF   00,W
0E53:  BCF    03.5
0E54:  MOVWF  6F
0E55:  BSF    03.5
0E56:  MOVF   13,W
0E57:  MOVWF  7A
0E58:  MOVF   12,W
0E59:  MOVWF  04
0E5A:  BCF    03.7
0E5B:  BTFSC  7A.0
0E5C:  BSF    03.7
0E5D:  MOVF   00,W
0E5E:  BCF    03.5
0E5F:  SUBWF  6F,W
0E60:  BTFSS  03.2
0E61:  GOTO   669
....................             return(sc1); 
0E62:  BSF    03.5
0E63:  MOVF   10,W
0E64:  MOVWF  78
0E65:  MOVF   11,W
0E66:  MOVWF  79
0E67:  GOTO   675
0E68:  BCF    03.5
0E69:  BSF    03.5
0E6A:  INCF   12,F
0E6B:  BTFSC  03.2
0E6C:  INCF   13,F
0E6D:  GOTO   641
0E6E:  INCF   10,F
0E6F:  BTFSC  03.2
0E70:  INCF   11,F
0E71:  GOTO   62F
....................    return(0); 
0E72:  MOVLW  00
0E73:  MOVWF  78
0E74:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0DA1:  MOVF   6C,W
0DA2:  BSF    03.5
0DA3:  MOVWF  11
0DA4:  BCF    03.5
0DA5:  MOVF   6B,W
0DA6:  BSF    03.5
0DA7:  MOVWF  10
0DA8:  MOVF   11,W
0DA9:  MOVWF  7A
0DAA:  MOVF   10,W
0DAB:  MOVWF  04
0DAC:  BCF    03.7
0DAD:  BTFSC  7A.0
0DAE:  BSF    03.7
0DAF:  MOVF   00,F
0DB0:  BTFSC  03.2
0DB1:  GOTO   5F7
....................       for (sc2 = s2; ; sc2++) 
0DB2:  BCF    03.5
0DB3:  MOVF   6E,W
0DB4:  BSF    03.5
0DB5:  MOVWF  13
0DB6:  BCF    03.5
0DB7:  MOVF   6D,W
0DB8:  BSF    03.5
0DB9:  MOVWF  12
....................     if (*sc2 == '\0') 
0DBA:  MOVF   13,W
0DBB:  MOVWF  7A
0DBC:  MOVF   12,W
0DBD:  MOVWF  04
0DBE:  BCF    03.7
0DBF:  BTFSC  7A.0
0DC0:  BSF    03.7
0DC1:  MOVF   00,F
0DC2:  BTFSS  03.2
0DC3:  GOTO   5D5
....................        return(sc1 - s1); 
0DC4:  BCF    03.5
0DC5:  MOVF   6B,W
0DC6:  BSF    03.5
0DC7:  SUBWF  10,W
0DC8:  MOVWF  77
0DC9:  MOVF   11,W
0DCA:  MOVWF  7A
0DCB:  BCF    03.5
0DCC:  MOVF   6C,W
0DCD:  BTFSS  03.0
0DCE:  INCFSZ 6C,W
0DCF:  SUBWF  7A,F
0DD0:  MOVF   77,W
0DD1:  MOVWF  78
0DD2:  GOTO   605
0DD3:  GOTO   5EC
0DD4:  BSF    03.5
....................          else if (*sc1 == *sc2) 
0DD5:  MOVF   11,W
0DD6:  MOVWF  7A
0DD7:  MOVF   10,W
0DD8:  MOVWF  04
0DD9:  BCF    03.7
0DDA:  BTFSC  7A.0
0DDB:  BSF    03.7
0DDC:  MOVF   00,W
0DDD:  BCF    03.5
0DDE:  MOVWF  6F
0DDF:  BSF    03.5
0DE0:  MOVF   13,W
0DE1:  MOVWF  7A
0DE2:  MOVF   12,W
0DE3:  MOVWF  04
0DE4:  BCF    03.7
0DE5:  BTFSC  7A.0
0DE6:  BSF    03.7
0DE7:  MOVF   00,W
0DE8:  BCF    03.5
0DE9:  SUBWF  6F,W
0DEA:  BTFSC  03.2
....................             break; 
0DEB:  GOTO   5F2
0DEC:  BSF    03.5
0DED:  INCF   12,F
0DEE:  BTFSC  03.2
0DEF:  INCF   13,F
0DF0:  GOTO   5BA
0DF1:  BCF    03.5
0DF2:  BSF    03.5
0DF3:  INCF   10,F
0DF4:  BTFSC  03.2
0DF5:  INCF   11,F
0DF6:  GOTO   5A8
....................    return(sc1 - s1); 
0DF7:  BCF    03.5
0DF8:  MOVF   6B,W
0DF9:  BSF    03.5
0DFA:  SUBWF  10,W
0DFB:  MOVWF  77
0DFC:  MOVF   11,W
0DFD:  MOVWF  7A
0DFE:  BCF    03.5
0DFF:  MOVF   6C,W
0E00:  BTFSS  03.0
0E01:  INCFSZ 6C,W
0E02:  SUBWF  7A,F
0E03:  MOVF   77,W
0E04:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
102E:  BCF    03.6
102F:  CLRF   2B
1030:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0D88:  BSF    03.6
0D89:  MOVF   63,W
0D8A:  IORWF  64,W
0D8B:  BTFSC  03.2
0D8C:  GOTO   591
0D8D:  MOVF   64,W
0D8E:  MOVWF  7A
0D8F:  MOVF   63,W
0D90:  GOTO   596
0D91:  BCF    03.6
0D92:  MOVF   2C,W
0D93:  MOVWF  7A
0D94:  MOVF   2B,W
0D95:  BSF    03.6
0D96:  MOVWF  67
0D97:  MOVF   7A,W
0D98:  MOVWF  68
....................    beg += strspn(beg, s2); 
0D99:  MOVF   68,W
0D9A:  MOVWF  6C
0D9B:  MOVF   67,W
0D9C:  MOVWF  6B
0D9D:  MOVF   66,W
0D9E:  MOVWF  6E
0D9F:  MOVF   65,W
0DA0:  MOVWF  6D
*
0E05:  MOVF   78,W
0E06:  ADDWF  67,F
0E07:  BTFSC  03.0
0E08:  INCF   68,F
....................    if (*beg == '\0') 
0E09:  MOVF   68,W
0E0A:  MOVWF  7A
0E0B:  MOVF   67,W
0E0C:  MOVWF  04
0E0D:  BCF    03.7
0E0E:  BTFSC  7A.0
0E0F:  BSF    03.7
0E10:  MOVF   00,F
0E11:  BTFSS  03.2
0E12:  GOTO   620
....................    { 
....................       *save = ' '; 
0E13:  BCF    03.6
0E14:  MOVF   2B,W
0E15:  MOVWF  04
0E16:  BCF    03.7
0E17:  BTFSC  2C.0
0E18:  BSF    03.7
0E19:  MOVLW  20
0E1A:  MOVWF  00
....................       return(0); 
0E1B:  MOVLW  00
0E1C:  MOVWF  78
0E1D:  MOVWF  79
0E1E:  GOTO   69A
0E1F:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
0E20:  MOVF   68,W
0E21:  MOVWF  6C
0E22:  MOVF   67,W
0E23:  MOVWF  6B
0E24:  MOVF   66,W
0E25:  MOVWF  6E
0E26:  MOVF   65,W
0E27:  MOVWF  6D
*
0E75:  MOVF   79,W
0E76:  BCF    03.5
0E77:  MOVWF  6A
0E78:  MOVF   78,W
0E79:  MOVWF  69
....................    if (*end != '\0') 
0E7A:  MOVF   6A,W
0E7B:  MOVWF  7A
0E7C:  MOVF   69,W
0E7D:  MOVWF  04
0E7E:  BCF    03.7
0E7F:  BTFSC  7A.0
0E80:  BSF    03.7
0E81:  MOVF   00,F
0E82:  BTFSC  03.2
0E83:  GOTO   68D
....................    { 
....................       *end = '\0'; 
0E84:  MOVF   69,W
0E85:  MOVWF  04
0E86:  BCF    03.7
0E87:  BTFSC  6A.0
0E88:  BSF    03.7
0E89:  CLRF   00
....................       end++; 
0E8A:  INCF   69,F
0E8B:  BTFSC  03.2
0E8C:  INCF   6A,F
....................    } 
....................    save = end; 
0E8D:  MOVF   6A,W
0E8E:  BCF    03.6
0E8F:  MOVWF  2C
0E90:  BSF    03.6
0E91:  MOVF   69,W
0E92:  BCF    03.6
0E93:  MOVWF  2B
....................    return(beg); 
0E94:  BSF    03.6
0E95:  MOVF   67,W
0E96:  MOVWF  78
0E97:  MOVF   68,W
0E98:  MOVWF  79
0E99:  BCF    03.6
0E9A:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0CBE:  MOVF   67,W
0CBF:  MOVWF  69
0CC0:  MOVF   66,W
0CC1:  MOVWF  68
0CC2:  MOVF   69,W
0CC3:  MOVWF  7A
0CC4:  MOVF   68,W
0CC5:  MOVWF  04
0CC6:  BCF    03.7
0CC7:  BTFSC  7A.0
0CC8:  BSF    03.7
0CC9:  MOVF   00,F
0CCA:  BTFSC  03.2
0CCB:  GOTO   4D0
0CCC:  INCF   68,F
0CCD:  BTFSC  03.2
0CCE:  INCF   69,F
0CCF:  GOTO   4C2
....................    return(sc - s); 
0CD0:  MOVF   66,W
0CD1:  SUBWF  68,W
0CD2:  MOVWF  77
0CD3:  MOVF   69,W
0CD4:  MOVWF  7A
0CD5:  MOVF   67,W
0CD6:  BTFSS  03.0
0CD7:  INCFSZ 67,W
0CD8:  SUBWF  7A,F
0CD9:  MOVF   77,W
0CDA:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
055E:  BSF    03.6
055F:  CLRF   6F
0560:  CLRF   6E
0561:  CLRF   6D
0562:  MOVLW  01
0563:  MOVWF  6C
0564:  BSF    03.5
0565:  CLRF   11
0566:  CLRF   12
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0567:  BCF    03.5
0568:  BTFSS  68.7
0569:  GOTO   5B4
....................          sign=1;        // Check for negative number 
056A:  MOVLW  01
056B:  BSF    03.5
056C:  MOVWF  11
....................          num*=-1; 
056D:  BCF    03.5
056E:  MOVF   68,W
056F:  BSF    03.5
0570:  MOVWF  17
0571:  BCF    03.5
0572:  MOVF   67,W
0573:  BSF    03.5
0574:  MOVWF  16
0575:  BCF    03.5
0576:  MOVF   66,W
0577:  BSF    03.5
0578:  MOVWF  15
0579:  BCF    03.5
057A:  MOVF   65,W
057B:  BSF    03.5
057C:  MOVWF  14
057D:  MOVLW  FF
057E:  MOVWF  1B
057F:  MOVWF  1A
0580:  MOVWF  19
0581:  MOVWF  18
*
05AB:  MOVF   7A,W
05AC:  BCF    03.5
05AD:  MOVWF  68
05AE:  MOVF   79,W
05AF:  MOVWF  67
05B0:  MOVF   78,W
05B1:  MOVWF  66
05B2:  MOVF   77,W
05B3:  MOVWF  65
....................      } 
....................  
....................      while(temp>0) { 
05B4:  MOVF   6C,F
05B5:  BTFSS  03.2
05B6:  GOTO   5C0
05B7:  MOVF   6D,F
05B8:  BTFSS  03.2
05B9:  GOTO   5C0
05BA:  MOVF   6E,F
05BB:  BTFSS  03.2
05BC:  GOTO   5C0
05BD:  MOVF   6F,F
05BE:  BTFSC  03.2
05BF:  GOTO   65A
....................          temp=(num/base); 
05C0:  BCF    03.1
05C1:  MOVF   68,W
05C2:  BSF    03.5
05C3:  MOVWF  1F
05C4:  BCF    03.5
05C5:  MOVF   67,W
05C6:  BSF    03.5
05C7:  MOVWF  1E
05C8:  BCF    03.5
05C9:  MOVF   66,W
05CA:  BSF    03.5
05CB:  MOVWF  1D
05CC:  BCF    03.5
05CD:  MOVF   65,W
05CE:  BSF    03.5
05CF:  MOVWF  1C
05D0:  CLRF   23
05D1:  CLRF   22
05D2:  CLRF   21
05D3:  BCF    03.5
05D4:  MOVF   69,W
05D5:  BSF    03.5
05D6:  MOVWF  20
05D7:  BCF    03.5
05D8:  BCF    03.6
05D9:  CALL   4E0
05DA:  MOVF   7A,W
05DB:  BSF    03.6
05DC:  MOVWF  6F
05DD:  MOVF   79,W
05DE:  MOVWF  6E
05DF:  MOVF   78,W
05E0:  MOVWF  6D
05E1:  MOVF   77,W
05E2:  MOVWF  6C
....................          s[cnt]=(num%base)+'0';    // Conversion 
05E3:  BSF    03.5
05E4:  MOVF   12,W
05E5:  BCF    03.5
05E6:  ADDWF  6A,W
05E7:  MOVWF  78
05E8:  MOVF   6B,W
05E9:  MOVWF  7A
05EA:  BTFSC  03.0
05EB:  INCF   7A,F
05EC:  MOVF   78,W
05ED:  BSF    03.5
05EE:  MOVWF  14
05EF:  MOVF   7A,W
05F0:  MOVWF  15
05F1:  CLRF   17
05F2:  MOVF   04,W
05F3:  MOVWF  16
05F4:  BCF    17.0
05F5:  BTFSC  03.7
05F6:  BSF    17.0
05F7:  BSF    03.1
05F8:  MOVLW  98
05F9:  MOVWF  04
05FA:  BSF    03.7
05FB:  BCF    03.5
05FC:  MOVF   68,W
05FD:  BSF    03.5
05FE:  MOVWF  1F
05FF:  BCF    03.5
0600:  MOVF   67,W
0601:  BSF    03.5
0602:  MOVWF  1E
0603:  BCF    03.5
0604:  MOVF   66,W
0605:  BSF    03.5
0606:  MOVWF  1D
0607:  BCF    03.5
0608:  MOVF   65,W
0609:  BSF    03.5
060A:  MOVWF  1C
060B:  CLRF   23
060C:  CLRF   22
060D:  CLRF   21
060E:  BCF    03.5
060F:  MOVF   69,W
0610:  BSF    03.5
0611:  MOVWF  20
0612:  BCF    03.5
0613:  BCF    03.6
0614:  CALL   4E0
0615:  BSF    03.5
0616:  BSF    03.6
0617:  MOVF   16,W
0618:  MOVWF  04
0619:  BCF    03.7
061A:  BTFSC  17.0
061B:  BSF    03.7
061C:  MOVLW  30
061D:  ADDWF  18,W
061E:  MOVWF  77
061F:  MOVF   19,W
0620:  MOVWF  78
0621:  MOVLW  00
0622:  BTFSC  03.0
0623:  MOVLW  01
0624:  ADDWF  78,F
0625:  MOVF   1A,W
0626:  MOVWF  79
0627:  MOVLW  00
0628:  BTFSC  03.0
0629:  MOVLW  01
062A:  ADDWF  79,F
062B:  MOVF   1B,W
062C:  MOVWF  7A
062D:  MOVLW  00
062E:  BTFSC  03.0
062F:  MOVLW  01
0630:  ADDWF  7A,F
0631:  MOVF   14,W
0632:  MOVWF  04
0633:  BCF    03.7
0634:  BTFSC  15.0
0635:  BSF    03.7
0636:  MOVF   77,W
0637:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0638:  MOVF   12,W
0639:  BCF    03.5
063A:  ADDWF  6A,W
063B:  MOVWF  04
063C:  BCF    03.7
063D:  BTFSC  6B.0
063E:  BSF    03.7
063F:  MOVF   00,W
0640:  SUBLW  39
0641:  BTFSC  03.0
0642:  GOTO   64E
....................             s[cnt]+=0x7; 
0643:  BSF    03.5
0644:  MOVF   12,W
0645:  BCF    03.5
0646:  ADDWF  6A,W
0647:  MOVWF  04
0648:  BCF    03.7
0649:  BTFSC  6B.0
064A:  BSF    03.7
064B:  MOVLW  07
064C:  ADDWF  00,W
064D:  MOVWF  00
....................  
....................          cnt++; 
064E:  BSF    03.5
064F:  INCF   12,F
....................          num=temp; 
0650:  BCF    03.5
0651:  MOVF   6F,W
0652:  MOVWF  68
0653:  MOVF   6E,W
0654:  MOVWF  67
0655:  MOVF   6D,W
0656:  MOVWF  66
0657:  MOVF   6C,W
0658:  MOVWF  65
0659:  GOTO   5B4
....................      } 
....................  
....................      if(sign==1) { 
065A:  BSF    03.5
065B:  DECFSZ 11,W
065C:  GOTO   668
....................          s[cnt]=0x2D;      // Negative sign 
065D:  MOVF   12,W
065E:  BCF    03.5
065F:  ADDWF  6A,W
0660:  MOVWF  04
0661:  BCF    03.7
0662:  BTFSC  6B.0
0663:  BSF    03.7
0664:  MOVLW  2D
0665:  MOVWF  00
....................          cnt++; 
0666:  BSF    03.5
0667:  INCF   12,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0668:  CLRF   10
0669:  BCF    03.0
066A:  RRF    12,W
066B:  SUBWF  10,W
066C:  BTFSC  03.0
066D:  GOTO   6A6
....................  
....................          c=s[i]; 
066E:  MOVF   10,W
066F:  BCF    03.5
0670:  ADDWF  6A,W
0671:  MOVWF  04
0672:  BCF    03.7
0673:  BTFSC  6B.0
0674:  BSF    03.7
0675:  MOVF   00,W
0676:  BSF    03.5
0677:  MOVWF  13
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0678:  MOVF   10,W
0679:  BCF    03.5
067A:  ADDWF  6A,W
067B:  MOVWF  78
067C:  MOVF   6B,W
067D:  MOVWF  7A
067E:  BTFSC  03.0
067F:  INCF   7A,F
0680:  MOVF   78,W
0681:  BSF    03.5
0682:  MOVWF  14
0683:  MOVF   7A,W
0684:  MOVWF  15
0685:  MOVF   10,W
0686:  SUBWF  12,W
0687:  ADDLW  FF
0688:  BCF    03.5
0689:  ADDWF  6A,W
068A:  MOVWF  04
068B:  BCF    03.7
068C:  BTFSC  6B.0
068D:  BSF    03.7
068E:  MOVF   00,W
068F:  BSF    03.5
0690:  MOVWF  16
0691:  MOVF   14,W
0692:  MOVWF  04
0693:  BCF    03.7
0694:  BTFSC  15.0
0695:  BSF    03.7
0696:  MOVF   16,W
0697:  MOVWF  00
....................          s[cnt-i-1]=c; 
0698:  MOVF   10,W
0699:  SUBWF  12,W
069A:  ADDLW  FF
069B:  BCF    03.5
069C:  ADDWF  6A,W
069D:  MOVWF  04
069E:  BCF    03.7
069F:  BTFSC  6B.0
06A0:  BSF    03.7
06A1:  BSF    03.5
06A2:  MOVF   13,W
06A3:  MOVWF  00
06A4:  INCF   10,F
06A5:  GOTO   669
....................      } 
....................      s[cnt]='\0';     // End the string 
06A6:  MOVF   12,W
06A7:  BCF    03.5
06A8:  ADDWF  6A,W
06A9:  MOVWF  04
06AA:  BCF    03.7
06AB:  BTFSC  6B.0
06AC:  BSF    03.7
06AD:  CLRF   00
....................      return s; 
06AE:  MOVF   6A,W
06AF:  MOVWF  78
06B0:  MOVF   6B,W
06B1:  MOVWF  79
06B2:  BCF    03.6
06B3:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0135:  MOVLW  68
0136:  MOVWF  04
0137:  BSF    03.7
0138:  MOVF   00,W
0139:  BTFSC  03.2
013A:  GOTO   148
013B:  MOVLW  06
013C:  MOVWF  78
013D:  CLRF   77
013E:  DECFSZ 77,F
013F:  GOTO   13E
0140:  DECFSZ 78,F
0141:  GOTO   13D
0142:  MOVLW  7B
0143:  MOVWF  77
0144:  DECFSZ 77,F
0145:  GOTO   144
0146:  DECFSZ 00,F
0147:  GOTO   13B
0148:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01E6:  BSF    07.0
....................    output_float(LCD_DATA5); 
01E7:  BSF    07.1
....................    output_float(LCD_DATA6); 
01E8:  BSF    07.2
....................    output_float(LCD_DATA7); 
01E9:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01EA:  BCF    03.5
01EB:  BSF    09.2
01EC:  BSF    03.5
01ED:  BCF    09.2
....................    delay_cycles(1); 
01EE:  NOP
....................    lcd_output_enable(1); 
01EF:  BCF    03.5
01F0:  BSF    09.0
01F1:  BSF    03.5
01F2:  BCF    09.0
....................    delay_cycles(1); 
01F3:  NOP
....................    high = lcd_read_nibble(); 
01F4:  BCF    03.5
01F5:  CALL   191
01F6:  MOVF   78,W
01F7:  BSF    03.6
01F8:  MOVWF  6F
....................        
....................    lcd_output_enable(0); 
01F9:  BCF    03.6
01FA:  BCF    09.0
01FB:  BSF    03.5
01FC:  BCF    09.0
....................    delay_cycles(1); 
01FD:  NOP
....................    lcd_output_enable(1); 
01FE:  BCF    03.5
01FF:  BSF    09.0
0200:  BSF    03.5
0201:  BCF    09.0
....................    delay_us(1); 
0202:  GOTO   203
0203:  GOTO   204
0204:  NOP
....................    low = lcd_read_nibble(); 
0205:  BCF    03.5
0206:  CALL   191
0207:  MOVF   78,W
0208:  BSF    03.6
0209:  MOVWF  6E
....................        
....................    lcd_output_enable(0); 
020A:  BCF    03.6
020B:  BCF    09.0
020C:  BSF    03.5
020D:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
020E:  BCF    03.5
020F:  BCF    31.0
0210:  MOVF   31,W
0211:  BSF    03.5
0212:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0213:  BCF    03.5
0214:  BCF    31.1
0215:  MOVF   31,W
0216:  BSF    03.5
0217:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0218:  BCF    03.5
0219:  BCF    31.2
021A:  MOVF   31,W
021B:  BSF    03.5
021C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
021D:  BCF    03.5
021E:  BCF    31.3
021F:  MOVF   31,W
0220:  BSF    03.5
0221:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0222:  BCF    03.5
0223:  BSF    03.6
0224:  SWAPF  6F,W
0225:  MOVWF  77
0226:  MOVLW  F0
0227:  ANDWF  77,F
0228:  MOVF   77,W
0229:  IORWF  6E,W
022A:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0191:  BSF    03.5
0192:  BSF    03.6
0193:  CLRF   10
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0194:  BCF    03.5
0195:  BCF    03.6
0196:  BSF    31.0
0197:  MOVF   31,W
0198:  BSF    03.5
0199:  MOVWF  07
019A:  MOVLW  00
019B:  BCF    03.5
019C:  BTFSC  07.0
019D:  MOVLW  01
019E:  BSF    03.5
019F:  BSF    03.6
01A0:  IORWF  10,F
....................    n |= input(LCD_DATA5) << 1; 
01A1:  BCF    03.5
01A2:  BCF    03.6
01A3:  BSF    31.1
01A4:  MOVF   31,W
01A5:  BSF    03.5
01A6:  MOVWF  07
01A7:  MOVLW  00
01A8:  BCF    03.5
01A9:  BTFSC  07.1
01AA:  MOVLW  01
01AB:  MOVWF  77
01AC:  BCF    03.0
01AD:  RLF    77,F
01AE:  MOVF   77,W
01AF:  BSF    03.5
01B0:  BSF    03.6
01B1:  IORWF  10,F
....................    n |= input(LCD_DATA6) << 2; 
01B2:  BCF    03.5
01B3:  BCF    03.6
01B4:  BSF    31.2
01B5:  MOVF   31,W
01B6:  BSF    03.5
01B7:  MOVWF  07
01B8:  MOVLW  00
01B9:  BCF    03.5
01BA:  BTFSC  07.2
01BB:  MOVLW  01
01BC:  MOVWF  77
01BD:  RLF    77,F
01BE:  RLF    77,F
01BF:  MOVLW  FC
01C0:  ANDWF  77,F
01C1:  MOVF   77,W
01C2:  BSF    03.5
01C3:  BSF    03.6
01C4:  IORWF  10,F
....................    n |= input(LCD_DATA7) << 3; 
01C5:  BCF    03.5
01C6:  BCF    03.6
01C7:  BSF    31.3
01C8:  MOVF   31,W
01C9:  BSF    03.5
01CA:  MOVWF  07
01CB:  MOVLW  00
01CC:  BCF    03.5
01CD:  BTFSC  07.3
01CE:  MOVLW  01
01CF:  MOVWF  77
01D0:  RLF    77,F
01D1:  RLF    77,F
01D2:  RLF    77,F
01D3:  MOVLW  F8
01D4:  ANDWF  77,F
01D5:  MOVF   77,W
01D6:  BSF    03.5
01D7:  BSF    03.6
01D8:  IORWF  10,F
....................     
....................    return(n); 
01D9:  MOVF   10,W
01DA:  MOVWF  78
....................   #else 
01DB:  BCF    03.5
01DC:  BCF    03.6
01DD:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0149:  BSF    03.6
014A:  BTFSC  6F.0
014B:  GOTO   150
014C:  BCF    03.6
014D:  BCF    07.0
014E:  GOTO   152
014F:  BSF    03.6
0150:  BCF    03.6
0151:  BSF    07.0
0152:  BCF    31.0
0153:  MOVF   31,W
0154:  BSF    03.5
0155:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0156:  BCF    03.5
0157:  BSF    03.6
0158:  BTFSC  6F.1
0159:  GOTO   15E
015A:  BCF    03.6
015B:  BCF    07.1
015C:  GOTO   160
015D:  BSF    03.6
015E:  BCF    03.6
015F:  BSF    07.1
0160:  BCF    31.1
0161:  MOVF   31,W
0162:  BSF    03.5
0163:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0164:  BCF    03.5
0165:  BSF    03.6
0166:  BTFSC  6F.2
0167:  GOTO   16C
0168:  BCF    03.6
0169:  BCF    07.2
016A:  GOTO   16E
016B:  BSF    03.6
016C:  BCF    03.6
016D:  BSF    07.2
016E:  BCF    31.2
016F:  MOVF   31,W
0170:  BSF    03.5
0171:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0172:  BCF    03.5
0173:  BSF    03.6
0174:  BTFSC  6F.3
0175:  GOTO   17A
0176:  BCF    03.6
0177:  BCF    07.3
0178:  GOTO   17C
0179:  BSF    03.6
017A:  BCF    03.6
017B:  BSF    07.3
017C:  BCF    31.3
017D:  MOVF   31,W
017E:  BSF    03.5
017F:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0180:  NOP
....................    lcd_output_enable(1); 
0181:  BCF    03.5
0182:  BSF    09.0
0183:  BSF    03.5
0184:  BCF    09.0
....................    delay_us(2); 
0185:  MOVLW  02
0186:  MOVWF  77
0187:  DECFSZ 77,F
0188:  GOTO   187
0189:  GOTO   18A
018A:  NOP
....................    lcd_output_enable(0); 
018B:  BCF    03.5
018C:  BCF    09.0
018D:  BSF    03.5
018E:  BCF    09.0
018F:  BCF    03.5
0190:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01DE:  BSF    03.5
01DF:  BCF    09.0
....................    lcd_rs_tris(); 
01E0:  BCF    09.1
....................    lcd_rw_tris(); 
01E1:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01E2:  BCF    03.5
01E3:  BCF    09.1
01E4:  BSF    03.5
01E5:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
022B:  MOVF   78,W
022C:  MOVWF  6E
022D:  BTFSS  6E.7
022E:  GOTO   232
022F:  BSF    03.5
0230:  BCF    03.6
0231:  GOTO   1E6
....................    lcd_output_rs(address); 
0232:  MOVF   6C,F
0233:  BTFSS  03.2
0234:  GOTO   239
0235:  BCF    03.6
0236:  BCF    09.1
0237:  GOTO   23B
0238:  BSF    03.6
0239:  BCF    03.6
023A:  BSF    09.1
023B:  BSF    03.5
023C:  BCF    09.1
....................    delay_cycles(1); 
023D:  NOP
....................    lcd_output_rw(0); 
023E:  BCF    03.5
023F:  BCF    09.2
0240:  BSF    03.5
0241:  BCF    09.2
....................    delay_cycles(1); 
0242:  NOP
....................    lcd_output_enable(0); 
0243:  BCF    03.5
0244:  BCF    09.0
0245:  BSF    03.5
0246:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0247:  BCF    03.5
0248:  BSF    03.6
0249:  SWAPF  6D,W
024A:  MOVWF  6E
024B:  MOVLW  0F
024C:  ANDWF  6E,F
024D:  MOVF   6E,W
024E:  MOVWF  6F
024F:  BCF    03.6
0250:  CALL   149
....................    lcd_send_nibble(n & 0xf); 
0251:  BSF    03.6
0252:  MOVF   6D,W
0253:  ANDLW  0F
0254:  MOVWF  6E
0255:  MOVWF  6F
0256:  BCF    03.6
0257:  CALL   149
0258:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0259:  MOVLW  28
025A:  BSF    03.6
025B:  MOVWF  64
025C:  MOVLW  0C
025D:  MOVWF  65
025E:  MOVLW  01
025F:  MOVWF  66
0260:  MOVLW  06
0261:  MOVWF  67
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0262:  BCF    03.6
0263:  BCF    09.0
0264:  BSF    03.5
0265:  BCF    09.0
....................    lcd_output_rs(0); 
0266:  BCF    03.5
0267:  BCF    09.1
0268:  BSF    03.5
0269:  BCF    09.1
....................    lcd_output_rw(0); 
026A:  BCF    03.5
026B:  BCF    09.2
026C:  BSF    03.5
026D:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
026E:  BCF    03.5
026F:  BCF    31.0
0270:  MOVF   31,W
0271:  BSF    03.5
0272:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0273:  BCF    03.5
0274:  BCF    31.1
0275:  MOVF   31,W
0276:  BSF    03.5
0277:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0278:  BCF    03.5
0279:  BCF    31.2
027A:  MOVF   31,W
027B:  BSF    03.5
027C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
027D:  BCF    03.5
027E:  BCF    31.3
027F:  MOVF   31,W
0280:  BSF    03.5
0281:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0282:  BCF    09.0
....................    lcd_rs_tris(); 
0283:  BCF    09.1
....................    lcd_rw_tris(); 
0284:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0285:  MOVLW  0F
0286:  BCF    03.5
0287:  BSF    03.6
0288:  MOVWF  68
0289:  BCF    03.6
028A:  CALL   135
....................    for(i=1;i<=3;++i) 
028B:  MOVLW  01
028C:  BSF    03.6
028D:  MOVWF  63
028E:  MOVF   63,W
028F:  SUBLW  03
0290:  BTFSS  03.0
0291:  GOTO   29E
....................    { 
....................        lcd_send_nibble(3); 
0292:  MOVLW  03
0293:  MOVWF  6F
0294:  BCF    03.6
0295:  CALL   149
....................        delay_ms(5); 
0296:  MOVLW  05
0297:  BSF    03.6
0298:  MOVWF  68
0299:  BCF    03.6
029A:  CALL   135
029B:  BSF    03.6
029C:  INCF   63,F
029D:  GOTO   28E
....................    } 
....................     
....................    lcd_send_nibble(2); 
029E:  MOVLW  02
029F:  MOVWF  6F
02A0:  BCF    03.6
02A1:  CALL   149
....................    delay_ms(5); 
02A2:  MOVLW  05
02A3:  BSF    03.6
02A4:  MOVWF  68
02A5:  BCF    03.6
02A6:  CALL   135
....................    for(i=0;i<=3;++i) 
02A7:  BSF    03.6
02A8:  CLRF   63
02A9:  MOVF   63,W
02AA:  SUBLW  03
02AB:  BTFSS  03.0
02AC:  GOTO   2BB
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02AD:  MOVLW  64
02AE:  ADDWF  63,W
02AF:  MOVWF  04
02B0:  BSF    03.7
02B1:  MOVF   00,W
02B2:  MOVWF  68
02B3:  CLRF   6C
02B4:  MOVF   68,W
02B5:  MOVWF  6D
02B6:  BCF    03.6
02B7:  CALL   1DE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02B8:  BSF    03.6
02B9:  INCF   63,F
02BA:  GOTO   2A9
02BB:  BCF    03.6
02BC:  BCF    0A.3
02BD:  BSF    0A.4
02BE:  GOTO   1C9 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0442:  BSF    03.6
0443:  DECFSZ 69,W
0444:  GOTO   446
0445:  GOTO   449
....................       address=LCD_LINE_TWO; 
0446:  MOVLW  40
0447:  MOVWF  6A
0448:  GOTO   44A
....................    else 
....................       address=0; 
0449:  CLRF   6A
....................       
....................    address+=x-1; 
044A:  MOVLW  01
044B:  SUBWF  68,W
044C:  ADDWF  6A,F
....................    lcd_send_byte(0,0x80|address); 
044D:  MOVF   6A,W
044E:  IORLW  80
044F:  MOVWF  6B
0450:  CLRF   6C
0451:  MOVF   6B,W
0452:  MOVWF  6D
0453:  BCF    03.6
0454:  CALL   1DE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0455:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0456:  BSF    03.6
0457:  MOVF   67,W
0458:  XORLW  07
0459:  BCF    03.6
045A:  BTFSC  03.2
045B:  GOTO   466
045C:  XORLW  0B
045D:  BTFSC  03.2
045E:  GOTO   46D
045F:  XORLW  06
0460:  BTFSC  03.2
0461:  GOTO   479
0462:  XORLW  02
0463:  BTFSC  03.2
0464:  GOTO   481
0465:  GOTO   488
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0466:  MOVLW  01
0467:  BSF    03.6
0468:  MOVWF  68
0469:  MOVWF  69
046A:  BCF    03.6
046B:  CALL   442
046C:  GOTO   48F
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
046D:  BSF    03.6
046E:  CLRF   6C
046F:  MOVLW  01
0470:  MOVWF  6D
0471:  BCF    03.6
0472:  CALL   1DE
....................                      delay_ms(2); 
0473:  MOVLW  02
0474:  BSF    03.6
0475:  MOVWF  68
0476:  BCF    03.6
0477:  CALL   135
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0478:  GOTO   48F
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0479:  MOVLW  01
047A:  BSF    03.6
047B:  MOVWF  68
047C:  MOVLW  02
047D:  MOVWF  69
047E:  BCF    03.6
047F:  CALL   442
0480:  GOTO   48F
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0481:  BSF    03.6
0482:  CLRF   6C
0483:  MOVLW  10
0484:  MOVWF  6D
0485:  BCF    03.6
0486:  CALL   1DE
0487:  GOTO   48F
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0488:  MOVLW  01
0489:  BSF    03.6
048A:  MOVWF  6C
048B:  MOVF   67,W
048C:  MOVWF  6D
048D:  BCF    03.6
048E:  CALL   1DE
....................      #endif 
....................    } 
048F:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 VT=0,TTNHAN=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... CHAR KYTUCHAR[20]="HIHI"; 
*
1031:  MOVLW  48
1032:  MOVWF  41
1033:  MOVLW  49
1034:  MOVWF  42
1035:  MOVLW  48
1036:  MOVWF  43
1037:  MOVLW  49
1038:  MOVWF  44
1039:  CLRF   45
.................... CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
103A:  MOVWF  5D
103B:  MOVLW  44
103C:  MOVWF  5E
103D:  MOVLW  47
103E:  MOVWF  5F
103F:  MOVLW  57
1040:  MOVWF  60
1041:  CLRF   61
1042:  MOVLW  49
1043:  MOVWF  62
1044:  MOVLW  44
1045:  MOVWF  63
1046:  MOVLW  4E
1047:  MOVWF  64
1048:  MOVLW  4F
1049:  MOVWF  65
104A:  MOVLW  44
104B:  MOVWF  66
104C:  MOVLW  45
104D:  MOVWF  67
104E:  CLRF   68
104F:  MOVLW  43
1050:  MOVWF  69
1051:  MOVLW  4F
1052:  MOVWF  6A
1053:  MOVLW  4D
1054:  MOVWF  6B
1055:  MOVWF  6C
1056:  MOVLW  41
1057:  MOVWF  6D
1058:  MOVLW  4E
1059:  MOVWF  6E
105A:  CLRF   6F
105B:  MOVLW  44
105C:  MOVWF  70
105D:  MOVLW  41
105E:  MOVWF  71
105F:  MOVLW  54
1060:  MOVWF  72
1061:  MOVLW  41
1062:  MOVWF  73
1063:  CLRF   74
1064:  CLRF   56
1065:  MOVLW  5D
1066:  MOVWF  55
1067:  CLRF   58
1068:  MOVLW  62
1069:  MOVWF  57
106A:  CLRF   5A
106B:  MOVLW  69
106C:  MOVWF  59
106D:  CLRF   5C
106E:  MOVLW  70
106F:  MOVWF  5B
.................... INT1 TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 0, 1, 0, 1, 1}; 
1070:  MOVLW  D6
1071:  MOVWF  76
.................... INT1 TT_SENSOR[8]={1, 1, 1, 1, 0, 0, 0, 0}; 
1072:  MOVLW  0F
1073:  MOVWF  7B
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
1074:  MOVLW  20
1075:  BSF    03.5
1076:  MOVWF  20
1077:  CLRF   21
1078:  CLRF   7D
1079:  MOVLW  A0
107A:  MOVWF  7C
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
107B:  MOVLW  20
107C:  MOVWF  24
107D:  CLRF   25
107E:  CLRF   23
107F:  MOVLW  A4
1080:  MOVWF  22
.................... CHAR *PACKAGE_NHIETDO[]={"*","ID_GW", "ID_NODE","LENGHT", "S_S" ,"TT_cambien","#"}; 
1081:  MOVLW  2A
1082:  MOVWF  34
1083:  CLRF   35
1084:  MOVLW  49
1085:  MOVWF  36
1086:  MOVLW  44
1087:  MOVWF  37
1088:  MOVLW  5F
1089:  MOVWF  38
108A:  MOVLW  47
108B:  MOVWF  39
108C:  MOVLW  57
108D:  MOVWF  3A
108E:  CLRF   3B
108F:  MOVLW  49
1090:  MOVWF  3C
1091:  MOVLW  44
1092:  MOVWF  3D
1093:  MOVLW  5F
1094:  MOVWF  3E
1095:  MOVLW  4E
1096:  MOVWF  3F
1097:  MOVLW  4F
1098:  MOVWF  40
1099:  MOVLW  44
109A:  MOVWF  41
109B:  MOVLW  45
109C:  MOVWF  42
109D:  CLRF   43
109E:  MOVLW  4C
109F:  MOVWF  44
10A0:  MOVLW  45
10A1:  MOVWF  45
10A2:  MOVLW  4E
10A3:  MOVWF  46
10A4:  MOVLW  47
10A5:  MOVWF  47
10A6:  MOVLW  48
10A7:  MOVWF  48
10A8:  MOVLW  54
10A9:  MOVWF  49
10AA:  CLRF   4A
10AB:  MOVLW  53
10AC:  MOVWF  4B
10AD:  MOVLW  5F
10AE:  MOVWF  4C
10AF:  MOVLW  53
10B0:  MOVWF  4D
10B1:  CLRF   4E
10B2:  MOVLW  54
10B3:  MOVWF  4F
10B4:  MOVWF  50
10B5:  MOVLW  5F
10B6:  MOVWF  51
10B7:  MOVLW  63
10B8:  MOVWF  52
10B9:  MOVLW  61
10BA:  MOVWF  53
10BB:  MOVLW  6D
10BC:  MOVWF  54
10BD:  MOVLW  62
10BE:  MOVWF  55
10BF:  MOVLW  69
10C0:  MOVWF  56
10C1:  MOVLW  65
10C2:  MOVWF  57
10C3:  MOVLW  6E
10C4:  MOVWF  58
10C5:  CLRF   59
10C6:  MOVLW  23
10C7:  MOVWF  5A
10C8:  CLRF   5B
10C9:  CLRF   27
10CA:  MOVLW  B4
10CB:  MOVWF  26
10CC:  CLRF   29
10CD:  MOVLW  B6
10CE:  MOVWF  28
10CF:  CLRF   2B
10D0:  MOVLW  BC
10D1:  MOVWF  2A
10D2:  CLRF   2D
10D3:  MOVLW  C4
10D4:  MOVWF  2C
10D5:  CLRF   2F
10D6:  MOVLW  CB
10D7:  MOVWF  2E
10D8:  CLRF   31
10D9:  MOVLW  CF
10DA:  MOVWF  30
10DB:  CLRF   33
10DC:  MOVLW  DA
10DD:  MOVWF  32
....................  
.................... CHAR *PACKAGE_CONFIG[]={"*","ID_GW" ,"ID_NODE", "LENGHT","C_F", "DEVICE1234","SENSOR1234","#"}; 
10DE:  MOVLW  2A
10DF:  BCF    03.5
10E0:  BSF    03.6
10E1:  MOVWF  10
10E2:  CLRF   11
10E3:  MOVLW  49
10E4:  MOVWF  12
10E5:  MOVLW  44
10E6:  MOVWF  13
10E7:  MOVLW  5F
10E8:  MOVWF  14
10E9:  MOVLW  47
10EA:  MOVWF  15
10EB:  MOVLW  57
10EC:  MOVWF  16
10ED:  CLRF   17
10EE:  MOVLW  49
10EF:  MOVWF  18
10F0:  MOVLW  44
10F1:  MOVWF  19
10F2:  MOVLW  5F
10F3:  MOVWF  1A
10F4:  MOVLW  4E
10F5:  MOVWF  1B
10F6:  MOVLW  4F
10F7:  MOVWF  1C
10F8:  MOVLW  44
10F9:  MOVWF  1D
10FA:  MOVLW  45
10FB:  MOVWF  1E
10FC:  CLRF   1F
10FD:  MOVLW  4C
10FE:  MOVWF  20
10FF:  MOVLW  45
1100:  MOVWF  21
1101:  MOVLW  4E
1102:  MOVWF  22
1103:  MOVLW  47
1104:  MOVWF  23
1105:  MOVLW  48
1106:  MOVWF  24
1107:  MOVLW  54
1108:  MOVWF  25
1109:  CLRF   26
110A:  MOVLW  43
110B:  MOVWF  27
110C:  MOVLW  5F
110D:  MOVWF  28
110E:  MOVLW  46
110F:  MOVWF  29
1110:  CLRF   2A
1111:  MOVLW  44
1112:  MOVWF  2B
1113:  MOVLW  45
1114:  MOVWF  2C
1115:  MOVLW  56
1116:  MOVWF  2D
1117:  MOVLW  49
1118:  MOVWF  2E
1119:  MOVLW  43
111A:  MOVWF  2F
111B:  MOVLW  45
111C:  MOVWF  30
111D:  MOVLW  31
111E:  MOVWF  31
111F:  MOVLW  32
1120:  MOVWF  32
1121:  MOVLW  33
1122:  MOVWF  33
1123:  MOVLW  34
1124:  MOVWF  34
1125:  CLRF   35
1126:  MOVLW  53
1127:  MOVWF  36
1128:  MOVLW  45
1129:  MOVWF  37
112A:  MOVLW  4E
112B:  MOVWF  38
112C:  MOVLW  53
112D:  MOVWF  39
112E:  MOVLW  4F
112F:  MOVWF  3A
1130:  MOVLW  52
1131:  MOVWF  3B
1132:  MOVLW  31
1133:  MOVWF  3C
1134:  MOVLW  32
1135:  MOVWF  3D
1136:  MOVLW  33
1137:  MOVWF  3E
1138:  MOVLW  34
1139:  MOVWF  3F
113A:  CLRF   40
113B:  MOVLW  23
113C:  MOVWF  41
113D:  CLRF   42
113E:  MOVLW  01
113F:  BSF    03.5
1140:  BCF    03.6
1141:  MOVWF  5D
1142:  MOVLW  10
1143:  MOVWF  5C
1144:  MOVLW  01
1145:  MOVWF  5F
1146:  MOVLW  12
1147:  MOVWF  5E
1148:  MOVLW  01
1149:  MOVWF  61
114A:  MOVLW  18
114B:  MOVWF  60
114C:  MOVLW  01
114D:  MOVWF  63
114E:  MOVLW  20
114F:  MOVWF  62
1150:  MOVLW  01
1151:  MOVWF  65
1152:  MOVLW  27
1153:  MOVWF  64
1154:  MOVLW  01
1155:  MOVWF  67
1156:  MOVLW  2B
1157:  MOVWF  66
1158:  MOVLW  01
1159:  MOVWF  69
115A:  MOVLW  36
115B:  MOVWF  68
115C:  MOVLW  01
115D:  MOVWF  6B
115E:  MOVLW  41
115F:  MOVWF  6A
....................  
.................... CHAR *ID_[]="0"; 
1160:  MOVLW  30
1161:  MOVWF  6E
1162:  CLRF   6F
1163:  CLRF   6D
1164:  MOVLW  EE
1165:  MOVWF  6C
.................... CHAR *ID_GW[]= "0000"; 
1166:  MOVLW  30
1167:  BCF    03.5
1168:  BSF    03.6
1169:  MOVWF  45
116A:  MOVWF  46
116B:  MOVWF  47
116C:  MOVWF  48
116D:  CLRF   49
116E:  MOVLW  01
116F:  MOVWF  44
1170:  MOVLW  45
1171:  MOVWF  43
.................... UNSIGNED INT8 ID_GATEWAY[4] = {0,0,0,0}; 
1172:  CLRF   4A
1173:  CLRF   4B
1174:  CLRF   4C
1175:  CLRF   4D
.................... CHAR *TEMP_CHAR[]="0"; 
1176:  MOVLW  30
1177:  MOVWF  50
1178:  CLRF   51
1179:  MOVLW  01
117A:  MOVWF  4F
117B:  MOVLW  50
117C:  MOVWF  4E
.................... CHAR *TEMP_CHAR2[]="0";  
117D:  MOVLW  30
117E:  MOVWF  54
117F:  CLRF   55
1180:  MOVLW  01
1181:  MOVWF  53
1182:  MOVLW  54
1183:  MOVWF  52
.................... CHAR *TEMP_CHAR3[]="0";  
1184:  MOVLW  30
1185:  MOVWF  58
1186:  CLRF   59
1187:  MOVLW  01
1188:  MOVWF  57
1189:  MOVLW  58
118A:  MOVWF  56
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... CHAR NHIETDO1[]="27"; 
118B:  MOVLW  32
118C:  MOVWF  5A
118D:  MOVLW  37
118E:  MOVWF  5B
118F:  CLRF   5C
.................... CHAR NHIETDO2[]="27"; 
1190:  MOVLW  32
1191:  MOVWF  5D
1192:  MOVLW  37
1193:  MOVWF  5E
1194:  CLRF   5F
.................... CONST CHAR PHANTICH_DATA = '_'; 
....................  
....................  
.................... #INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    75.2
....................    TT_STT = 1; 
0808:  BSF    75.4
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  68
080C:  MOVLW  02
080D:  MOVWF  69
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   442
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  68
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   135
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  6F
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   490
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  75.4
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  63
0831:  MOVLW  96
0832:  MOVWF  68
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   135
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 63,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   68
083B:  CLRF   67
083C:  CLRF   66
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  65
0841:  MOVLW  0A
0842:  MOVWF  69
0843:  CLRF   6B
0844:  MOVLW  EC
0845:  MOVWF  6A
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   55E
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  68
084D:  MOVLW  02
084E:  MOVWF  69
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   442
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  68
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   135
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  EC
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   6B4
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  68
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   135
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    75.2
....................    TT_STT = 1; 
086F:  BSF    75.4
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  68
0873:  MOVLW  02
0874:  MOVWF  69
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   442
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  68
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   135
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:           "); 
0880:  MOVLW  78
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   490
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  75.4
088A:  GOTO   178
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11C
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  63
0898:  MOVLW  96
0899:  MOVWF  68
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   135
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 63,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   68
08A2:  CLRF   67
08A3:  CLRF   66
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  65
08A8:  MOVLW  0A
08A9:  MOVWF  69
08AA:  MOVLW  01
08AB:  MOVWF  6B
08AC:  MOVLW  4E
08AD:  MOVWF  6A
08AE:  BCF    0A.3
08AF:  BCF    03.6
08B0:  CALL   55E
08B1:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B2:  MOVLW  09
08B3:  BSF    03.6
08B4:  MOVWF  68
08B5:  MOVLW  02
08B6:  MOVWF  69
08B7:  BCF    0A.3
08B8:  BCF    03.6
08B9:  CALL   442
08BA:  BSF    0A.3
....................          DELAY_MS (10); 
08BB:  MOVLW  0A
08BC:  BSF    03.6
08BD:  MOVWF  68
08BE:  BCF    0A.3
08BF:  BCF    03.6
08C0:  CALL   135
08C1:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C2:  MOVLW  4E
08C3:  MOVWF  04
08C4:  BSF    03.7
08C5:  BCF    0A.3
08C6:  CALL   6B4
08C7:  BSF    0A.3
....................          DELAY_MS (1); 
08C8:  MOVLW  01
08C9:  BSF    03.6
08CA:  MOVWF  68
08CB:  BCF    0A.3
08CC:  BCF    03.6
08CD:  CALL   135
08CE:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
08CF:  MOVLW  20
08D0:  BSF    03.6
08D1:  MOVWF  67
08D2:  BCF    0A.3
08D3:  BCF    03.6
08D4:  CALL   456
08D5:  BSF    0A.3
08D6:  MOVLW  3A
08D7:  BSF    03.6
08D8:  MOVWF  67
08D9:  BCF    0A.3
08DA:  BCF    03.6
08DB:  CALL   456
08DC:  BSF    0A.3
08DD:  MOVLW  20
08DE:  BSF    03.6
08DF:  MOVWF  67
08E0:  BCF    0A.3
08E1:  BCF    03.6
08E2:  CALL   456
08E3:  BSF    0A.3
....................          DELAY_MS (1); 
08E4:  MOVLW  01
08E5:  BSF    03.6
08E6:  MOVWF  68
08E7:  BCF    0A.3
08E8:  BCF    03.6
08E9:  CALL   135
08EA:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EB:  MOVF   3A,W
08EC:  BSF    03.6
08ED:  MOVWF  65
08EE:  CLRF   67
08EF:  MOVLW  76
08F0:  MOVWF  66
08F1:  BCF    0A.3
08F2:  BCF    03.6
08F3:  CALL   6D1
08F4:  BSF    0A.3
08F5:  MOVLW  00
08F6:  BTFSC  78.0
08F7:  MOVLW  01
08F8:  BSF    03.6
08F9:  MOVWF  63
08FA:  CLRF   68
08FB:  CLRF   67
08FC:  CLRF   66
08FD:  MOVF   63,W
08FE:  MOVWF  65
08FF:  MOVLW  0A
0900:  MOVWF  69
0901:  MOVLW  01
0902:  MOVWF  6B
0903:  MOVLW  4E
0904:  MOVWF  6A
0905:  BCF    0A.3
0906:  BCF    03.6
0907:  CALL   55E
0908:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0909:  MOVLW  4E
090A:  MOVWF  04
090B:  BSF    03.7
090C:  BCF    0A.3
090D:  CALL   6B4
090E:  BSF    0A.3
....................          DELAY_MS (1); 
090F:  MOVLW  01
0910:  BSF    03.6
0911:  MOVWF  68
0912:  BCF    0A.3
0913:  BCF    03.6
0914:  CALL   135
0915:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0916:  BSF    03.5
0917:  BCF    08.0
0918:  MOVLW  01
0919:  BCF    03.5
091A:  XORWF  08,F
....................       } 
091B:  GOTO   177
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091C:  BSF    03.5
091D:  BSF    06.3
091E:  BCF    03.5
091F:  BTFSC  06.3
0920:  GOTO   177
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
0921:  MOVF   3A,W
0922:  BSF    03.6
0923:  MOVWF  65
0924:  CLRF   67
0925:  MOVLW  76
0926:  MOVWF  66
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   6D1
092A:  BSF    0A.3
092B:  MOVLW  00
092C:  BTFSS  78.0
092D:  MOVLW  01
092E:  BSF    03.6
092F:  MOVWF  63
0930:  BCF    03.6
0931:  MOVF   3A,W
0932:  BSF    03.6
0933:  MOVWF  64
0934:  MOVF   63,W
0935:  MOVWF  65
0936:  CLRF   67
0937:  MOVLW  76
0938:  MOVWF  66
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   6EA
093C:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
093D:  MOVLW  0D
093E:  BSF    03.6
093F:  MOVWF  68
0940:  MOVLW  02
0941:  MOVWF  69
0942:  BCF    0A.3
0943:  BCF    03.6
0944:  CALL   442
0945:  BSF    0A.3
....................          DELAY_MS (300); 
0946:  MOVLW  02
0947:  BSF    03.6
0948:  MOVWF  63
0949:  MOVLW  96
094A:  MOVWF  68
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   135
094E:  BSF    0A.3
094F:  BSF    03.6
0950:  DECFSZ 63,F
0951:  GOTO   149
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0952:  BCF    03.6
0953:  MOVF   3A,W
0954:  BSF    03.6
0955:  MOVWF  65
0956:  CLRF   67
0957:  MOVLW  76
0958:  MOVWF  66
0959:  BCF    0A.3
095A:  BCF    03.6
095B:  CALL   6D1
095C:  BSF    0A.3
095D:  MOVLW  00
095E:  BTFSC  78.0
095F:  MOVLW  01
0960:  BSF    03.6
0961:  MOVWF  63
0962:  CLRF   68
0963:  CLRF   67
0964:  CLRF   66
0965:  MOVF   63,W
0966:  MOVWF  65
0967:  MOVLW  0A
0968:  MOVWF  69
0969:  MOVLW  01
096A:  MOVWF  6B
096B:  MOVLW  4E
096C:  MOVWF  6A
096D:  BCF    0A.3
096E:  BCF    03.6
096F:  CALL   55E
0970:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0971:  MOVLW  4E
0972:  MOVWF  04
0973:  BSF    03.7
0974:  BCF    0A.3
0975:  CALL   6B4
0976:  BSF    0A.3
....................       } 
0977:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0979:  BCF    75.2
....................    TT_STT = 1; 
097A:  BSF    75.4
....................    LCD_GOTOXY (1, 2) ; 
097B:  MOVLW  01
097C:  BSF    03.6
097D:  MOVWF  68
097E:  MOVLW  02
097F:  MOVWF  69
0980:  BCF    0A.3
0981:  BCF    03.6
0982:  CALL   442
0983:  BSF    0A.3
....................    DELAY_MS (10);   
0984:  MOVLW  0A
0985:  BSF    03.6
0986:  MOVWF  68
0987:  BCF    0A.3
0988:  BCF    03.6
0989:  CALL   135
098A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
098B:  MOVLW  82
098C:  BSF    03.6
098D:  MOVWF  0D
098E:  MOVLW  00
098F:  MOVWF  0F
0990:  BCF    0A.3
0991:  BCF    03.6
0992:  CALL   490
0993:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0994:  BTFSS  75.4
0995:  GOTO   283
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0996:  BSF    03.5
0997:  BSF    06.2
0998:  BCF    03.5
0999:  BTFSC  06.2
099A:  GOTO   227
....................       { 
....................          STT_SENSOR ++; 
099B:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
099C:  MOVF   3B,W
099D:  SUBLW  03
099E:  BTFSS  03.0
099F:  CLRF   3B
....................          DELAY_MS (300); 
09A0:  MOVLW  02
09A1:  BSF    03.6
09A2:  MOVWF  63
09A3:  MOVLW  96
09A4:  MOVWF  68
09A5:  BCF    0A.3
09A6:  BCF    03.6
09A7:  CALL   135
09A8:  BSF    0A.3
09A9:  BSF    03.6
09AA:  DECFSZ 63,F
09AB:  GOTO   1A3
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09AC:  CLRF   68
09AD:  CLRF   67
09AE:  CLRF   66
09AF:  BCF    03.6
09B0:  MOVF   3B,W
09B1:  BSF    03.6
09B2:  MOVWF  65
09B3:  MOVLW  0A
09B4:  MOVWF  69
09B5:  MOVLW  01
09B6:  MOVWF  6B
09B7:  MOVLW  4E
09B8:  MOVWF  6A
09B9:  BCF    0A.3
09BA:  BCF    03.6
09BB:  CALL   55E
09BC:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09BD:  MOVLW  09
09BE:  BSF    03.6
09BF:  MOVWF  68
09C0:  MOVLW  02
09C1:  MOVWF  69
09C2:  BCF    0A.3
09C3:  BCF    03.6
09C4:  CALL   442
09C5:  BSF    0A.3
....................          DELAY_MS (10); 
09C6:  MOVLW  0A
09C7:  BSF    03.6
09C8:  MOVWF  68
09C9:  BCF    0A.3
09CA:  BCF    03.6
09CB:  CALL   135
09CC:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09CD:  MOVLW  4E
09CE:  MOVWF  04
09CF:  BSF    03.7
09D0:  BCF    0A.3
09D1:  CALL   6B4
09D2:  BSF    0A.3
....................          DELAY_MS (1); 
09D3:  MOVLW  01
09D4:  BSF    03.6
09D5:  MOVWF  68
09D6:  BCF    0A.3
09D7:  BCF    03.6
09D8:  CALL   135
09D9:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
09DA:  MOVLW  20
09DB:  BSF    03.6
09DC:  MOVWF  67
09DD:  BCF    0A.3
09DE:  BCF    03.6
09DF:  CALL   456
09E0:  BSF    0A.3
09E1:  MOVLW  3A
09E2:  BSF    03.6
09E3:  MOVWF  67
09E4:  BCF    0A.3
09E5:  BCF    03.6
09E6:  CALL   456
09E7:  BSF    0A.3
09E8:  MOVLW  20
09E9:  BSF    03.6
09EA:  MOVWF  67
09EB:  BCF    0A.3
09EC:  BCF    03.6
09ED:  CALL   456
09EE:  BSF    0A.3
....................          DELAY_MS (1); 
09EF:  MOVLW  01
09F0:  BSF    03.6
09F1:  MOVWF  68
09F2:  BCF    0A.3
09F3:  BCF    03.6
09F4:  CALL   135
09F5:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F6:  MOVF   3B,W
09F7:  BSF    03.6
09F8:  MOVWF  65
09F9:  CLRF   67
09FA:  MOVLW  7B
09FB:  MOVWF  66
09FC:  BCF    0A.3
09FD:  BCF    03.6
09FE:  CALL   6D1
09FF:  BSF    0A.3
0A00:  MOVLW  00
0A01:  BTFSC  78.0
0A02:  MOVLW  01
0A03:  BSF    03.6
0A04:  MOVWF  63
0A05:  CLRF   68
0A06:  CLRF   67
0A07:  CLRF   66
0A08:  MOVF   63,W
0A09:  MOVWF  65
0A0A:  MOVLW  0A
0A0B:  MOVWF  69
0A0C:  MOVLW  01
0A0D:  MOVWF  6B
0A0E:  MOVLW  4E
0A0F:  MOVWF  6A
0A10:  BCF    0A.3
0A11:  BCF    03.6
0A12:  CALL   55E
0A13:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A14:  MOVLW  4E
0A15:  MOVWF  04
0A16:  BSF    03.7
0A17:  BCF    0A.3
0A18:  CALL   6B4
0A19:  BSF    0A.3
....................          DELAY_MS (1); 
0A1A:  MOVLW  01
0A1B:  BSF    03.6
0A1C:  MOVWF  68
0A1D:  BCF    0A.3
0A1E:  BCF    03.6
0A1F:  CALL   135
0A20:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A21:  BSF    03.5
0A22:  BCF    08.0
0A23:  MOVLW  01
0A24:  BCF    03.5
0A25:  XORWF  08,F
....................       } 
0A26:  GOTO   282
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A27:  BSF    03.5
0A28:  BSF    06.3
0A29:  BCF    03.5
0A2A:  BTFSC  06.3
0A2B:  GOTO   282
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A2C:  MOVF   3B,W
0A2D:  BSF    03.6
0A2E:  MOVWF  65
0A2F:  CLRF   67
0A30:  MOVLW  7B
0A31:  MOVWF  66
0A32:  BCF    0A.3
0A33:  BCF    03.6
0A34:  CALL   6D1
0A35:  BSF    0A.3
0A36:  MOVLW  00
0A37:  BTFSS  78.0
0A38:  MOVLW  01
0A39:  BSF    03.6
0A3A:  MOVWF  63
0A3B:  BCF    03.6
0A3C:  MOVF   3B,W
0A3D:  BSF    03.6
0A3E:  MOVWF  64
0A3F:  MOVF   63,W
0A40:  MOVWF  65
0A41:  CLRF   67
0A42:  MOVLW  7B
0A43:  MOVWF  66
0A44:  BCF    0A.3
0A45:  BCF    03.6
0A46:  CALL   6EA
0A47:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A48:  MOVLW  0D
0A49:  BSF    03.6
0A4A:  MOVWF  68
0A4B:  MOVLW  02
0A4C:  MOVWF  69
0A4D:  BCF    0A.3
0A4E:  BCF    03.6
0A4F:  CALL   442
0A50:  BSF    0A.3
....................          DELAY_MS (300); 
0A51:  MOVLW  02
0A52:  BSF    03.6
0A53:  MOVWF  63
0A54:  MOVLW  96
0A55:  MOVWF  68
0A56:  BCF    0A.3
0A57:  BCF    03.6
0A58:  CALL   135
0A59:  BSF    0A.3
0A5A:  BSF    03.6
0A5B:  DECFSZ 63,F
0A5C:  GOTO   254
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A5D:  BCF    03.6
0A5E:  MOVF   3B,W
0A5F:  BSF    03.6
0A60:  MOVWF  65
0A61:  CLRF   67
0A62:  MOVLW  7B
0A63:  MOVWF  66
0A64:  BCF    0A.3
0A65:  BCF    03.6
0A66:  CALL   6D1
0A67:  BSF    0A.3
0A68:  MOVLW  00
0A69:  BTFSC  78.0
0A6A:  MOVLW  01
0A6B:  BSF    03.6
0A6C:  MOVWF  63
0A6D:  CLRF   68
0A6E:  CLRF   67
0A6F:  CLRF   66
0A70:  MOVF   63,W
0A71:  MOVWF  65
0A72:  MOVLW  0A
0A73:  MOVWF  69
0A74:  MOVLW  01
0A75:  MOVWF  6B
0A76:  MOVLW  4E
0A77:  MOVWF  6A
0A78:  BCF    0A.3
0A79:  BCF    03.6
0A7A:  CALL   55E
0A7B:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A7C:  MOVLW  4E
0A7D:  MOVWF  04
0A7E:  BSF    03.7
0A7F:  BCF    0A.3
0A80:  CALL   6B4
0A81:  BSF    0A.3
....................       } 
0A82:  GOTO   194
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0A84:  BSF    03.6
0A85:  CLRF   63
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    ID_GW = "\0"; 
0A86:  CLRF   64
0A87:  CLRF   65
0A88:  MOVLW  43
0A89:  MOVWF  04
0A8A:  BSF    03.7
0A8B:  MOVF   64,W
0A8C:  ADDWF  04,F
0A8D:  MOVF   65,W
0A8E:  BCF    0A.3
0A8F:  BCF    03.6
0A90:  CALL   058
0A91:  BSF    0A.3
0A92:  MOVWF  00
0A93:  IORLW  00
0A94:  BTFSC  03.2
0A95:  GOTO   29B
0A96:  BSF    03.6
0A97:  INCF   65,F
0A98:  INCF   64,F
0A99:  GOTO   288
0A9A:  BCF    03.6
....................    TEMP_CHAR3 = "0"; 
0A9B:  BSF    03.6
0A9C:  CLRF   64
0A9D:  CLRF   65
0A9E:  MOVLW  56
0A9F:  MOVWF  04
0AA0:  BSF    03.7
0AA1:  MOVF   64,W
0AA2:  ADDWF  04,F
0AA3:  MOVF   65,W
0AA4:  BCF    0A.3
0AA5:  BCF    03.6
0AA6:  CALL   05E
0AA7:  BSF    0A.3
0AA8:  MOVWF  00
0AA9:  IORLW  00
0AAA:  BTFSC  03.2
0AAB:  GOTO   2B1
0AAC:  BSF    03.6
0AAD:  INCF   65,F
0AAE:  INCF   64,F
0AAF:  GOTO   29E
0AB0:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0AB1:  BCF    75.2
....................    TT_STT = 1; 
0AB2:  BSF    75.4
....................    LCD_GOTOXY (1, 2) ; 
0AB3:  MOVLW  01
0AB4:  BSF    03.6
0AB5:  MOVWF  68
0AB6:  MOVLW  02
0AB7:  MOVWF  69
0AB8:  BCF    0A.3
0AB9:  BCF    03.6
0ABA:  CALL   442
0ABB:  BSF    0A.3
....................    DELAY_MS (10); 
0ABC:  MOVLW  0A
0ABD:  BSF    03.6
0ABE:  MOVWF  68
0ABF:  BCF    0A.3
0AC0:  BCF    03.6
0AC1:  CALL   135
0AC2:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:  0000 "); 
0AC3:  MOVLW  8B
0AC4:  BSF    03.6
0AC5:  MOVWF  0D
0AC6:  MOVLW  00
0AC7:  MOVWF  0F
0AC8:  BCF    0A.3
0AC9:  BCF    03.6
0ACA:  CALL   490
0ACB:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0ACC:  MOVLW  01
0ACD:  BSF    03.6
0ACE:  MOVWF  68
0ACF:  MOVWF  69
0AD0:  BCF    0A.3
0AD1:  BCF    03.6
0AD2:  CALL   442
0AD3:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "        _    "); 
0AD4:  MOVLW  92
0AD5:  BSF    03.6
0AD6:  MOVWF  0D
0AD7:  MOVLW  00
0AD8:  MOVWF  0F
0AD9:  BCF    0A.3
0ADA:  BCF    03.6
0ADB:  CALL   490
0ADC:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0ADD:  BTFSS  75.4
0ADE:  GOTO   37F
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0ADF:  BSF    03.5
0AE0:  BSF    06.2
0AE1:  BCF    03.5
0AE2:  BTFSC  06.2
0AE3:  GOTO   309
....................       { 
....................           
....................          NUM++; 
0AE4:  BSF    03.6
0AE5:  INCF   63,F
....................          NUM = NUM % 4; 
0AE6:  MOVLW  03
0AE7:  ANDWF  63,F
....................          LCD_GOTOXY (5 + NUM, 1); 
0AE8:  MOVLW  05
0AE9:  ADDWF  63,W
0AEA:  MOVWF  64
0AEB:  MOVWF  68
0AEC:  MOVLW  01
0AED:  MOVWF  69
0AEE:  BCF    0A.3
0AEF:  BCF    03.6
0AF0:  CALL   442
0AF1:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    "); 
0AF2:  MOVLW  99
0AF3:  BSF    03.6
0AF4:  MOVWF  0D
0AF5:  MOVLW  00
0AF6:  MOVWF  0F
0AF7:  BCF    0A.3
0AF8:  BCF    03.6
0AF9:  CALL   490
0AFA:  BSF    0A.3
....................          DELAY_MS (300);  
0AFB:  MOVLW  02
0AFC:  BSF    03.6
0AFD:  MOVWF  64
0AFE:  MOVLW  96
0AFF:  MOVWF  68
0B00:  BCF    0A.3
0B01:  BCF    03.6
0B02:  CALL   135
0B03:  BSF    0A.3
0B04:  BSF    03.6
0B05:  DECFSZ 64,F
0B06:  GOTO   2FE
....................       } 
0B07:  GOTO   37D
0B08:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0B09:  BSF    03.5
0B0A:  BSF    06.3
0B0B:  BCF    03.5
0B0C:  BTFSC  06.3
0B0D:  GOTO   37E
....................       { 
....................          ID_GATEWAY[NUM]++; 
0B0E:  MOVLW  4A
0B0F:  BSF    03.6
0B10:  ADDWF  63,W
0B11:  MOVWF  04
0B12:  BSF    03.7
0B13:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0B14:  MOVLW  4A
0B15:  ADDWF  63,W
0B16:  MOVWF  78
0B17:  MOVLW  01
0B18:  MOVWF  7A
0B19:  BTFSC  03.0
0B1A:  INCF   7A,F
0B1B:  MOVF   78,W
0B1C:  MOVWF  64
0B1D:  MOVF   7A,W
0B1E:  MOVWF  65
0B1F:  MOVLW  4A
0B20:  ADDWF  63,W
0B21:  MOVWF  04
0B22:  BSF    03.7
0B23:  MOVF   00,W
0B24:  MOVWF  67
0B25:  MOVLW  0A
0B26:  MOVWF  68
*
0B3B:  MOVF   77,W
0B3C:  MOVWF  66
0B3D:  MOVF   64,W
0B3E:  MOVWF  04
0B3F:  BCF    03.7
0B40:  BTFSC  65.0
0B41:  BSF    03.7
0B42:  MOVF   66,W
0B43:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR3); 
0B44:  MOVLW  4A
0B45:  ADDWF  63,W
0B46:  MOVWF  04
0B47:  BSF    03.7
0B48:  MOVF   00,W
0B49:  MOVWF  64
0B4A:  CLRF   68
0B4B:  CLRF   67
0B4C:  CLRF   66
0B4D:  MOVF   64,W
0B4E:  MOVWF  65
0B4F:  MOVLW  0A
0B50:  MOVWF  69
0B51:  MOVLW  01
0B52:  MOVWF  6B
0B53:  MOVLW  56
0B54:  MOVWF  6A
0B55:  BCF    0A.3
0B56:  BCF    03.6
0B57:  CALL   55E
0B58:  BSF    0A.3
....................          LCD_GOTOXY (9 + NUM, 2); 
0B59:  MOVLW  09
0B5A:  BSF    03.6
0B5B:  ADDWF  63,W
0B5C:  MOVWF  64
0B5D:  MOVWF  68
0B5E:  MOVLW  02
0B5F:  MOVWF  69
0B60:  BCF    0A.3
0B61:  BCF    03.6
0B62:  CALL   442
0B63:  BSF    0A.3
....................          DELAY_MS (10); 
0B64:  MOVLW  0A
0B65:  BSF    03.6
0B66:  MOVWF  68
0B67:  BCF    0A.3
0B68:  BCF    03.6
0B69:  CALL   135
0B6A:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR3); 
0B6B:  MOVLW  56
0B6C:  MOVWF  04
0B6D:  BSF    03.7
0B6E:  BCF    0A.3
0B6F:  CALL   6B4
0B70:  BSF    0A.3
....................          DELAY_MS (300); 
0B71:  MOVLW  02
0B72:  BSF    03.6
0B73:  MOVWF  64
0B74:  MOVLW  96
0B75:  MOVWF  68
0B76:  BCF    0A.3
0B77:  BCF    03.6
0B78:  CALL   135
0B79:  BSF    0A.3
0B7A:  BSF    03.6
0B7B:  DECFSZ 64,F
0B7C:  GOTO   374
0B7D:  BCF    03.6
....................       } 
0B7E:  GOTO   2DD
....................    } 
....................  
....................    FOR (NUM = 0; NUM < 4; NUM++) 
0B7F:  BSF    03.6
0B80:  CLRF   63
0B81:  MOVF   63,W
0B82:  SUBLW  03
0B83:  BTFSS  03.0
0B84:  GOTO   3B1
....................    { 
....................       ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR3); 
0B85:  MOVLW  4A
0B86:  ADDWF  63,W
0B87:  MOVWF  04
0B88:  BSF    03.7
0B89:  MOVF   00,W
0B8A:  MOVWF  64
0B8B:  CLRF   68
0B8C:  CLRF   67
0B8D:  CLRF   66
0B8E:  MOVF   64,W
0B8F:  MOVWF  65
0B90:  MOVLW  0A
0B91:  MOVWF  69
0B92:  MOVLW  01
0B93:  MOVWF  6B
0B94:  MOVLW  56
0B95:  MOVWF  6A
0B96:  BCF    0A.3
0B97:  BCF    03.6
0B98:  CALL   55E
0B99:  BSF    0A.3
....................       DELAY_MS (1); 
0B9A:  MOVLW  01
0B9B:  BSF    03.6
0B9C:  MOVWF  68
0B9D:  BCF    0A.3
0B9E:  BCF    03.6
0B9F:  CALL   135
0BA0:  BSF    0A.3
....................       STRCAT (ID_GW, TEMP_CHAR3); 
0BA1:  MOVLW  01
0BA2:  BSF    03.6
0BA3:  MOVWF  66
0BA4:  MOVLW  43
0BA5:  MOVWF  65
0BA6:  MOVLW  01
0BA7:  MOVWF  68
0BA8:  MOVLW  56
0BA9:  MOVWF  67
0BAA:  BCF    0A.3
0BAB:  BCF    03.6
0BAC:  CALL   70C
0BAD:  BSF    0A.3
0BAE:  BSF    03.6
0BAF:  INCF   63,F
0BB0:  GOTO   381
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
010E:  BCF    75.2
....................    TT_FUN = 0; 
010F:  BCF    75.3
....................    TT_STT = 0; 
0110:  BCF    75.4
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    75.2
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   3B2
0805:  ADDLW  04
0806:  GOTO   3B5
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   3B2
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0978:  GOTO   3B2
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A83:  GOTO   3B2
....................  
....................       CASE 3: 
....................       NHAPID_GW (); 
....................       BREAK; 
*
0BB1:  BCF    03.6
....................    } 
0BB2:  BCF    0A.3
0BB3:  BCF    0A.4
0BB4:  GOTO   7CD (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
074A:  BSF    75.3
....................    LCD_GOTOXY (1, 1) ; 
074B:  MOVLW  01
074C:  BSF    03.6
074D:  MOVWF  68
074E:  MOVWF  69
074F:  BCF    03.6
0750:  CALL   442
....................    DELAY_MS (10); 
0751:  MOVLW  0A
0752:  BSF    03.6
0753:  MOVWF  68
0754:  BCF    03.6
0755:  CALL   135
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0756:  MOVLW  9E
0757:  BSF    03.6
0758:  MOVWF  0D
0759:  MOVLW  00
075A:  MOVWF  0F
075B:  BCF    03.6
075C:  CALL   490
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
075D:  MOVLW  01
075E:  BSF    03.6
075F:  MOVWF  68
0760:  MOVLW  02
0761:  MOVWF  69
0762:  BCF    03.6
0763:  CALL   442
....................    DELAY_MS (10); 
0764:  MOVLW  0A
0765:  BSF    03.6
0766:  MOVWF  68
0767:  BCF    03.6
0768:  CALL   135
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0769:  MOVLW  A6
076A:  BSF    03.6
076B:  MOVWF  0D
076C:  MOVLW  00
076D:  MOVWF  0F
076E:  BCF    03.6
076F:  CALL   490
....................  
....................    WHILE (TT_FUN) 
0770:  BTFSS  75.3
0771:  GOTO   7C9
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0772:  BSF    03.5
0773:  BSF    06.2
0774:  BCF    03.5
0775:  BTFSC  06.2
0776:  GOTO   7C8
....................       { 
....................          CONFIG_FUN ++; 
0777:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0778:  MOVLW  03
0779:  ANDWF  38,F
....................          DELAY_MS (300); 
077A:  MOVLW  02
077B:  BSF    03.6
077C:  MOVWF  63
077D:  MOVLW  96
077E:  MOVWF  68
077F:  BCF    03.6
0780:  CALL   135
0781:  BSF    03.6
0782:  DECFSZ 63,F
0783:  GOTO   77D
....................  
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0784:  MOVLW  06
0785:  MOVWF  68
0786:  MOVLW  02
0787:  MOVWF  69
0788:  BCF    03.6
0789:  CALL   442
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
078A:  BSF    03.6
078B:  CLRF   68
078C:  CLRF   67
078D:  CLRF   66
078E:  BCF    03.6
078F:  MOVF   38,W
0790:  BSF    03.6
0791:  MOVWF  65
0792:  MOVLW  0A
0793:  MOVWF  69
0794:  MOVLW  01
0795:  MOVWF  6B
0796:  MOVLW  4E
0797:  MOVWF  6A
0798:  BCF    03.6
0799:  CALL   55E
....................          DELAY_MS (10); 
079A:  MOVLW  0A
079B:  BSF    03.6
079C:  MOVWF  68
079D:  BCF    03.6
079E:  CALL   135
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
079F:  MOVLW  4E
07A0:  MOVWF  04
07A1:  BSF    03.7
07A2:  CALL   6B4
....................  
....................          SWITCH (CONFIG_FUN) 
07A3:  MOVF   38,W
07A4:  ADDLW  FC
07A5:  BTFSC  03.0
07A6:  GOTO   7C8
07A7:  ADDLW  04
07A8:  GOTO   7D1
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID         "); 
07A9:  MOVLW  AE
07AA:  BSF    03.6
07AB:  MOVWF  0D
07AC:  MOVLW  00
07AD:  MOVWF  0F
07AE:  BCF    03.6
07AF:  CALL   490
....................             BREAK; 
07B0:  GOTO   7C8
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - DEVICES    "); 
07B1:  MOVLW  B6
07B2:  BSF    03.6
07B3:  MOVWF  0D
07B4:  MOVLW  00
07B5:  MOVWF  0F
07B6:  BCF    03.6
07B7:  CALL   490
....................             BREAK; 
07B8:  GOTO   7C8
....................              
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, " - SENSORS    "); 
07B9:  MOVLW  BE
07BA:  BSF    03.6
07BB:  MOVWF  0D
07BC:  MOVLW  00
07BD:  MOVWF  0F
07BE:  BCF    03.6
07BF:  CALL   490
....................             BREAK; 
07C0:  GOTO   7C8
....................              
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, " - ID - GW:    "); 
07C1:  MOVLW  C6
07C2:  BSF    03.6
07C3:  MOVWF  0D
07C4:  MOVLW  00
07C5:  MOVWF  0F
07C6:  BCF    03.6
07C7:  CALL   490
....................             BREAK; 
....................          } 
....................       } 
07C8:  GOTO   770
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
07C9:  BTFSC  75.2
07CA:  GOTO   7CE
....................    { 
....................       SELLECT_FUN (); 
07CB:  BSF    0A.3
07CC:  GOTO   000
07CD:  BCF    0A.3
....................    } 
07CE:  BCF    0A.3
07CF:  BSF    0A.4
07D0:  GOTO   1E0 (RETURN)
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    * TEMP_CHAR2 = '\0'; 
*
0C04:  MOVLW  01
0C05:  MOVWF  7A
0C06:  MOVLW  52
0C07:  MOVWF  04
0C08:  BCF    03.7
0C09:  BTFSC  7A.0
0C0A:  BSF    03.7
0C0B:  CLRF   00
....................    * TT_DEVICE_CHAR = '\0'; 
0C0C:  CLRF   7A
0C0D:  MOVLW  7C
0C0E:  MOVWF  04
0C0F:  BCF    03.7
0C10:  BTFSC  7A.0
0C11:  BSF    03.7
0C12:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
0C13:  BSF    03.6
0C14:  CLRF   64
0C15:  MOVF   64,W
0C16:  SUBLW  07
0C17:  BTFSS  03.0
0C18:  GOTO   44A
....................    { 
....................       IF (TT_DEVICE[I]) 
0C19:  MOVF   64,W
0C1A:  MOVWF  65
0C1B:  CLRF   67
0C1C:  MOVLW  76
0C1D:  MOVWF  66
0C1E:  BCF    0A.3
0C1F:  BCF    03.6
0C20:  CALL   6D1
0C21:  BSF    0A.3
0C22:  BTFSS  78.0
0C23:  GOTO   447
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
0C24:  BSF    03.6
0C25:  CLRF   68
0C26:  CLRF   67
0C27:  CLRF   66
0C28:  MOVF   64,W
0C29:  MOVWF  65
0C2A:  MOVLW  0A
0C2B:  MOVWF  69
0C2C:  MOVLW  01
0C2D:  MOVWF  6B
0C2E:  MOVLW  52
0C2F:  MOVWF  6A
0C30:  BCF    0A.3
0C31:  BCF    03.6
0C32:  CALL   55E
0C33:  BSF    0A.3
....................          DELAY_MS (1); 
0C34:  MOVLW  01
0C35:  BSF    03.6
0C36:  MOVWF  68
0C37:  BCF    0A.3
0C38:  BCF    03.6
0C39:  CALL   135
0C3A:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0C3B:  BSF    03.6
0C3C:  CLRF   66
0C3D:  MOVLW  7C
0C3E:  MOVWF  65
0C3F:  MOVLW  01
0C40:  MOVWF  68
0C41:  MOVLW  52
0C42:  MOVWF  67
0C43:  BCF    0A.3
0C44:  BCF    03.6
0C45:  CALL   70C
0C46:  BSF    0A.3
....................       } 
0C47:  BSF    03.6
0C48:  INCF   64,F
0C49:  GOTO   415
....................    } 
....................  
....................    // PACKAGE_CONFIG[6] = TT_DEVICE_CHAR; 
.................... } 
....................  
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    * TEMP_CHAR2 = '\0'; 
0C4A:  MOVLW  01
0C4B:  MOVWF  7A
0C4C:  MOVLW  52
0C4D:  MOVWF  04
0C4E:  BCF    03.7
0C4F:  BTFSC  7A.0
0C50:  BSF    03.7
0C51:  CLRF   00
....................    * TEMP_CHAR3 = '\0'; 
0C52:  MOVLW  01
0C53:  MOVWF  7A
0C54:  MOVLW  56
0C55:  MOVWF  04
0C56:  BCF    03.7
0C57:  BTFSC  7A.0
0C58:  BSF    03.7
0C59:  CLRF   00
....................    FOR (INT J = 0; J < 5; J++) 
0C5A:  CLRF   64
0C5B:  MOVF   64,W
0C5C:  SUBLW  04
0C5D:  BTFSS  03.0
0C5E:  GOTO   491
....................    { 
....................       IF (TT_SENSOR[J]) 
0C5F:  MOVF   64,W
0C60:  MOVWF  65
0C61:  CLRF   67
0C62:  MOVLW  7B
0C63:  MOVWF  66
0C64:  BCF    0A.3
0C65:  BCF    03.6
0C66:  CALL   6D1
0C67:  BSF    0A.3
0C68:  BTFSS  78.0
0C69:  GOTO   48E
....................       { 
....................          ITOA (J, 10, TEMP_CHAR2); 
0C6A:  BSF    03.6
0C6B:  CLRF   68
0C6C:  CLRF   67
0C6D:  CLRF   66
0C6E:  MOVF   64,W
0C6F:  MOVWF  65
0C70:  MOVLW  0A
0C71:  MOVWF  69
0C72:  MOVLW  01
0C73:  MOVWF  6B
0C74:  MOVLW  52
0C75:  MOVWF  6A
0C76:  BCF    0A.3
0C77:  BCF    03.6
0C78:  CALL   55E
0C79:  BSF    0A.3
....................          DELAY_MS (1); 
0C7A:  MOVLW  01
0C7B:  BSF    03.6
0C7C:  MOVWF  68
0C7D:  BCF    0A.3
0C7E:  BCF    03.6
0C7F:  CALL   135
0C80:  BSF    0A.3
....................          STRCAT (TEMP_CHAR3, TEMP_CHAR2); 
0C81:  MOVLW  01
0C82:  BSF    03.6
0C83:  MOVWF  66
0C84:  MOVLW  56
0C85:  MOVWF  65
0C86:  MOVLW  01
0C87:  MOVWF  68
0C88:  MOVLW  52
0C89:  MOVWF  67
0C8A:  BCF    0A.3
0C8B:  BCF    03.6
0C8C:  CALL   70C
0C8D:  BSF    0A.3
....................       } 
0C8E:  BSF    03.6
0C8F:  INCF   64,F
0C90:  GOTO   45B
....................    } 
....................  
....................    //PACKAGE_CONFIG[7] = TEMP_CHAR3; 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0BBD:  BCF    75.3
....................    TT_STT = 0; 
0BBE:  BCF    75.4
.................... PACKAGE_CONFIG[1] = ID_GW; 
0BBF:  MOVLW  01
0BC0:  BSF    03.5
0BC1:  MOVWF  5F
0BC2:  MOVLW  43
0BC3:  MOVWF  5E
....................    DELAY_MS (2); 
0BC4:  MOVLW  02
0BC5:  BCF    03.5
0BC6:  BSF    03.6
0BC7:  MOVWF  68
0BC8:  BCF    0A.3
0BC9:  BCF    03.6
0BCA:  CALL   135
0BCB:  BSF    0A.3
....................    PACKAGE_CONFIG[2] = ID_; 
0BCC:  BSF    03.5
0BCD:  CLRF   61
0BCE:  MOVLW  EC
0BCF:  MOVWF  60
....................    DELAY_MS (2); 
0BD0:  MOVLW  02
0BD1:  BCF    03.5
0BD2:  BSF    03.6
0BD3:  MOVWF  68
0BD4:  BCF    0A.3
0BD5:  BCF    03.6
0BD6:  CALL   135
0BD7:  BSF    0A.3
....................    TT_DEVICE_CHAR = ""; 
0BD8:  BSF    03.6
0BD9:  CLRF   64
0BDA:  CLRF   65
0BDB:  MOVLW  7C
0BDC:  MOVWF  04
0BDD:  BCF    03.7
0BDE:  MOVF   64,W
0BDF:  ADDWF  04,F
0BE0:  MOVF   65,W
0BE1:  BCF    0A.3
0BE2:  BCF    03.6
0BE3:  CALL   064
0BE4:  BSF    0A.3
0BE5:  MOVWF  00
0BE6:  IORLW  00
0BE7:  BTFSC  03.2
0BE8:  GOTO   3EE
0BE9:  BSF    03.6
0BEA:  INCF   65,F
0BEB:  INCF   64,F
0BEC:  GOTO   3DB
0BED:  BCF    03.6
....................    TT_SENSOR_CHAR = ""; 
0BEE:  BSF    03.6
0BEF:  CLRF   64
0BF0:  CLRF   65
0BF1:  MOVLW  A2
0BF2:  MOVWF  04
0BF3:  BCF    03.7
0BF4:  MOVF   64,W
0BF5:  ADDWF  04,F
0BF6:  MOVF   65,W
0BF7:  BCF    0A.3
0BF8:  BCF    03.6
0BF9:  CALL   064
0BFA:  BSF    0A.3
0BFB:  MOVWF  00
0BFC:  IORLW  00
0BFD:  BTFSC  03.2
0BFE:  GOTO   404
0BFF:  BSF    03.6
0C00:  INCF   65,F
0C01:  INCF   64,F
0C02:  GOTO   3F1
0C03:  BCF    03.6
....................    XULYDEVICE_CF (); 
....................    XULYSENSOR_CF (); 
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
*
0C91:  BSF    03.5
0C92:  BCF    03.6
0C93:  CLRF   67
0C94:  MOVLW  7C
0C95:  MOVWF  66
....................    DELAY_MS (2); 
0C96:  MOVLW  02
0C97:  BCF    03.5
0C98:  BSF    03.6
0C99:  MOVWF  68
0C9A:  BCF    0A.3
0C9B:  BCF    03.6
0C9C:  CALL   135
0C9D:  BSF    0A.3
....................    PACKAGE_CONFIG[6] = TEMP_CHAR3; 
0C9E:  MOVLW  01
0C9F:  BSF    03.5
0CA0:  MOVWF  69
0CA1:  MOVLW  56
0CA2:  MOVWF  68
....................    //TINH DO DAI --> 
....................    LEN_PACKAGES = 0; 
0CA3:  CLRF   7E
....................    PACKAGE_CONFIG[3] = "12"; //DO DAI CUA LENGHT C? ?? DAI = 2 
0CA4:  MOVLW  31
0CA5:  MOVWF  62
0CA6:  MOVLW  32
0CA7:  MOVWF  63
....................    FOR (INT J = 0; J < 9; J++) 
0CA8:  BCF    03.5
0CA9:  BSF    03.6
0CAA:  CLRF   63
0CAB:  MOVF   63,W
0CAC:  SUBLW  08
0CAD:  BTFSS  03.0
0CAE:  GOTO   4DF
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
0CAF:  BCF    03.0
0CB0:  RLF    63,W
0CB1:  ADDLW  DC
0CB2:  MOVWF  04
0CB3:  BCF    03.7
0CB4:  INCF   04,F
0CB5:  MOVF   00,W
0CB6:  MOVWF  65
0CB7:  DECF   04,F
0CB8:  MOVF   00,W
0CB9:  MOVWF  64
0CBA:  MOVF   65,W
0CBB:  MOVWF  67
0CBC:  MOVF   64,W
0CBD:  MOVWF  66
*
0CDB:  MOVF   78,W
0CDC:  ADDWF  7E,F
0CDD:  INCF   63,F
0CDE:  GOTO   4AB
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+6; //7 @ 
0CDF:  MOVLW  06
0CE0:  ADDWF  7E,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0CE1:  CLRF   68
0CE2:  CLRF   67
0CE3:  CLRF   66
0CE4:  MOVF   7E,W
0CE5:  MOVWF  65
0CE6:  MOVLW  0A
0CE7:  MOVWF  69
0CE8:  MOVLW  01
0CE9:  MOVWF  6B
0CEA:  MOVLW  4E
0CEB:  MOVWF  6A
0CEC:  BCF    0A.3
0CED:  BCF    03.6
0CEE:  CALL   55E
0CEF:  BSF    0A.3
....................    PACKAGE_CONFIG[3] = TEMP_CHAR; 
0CF0:  MOVLW  01
0CF1:  BSF    03.5
0CF2:  MOVWF  63
0CF3:  MOVLW  4E
0CF4:  MOVWF  62
....................     
....................    FOR ( J = 0; J < 8; J++) 
0CF5:  BCF    03.5
0CF6:  BSF    03.6
0CF7:  CLRF   63
0CF8:  MOVF   63,W
0CF9:  SUBLW  07
0CFA:  BTFSS  03.0
0CFB:  GOTO   516
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0CFC:  BCF    03.0
0CFD:  RLF    63,W
0CFE:  ADDLW  DC
0CFF:  MOVWF  04
0D00:  BCF    03.7
0D01:  INCF   04,F
0D02:  MOVF   00,W
0D03:  MOVWF  65
0D04:  DECF   04,F
0D05:  MOVF   00,W
0D06:  MOVWF  64
0D07:  MOVWF  04
0D08:  BCF    03.7
0D09:  BTFSC  65.0
0D0A:  BSF    03.7
0D0B:  BCF    0A.3
0D0C:  BCF    03.6
0D0D:  CALL   7D9
0D0E:  BSF    0A.3
....................       PRINTF ("@"); 
0D0F:  MOVLW  40
0D10:  BTFSS  0C.4
0D11:  GOTO   510
0D12:  MOVWF  19
0D13:  BSF    03.6
0D14:  INCF   63,F
0D15:  GOTO   4F8
....................    } 
....................  
....................    /* 
....................    LCD_GOTOXY (1, 1) ; 
....................    DELAY_MS (10); 
....................    FOR (J = 0; J < 9; J++) 
....................    { 
....................       PRINTF (LCD_PUTC, PACKAGE_CONFIG[J]); 
....................    } 
....................    */ 
....................  
....................    LCD_GOTOXY (1, 1) ; 
0D16:  MOVLW  01
0D17:  MOVWF  68
0D18:  MOVWF  69
0D19:  BCF    0A.3
0D1A:  BCF    03.6
0D1B:  CALL   442
0D1C:  BSF    0A.3
....................    DELAY_MS (10); 
0D1D:  MOVLW  0A
0D1E:  BSF    03.6
0D1F:  MOVWF  68
0D20:  BCF    0A.3
0D21:  BCF    03.6
0D22:  CALL   135
0D23:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0D24:  MOVLW  CE
0D25:  BSF    03.6
0D26:  MOVWF  0D
0D27:  MOVLW  00
0D28:  MOVWF  0F
0D29:  BCF    0A.3
0D2A:  BCF    03.6
0D2B:  CALL   490
0D2C:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0D2D:  MOVLW  01
0D2E:  BSF    03.6
0D2F:  MOVWF  68
0D30:  MOVLW  02
0D31:  MOVWF  69
0D32:  BCF    0A.3
0D33:  BCF    03.6
0D34:  CALL   442
0D35:  BSF    0A.3
....................    DELAY_MS (10); 
0D36:  MOVLW  0A
0D37:  BSF    03.6
0D38:  MOVWF  68
0D39:  BCF    0A.3
0D3A:  BCF    03.6
0D3B:  CALL   135
0D3C:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0D3D:  MOVLW  D8
0D3E:  BSF    03.6
0D3F:  MOVWF  0D
0D40:  MOVLW  00
0D41:  MOVWF  0F
0D42:  BCF    0A.3
0D43:  BCF    03.6
0D44:  CALL   490
0D45:  BSF    0A.3
....................    PACKAGE_NHIETDO[1] = ID_; 
0D46:  BSF    03.5
0D47:  CLRF   29
0D48:  MOVLW  EC
0D49:  MOVWF  28
....................    TT_CONFIG_DONE = 0; 
0D4A:  BCF    75.2
0D4B:  BCF    03.5
0D4C:  BCF    0A.3
0D4D:  BSF    0A.4
0D4E:  GOTO   1E7 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00E2:  BSF    03.5
00E3:  BSF    03.6
00E4:  CLRF   2F
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00E5:  BCF    03.6
00E6:  BSF    06.1
00E7:  BCF    03.5
00E8:  BTFSC  06.1
00E9:  GOTO   101
....................    { 
....................       IF (TMR1IF) 
00EA:  BTFSS  0C.0
00EB:  GOTO   0FC
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00EC:  BSF    03.5
00ED:  BCF    08.2
00EE:  MOVLW  04
00EF:  BCF    03.5
00F0:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00F1:  BCF    0C.0
00F2:  CLRF   0E
00F3:  MOVLW  0B
00F4:  MOVWF  0F
00F5:  MOVLW  DC
00F6:  MOVWF  0E
00F7:  BSF    03.5
00F8:  BSF    03.6
00F9:  INCF   2F,F
00FA:  BCF    03.5
00FB:  BCF    03.6
....................       } 
00FC:  BSF    03.5
00FD:  BSF    03.6
00FE:  GOTO   0E5
00FF:  BCF    03.5
0100:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
0101:  BSF    03.5
0102:  BSF    03.6
0103:  MOVF   2F,W
0104:  SUBLW  14
0105:  BTFSC  03.0
0106:  GOTO   10E
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0107:  MOVLW  01
0108:  XORWF  75,F
....................       TT_CONTROL = ~TT_CONTROL; 
0109:  MOVLW  02
010A:  XORWF  75,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
010B:  BSF    75.2
....................       TT_FUN = 0; 
010C:  BCF    75.3
....................    } 
010D:  GOTO   111
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
0111:  BCF    03.5
0112:  BCF    03.6
0113:  BCF    0B.1
0114:  BCF    0A.3
0115:  BCF    0A.4
0116:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0117:  MOVLW  41
0118:  ADDWF  3C,W
0119:  MOVWF  04
011A:  BCF    03.7
011B:  BTFSS  0C.5
011C:  GOTO   11B
011D:  MOVF   1A,W
011E:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
011F:  MOVLW  41
0120:  ADDWF  3C,W
0121:  MOVWF  04
0122:  BCF    03.7
0123:  MOVF   00,W
0124:  SUBLW  2E
0125:  BTFSS  03.2
0126:  GOTO   130
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0127:  MOVLW  41
0128:  ADDWF  3C,W
0129:  MOVWF  04
012A:  BCF    03.7
012B:  CLRF   00
....................        VT = 0; 
012C:  CLRF   3C
....................        TTNHAN = 1; 
012D:  MOVLW  01
012E:  MOVWF  3D
....................     } 
012F:  GOTO   131
....................  
....................     ELSE 
....................     VT++; 
0130:  INCF   3C,F
0131:  BCF    0C.5
0132:  BCF    0A.3
0133:  BCF    0A.4
0134:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
0D69:  MOVLW  01
0D6A:  BSF    03.6
0D6B:  MOVWF  68
0D6C:  MOVWF  69
0D6D:  BCF    0A.3
0D6E:  BCF    03.6
0D6F:  CALL   442
0D70:  BSF    0A.3
....................     DELAY_MS (10); 
0D71:  MOVLW  0A
0D72:  BSF    03.6
0D73:  MOVWF  68
0D74:  BCF    0A.3
0D75:  BCF    03.6
0D76:  CALL   135
0D77:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTUCHAR); 
0D78:  MOVLW  41
0D79:  MOVWF  04
0D7A:  BCF    03.7
0D7B:  BCF    0A.3
0D7C:  CALL   6B4
0D7D:  BSF    0A.3
....................     DELAY_MS (1); 
0D7E:  MOVLW  01
0D7F:  BSF    03.6
0D80:  MOVWF  68
0D81:  BCF    0A.3
0D82:  BCF    03.6
0D83:  CALL   135
0D84:  BSF    0A.3
0D85:  BCF    0A.3
0D86:  BSF    0A.4
0D87:  GOTO   263 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
02BF:  BSF    03.6
02C0:  RLF    63,W
02C1:  MOVWF  77
02C2:  RLF    77,F
02C3:  MOVLW  FC
02C4:  ANDWF  77,F
02C5:  BCF    03.6
02C6:  MOVF   1F,W
02C7:  ANDLW  C3
02C8:  IORWF  77,W
02C9:  MOVWF  1F
....................     KQADC = 0; 
02CA:  CLRF   33
02CB:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
02CC:  BSF    03.6
02CD:  CLRF   64
02CE:  MOVF   64,W
02CF:  SUBLW  63
02D0:  BTFSS  03.0
02D1:  GOTO   2E6
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
02D2:  BCF    03.6
02D3:  BSF    1F.1
02D4:  BTFSC  1F.1
02D5:  GOTO   2D4
02D6:  BSF    03.5
02D7:  MOVF   1E,W
02D8:  BCF    03.5
02D9:  ADDWF  32,F
02DA:  MOVF   1E,W
02DB:  BTFSC  03.0
02DC:  INCFSZ 1E,W
02DD:  ADDWF  33,F
....................        DELAY_MS (1); 
02DE:  MOVLW  01
02DF:  BSF    03.6
02E0:  MOVWF  68
02E1:  BCF    03.6
02E2:  CALL   135
02E3:  BSF    03.6
02E4:  INCF   64,F
02E5:  GOTO   2CE
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
02E6:  BCF    03.6
02E7:  MOVF   33,W
02E8:  BSF    03.6
02E9:  MOVWF  66
02EA:  BCF    03.6
02EB:  MOVF   32,W
02EC:  BSF    03.6
02ED:  MOVWF  65
*
030A:  MOVF   7A,W
030B:  MOVWF  68
030C:  MOVF   79,W
030D:  MOVWF  67
030E:  MOVF   78,W
030F:  MOVWF  66
0310:  MOVF   77,W
0311:  MOVWF  65
0312:  MOVLW  9A
0313:  MOVWF  6C
0314:  MOVLW  99
0315:  MOVWF  6B
0316:  MOVLW  4C
0317:  MOVWF  6A
0318:  MOVLW  86
0319:  MOVWF  69
*
0411:  MOVF   7A,W
0412:  BCF    03.5
0413:  MOVWF  68
0414:  MOVF   79,W
0415:  MOVWF  67
0416:  MOVF   78,W
0417:  MOVWF  66
0418:  MOVF   77,W
0419:  MOVWF  65
*
0438:  MOVF   79,W
0439:  BCF    03.6
043A:  MOVWF  33
043B:  MOVF   78,W
043C:  MOVWF  32
....................     RETURN KQADC; 
043D:  MOVF   32,W
043E:  MOVWF  78
043F:  BCF    0A.3
0440:  BSF    0A.4
0441:  GOTO   1D8 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0D4F:  BSF    03.6
0D50:  CLRF   63
0D51:  MOVF   63,W
0D52:  SUBLW  1E
0D53:  BTFSS  03.0
0D54:  GOTO   565
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
0D55:  BSF    03.5
0D56:  BCF    03.6
0D57:  BCF    08.1
0D58:  MOVLW  02
0D59:  BCF    03.5
0D5A:  XORWF  08,F
....................        DELAY_MS (100); 
0D5B:  MOVLW  64
0D5C:  BSF    03.6
0D5D:  MOVWF  68
0D5E:  BCF    0A.3
0D5F:  BCF    03.6
0D60:  CALL   135
0D61:  BSF    0A.3
0D62:  BSF    03.6
0D63:  INCF   63,F
0D64:  GOTO   551
....................     } 
0D65:  BCF    03.6
0D66:  BCF    0A.3
0D67:  BSF    0A.4
0D68:  GOTO   1EF (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  BSF    03.5
1004:  BSF    03.6
1005:  BSF    07.3
1006:  MOVLW  08
1007:  BCF    03.6
1008:  MOVWF  19
1009:  MOVLW  02
100A:  MOVWF  1A
100B:  MOVLW  A6
100C:  MOVWF  18
100D:  MOVLW  90
100E:  BCF    03.5
100F:  MOVWF  18
1010:  MOVLW  FF
1011:  MOVWF  31
1012:  CLRF   38
1013:  CLRF   39
1014:  CLRF   3A
1015:  CLRF   3B
1016:  CLRF   3C
1017:  CLRF   3D
1018:  BCF    75.0
1019:  BCF    75.1
101A:  BCF    75.2
101B:  BCF    75.3
101C:  BCF    75.4
101D:  CLRF   7E
101E:  BSF    03.5
101F:  BSF    03.6
1020:  MOVF   09,W
1021:  ANDLW  C0
1022:  MOVWF  09
1023:  BCF    03.6
1024:  BCF    1F.4
1025:  BCF    1F.5
1026:  MOVLW  00
1027:  BSF    03.6
1028:  MOVWF  08
1029:  BCF    03.5
102A:  CLRF   07
102B:  CLRF   08
102C:  CLRF   09
102D:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
1195:  MOVLW  00
1196:  BSF    03.5
1197:  BCF    03.6
1198:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1199:  MOVLW  FF
119A:  MOVWF  06
....................     SET_TRIS_E (0); 
119B:  BCF    09.0
119C:  BCF    09.1
119D:  BCF    09.2
119E:  BCF    09.3
....................     SET_TRIS_C (0X80); 
119F:  MOVLW  80
11A0:  MOVWF  07
11A1:  BCF    03.5
11A2:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
11A3:  BSF    1F.6
11A4:  BCF    1F.7
11A5:  BSF    03.5
11A6:  BSF    1F.7
11A7:  BCF    03.5
11A8:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
11A9:  BSF    03.5
11AA:  BSF    03.6
11AB:  MOVF   09,W
11AC:  ANDLW  C0
11AD:  MOVWF  09
11AE:  BCF    03.6
11AF:  BCF    1F.4
11B0:  BCF    1F.5
11B1:  MOVLW  01
11B2:  BSF    03.6
11B3:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
11B4:  BCF    03.5
11B5:  BCF    03.6
11B6:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
11B7:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
11B8:  BSF    0B.4
11B9:  BSF    03.5
11BA:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
11BB:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
11BC:  MOVLW  C0
11BD:  BCF    03.5
11BE:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
11BF:  MOVLW  35
11C0:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
11C1:  CLRF   0E
11C2:  MOVLW  0B
11C3:  MOVWF  0F
11C4:  MOVLW  DC
11C5:  MOVWF  0E
....................     TMR1IF = 0; 
11C6:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
11C7:  BCF    0A.4
11C8:  GOTO   259
11C9:  BSF    0A.4
....................     ID_NODE = 0; 
11CA:  CLRF   39
....................     TT_CONFIG = 0; 
11CB:  BCF    75.0
....................     TT_CONFIG_DONE = 0; 
11CC:  BCF    75.2
....................     TT_CONTROL=1; 
11CD:  BSF    75.1
....................     OUTPUT_D (0X00); 
11CE:  BSF    03.5
11CF:  CLRF   08
11D0:  BCF    03.5
11D1:  CLRF   08
....................     TTNHAN = 0; 
11D2:  CLRF   3D
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
11D3:  BSF    03.6
11D4:  CLRF   63
11D5:  BCF    0A.4
11D6:  BCF    03.6
11D7:  GOTO   2BF
11D8:  BSF    0A.4
11D9:  CLRF   35
11DA:  MOVF   78,W
11DB:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
11DC:  BTFSS  75.0
11DD:  GOTO   1E2
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
11DE:  BCF    0A.4
11DF:  GOTO   74A
11E0:  BSF    0A.4
....................        } 
11E1:  GOTO   2EE
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
11E2:  BTFSS  75.2
11E3:  GOTO   1EA
....................        { 
....................           CONFIG_DONE (); 
11E4:  BCF    0A.4
11E5:  BSF    0A.3
11E6:  GOTO   3BD
11E7:  BSF    0A.4
11E8:  BCF    0A.3
....................        } 
11E9:  GOTO   2EE
....................  
....................         
....................        ELSE 
....................        { 
....................  
....................           WHILE (!TT_CONFIG) 
11EA:  BTFSC  75.0
11EB:  GOTO   2EE
....................           { 
....................              CHUONG_TRINH_CON (); 
11EC:  BCF    0A.4
11ED:  BSF    0A.3
11EE:  GOTO   54F
11EF:  BSF    0A.4
11F0:  BCF    0A.3
....................  
....................              IF (AN0 > 26) 
11F1:  MOVF   35,F
11F2:  BTFSS  03.2
11F3:  GOTO   1F8
11F4:  MOVF   34,W
11F5:  SUBLW  1A
11F6:  BTFSC  03.0
11F7:  GOTO   25D
....................              { 
....................                 ITOA (AN0, 10, NHIETDO1); 
11F8:  BSF    03.6
11F9:  CLRF   68
11FA:  CLRF   67
11FB:  BCF    03.6
11FC:  MOVF   35,W
11FD:  BSF    03.6
11FE:  MOVWF  66
11FF:  BCF    03.6
1200:  MOVF   34,W
1201:  BSF    03.6
1202:  MOVWF  65
1203:  MOVLW  0A
1204:  MOVWF  69
1205:  MOVLW  01
1206:  MOVWF  6B
1207:  MOVLW  5A
1208:  MOVWF  6A
1209:  BCF    0A.4
120A:  BCF    03.6
120B:  CALL   55E
120C:  BSF    0A.4
....................                 PACKAGE_NHIETDO[4] = NHIETDO1; 
120D:  MOVLW  01
120E:  BSF    03.5
120F:  MOVWF  2F
1210:  MOVLW  5A
1211:  MOVWF  2E
....................                 ITOA (AN1, 10, NHIETDO2); 
1212:  BCF    03.5
1213:  BSF    03.6
1214:  CLRF   68
1215:  CLRF   67
1216:  BCF    03.6
1217:  MOVF   37,W
1218:  BSF    03.6
1219:  MOVWF  66
121A:  BCF    03.6
121B:  MOVF   36,W
121C:  BSF    03.6
121D:  MOVWF  65
121E:  MOVLW  0A
121F:  MOVWF  69
1220:  MOVLW  01
1221:  MOVWF  6B
1222:  MOVLW  5D
1223:  MOVWF  6A
1224:  BCF    0A.4
1225:  BCF    03.6
1226:  CALL   55E
1227:  BSF    0A.4
....................                 PACKAGE_NHIETDO[5] = NHIETDO2; 
1228:  MOVLW  01
1229:  BSF    03.5
122A:  MOVWF  31
122B:  MOVLW  5D
122C:  MOVWF  30
....................                  
....................                 FOR (INT I = 0; I < 8; I++) 
122D:  BCF    03.5
122E:  BSF    03.6
122F:  CLRF   60
1230:  MOVF   60,W
1231:  SUBLW  07
1232:  BTFSS  03.0
1233:  GOTO   251
....................                 { 
....................                    PRINTF (PACKAGE_NHIETDO[I]); 
1234:  BCF    03.0
1235:  RLF    60,W
1236:  ADDLW  A6
1237:  MOVWF  04
1238:  BCF    03.7
1239:  INCF   04,F
123A:  MOVF   00,W
123B:  MOVWF  64
123C:  DECF   04,F
123D:  MOVF   00,W
123E:  MOVWF  63
123F:  MOVWF  04
1240:  BCF    03.7
1241:  BTFSC  64.0
1242:  BSF    03.7
1243:  BCF    0A.4
1244:  BCF    03.6
1245:  CALL   7D9
1246:  BSF    0A.4
....................                    DELAY_MS (1); 
1247:  MOVLW  01
1248:  BSF    03.6
1249:  MOVWF  68
124A:  BCF    0A.4
124B:  BCF    03.6
124C:  CALL   135
124D:  BSF    0A.4
124E:  BSF    03.6
124F:  INCF   60,F
1250:  GOTO   230
....................                 } 
....................  
....................                  
....................                 DELAY_MS (1000); 
1251:  MOVLW  04
1252:  MOVWF  63
1253:  MOVLW  FA
1254:  MOVWF  68
1255:  BCF    0A.4
1256:  BCF    03.6
1257:  CALL   135
1258:  BSF    0A.4
1259:  BSF    03.6
125A:  DECFSZ 63,F
125B:  GOTO   253
125C:  BCF    03.6
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
125D:  DECFSZ 3D,W
125E:  GOTO   2ED
....................              { 
....................                 TTNHAN = 0; 
125F:  CLRF   3D
....................                 //TEMP_CHAR = 'K'; 
....................                 //ID_NODE_NHAN = KYTU[1] - 48; 
....................                 //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................                 //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................                 XUATLCD (); 
1260:  BCF    0A.4
1261:  BSF    0A.3
1262:  GOTO   569
1263:  BSF    0A.4
1264:  BCF    0A.3
....................  
....................                             
....................                   /* LAY TOKEN DAU TIEN */ 
....................                   TEMP_CHAR3="_"; 
1265:  BSF    03.6
1266:  CLRF   63
1267:  CLRF   64
1268:  MOVLW  56
1269:  MOVWF  04
126A:  BSF    03.7
126B:  MOVF   63,W
126C:  ADDWF  04,F
126D:  MOVF   64,W
126E:  BCF    0A.4
126F:  BCF    03.6
1270:  CALL   069
1271:  BSF    0A.4
1272:  MOVWF  00
1273:  IORLW  00
1274:  BTFSC  03.2
1275:  GOTO   27B
1276:  BSF    03.6
1277:  INCF   64,F
1278:  INCF   63,F
1279:  GOTO   268
127A:  BCF    03.6
....................                   CHAR* TOKEN; 
....................                   TOKEN = STRTOK(KYTUCHAR,TEMP_CHAR3 ); 
127B:  BSF    03.6
127C:  CLRF   64
127D:  MOVLW  41
127E:  MOVWF  63
127F:  MOVLW  01
1280:  MOVWF  66
1281:  MOVLW  56
1282:  MOVWF  65
1283:  BCF    0A.4
1284:  BSF    0A.3
1285:  BCF    03.6
1286:  CALL   588
1287:  BSF    0A.4
1288:  BCF    0A.3
1289:  MOVF   79,W
128A:  BSF    03.6
128B:  MOVWF  62
128C:  MOVF   78,W
128D:  MOVWF  61
....................                    
....................                   /* DUYET QUA CAC TOKEN CON LAI */ 
....................                   LCD_GOTOXY (1, 2) ; 
128E:  MOVLW  01
128F:  MOVWF  68
1290:  MOVLW  02
1291:  MOVWF  69
1292:  BCF    0A.4
1293:  BCF    03.6
1294:  CALL   442
1295:  BSF    0A.4
....................                   WHILE( TOKEN != NULL )  
1296:  BSF    03.6
1297:  MOVF   61,F
1298:  BTFSS  03.2
1299:  GOTO   29D
129A:  MOVF   62,F
129B:  BTFSC  03.2
129C:  GOTO   2CB
....................                   { 
....................                   //PRINTF( " %S\N", TEMPCHAR ); 
....................                        
....................                      DELAY_MS (1000); 
129D:  MOVLW  04
129E:  MOVWF  63
129F:  MOVLW  FA
12A0:  MOVWF  68
12A1:  BCF    0A.4
12A2:  BCF    03.6
12A3:  CALL   135
12A4:  BSF    0A.4
12A5:  BSF    03.6
12A6:  DECFSZ 63,F
12A7:  GOTO   29F
....................                       PRINTF (LCD_PUTC, TOKEN); 
12A8:  MOVF   61,W
12A9:  MOVWF  04
12AA:  BCF    03.7
12AB:  BTFSC  62.0
12AC:  BSF    03.7
12AD:  BCF    0A.4
12AE:  BCF    03.6
12AF:  CALL   6B4
12B0:  BSF    0A.4
....................                       DELAY_MS (1); 
12B1:  MOVLW  01
12B2:  BSF    03.6
12B3:  MOVWF  68
12B4:  BCF    0A.4
12B5:  BCF    03.6
12B6:  CALL   135
12B7:  BSF    0A.4
....................                       TOKEN = STRTOK(NULL, TEMP_CHAR3); 
12B8:  BSF    03.6
12B9:  CLRF   64
12BA:  CLRF   63
12BB:  MOVLW  01
12BC:  MOVWF  66
12BD:  MOVLW  56
12BE:  MOVWF  65
12BF:  BCF    0A.4
12C0:  BSF    0A.3
12C1:  BCF    03.6
12C2:  CALL   588
12C3:  BSF    0A.4
12C4:  BCF    0A.3
12C5:  MOVF   79,W
12C6:  BSF    03.6
12C7:  MOVWF  62
12C8:  MOVF   78,W
12C9:  MOVWF  61
12CA:  GOTO   297
....................                   }      
....................                    
....................                  
....................                 IF (ID_NODE_NHAN == ID_NODE) 
12CB:  BCF    03.6
12CC:  MOVF   39,W
12CD:  SUBWF  3E,W
12CE:  BTFSS  03.2
12CF:  GOTO   2ED
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
12D0:  MOVF   40,F
12D1:  BTFSS  03.2
12D2:  GOTO   2D5
12D3:  MOVLW  00
12D4:  GOTO   2D6
12D5:  MOVLW  01
12D6:  MOVWF  77
12D7:  MOVF   3F,W
12D8:  BSF    03.6
12D9:  MOVWF  64
12DA:  MOVF   77,W
12DB:  MOVWF  65
12DC:  CLRF   67
12DD:  CLRF   66
12DE:  BCF    0A.4
12DF:  BCF    03.6
12E0:  CALL   6EA
12E1:  BSF    0A.4
12E2:  MOVF   3F,W
12E3:  BSF    03.6
12E4:  MOVWF  64
12E5:  CLRF   65
12E6:  CLRF   67
12E7:  MOVLW  80
12E8:  MOVWF  66
12E9:  BCF    0A.4
12EA:  BCF    03.6
12EB:  CALL   6EA
12EC:  BSF    0A.4
....................                 } 
....................              } 
12ED:  GOTO   1EA
....................           } 
....................        } 
12EE:  GOTO   1D3
....................     } 
....................  } 
....................  
12EF:  SLEEP
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
