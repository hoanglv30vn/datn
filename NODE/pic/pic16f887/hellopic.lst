CCS PCM C Compiler, Version 5.015, 5967               24-Oct-21 16:52

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3926 words (48%)
                           Largest free fragment is 2048
               RAM used:   236 (64%) at main() level
                           280 (76%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   53C
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0DC
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   113
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  30
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 00,00
0072:  DATA C4,22
0073:  DATA D6,24
0074:  DATA C3,22
0075:  DATA 3A,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 00,01
007C:  DATA D3,22
007D:  DATA CE,29
007E:  DATA 4F,29
007F:  DATA 3A,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 00,01
0085:  DATA 49,22
0086:  DATA DF,23
0087:  DATA 57,1D
0088:  DATA 20,10
0089:  DATA 30,18
008A:  DATA 30,18
008B:  DATA 20,00
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 5F,10
0091:  DATA 20,10
0092:  DATA 20,00
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 5F,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA C3,27
0099:  DATA 4E,23
009A:  DATA C9,23
009B:  DATA 3A,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,00
00A0:  DATA C3,20
00A1:  DATA D3,22
00A2:  DATA 3A,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 20,00
00A8:  DATA A0,16
00A9:  DATA A0,24
00AA:  DATA 44,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 00,01
00B0:  DATA A0,16
00B1:  DATA 20,22
00B2:  DATA 45,2B
00B3:  DATA C9,21
00B4:  DATA C5,29
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 00,01
00B8:  DATA A0,16
00B9:  DATA A0,29
00BA:  DATA 45,27
00BB:  DATA D3,27
00BC:  DATA D2,29
00BD:  DATA 20,10
00BE:  DATA 20,10
00BF:  DATA 00,01
00C0:  DATA A0,16
00C1:  DATA A0,24
00C2:  DATA 44,10
00C3:  DATA 2D,10
00C4:  DATA C7,2B
00C5:  DATA 3A,10
00C6:  DATA 20,10
00C7:  DATA 20,00
00C8:  DATA C3,27
00C9:  DATA 4E,23
00CA:  DATA C9,23
00CB:  DATA 20,22
00CC:  DATA 4F,27
00CD:  DATA 45,10
00CE:  DATA 20,10
00CF:  DATA 20,10
00D0:  DATA 20,10
00D1:  DATA 20,00
00D2:  DATA C3,27
00D3:  DATA 4E,23
00D4:  DATA C9,23
00D5:  DATA 20,22
00D6:  DATA 4F,27
00D7:  DATA 45,10
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,00
*
02E0:  MOVLW  8E
02E1:  MOVWF  77
02E2:  MOVF   4E,W
02E3:  MOVWF  78
02E4:  MOVF   4D,W
02E5:  MOVWF  79
02E6:  CLRF   7A
02E7:  MOVF   78,F
02E8:  BTFSS  03.2
02E9:  GOTO   2F4
02EA:  MOVF   79,W
02EB:  MOVWF  78
02EC:  CLRF   79
02ED:  MOVLW  08
02EE:  SUBWF  77,F
02EF:  MOVF   78,F
02F0:  BTFSS  03.2
02F1:  GOTO   2F4
02F2:  CLRF   77
02F3:  GOTO   2FC
02F4:  BCF    03.0
02F5:  BTFSC  78.7
02F6:  GOTO   2FB
02F7:  RLF    79,F
02F8:  RLF    78,F
02F9:  DECF   77,F
02FA:  GOTO   2F4
02FB:  BCF    78.7
*
030C:  MOVF   4D,W
030D:  BTFSC  03.2
030E:  GOTO   3D1
030F:  MOVWF  59
0310:  MOVF   51,W
0311:  BTFSC  03.2
0312:  GOTO   3D1
0313:  SUBWF  59,F
0314:  BTFSS  03.0
0315:  GOTO   31B
0316:  MOVLW  7F
0317:  ADDWF  59,F
0318:  BTFSC  03.0
0319:  GOTO   3D1
031A:  GOTO   321
031B:  MOVLW  81
031C:  SUBWF  59,F
031D:  BTFSS  03.0
031E:  GOTO   3D1
031F:  BTFSC  03.2
0320:  GOTO   3D1
0321:  MOVF   59,W
0322:  MOVWF  77
0323:  CLRF   78
0324:  CLRF   79
0325:  CLRF   7A
0326:  CLRF   58
0327:  MOVF   4E,W
0328:  MOVWF  57
0329:  BSF    57.7
032A:  MOVF   4F,W
032B:  MOVWF  56
032C:  MOVF   50,W
032D:  MOVWF  55
032E:  MOVLW  19
032F:  MOVWF  59
0330:  MOVF   54,W
0331:  SUBWF  55,F
0332:  BTFSC  03.0
0333:  GOTO   344
0334:  MOVLW  01
0335:  SUBWF  56,F
0336:  BTFSC  03.0
0337:  GOTO   344
0338:  SUBWF  57,F
0339:  BTFSC  03.0
033A:  GOTO   344
033B:  SUBWF  58,F
033C:  BTFSC  03.0
033D:  GOTO   344
033E:  INCF   58,F
033F:  INCF   57,F
0340:  INCF   56,F
0341:  MOVF   54,W
0342:  ADDWF  55,F
0343:  GOTO   376
0344:  MOVF   53,W
0345:  SUBWF  56,F
0346:  BTFSC  03.0
0347:  GOTO   35F
0348:  MOVLW  01
0349:  SUBWF  57,F
034A:  BTFSC  03.0
034B:  GOTO   35F
034C:  SUBWF  58,F
034D:  BTFSC  03.0
034E:  GOTO   35F
034F:  INCF   58,F
0350:  INCF   57,F
0351:  MOVF   53,W
0352:  ADDWF  56,F
0353:  MOVF   54,W
0354:  ADDWF  55,F
0355:  BTFSS  03.0
0356:  GOTO   376
0357:  INCF   56,F
0358:  BTFSS  03.2
0359:  GOTO   376
035A:  INCF   57,F
035B:  BTFSS  03.2
035C:  GOTO   376
035D:  INCF   58,F
035E:  GOTO   376
035F:  MOVF   52,W
0360:  IORLW  80
0361:  SUBWF  57,F
0362:  BTFSC  03.0
0363:  GOTO   375
0364:  MOVLW  01
0365:  SUBWF  58,F
0366:  BTFSC  03.0
0367:  GOTO   375
0368:  INCF   58,F
0369:  MOVF   52,W
036A:  IORLW  80
036B:  ADDWF  57,F
036C:  MOVF   53,W
036D:  ADDWF  56,F
036E:  BTFSS  03.0
036F:  GOTO   353
0370:  INCF   57,F
0371:  BTFSS  03.2
0372:  GOTO   353
0373:  INCF   58,F
0374:  GOTO   353
0375:  BSF    7A.0
0376:  DECFSZ 59,F
0377:  GOTO   379
0378:  GOTO   384
0379:  BCF    03.0
037A:  RLF    55,F
037B:  RLF    56,F
037C:  RLF    57,F
037D:  RLF    58,F
037E:  BCF    03.0
037F:  RLF    7A,F
0380:  RLF    79,F
0381:  RLF    78,F
0382:  RLF    5A,F
0383:  GOTO   330
0384:  BTFSS  5A.0
0385:  GOTO   38C
0386:  BCF    03.0
0387:  RRF    78,F
0388:  RRF    79,F
0389:  RRF    7A,F
038A:  RRF    5A,F
038B:  GOTO   38F
038C:  DECF   77,F
038D:  BTFSC  03.2
038E:  GOTO   3D1
038F:  BTFSC  5A.7
0390:  GOTO   3B8
0391:  BCF    03.0
0392:  RLF    55,F
0393:  RLF    56,F
0394:  RLF    57,F
0395:  RLF    58,F
0396:  MOVF   54,W
0397:  SUBWF  55,F
0398:  BTFSC  03.0
0399:  GOTO   3A4
039A:  MOVLW  01
039B:  SUBWF  56,F
039C:  BTFSC  03.0
039D:  GOTO   3A4
039E:  SUBWF  57,F
039F:  BTFSC  03.0
03A0:  GOTO   3A4
03A1:  SUBWF  58,F
03A2:  BTFSS  03.0
03A3:  GOTO   3C7
03A4:  MOVF   53,W
03A5:  SUBWF  56,F
03A6:  BTFSC  03.0
03A7:  GOTO   3AF
03A8:  MOVLW  01
03A9:  SUBWF  57,F
03AA:  BTFSC  03.0
03AB:  GOTO   3AF
03AC:  SUBWF  58,F
03AD:  BTFSS  03.0
03AE:  GOTO   3C7
03AF:  MOVF   52,W
03B0:  IORLW  80
03B1:  SUBWF  57,F
03B2:  BTFSC  03.0
03B3:  GOTO   3B8
03B4:  MOVLW  01
03B5:  SUBWF  58,F
03B6:  BTFSS  03.0
03B7:  GOTO   3C7
03B8:  INCF   7A,F
03B9:  BTFSS  03.2
03BA:  GOTO   3C7
03BB:  INCF   79,F
03BC:  BTFSS  03.2
03BD:  GOTO   3C7
03BE:  INCF   78,F
03BF:  BTFSS  03.2
03C0:  GOTO   3C7
03C1:  INCF   77,F
03C2:  BTFSC  03.2
03C3:  GOTO   3D1
03C4:  RRF    78,F
03C5:  RRF    79,F
03C6:  RRF    7A,F
03C7:  MOVF   4E,W
03C8:  MOVWF  59
03C9:  MOVF   52,W
03CA:  XORWF  59,F
03CB:  BTFSS  59.7
03CC:  GOTO   3CF
03CD:  BSF    78.7
03CE:  GOTO   3D5
03CF:  BCF    78.7
03D0:  GOTO   3D5
03D1:  CLRF   77
03D2:  CLRF   78
03D3:  CLRF   79
03D4:  CLRF   7A
*
03DD:  MOVLW  8E
03DE:  MOVWF  77
03DF:  MOVF   4D,W
03E0:  SUBWF  77,F
03E1:  MOVF   4E,W
03E2:  MOVWF  79
03E3:  MOVF   4F,W
03E4:  MOVWF  78
03E5:  BSF    79.7
03E6:  MOVF   77,F
03E7:  BTFSC  03.2
03E8:  GOTO   3F4
03E9:  BCF    03.0
03EA:  MOVF   79,F
03EB:  BTFSS  03.2
03EC:  GOTO   3F0
03ED:  MOVF   78,F
03EE:  BTFSC  03.2
03EF:  GOTO   3F4
03F0:  RRF    79,F
03F1:  RRF    78,F
03F2:  DECFSZ 77,F
03F3:  GOTO   3E9
03F4:  BTFSS  4E.7
03F5:  GOTO   3FB
03F6:  COMF   78,F
03F7:  COMF   79,F
03F8:  INCF   78,F
03F9:  BTFSC  03.2
03FA:  INCF   79,F
*
0453:  MOVF   0B,W
0454:  BSF    03.6
0455:  MOVWF  4C
0456:  BCF    03.6
0457:  BCF    0B.7
0458:  BSF    03.5
0459:  BSF    03.6
045A:  BSF    0C.7
045B:  BSF    0C.0
045C:  NOP
045D:  NOP
045E:  BCF    03.5
045F:  BTFSS  4C.7
0460:  GOTO   464
0461:  BCF    03.6
0462:  BSF    0B.7
0463:  BSF    03.6
0464:  MOVF   0C,W
0465:  ANDLW  7F
0466:  BTFSC  03.2
0467:  GOTO   4A1
0468:  MOVWF  4C
0469:  MOVF   0D,W
046A:  MOVWF  4D
046B:  MOVF   0F,W
046C:  MOVWF  4E
046D:  MOVF   4C,W
046E:  MOVWF  4F
046F:  BCF    03.6
0470:  CALL   419
0471:  BSF    03.6
0472:  MOVF   4D,W
0473:  MOVWF  0D
0474:  MOVF   4E,W
0475:  MOVWF  0F
0476:  BCF    03.6
0477:  MOVF   0B,W
0478:  BSF    03.6
0479:  MOVWF  4F
047A:  BCF    03.6
047B:  BCF    0B.7
047C:  BSF    03.5
047D:  BSF    03.6
047E:  BSF    0C.7
047F:  BSF    0C.0
0480:  NOP
0481:  NOP
0482:  BCF    03.5
0483:  BTFSS  4F.7
0484:  GOTO   488
0485:  BCF    03.6
0486:  BSF    0B.7
0487:  BSF    03.6
0488:  RLF    0C,W
0489:  RLF    0E,W
048A:  ANDLW  7F
048B:  BTFSC  03.2
048C:  GOTO   4A1
048D:  MOVWF  4C
048E:  MOVF   0D,W
048F:  MOVWF  4D
0490:  MOVF   0F,W
0491:  MOVWF  4E
0492:  MOVF   4C,W
0493:  MOVWF  4F
0494:  BCF    03.6
0495:  CALL   419
0496:  BSF    03.6
0497:  MOVF   4D,W
0498:  MOVWF  0D
0499:  MOVF   4E,W
049A:  MOVWF  0F
049B:  INCF   0D,F
049C:  BTFSC  03.2
049D:  INCF   0F,F
049E:  BCF    03.6
049F:  GOTO   453
04A0:  BSF    03.6
04A1:  BCF    03.6
04A2:  RETURN
04A3:  BTFSC  03.1
04A4:  GOTO   4A8
04A5:  MOVLW  90
04A6:  MOVWF  04
04A7:  BSF    03.7
04A8:  BSF    03.6
04A9:  MOVF   67,W
04AA:  XORWF  6B,W
04AB:  ANDLW  80
04AC:  BSF    03.5
04AD:  MOVWF  15
04AE:  BCF    03.5
04AF:  BTFSS  67.7
04B0:  GOTO   4BC
04B1:  COMF   64,F
04B2:  COMF   65,F
04B3:  COMF   66,F
04B4:  COMF   67,F
04B5:  INCF   64,F
04B6:  BTFSC  03.2
04B7:  INCF   65,F
04B8:  BTFSC  03.2
04B9:  INCF   66,F
04BA:  BTFSC  03.2
04BB:  INCF   67,F
04BC:  BTFSS  6B.7
04BD:  GOTO   4C9
04BE:  COMF   68,F
04BF:  COMF   69,F
04C0:  COMF   6A,F
04C1:  COMF   6B,F
04C2:  INCF   68,F
04C3:  BTFSC  03.2
04C4:  INCF   69,F
04C5:  BTFSC  03.2
04C6:  INCF   6A,F
04C7:  BTFSC  03.2
04C8:  INCF   6B,F
04C9:  CLRF   77
04CA:  CLRF   78
04CB:  CLRF   79
04CC:  CLRF   7A
04CD:  BSF    03.5
04CE:  CLRF   10
04CF:  CLRF   11
04D0:  CLRF   12
04D1:  CLRF   13
04D2:  BCF    03.5
04D3:  MOVF   6B,W
04D4:  IORWF  6A,W
04D5:  IORWF  69,W
04D6:  IORWF  68,W
04D7:  BTFSC  03.2
04D8:  GOTO   525
04D9:  MOVLW  20
04DA:  BSF    03.5
04DB:  MOVWF  14
04DC:  BCF    03.0
04DD:  BCF    03.5
04DE:  RLF    64,F
04DF:  RLF    65,F
04E0:  RLF    66,F
04E1:  RLF    67,F
04E2:  BSF    03.5
04E3:  RLF    10,F
04E4:  RLF    11,F
04E5:  RLF    12,F
04E6:  RLF    13,F
04E7:  BCF    03.5
04E8:  MOVF   6B,W
04E9:  BSF    03.5
04EA:  SUBWF  13,W
04EB:  BTFSS  03.2
04EC:  GOTO   4FD
04ED:  BCF    03.5
04EE:  MOVF   6A,W
04EF:  BSF    03.5
04F0:  SUBWF  12,W
04F1:  BTFSS  03.2
04F2:  GOTO   4FD
04F3:  BCF    03.5
04F4:  MOVF   69,W
04F5:  BSF    03.5
04F6:  SUBWF  11,W
04F7:  BTFSS  03.2
04F8:  GOTO   4FD
04F9:  BCF    03.5
04FA:  MOVF   68,W
04FB:  BSF    03.5
04FC:  SUBWF  10,W
04FD:  BTFSS  03.0
04FE:  GOTO   51E
04FF:  BCF    03.5
0500:  MOVF   68,W
0501:  BSF    03.5
0502:  SUBWF  10,F
0503:  BCF    03.5
0504:  MOVF   69,W
0505:  BTFSS  03.0
0506:  INCFSZ 69,W
0507:  GOTO   509
0508:  GOTO   50C
0509:  BSF    03.5
050A:  SUBWF  11,F
050B:  BCF    03.5
050C:  MOVF   6A,W
050D:  BTFSS  03.0
050E:  INCFSZ 6A,W
050F:  GOTO   511
0510:  GOTO   514
0511:  BSF    03.5
0512:  SUBWF  12,F
0513:  BCF    03.5
0514:  MOVF   6B,W
0515:  BTFSS  03.0
0516:  INCFSZ 6B,W
0517:  GOTO   519
0518:  GOTO   51C
0519:  BSF    03.5
051A:  SUBWF  13,F
051B:  BCF    03.5
051C:  BSF    03.0
051D:  BSF    03.5
051E:  RLF    77,F
051F:  RLF    78,F
0520:  RLF    79,F
0521:  RLF    7A,F
0522:  DECFSZ 14,F
0523:  GOTO   4DC
0524:  BCF    03.5
0525:  BSF    03.5
0526:  BTFSS  15.7
0527:  GOTO   533
0528:  COMF   77,F
0529:  COMF   78,F
052A:  COMF   79,F
052B:  COMF   7A,F
052C:  INCF   77,F
052D:  BTFSC  03.2
052E:  INCF   78,F
052F:  BTFSC  03.2
0530:  INCF   79,F
0531:  BTFSC  03.2
0532:  INCF   7A,F
0533:  MOVF   10,W
0534:  MOVWF  00
0535:  INCF   04,F
0536:  MOVF   11,W
0537:  MOVWF  00
0538:  INCF   04,F
0539:  MOVF   12,W
053A:  MOVWF  00
053B:  INCF   04,F
053C:  MOVF   13,W
053D:  MOVWF  00
053E:  BCF    03.5
053F:  BCF    03.6
0540:  RETURN
*
055A:  MOVLW  20
055B:  MOVWF  68
055C:  CLRF   64
055D:  CLRF   65
055E:  CLRF   66
055F:  CLRF   67
0560:  MOVF   5F,W
0561:  MOVWF  7A
0562:  MOVF   5E,W
0563:  MOVWF  79
0564:  MOVF   5D,W
0565:  MOVWF  78
0566:  MOVF   5C,W
0567:  MOVWF  77
0568:  BCF    03.0
0569:  BTFSS  77.0
056A:  GOTO   579
056B:  MOVF   60,W
056C:  ADDWF  64,F
056D:  MOVF   61,W
056E:  BTFSC  03.0
056F:  INCFSZ 61,W
0570:  ADDWF  65,F
0571:  MOVF   62,W
0572:  BTFSC  03.0
0573:  INCFSZ 62,W
0574:  ADDWF  66,F
0575:  MOVF   63,W
0576:  BTFSC  03.0
0577:  INCFSZ 63,W
0578:  ADDWF  67,F
0579:  RRF    67,F
057A:  RRF    66,F
057B:  RRF    65,F
057C:  RRF    64,F
057D:  RRF    7A,F
057E:  RRF    79,F
057F:  RRF    78,F
0580:  RRF    77,F
0581:  DECFSZ 68,F
0582:  GOTO   568
*
0661:  MOVF   00,F
0662:  BTFSC  03.2
0663:  GOTO   67D
0664:  BSF    03.6
0665:  CLRF   4D
0666:  MOVF   04,W
0667:  MOVWF  4C
0668:  BCF    4D.0
0669:  BTFSC  03.7
066A:  BSF    4D.0
066B:  MOVF   00,W
066C:  MOVWF  4F
066D:  BCF    03.6
066E:  CALL   419
066F:  BSF    03.6
0670:  MOVF   4C,W
0671:  MOVWF  04
0672:  BCF    03.7
0673:  BTFSC  4D.0
0674:  BSF    03.7
0675:  INCF   04,F
0676:  BTFSS  03.2
0677:  GOTO   67B
0678:  BCF    03.6
0679:  INCF   05,F
067A:  BSF    03.6
067B:  BCF    03.6
067C:  GOTO   661
067D:  RETURN
067E:  BSF    03.6
067F:  MOVF   4D,W
0680:  ANDLW  07
0681:  MOVWF  77
0682:  RRF    4D,W
0683:  MOVWF  78
0684:  RRF    78,F
0685:  RRF    78,F
0686:  MOVLW  1F
0687:  ANDWF  78,F
0688:  MOVF   78,W
0689:  ADDWF  4E,W
068A:  MOVWF  04
068B:  BCF    03.7
068C:  BTFSC  4F.0
068D:  BSF    03.7
068E:  MOVF   00,W
068F:  MOVWF  78
0690:  INCF   77,F
0691:  GOTO   693
0692:  RRF    78,F
0693:  DECFSZ 77,F
0694:  GOTO   692
0695:  BCF    03.6
0696:  RETURN
0697:  BSF    03.6
0698:  MOVF   4C,W
0699:  ANDLW  07
069A:  MOVWF  77
069B:  RRF    4C,W
069C:  MOVWF  78
069D:  RRF    78,F
069E:  RRF    78,F
069F:  MOVLW  1F
06A0:  ANDWF  78,F
06A1:  MOVF   78,W
06A2:  ADDWF  4E,W
06A3:  MOVWF  04
06A4:  BCF    03.7
06A5:  BTFSC  4F.0
06A6:  BSF    03.7
06A7:  CLRF   78
06A8:  INCF   78,F
06A9:  INCF   77,F
06AA:  GOTO   6AC
06AB:  RLF    78,F
06AC:  DECFSZ 77,F
06AD:  GOTO   6AB
06AE:  MOVF   4D,F
06AF:  BTFSC  03.2
06B0:  GOTO   6B4
06B1:  MOVF   78,W
06B2:  IORWF  00,F
06B3:  GOTO   6B7
06B4:  COMF   78,F
06B5:  MOVF   78,W
06B6:  ANDWF  00,F
06B7:  BCF    03.6
06B8:  RETURN
*
077D:  BSF    0A.0
077E:  BSF    0A.1
077F:  BSF    0A.2
0780:  ADDWF  02,F
0781:  GOTO   755
0782:  GOTO   75D
0783:  GOTO   765
0784:  GOTO   76D
0785:  MOVF   00,F
0786:  BTFSC  03.2
0787:  GOTO   7A2
0788:  BSF    03.6
0789:  CLRF   4F
078A:  MOVF   04,W
078B:  MOVWF  4E
078C:  BCF    4F.0
078D:  BTFSC  03.7
078E:  BSF    4F.0
078F:  MOVF   00,W
0790:  BCF    03.6
0791:  BTFSS  0C.4
0792:  GOTO   791
0793:  MOVWF  19
0794:  BSF    03.6
0795:  MOVF   4E,W
0796:  MOVWF  04
0797:  BCF    03.7
0798:  BTFSC  4F.0
0799:  BSF    03.7
079A:  INCF   04,F
079B:  BTFSS  03.2
079C:  GOTO   7A0
079D:  BCF    03.6
079E:  INCF   05,F
079F:  BSF    03.6
07A0:  BCF    03.6
07A1:  GOTO   785
07A2:  RETURN
*
0B20:  MOVF   50,W
0B21:  CLRF   78
0B22:  SUBWF  4F,W
0B23:  BTFSC  03.0
0B24:  GOTO   328
0B25:  MOVF   4F,W
0B26:  MOVWF  77
0B27:  GOTO   334
0B28:  CLRF   77
0B29:  MOVLW  08
0B2A:  MOVWF  51
0B2B:  RLF    4F,F
0B2C:  RLF    77,F
0B2D:  MOVF   50,W
0B2E:  SUBWF  77,W
0B2F:  BTFSC  03.0
0B30:  MOVWF  77
0B31:  RLF    78,F
0B32:  DECFSZ 51,F
0B33:  GOTO   32B
*
0BAA:  BSF    0A.0
0BAB:  BSF    0A.1
0BAC:  BCF    0A.2
0BAD:  ADDWF  02,F
0BAE:  GOTO   007
0BAF:  GOTO   06E
0BB0:  GOTO   176
0BB1:  GOTO   27E
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
06B9:  BSF    03.6
06BA:  MOVF   4E,W
06BB:  MOVWF  52
06BC:  MOVF   4D,W
06BD:  MOVWF  51
06BE:  MOVF   52,W
06BF:  MOVWF  7A
06C0:  MOVF   51,W
06C1:  MOVWF  04
06C2:  BCF    03.7
06C3:  BTFSC  7A.0
06C4:  BSF    03.7
06C5:  MOVF   00,F
06C6:  BTFSC  03.2
06C7:  GOTO   6CC
06C8:  INCF   51,F
06C9:  BTFSC  03.2
06CA:  INCF   52,F
06CB:  GOTO   6BE
....................    while(*s2 != '\0') 
06CC:  MOVF   50,W
06CD:  MOVWF  7A
06CE:  MOVF   4F,W
06CF:  MOVWF  04
06D0:  BCF    03.7
06D1:  BTFSC  7A.0
06D2:  BSF    03.7
06D3:  MOVF   00,F
06D4:  BTFSC  03.2
06D5:  GOTO   6EB
....................    { 
....................       *s = *s2; 
06D6:  MOVF   4F,W
06D7:  MOVWF  04
06D8:  BCF    03.7
06D9:  BTFSC  50.0
06DA:  BSF    03.7
06DB:  MOVF   00,W
06DC:  MOVWF  55
06DD:  MOVF   51,W
06DE:  MOVWF  04
06DF:  BCF    03.7
06E0:  BTFSC  52.0
06E1:  BSF    03.7
06E2:  MOVF   55,W
06E3:  MOVWF  00
....................       ++s; 
06E4:  INCF   51,F
06E5:  BTFSC  03.2
06E6:  INCF   52,F
....................       ++s2; 
06E7:  INCF   4F,F
06E8:  BTFSC  03.2
06E9:  INCF   50,F
06EA:  GOTO   6CC
....................    } 
....................  
....................    *s = '\0'; 
06EB:  MOVF   51,W
06EC:  MOVWF  04
06ED:  BCF    03.7
06EE:  BTFSC  52.0
06EF:  BSF    03.7
06F0:  CLRF   00
....................    return(s1); 
06F1:  MOVF   4D,W
06F2:  MOVWF  78
06F3:  MOVF   4E,W
06F4:  MOVWF  79
06F5:  BCF    03.6
06F6:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0D69:  BCF    03.6
0D6A:  CLRF   2B
0D6B:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0CAD:  MOVF   4F,W
0CAE:  MOVWF  51
0CAF:  MOVF   4E,W
0CB0:  MOVWF  50
0CB1:  MOVF   51,W
0CB2:  MOVWF  7A
0CB3:  MOVF   50,W
0CB4:  MOVWF  04
0CB5:  BCF    03.7
0CB6:  BTFSC  7A.0
0CB7:  BSF    03.7
0CB8:  MOVF   00,F
0CB9:  BTFSC  03.2
0CBA:  GOTO   4BF
0CBB:  INCF   50,F
0CBC:  BTFSC  03.2
0CBD:  INCF   51,F
0CBE:  GOTO   4B1
....................    return(sc - s); 
0CBF:  MOVF   4E,W
0CC0:  SUBWF  50,W
0CC1:  MOVWF  77
0CC2:  MOVF   51,W
0CC3:  MOVWF  7A
0CC4:  MOVF   4F,W
0CC5:  BTFSS  03.0
0CC6:  INCFSZ 4F,W
0CC7:  SUBWF  7A,F
0CC8:  MOVF   77,W
0CC9:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0541:  BSF    03.6
0542:  CLRF   57
0543:  CLRF   56
0544:  CLRF   55
0545:  MOVLW  01
0546:  MOVWF  54
0547:  CLRF   59
0548:  CLRF   5A
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0549:  BTFSS  50.7
054A:  GOTO   58B
....................          sign=1;        // Check for negative number 
054B:  MOVLW  01
054C:  MOVWF  59
....................          num*=-1; 
054D:  MOVF   50,W
054E:  MOVWF  5F
054F:  MOVF   4F,W
0550:  MOVWF  5E
0551:  MOVF   4E,W
0552:  MOVWF  5D
0553:  MOVF   4D,W
0554:  MOVWF  5C
0555:  MOVLW  FF
0556:  MOVWF  63
0557:  MOVWF  62
0558:  MOVWF  61
0559:  MOVWF  60
*
0583:  MOVF   7A,W
0584:  MOVWF  50
0585:  MOVF   79,W
0586:  MOVWF  4F
0587:  MOVF   78,W
0588:  MOVWF  4E
0589:  MOVF   77,W
058A:  MOVWF  4D
....................      } 
....................  
....................      while(temp>0) { 
058B:  MOVF   54,F
058C:  BTFSS  03.2
058D:  GOTO   597
058E:  MOVF   55,F
058F:  BTFSS  03.2
0590:  GOTO   597
0591:  MOVF   56,F
0592:  BTFSS  03.2
0593:  GOTO   597
0594:  MOVF   57,F
0595:  BTFSC  03.2
0596:  GOTO   613
....................          temp=(num/base); 
0597:  BCF    03.1
0598:  MOVF   50,W
0599:  MOVWF  67
059A:  MOVF   4F,W
059B:  MOVWF  66
059C:  MOVF   4E,W
059D:  MOVWF  65
059E:  MOVF   4D,W
059F:  MOVWF  64
05A0:  CLRF   6B
05A1:  CLRF   6A
05A2:  CLRF   69
05A3:  MOVF   51,W
05A4:  MOVWF  68
05A5:  BCF    03.6
05A6:  CALL   4A3
05A7:  MOVF   7A,W
05A8:  BSF    03.6
05A9:  MOVWF  57
05AA:  MOVF   79,W
05AB:  MOVWF  56
05AC:  MOVF   78,W
05AD:  MOVWF  55
05AE:  MOVF   77,W
05AF:  MOVWF  54
....................          s[cnt]=(num%base)+'0';    // Conversion 
05B0:  MOVF   5A,W
05B1:  ADDWF  52,W
05B2:  MOVWF  78
05B3:  MOVF   53,W
05B4:  MOVWF  7A
05B5:  BTFSC  03.0
05B6:  INCF   7A,F
05B7:  MOVF   78,W
05B8:  MOVWF  5C
05B9:  MOVF   7A,W
05BA:  MOVWF  5D
05BB:  CLRF   5F
05BC:  MOVF   04,W
05BD:  MOVWF  5E
05BE:  BCF    5F.0
05BF:  BTFSC  03.7
05C0:  BSF    5F.0
05C1:  BSF    03.1
05C2:  MOVLW  60
05C3:  MOVWF  04
05C4:  BSF    03.7
05C5:  MOVF   50,W
05C6:  MOVWF  67
05C7:  MOVF   4F,W
05C8:  MOVWF  66
05C9:  MOVF   4E,W
05CA:  MOVWF  65
05CB:  MOVF   4D,W
05CC:  MOVWF  64
05CD:  CLRF   6B
05CE:  CLRF   6A
05CF:  CLRF   69
05D0:  MOVF   51,W
05D1:  MOVWF  68
05D2:  BCF    03.6
05D3:  CALL   4A3
05D4:  BSF    03.6
05D5:  MOVF   5E,W
05D6:  MOVWF  04
05D7:  BCF    03.7
05D8:  BTFSC  5F.0
05D9:  BSF    03.7
05DA:  MOVLW  30
05DB:  ADDWF  60,W
05DC:  MOVWF  77
05DD:  MOVF   61,W
05DE:  MOVWF  78
05DF:  MOVLW  00
05E0:  BTFSC  03.0
05E1:  MOVLW  01
05E2:  ADDWF  78,F
05E3:  MOVF   62,W
05E4:  MOVWF  79
05E5:  MOVLW  00
05E6:  BTFSC  03.0
05E7:  MOVLW  01
05E8:  ADDWF  79,F
05E9:  MOVF   63,W
05EA:  MOVWF  7A
05EB:  MOVLW  00
05EC:  BTFSC  03.0
05ED:  MOVLW  01
05EE:  ADDWF  7A,F
05EF:  MOVF   5C,W
05F0:  MOVWF  04
05F1:  BCF    03.7
05F2:  BTFSC  5D.0
05F3:  BSF    03.7
05F4:  MOVF   77,W
05F5:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
05F6:  MOVF   5A,W
05F7:  ADDWF  52,W
05F8:  MOVWF  04
05F9:  BCF    03.7
05FA:  BTFSC  53.0
05FB:  BSF    03.7
05FC:  MOVF   00,W
05FD:  SUBLW  39
05FE:  BTFSC  03.0
05FF:  GOTO   609
....................             s[cnt]+=0x7; 
0600:  MOVF   5A,W
0601:  ADDWF  52,W
0602:  MOVWF  04
0603:  BCF    03.7
0604:  BTFSC  53.0
0605:  BSF    03.7
0606:  MOVLW  07
0607:  ADDWF  00,W
0608:  MOVWF  00
....................  
....................          cnt++; 
0609:  INCF   5A,F
....................          num=temp; 
060A:  MOVF   57,W
060B:  MOVWF  50
060C:  MOVF   56,W
060D:  MOVWF  4F
060E:  MOVF   55,W
060F:  MOVWF  4E
0610:  MOVF   54,W
0611:  MOVWF  4D
0612:  GOTO   58B
....................      } 
....................  
....................      if(sign==1) { 
0613:  DECFSZ 59,W
0614:  GOTO   61E
....................          s[cnt]=0x2D;      // Negative sign 
0615:  MOVF   5A,W
0616:  ADDWF  52,W
0617:  MOVWF  04
0618:  BCF    03.7
0619:  BTFSC  53.0
061A:  BSF    03.7
061B:  MOVLW  2D
061C:  MOVWF  00
....................          cnt++; 
061D:  INCF   5A,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
061E:  CLRF   58
061F:  BCF    03.0
0620:  RRF    5A,W
0621:  SUBWF  58,W
0622:  BTFSC  03.0
0623:  GOTO   654
....................  
....................          c=s[i]; 
0624:  MOVF   58,W
0625:  ADDWF  52,W
0626:  MOVWF  04
0627:  BCF    03.7
0628:  BTFSC  53.0
0629:  BSF    03.7
062A:  MOVF   00,W
062B:  MOVWF  5B
....................          s[i]=s[cnt-i-1];        // Reverse the number 
062C:  MOVF   58,W
062D:  ADDWF  52,W
062E:  MOVWF  78
062F:  MOVF   53,W
0630:  MOVWF  7A
0631:  BTFSC  03.0
0632:  INCF   7A,F
0633:  MOVF   78,W
0634:  MOVWF  5C
0635:  MOVF   7A,W
0636:  MOVWF  5D
0637:  MOVF   58,W
0638:  SUBWF  5A,W
0639:  ADDLW  FF
063A:  ADDWF  52,W
063B:  MOVWF  04
063C:  BCF    03.7
063D:  BTFSC  53.0
063E:  BSF    03.7
063F:  MOVF   00,W
0640:  MOVWF  5E
0641:  MOVF   5C,W
0642:  MOVWF  04
0643:  BCF    03.7
0644:  BTFSC  5D.0
0645:  BSF    03.7
0646:  MOVF   5E,W
0647:  MOVWF  00
....................          s[cnt-i-1]=c; 
0648:  MOVF   58,W
0649:  SUBWF  5A,W
064A:  ADDLW  FF
064B:  ADDWF  52,W
064C:  MOVWF  04
064D:  BCF    03.7
064E:  BTFSC  53.0
064F:  BSF    03.7
0650:  MOVF   5B,W
0651:  MOVWF  00
0652:  INCF   58,F
0653:  GOTO   61F
....................      } 
....................      s[cnt]='\0';     // End the string 
0654:  MOVF   5A,W
0655:  ADDWF  52,W
0656:  MOVWF  04
0657:  BCF    03.7
0658:  BTFSC  53.0
0659:  BSF    03.7
065A:  CLRF   00
....................      return s; 
065B:  MOVF   52,W
065C:  MOVWF  78
065D:  MOVF   53,W
065E:  MOVWF  79
065F:  BCF    03.6
0660:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#INCLUDE <CONFIG_NODE.C> 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0131:  MOVLW  50
0132:  MOVWF  04
0133:  BSF    03.7
0134:  MOVF   00,W
0135:  BTFSC  03.2
0136:  GOTO   144
0137:  MOVLW  06
0138:  MOVWF  78
0139:  CLRF   77
013A:  DECFSZ 77,F
013B:  GOTO   13A
013C:  DECFSZ 78,F
013D:  GOTO   139
013E:  MOVLW  7B
013F:  MOVWF  77
0140:  DECFSZ 77,F
0141:  GOTO   140
0142:  DECFSZ 00,F
0143:  GOTO   137
0144:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01D8:  BSF    07.0
....................    output_float(LCD_DATA5); 
01D9:  BSF    07.1
....................    output_float(LCD_DATA6); 
01DA:  BSF    07.2
....................    output_float(LCD_DATA7); 
01DB:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01DC:  BCF    03.5
01DD:  BSF    09.2
01DE:  BSF    03.5
01DF:  BCF    09.2
....................    delay_cycles(1); 
01E0:  NOP
....................    lcd_output_enable(1); 
01E1:  BCF    03.5
01E2:  BSF    09.0
01E3:  BSF    03.5
01E4:  BCF    09.0
....................    delay_cycles(1); 
01E5:  NOP
....................    high = lcd_read_nibble(); 
01E6:  BCF    03.5
01E7:  CALL   18D
01E8:  MOVF   78,W
01E9:  BSF    03.6
01EA:  MOVWF  57
....................        
....................    lcd_output_enable(0); 
01EB:  BCF    03.6
01EC:  BCF    09.0
01ED:  BSF    03.5
01EE:  BCF    09.0
....................    delay_cycles(1); 
01EF:  NOP
....................    lcd_output_enable(1); 
01F0:  BCF    03.5
01F1:  BSF    09.0
01F2:  BSF    03.5
01F3:  BCF    09.0
....................    delay_us(1); 
01F4:  GOTO   1F5
01F5:  GOTO   1F6
01F6:  NOP
....................    low = lcd_read_nibble(); 
01F7:  BCF    03.5
01F8:  CALL   18D
01F9:  MOVF   78,W
01FA:  BSF    03.6
01FB:  MOVWF  56
....................        
....................    lcd_output_enable(0); 
01FC:  BCF    03.6
01FD:  BCF    09.0
01FE:  BSF    03.5
01FF:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0200:  BCF    03.5
0201:  BCF    31.0
0202:  MOVF   31,W
0203:  BSF    03.5
0204:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0205:  BCF    03.5
0206:  BCF    31.1
0207:  MOVF   31,W
0208:  BSF    03.5
0209:  MOVWF  07
....................    output_drive(LCD_DATA6); 
020A:  BCF    03.5
020B:  BCF    31.2
020C:  MOVF   31,W
020D:  BSF    03.5
020E:  MOVWF  07
....................    output_drive(LCD_DATA7); 
020F:  BCF    03.5
0210:  BCF    31.3
0211:  MOVF   31,W
0212:  BSF    03.5
0213:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0214:  BCF    03.5
0215:  BSF    03.6
0216:  SWAPF  57,W
0217:  MOVWF  77
0218:  MOVLW  F0
0219:  ANDWF  77,F
021A:  MOVF   77,W
021B:  IORWF  56,W
021C:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
018D:  BSF    03.6
018E:  CLRF   58
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
018F:  BCF    03.6
0190:  BSF    31.0
0191:  MOVF   31,W
0192:  BSF    03.5
0193:  MOVWF  07
0194:  MOVLW  00
0195:  BCF    03.5
0196:  BTFSC  07.0
0197:  MOVLW  01
0198:  BSF    03.6
0199:  IORWF  58,F
....................    n |= input(LCD_DATA5) << 1; 
019A:  BCF    03.6
019B:  BSF    31.1
019C:  MOVF   31,W
019D:  BSF    03.5
019E:  MOVWF  07
019F:  MOVLW  00
01A0:  BCF    03.5
01A1:  BTFSC  07.1
01A2:  MOVLW  01
01A3:  MOVWF  77
01A4:  BCF    03.0
01A5:  RLF    77,F
01A6:  MOVF   77,W
01A7:  BSF    03.6
01A8:  IORWF  58,F
....................    n |= input(LCD_DATA6) << 2; 
01A9:  BCF    03.6
01AA:  BSF    31.2
01AB:  MOVF   31,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  MOVLW  00
01AF:  BCF    03.5
01B0:  BTFSC  07.2
01B1:  MOVLW  01
01B2:  MOVWF  77
01B3:  RLF    77,F
01B4:  RLF    77,F
01B5:  MOVLW  FC
01B6:  ANDWF  77,F
01B7:  MOVF   77,W
01B8:  BSF    03.6
01B9:  IORWF  58,F
....................    n |= input(LCD_DATA7) << 3; 
01BA:  BCF    03.6
01BB:  BSF    31.3
01BC:  MOVF   31,W
01BD:  BSF    03.5
01BE:  MOVWF  07
01BF:  MOVLW  00
01C0:  BCF    03.5
01C1:  BTFSC  07.3
01C2:  MOVLW  01
01C3:  MOVWF  77
01C4:  RLF    77,F
01C5:  RLF    77,F
01C6:  RLF    77,F
01C7:  MOVLW  F8
01C8:  ANDWF  77,F
01C9:  MOVF   77,W
01CA:  BSF    03.6
01CB:  IORWF  58,F
....................     
....................    return(n); 
01CC:  MOVF   58,W
01CD:  MOVWF  78
....................   #else 
01CE:  BCF    03.6
01CF:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0145:  BSF    03.6
0146:  BTFSC  57.0
0147:  GOTO   14C
0148:  BCF    03.6
0149:  BCF    07.0
014A:  GOTO   14E
014B:  BSF    03.6
014C:  BCF    03.6
014D:  BSF    07.0
014E:  BCF    31.0
014F:  MOVF   31,W
0150:  BSF    03.5
0151:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0152:  BCF    03.5
0153:  BSF    03.6
0154:  BTFSC  57.1
0155:  GOTO   15A
0156:  BCF    03.6
0157:  BCF    07.1
0158:  GOTO   15C
0159:  BSF    03.6
015A:  BCF    03.6
015B:  BSF    07.1
015C:  BCF    31.1
015D:  MOVF   31,W
015E:  BSF    03.5
015F:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0160:  BCF    03.5
0161:  BSF    03.6
0162:  BTFSC  57.2
0163:  GOTO   168
0164:  BCF    03.6
0165:  BCF    07.2
0166:  GOTO   16A
0167:  BSF    03.6
0168:  BCF    03.6
0169:  BSF    07.2
016A:  BCF    31.2
016B:  MOVF   31,W
016C:  BSF    03.5
016D:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
016E:  BCF    03.5
016F:  BSF    03.6
0170:  BTFSC  57.3
0171:  GOTO   176
0172:  BCF    03.6
0173:  BCF    07.3
0174:  GOTO   178
0175:  BSF    03.6
0176:  BCF    03.6
0177:  BSF    07.3
0178:  BCF    31.3
0179:  MOVF   31,W
017A:  BSF    03.5
017B:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
017C:  NOP
....................    lcd_output_enable(1); 
017D:  BCF    03.5
017E:  BSF    09.0
017F:  BSF    03.5
0180:  BCF    09.0
....................    delay_us(2); 
0181:  MOVLW  02
0182:  MOVWF  77
0183:  DECFSZ 77,F
0184:  GOTO   183
0185:  GOTO   186
0186:  NOP
....................    lcd_output_enable(0); 
0187:  BCF    03.5
0188:  BCF    09.0
0189:  BSF    03.5
018A:  BCF    09.0
018B:  BCF    03.5
018C:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01D0:  BSF    03.5
01D1:  BCF    09.0
....................    lcd_rs_tris(); 
01D2:  BCF    09.1
....................    lcd_rw_tris(); 
01D3:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01D4:  BCF    03.5
01D5:  BCF    09.1
01D6:  BSF    03.5
01D7:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
021D:  MOVF   78,W
021E:  MOVWF  56
021F:  BTFSS  56.7
0220:  GOTO   224
0221:  BSF    03.5
0222:  BCF    03.6
0223:  GOTO   1D8
....................    lcd_output_rs(address); 
0224:  MOVF   54,F
0225:  BTFSS  03.2
0226:  GOTO   22B
0227:  BCF    03.6
0228:  BCF    09.1
0229:  GOTO   22D
022A:  BSF    03.6
022B:  BCF    03.6
022C:  BSF    09.1
022D:  BSF    03.5
022E:  BCF    09.1
....................    delay_cycles(1); 
022F:  NOP
....................    lcd_output_rw(0); 
0230:  BCF    03.5
0231:  BCF    09.2
0232:  BSF    03.5
0233:  BCF    09.2
....................    delay_cycles(1); 
0234:  NOP
....................    lcd_output_enable(0); 
0235:  BCF    03.5
0236:  BCF    09.0
0237:  BSF    03.5
0238:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0239:  BCF    03.5
023A:  BSF    03.6
023B:  SWAPF  55,W
023C:  MOVWF  56
023D:  MOVLW  0F
023E:  ANDWF  56,F
023F:  MOVF   56,W
0240:  MOVWF  57
0241:  BCF    03.6
0242:  CALL   145
....................    lcd_send_nibble(n & 0xf); 
0243:  BSF    03.6
0244:  MOVF   55,W
0245:  ANDLW  0F
0246:  MOVWF  56
0247:  MOVWF  57
0248:  BCF    03.6
0249:  CALL   145
024A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
024B:  MOVLW  28
024C:  BSF    03.6
024D:  MOVWF  4C
024E:  MOVLW  0C
024F:  MOVWF  4D
0250:  MOVLW  01
0251:  MOVWF  4E
0252:  MOVLW  06
0253:  MOVWF  4F
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0254:  BCF    03.6
0255:  BCF    09.0
0256:  BSF    03.5
0257:  BCF    09.0
....................    lcd_output_rs(0); 
0258:  BCF    03.5
0259:  BCF    09.1
025A:  BSF    03.5
025B:  BCF    09.1
....................    lcd_output_rw(0); 
025C:  BCF    03.5
025D:  BCF    09.2
025E:  BSF    03.5
025F:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0260:  BCF    03.5
0261:  BCF    31.0
0262:  MOVF   31,W
0263:  BSF    03.5
0264:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0265:  BCF    03.5
0266:  BCF    31.1
0267:  MOVF   31,W
0268:  BSF    03.5
0269:  MOVWF  07
....................    output_drive(LCD_DATA6); 
026A:  BCF    03.5
026B:  BCF    31.2
026C:  MOVF   31,W
026D:  BSF    03.5
026E:  MOVWF  07
....................    output_drive(LCD_DATA7); 
026F:  BCF    03.5
0270:  BCF    31.3
0271:  MOVF   31,W
0272:  BSF    03.5
0273:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0274:  BCF    09.0
....................    lcd_rs_tris(); 
0275:  BCF    09.1
....................    lcd_rw_tris(); 
0276:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0277:  MOVLW  0F
0278:  BCF    03.5
0279:  BSF    03.6
027A:  MOVWF  50
027B:  BCF    03.6
027C:  CALL   131
....................    for(i=1;i<=3;++i) 
027D:  MOVLW  01
027E:  BSF    03.6
027F:  MOVWF  4B
0280:  MOVF   4B,W
0281:  SUBLW  03
0282:  BTFSS  03.0
0283:  GOTO   290
....................    { 
....................        lcd_send_nibble(3); 
0284:  MOVLW  03
0285:  MOVWF  57
0286:  BCF    03.6
0287:  CALL   145
....................        delay_ms(5); 
0288:  MOVLW  05
0289:  BSF    03.6
028A:  MOVWF  50
028B:  BCF    03.6
028C:  CALL   131
028D:  BSF    03.6
028E:  INCF   4B,F
028F:  GOTO   280
....................    } 
....................     
....................    lcd_send_nibble(2); 
0290:  MOVLW  02
0291:  MOVWF  57
0292:  BCF    03.6
0293:  CALL   145
....................    delay_ms(5); 
0294:  MOVLW  05
0295:  BSF    03.6
0296:  MOVWF  50
0297:  BCF    03.6
0298:  CALL   131
....................    for(i=0;i<=3;++i) 
0299:  BSF    03.6
029A:  CLRF   4B
029B:  MOVF   4B,W
029C:  SUBLW  03
029D:  BTFSS  03.0
029E:  GOTO   2AD
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
029F:  MOVLW  4C
02A0:  ADDWF  4B,W
02A1:  MOVWF  04
02A2:  BSF    03.7
02A3:  MOVF   00,W
02A4:  MOVWF  50
02A5:  CLRF   54
02A6:  MOVF   50,W
02A7:  MOVWF  55
02A8:  BCF    03.6
02A9:  CALL   1D0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02AA:  BSF    03.6
02AB:  INCF   4B,F
02AC:  GOTO   29B
02AD:  BCF    03.6
02AE:  BSF    0A.3
02AF:  BCF    0A.4
02B0:  GOTO   6C3 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0405:  BSF    03.6
0406:  DECFSZ 51,W
0407:  GOTO   409
0408:  GOTO   40C
....................       address=LCD_LINE_TWO; 
0409:  MOVLW  40
040A:  MOVWF  52
040B:  GOTO   40D
....................    else 
....................       address=0; 
040C:  CLRF   52
....................       
....................    address+=x-1; 
040D:  MOVLW  01
040E:  SUBWF  50,W
040F:  ADDWF  52,F
....................    lcd_send_byte(0,0x80|address); 
0410:  MOVF   52,W
0411:  IORLW  80
0412:  MOVWF  53
0413:  CLRF   54
0414:  MOVF   53,W
0415:  MOVWF  55
0416:  BCF    03.6
0417:  CALL   1D0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0418:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0419:  BSF    03.6
041A:  MOVF   4F,W
041B:  XORLW  07
041C:  BCF    03.6
041D:  BTFSC  03.2
041E:  GOTO   429
041F:  XORLW  0B
0420:  BTFSC  03.2
0421:  GOTO   430
0422:  XORLW  06
0423:  BTFSC  03.2
0424:  GOTO   43C
0425:  XORLW  02
0426:  BTFSC  03.2
0427:  GOTO   444
0428:  GOTO   44B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0429:  MOVLW  01
042A:  BSF    03.6
042B:  MOVWF  50
042C:  MOVWF  51
042D:  BCF    03.6
042E:  CALL   405
042F:  GOTO   452
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0430:  BSF    03.6
0431:  CLRF   54
0432:  MOVLW  01
0433:  MOVWF  55
0434:  BCF    03.6
0435:  CALL   1D0
....................                      delay_ms(2); 
0436:  MOVLW  02
0437:  BSF    03.6
0438:  MOVWF  50
0439:  BCF    03.6
043A:  CALL   131
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
043B:  GOTO   452
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
043C:  MOVLW  01
043D:  BSF    03.6
043E:  MOVWF  50
043F:  MOVLW  02
0440:  MOVWF  51
0441:  BCF    03.6
0442:  CALL   405
0443:  GOTO   452
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0444:  BSF    03.6
0445:  CLRF   54
0446:  MOVLW  10
0447:  MOVWF  55
0448:  BCF    03.6
0449:  CALL   1D0
044A:  GOTO   452
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
044B:  MOVLW  01
044C:  BSF    03.6
044D:  MOVWF  54
044E:  MOVF   4F,W
044F:  MOVWF  55
0450:  BCF    03.6
0451:  CALL   1D0
....................      #endif 
....................    } 
0452:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 0, 1, 0, 1, 1}; 
*
0D6C:  MOVLW  D6
0D6D:  MOVWF  60
.................... INT1 TT_SENSOR[8]={1, 1, 1, 1, 0, 0, 0, 0}; 
0D6E:  MOVLW  0F
0D6F:  MOVWF  61
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
0D70:  MOVLW  20
0D71:  MOVWF  64
0D72:  CLRF   65
0D73:  CLRF   63
0D74:  MOVLW  64
0D75:  MOVWF  62
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
0D76:  MOVLW  20
0D77:  MOVWF  68
0D78:  CLRF   69
0D79:  CLRF   67
0D7A:  MOVLW  68
0D7B:  MOVWF  66
.................... CHAR *PACKAGE_NHIETDO[]={"*","ID_GW", "ID_NODE","LENGHT", "S_S" ,"TT_cambien","#"}; 
0D7C:  MOVLW  2A
0D7D:  BSF    03.5
0D7E:  MOVWF  2E
0D7F:  CLRF   2F
0D80:  MOVLW  49
0D81:  MOVWF  30
0D82:  MOVLW  44
0D83:  MOVWF  31
0D84:  MOVLW  5F
0D85:  MOVWF  32
0D86:  MOVLW  47
0D87:  MOVWF  33
0D88:  MOVLW  57
0D89:  MOVWF  34
0D8A:  CLRF   35
0D8B:  MOVLW  49
0D8C:  MOVWF  36
0D8D:  MOVLW  44
0D8E:  MOVWF  37
0D8F:  MOVLW  5F
0D90:  MOVWF  38
0D91:  MOVLW  4E
0D92:  MOVWF  39
0D93:  MOVLW  4F
0D94:  MOVWF  3A
0D95:  MOVLW  44
0D96:  MOVWF  3B
0D97:  MOVLW  45
0D98:  MOVWF  3C
0D99:  CLRF   3D
0D9A:  MOVLW  4C
0D9B:  MOVWF  3E
0D9C:  MOVLW  45
0D9D:  MOVWF  3F
0D9E:  MOVLW  4E
0D9F:  MOVWF  40
0DA0:  MOVLW  47
0DA1:  MOVWF  41
0DA2:  MOVLW  48
0DA3:  MOVWF  42
0DA4:  MOVLW  54
0DA5:  MOVWF  43
0DA6:  CLRF   44
0DA7:  MOVLW  53
0DA8:  MOVWF  45
0DA9:  MOVLW  5F
0DAA:  MOVWF  46
0DAB:  MOVLW  53
0DAC:  MOVWF  47
0DAD:  CLRF   48
0DAE:  MOVLW  54
0DAF:  MOVWF  49
0DB0:  MOVWF  4A
0DB1:  MOVLW  5F
0DB2:  MOVWF  4B
0DB3:  MOVLW  63
0DB4:  MOVWF  4C
0DB5:  MOVLW  61
0DB6:  MOVWF  4D
0DB7:  MOVLW  6D
0DB8:  MOVWF  4E
0DB9:  MOVLW  62
0DBA:  MOVWF  4F
0DBB:  MOVLW  69
0DBC:  MOVWF  50
0DBD:  MOVLW  65
0DBE:  MOVWF  51
0DBF:  MOVLW  6E
0DC0:  MOVWF  52
0DC1:  CLRF   53
0DC2:  MOVLW  23
0DC3:  MOVWF  54
0DC4:  CLRF   55
0DC5:  CLRF   21
0DC6:  MOVLW  AE
0DC7:  MOVWF  20
0DC8:  CLRF   23
0DC9:  MOVLW  B0
0DCA:  MOVWF  22
0DCB:  CLRF   25
0DCC:  MOVLW  B6
0DCD:  MOVWF  24
0DCE:  CLRF   27
0DCF:  MOVLW  BE
0DD0:  MOVWF  26
0DD1:  CLRF   29
0DD2:  MOVLW  C5
0DD3:  MOVWF  28
0DD4:  CLRF   2B
0DD5:  MOVLW  C9
0DD6:  MOVWF  2A
0DD7:  CLRF   2D
0DD8:  MOVLW  D4
0DD9:  MOVWF  2C
....................  
.................... CHAR *PACKAGE_CONFIG[]={"*","ID_GW" ,"ID_NODE", "LENGHT","C_F", "DEVICE1234","SENSOR1234","#"}; 
0DDA:  MOVLW  2A
0DDB:  BCF    03.5
0DDC:  BSF    03.6
0DDD:  MOVWF  10
0DDE:  CLRF   11
0DDF:  MOVLW  49
0DE0:  MOVWF  12
0DE1:  MOVLW  44
0DE2:  MOVWF  13
0DE3:  MOVLW  5F
0DE4:  MOVWF  14
0DE5:  MOVLW  47
0DE6:  MOVWF  15
0DE7:  MOVLW  57
0DE8:  MOVWF  16
0DE9:  CLRF   17
0DEA:  MOVLW  49
0DEB:  MOVWF  18
0DEC:  MOVLW  44
0DED:  MOVWF  19
0DEE:  MOVLW  5F
0DEF:  MOVWF  1A
0DF0:  MOVLW  4E
0DF1:  MOVWF  1B
0DF2:  MOVLW  4F
0DF3:  MOVWF  1C
0DF4:  MOVLW  44
0DF5:  MOVWF  1D
0DF6:  MOVLW  45
0DF7:  MOVWF  1E
0DF8:  CLRF   1F
0DF9:  MOVLW  4C
0DFA:  MOVWF  20
0DFB:  MOVLW  45
0DFC:  MOVWF  21
0DFD:  MOVLW  4E
0DFE:  MOVWF  22
0DFF:  MOVLW  47
0E00:  MOVWF  23
0E01:  MOVLW  48
0E02:  MOVWF  24
0E03:  MOVLW  54
0E04:  MOVWF  25
0E05:  CLRF   26
0E06:  MOVLW  43
0E07:  MOVWF  27
0E08:  MOVLW  5F
0E09:  MOVWF  28
0E0A:  MOVLW  46
0E0B:  MOVWF  29
0E0C:  CLRF   2A
0E0D:  MOVLW  44
0E0E:  MOVWF  2B
0E0F:  MOVLW  45
0E10:  MOVWF  2C
0E11:  MOVLW  56
0E12:  MOVWF  2D
0E13:  MOVLW  49
0E14:  MOVWF  2E
0E15:  MOVLW  43
0E16:  MOVWF  2F
0E17:  MOVLW  45
0E18:  MOVWF  30
0E19:  MOVLW  31
0E1A:  MOVWF  31
0E1B:  MOVLW  32
0E1C:  MOVWF  32
0E1D:  MOVLW  33
0E1E:  MOVWF  33
0E1F:  MOVLW  34
0E20:  MOVWF  34
0E21:  CLRF   35
0E22:  MOVLW  53
0E23:  MOVWF  36
0E24:  MOVLW  45
0E25:  MOVWF  37
0E26:  MOVLW  4E
0E27:  MOVWF  38
0E28:  MOVLW  53
0E29:  MOVWF  39
0E2A:  MOVLW  4F
0E2B:  MOVWF  3A
0E2C:  MOVLW  52
0E2D:  MOVWF  3B
0E2E:  MOVLW  31
0E2F:  MOVWF  3C
0E30:  MOVLW  32
0E31:  MOVWF  3D
0E32:  MOVLW  33
0E33:  MOVWF  3E
0E34:  MOVLW  34
0E35:  MOVWF  3F
0E36:  CLRF   40
0E37:  MOVLW  23
0E38:  MOVWF  41
0E39:  CLRF   42
0E3A:  MOVLW  01
0E3B:  BSF    03.5
0E3C:  BCF    03.6
0E3D:  MOVWF  57
0E3E:  MOVLW  10
0E3F:  MOVWF  56
0E40:  MOVLW  01
0E41:  MOVWF  59
0E42:  MOVLW  12
0E43:  MOVWF  58
0E44:  MOVLW  01
0E45:  MOVWF  5B
0E46:  MOVLW  18
0E47:  MOVWF  5A
0E48:  MOVLW  01
0E49:  MOVWF  5D
0E4A:  MOVLW  20
0E4B:  MOVWF  5C
0E4C:  MOVLW  01
0E4D:  MOVWF  5F
0E4E:  MOVLW  27
0E4F:  MOVWF  5E
0E50:  MOVLW  01
0E51:  MOVWF  61
0E52:  MOVLW  2B
0E53:  MOVWF  60
0E54:  MOVLW  01
0E55:  MOVWF  63
0E56:  MOVLW  36
0E57:  MOVWF  62
0E58:  MOVLW  01
0E59:  MOVWF  65
0E5A:  MOVLW  41
0E5B:  MOVWF  64
.................... CHAR *ID_[]="0"; 
0E5C:  MOVLW  30
0E5D:  BCF    03.5
0E5E:  MOVWF  6C
0E5F:  CLRF   6D
0E60:  CLRF   6B
0E61:  MOVLW  6C
0E62:  MOVWF  6A
.................... CHAR *ID_GW[]= "0000"; 
0E63:  MOVLW  30
0E64:  MOVWF  70
0E65:  MOVWF  71
0E66:  MOVWF  72
0E67:  MOVWF  73
0E68:  CLRF   74
0E69:  CLRF   6F
0E6A:  MOVLW  70
0E6B:  MOVWF  6E
.................... UNSIGNED INT8 ID_GATEWAY[4] = {0,0,0,0}; 
0E6C:  CLRF   7B
0E6D:  CLRF   7C
0E6E:  CLRF   7D
0E6F:  CLRF   7E
.................... CHAR *TEMP_CHAR[]="0"; 
0E70:  MOVLW  30
0E71:  BSF    03.5
0E72:  MOVWF  66
0E73:  CLRF   67
0E74:  CLRF   76
0E75:  MOVLW  E6
0E76:  MOVWF  75
.................... CHAR *TEMP_CHAR2[]="0";  
0E77:  MOVLW  30
0E78:  MOVWF  6A
0E79:  CLRF   6B
0E7A:  CLRF   69
0E7B:  MOVLW  EA
0E7C:  MOVWF  68
.................... CHAR *TEMP_CHAR3[]="0";  
0E7D:  MOVLW  30
0E7E:  MOVWF  6E
0E7F:  CLRF   6F
0E80:  CLRF   6D
0E81:  MOVLW  EE
0E82:  MOVWF  6C
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
....................  
.................... CHAR NHIETDO1[]="27"; 
0E83:  MOVLW  32
0E84:  BCF    03.5
0E85:  BSF    03.6
0E86:  MOVWF  44
0E87:  MOVLW  37
0E88:  MOVWF  45
0E89:  CLRF   46
.................... CHAR NHIETDO2[]="27"; 
0E8A:  MOVLW  32
0E8B:  MOVWF  47
0E8C:  MOVLW  37
0E8D:  MOVWF  48
0E8E:  CLRF   49
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    5F.1
....................    TT_STT = 1; 
0808:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  50
080C:  MOVLW  02
080D:  MOVWF  51
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   405
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  50
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   131
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   453
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  5F.3
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  4B
0831:  MOVLW  96
0832:  MOVWF  50
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   131
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 4B,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   50
083B:  CLRF   4F
083C:  CLRF   4E
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  4D
0841:  MOVLW  0A
0842:  MOVWF  51
0843:  CLRF   53
0844:  MOVLW  6A
0845:  MOVWF  52
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   541
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  50
084D:  MOVLW  02
084E:  MOVWF  51
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   405
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  50
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   131
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  6A
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   661
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  50
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   131
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    5F.1
....................    TT_STT = 1; 
086F:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  50
0873:  MOVLW  02
0874:  MOVWF  51
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   405
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  50
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   131
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:           "); 
0880:  MOVLW  72
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   453
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  5F.3
088A:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11A
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  4B
0898:  MOVLW  96
0899:  MOVWF  50
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   131
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 4B,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   50
08A2:  CLRF   4F
08A3:  CLRF   4E
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  4D
08A8:  MOVLW  0A
08A9:  MOVWF  51
08AA:  CLRF   53
08AB:  MOVLW  75
08AC:  MOVWF  52
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   541
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  50
08B4:  MOVLW  02
08B5:  MOVWF  51
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   405
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  50
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   131
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  75
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   661
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  50
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   131
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
08CE:  MOVLW  20
08CF:  BSF    03.6
08D0:  MOVWF  4F
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   419
08D4:  BSF    0A.3
08D5:  MOVLW  3A
08D6:  BSF    03.6
08D7:  MOVWF  4F
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   419
08DB:  BSF    0A.3
08DC:  MOVLW  20
08DD:  BSF    03.6
08DE:  MOVWF  4F
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   419
08E2:  BSF    0A.3
....................          DELAY_MS (1); 
08E3:  MOVLW  01
08E4:  BSF    03.6
08E5:  MOVWF  50
08E6:  BCF    0A.3
08E7:  BCF    03.6
08E8:  CALL   131
08E9:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EA:  MOVF   3A,W
08EB:  BSF    03.6
08EC:  MOVWF  4D
08ED:  CLRF   4F
08EE:  MOVLW  60
08EF:  MOVWF  4E
08F0:  BCF    0A.3
08F1:  BCF    03.6
08F2:  CALL   67E
08F3:  BSF    0A.3
08F4:  MOVLW  00
08F5:  BTFSC  78.0
08F6:  MOVLW  01
08F7:  BSF    03.6
08F8:  MOVWF  4B
08F9:  CLRF   50
08FA:  CLRF   4F
08FB:  CLRF   4E
08FC:  MOVF   4B,W
08FD:  MOVWF  4D
08FE:  MOVLW  0A
08FF:  MOVWF  51
0900:  CLRF   53
0901:  MOVLW  75
0902:  MOVWF  52
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   541
0906:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0907:  MOVLW  75
0908:  MOVWF  04
0909:  BCF    03.7
090A:  BCF    0A.3
090B:  CALL   661
090C:  BSF    0A.3
....................          DELAY_MS (1); 
090D:  MOVLW  01
090E:  BSF    03.6
090F:  MOVWF  50
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   131
0913:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0914:  BSF    03.5
0915:  BCF    08.0
0916:  MOVLW  01
0917:  BCF    03.5
0918:  XORWF  08,F
....................       } 
0919:  GOTO   174
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091A:  BSF    03.5
091B:  BSF    06.3
091C:  BCF    03.5
091D:  BTFSC  06.3
091E:  GOTO   174
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
091F:  MOVF   3A,W
0920:  BSF    03.6
0921:  MOVWF  4D
0922:  CLRF   4F
0923:  MOVLW  60
0924:  MOVWF  4E
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   67E
0928:  BSF    0A.3
0929:  MOVLW  00
092A:  BTFSS  78.0
092B:  MOVLW  01
092C:  BSF    03.6
092D:  MOVWF  4B
092E:  BCF    03.6
092F:  MOVF   3A,W
0930:  BSF    03.6
0931:  MOVWF  4C
0932:  MOVF   4B,W
0933:  MOVWF  4D
0934:  CLRF   4F
0935:  MOVLW  60
0936:  MOVWF  4E
0937:  BCF    0A.3
0938:  BCF    03.6
0939:  CALL   697
093A:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
093B:  MOVLW  0D
093C:  BSF    03.6
093D:  MOVWF  50
093E:  MOVLW  02
093F:  MOVWF  51
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   405
0943:  BSF    0A.3
....................          DELAY_MS (300); 
0944:  MOVLW  02
0945:  BSF    03.6
0946:  MOVWF  4B
0947:  MOVLW  96
0948:  MOVWF  50
0949:  BCF    0A.3
094A:  BCF    03.6
094B:  CALL   131
094C:  BSF    0A.3
094D:  BSF    03.6
094E:  DECFSZ 4B,F
094F:  GOTO   147
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0950:  BCF    03.6
0951:  MOVF   3A,W
0952:  BSF    03.6
0953:  MOVWF  4D
0954:  CLRF   4F
0955:  MOVLW  60
0956:  MOVWF  4E
0957:  BCF    0A.3
0958:  BCF    03.6
0959:  CALL   67E
095A:  BSF    0A.3
095B:  MOVLW  00
095C:  BTFSC  78.0
095D:  MOVLW  01
095E:  BSF    03.6
095F:  MOVWF  4B
0960:  CLRF   50
0961:  CLRF   4F
0962:  CLRF   4E
0963:  MOVF   4B,W
0964:  MOVWF  4D
0965:  MOVLW  0A
0966:  MOVWF  51
0967:  CLRF   53
0968:  MOVLW  75
0969:  MOVWF  52
096A:  BCF    0A.3
096B:  BCF    03.6
096C:  CALL   541
096D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
096E:  MOVLW  75
096F:  MOVWF  04
0970:  BCF    03.7
0971:  BCF    0A.3
0972:  CALL   661
0973:  BSF    0A.3
....................       } 
0974:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0976:  BCF    5F.1
....................    TT_STT = 1; 
0977:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0978:  MOVLW  01
0979:  BSF    03.6
097A:  MOVWF  50
097B:  MOVLW  02
097C:  MOVWF  51
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   405
0980:  BSF    0A.3
....................    DELAY_MS (10);   
0981:  MOVLW  0A
0982:  BSF    03.6
0983:  MOVWF  50
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   131
0987:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
0988:  MOVLW  7C
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  MOVLW  00
098C:  MOVWF  0F
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   453
0990:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0991:  BTFSS  5F.3
0992:  GOTO   27D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0993:  BSF    03.5
0994:  BSF    06.2
0995:  BCF    03.5
0996:  BTFSC  06.2
0997:  GOTO   222
....................       { 
....................          STT_SENSOR ++; 
0998:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0999:  MOVF   3B,W
099A:  SUBLW  03
099B:  BTFSS  03.0
099C:  CLRF   3B
....................          DELAY_MS (300); 
099D:  MOVLW  02
099E:  BSF    03.6
099F:  MOVWF  4B
09A0:  MOVLW  96
09A1:  MOVWF  50
09A2:  BCF    0A.3
09A3:  BCF    03.6
09A4:  CALL   131
09A5:  BSF    0A.3
09A6:  BSF    03.6
09A7:  DECFSZ 4B,F
09A8:  GOTO   1A0
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09A9:  CLRF   50
09AA:  CLRF   4F
09AB:  CLRF   4E
09AC:  BCF    03.6
09AD:  MOVF   3B,W
09AE:  BSF    03.6
09AF:  MOVWF  4D
09B0:  MOVLW  0A
09B1:  MOVWF  51
09B2:  CLRF   53
09B3:  MOVLW  75
09B4:  MOVWF  52
09B5:  BCF    0A.3
09B6:  BCF    03.6
09B7:  CALL   541
09B8:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09B9:  MOVLW  09
09BA:  BSF    03.6
09BB:  MOVWF  50
09BC:  MOVLW  02
09BD:  MOVWF  51
09BE:  BCF    0A.3
09BF:  BCF    03.6
09C0:  CALL   405
09C1:  BSF    0A.3
....................          DELAY_MS (10); 
09C2:  MOVLW  0A
09C3:  BSF    03.6
09C4:  MOVWF  50
09C5:  BCF    0A.3
09C6:  BCF    03.6
09C7:  CALL   131
09C8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09C9:  MOVLW  75
09CA:  MOVWF  04
09CB:  BCF    03.7
09CC:  BCF    0A.3
09CD:  CALL   661
09CE:  BSF    0A.3
....................          DELAY_MS (1); 
09CF:  MOVLW  01
09D0:  BSF    03.6
09D1:  MOVWF  50
09D2:  BCF    0A.3
09D3:  BCF    03.6
09D4:  CALL   131
09D5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
09D6:  MOVLW  20
09D7:  BSF    03.6
09D8:  MOVWF  4F
09D9:  BCF    0A.3
09DA:  BCF    03.6
09DB:  CALL   419
09DC:  BSF    0A.3
09DD:  MOVLW  3A
09DE:  BSF    03.6
09DF:  MOVWF  4F
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   419
09E3:  BSF    0A.3
09E4:  MOVLW  20
09E5:  BSF    03.6
09E6:  MOVWF  4F
09E7:  BCF    0A.3
09E8:  BCF    03.6
09E9:  CALL   419
09EA:  BSF    0A.3
....................          DELAY_MS (1); 
09EB:  MOVLW  01
09EC:  BSF    03.6
09ED:  MOVWF  50
09EE:  BCF    0A.3
09EF:  BCF    03.6
09F0:  CALL   131
09F1:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F2:  MOVF   3B,W
09F3:  BSF    03.6
09F4:  MOVWF  4D
09F5:  CLRF   4F
09F6:  MOVLW  61
09F7:  MOVWF  4E
09F8:  BCF    0A.3
09F9:  BCF    03.6
09FA:  CALL   67E
09FB:  BSF    0A.3
09FC:  MOVLW  00
09FD:  BTFSC  78.0
09FE:  MOVLW  01
09FF:  BSF    03.6
0A00:  MOVWF  4B
0A01:  CLRF   50
0A02:  CLRF   4F
0A03:  CLRF   4E
0A04:  MOVF   4B,W
0A05:  MOVWF  4D
0A06:  MOVLW  0A
0A07:  MOVWF  51
0A08:  CLRF   53
0A09:  MOVLW  75
0A0A:  MOVWF  52
0A0B:  BCF    0A.3
0A0C:  BCF    03.6
0A0D:  CALL   541
0A0E:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A0F:  MOVLW  75
0A10:  MOVWF  04
0A11:  BCF    03.7
0A12:  BCF    0A.3
0A13:  CALL   661
0A14:  BSF    0A.3
....................          DELAY_MS (1); 
0A15:  MOVLW  01
0A16:  BSF    03.6
0A17:  MOVWF  50
0A18:  BCF    0A.3
0A19:  BCF    03.6
0A1A:  CALL   131
0A1B:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A1C:  BSF    03.5
0A1D:  BCF    08.0
0A1E:  MOVLW  01
0A1F:  BCF    03.5
0A20:  XORWF  08,F
....................       } 
0A21:  GOTO   27C
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A22:  BSF    03.5
0A23:  BSF    06.3
0A24:  BCF    03.5
0A25:  BTFSC  06.3
0A26:  GOTO   27C
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A27:  MOVF   3B,W
0A28:  BSF    03.6
0A29:  MOVWF  4D
0A2A:  CLRF   4F
0A2B:  MOVLW  61
0A2C:  MOVWF  4E
0A2D:  BCF    0A.3
0A2E:  BCF    03.6
0A2F:  CALL   67E
0A30:  BSF    0A.3
0A31:  MOVLW  00
0A32:  BTFSS  78.0
0A33:  MOVLW  01
0A34:  BSF    03.6
0A35:  MOVWF  4B
0A36:  BCF    03.6
0A37:  MOVF   3B,W
0A38:  BSF    03.6
0A39:  MOVWF  4C
0A3A:  MOVF   4B,W
0A3B:  MOVWF  4D
0A3C:  CLRF   4F
0A3D:  MOVLW  61
0A3E:  MOVWF  4E
0A3F:  BCF    0A.3
0A40:  BCF    03.6
0A41:  CALL   697
0A42:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A43:  MOVLW  0D
0A44:  BSF    03.6
0A45:  MOVWF  50
0A46:  MOVLW  02
0A47:  MOVWF  51
0A48:  BCF    0A.3
0A49:  BCF    03.6
0A4A:  CALL   405
0A4B:  BSF    0A.3
....................          DELAY_MS (300); 
0A4C:  MOVLW  02
0A4D:  BSF    03.6
0A4E:  MOVWF  4B
0A4F:  MOVLW  96
0A50:  MOVWF  50
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   131
0A54:  BSF    0A.3
0A55:  BSF    03.6
0A56:  DECFSZ 4B,F
0A57:  GOTO   24F
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A58:  BCF    03.6
0A59:  MOVF   3B,W
0A5A:  BSF    03.6
0A5B:  MOVWF  4D
0A5C:  CLRF   4F
0A5D:  MOVLW  61
0A5E:  MOVWF  4E
0A5F:  BCF    0A.3
0A60:  BCF    03.6
0A61:  CALL   67E
0A62:  BSF    0A.3
0A63:  MOVLW  00
0A64:  BTFSC  78.0
0A65:  MOVLW  01
0A66:  BSF    03.6
0A67:  MOVWF  4B
0A68:  CLRF   50
0A69:  CLRF   4F
0A6A:  CLRF   4E
0A6B:  MOVF   4B,W
0A6C:  MOVWF  4D
0A6D:  MOVLW  0A
0A6E:  MOVWF  51
0A6F:  CLRF   53
0A70:  MOVLW  75
0A71:  MOVWF  52
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   541
0A75:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A76:  MOVLW  75
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  BCF    0A.3
0A7A:  CALL   661
0A7B:  BSF    0A.3
....................       } 
0A7C:  GOTO   191
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0A7E:  BSF    03.6
0A7F:  CLRF   4B
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    ID_GW = "\0"; 
0A80:  CLRF   4C
0A81:  CLRF   4D
0A82:  MOVLW  6E
0A83:  MOVWF  04
0A84:  BCF    03.7
0A85:  MOVF   4C,W
0A86:  ADDWF  04,F
0A87:  MOVF   4D,W
0A88:  BCF    0A.3
0A89:  BCF    03.6
0A8A:  CALL   058
0A8B:  BSF    0A.3
0A8C:  MOVWF  00
0A8D:  IORLW  00
0A8E:  BTFSC  03.2
0A8F:  GOTO   295
0A90:  BSF    03.6
0A91:  INCF   4D,F
0A92:  INCF   4C,F
0A93:  GOTO   282
0A94:  BCF    03.6
....................    TEMP_CHAR3 = "0"; 
0A95:  BSF    03.6
0A96:  CLRF   4C
0A97:  CLRF   4D
0A98:  MOVLW  EC
0A99:  MOVWF  04
0A9A:  BCF    03.7
0A9B:  MOVF   4C,W
0A9C:  ADDWF  04,F
0A9D:  MOVF   4D,W
0A9E:  BCF    0A.3
0A9F:  BCF    03.6
0AA0:  CALL   05E
0AA1:  BSF    0A.3
0AA2:  MOVWF  00
0AA3:  IORLW  00
0AA4:  BTFSC  03.2
0AA5:  GOTO   2AB
0AA6:  BSF    03.6
0AA7:  INCF   4D,F
0AA8:  INCF   4C,F
0AA9:  GOTO   298
0AAA:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0AAB:  BCF    5F.1
....................    TT_STT = 1; 
0AAC:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0AAD:  MOVLW  01
0AAE:  BSF    03.6
0AAF:  MOVWF  50
0AB0:  MOVLW  02
0AB1:  MOVWF  51
0AB2:  BCF    0A.3
0AB3:  BCF    03.6
0AB4:  CALL   405
0AB5:  BSF    0A.3
....................    DELAY_MS (10); 
0AB6:  MOVLW  0A
0AB7:  BSF    03.6
0AB8:  MOVWF  50
0AB9:  BCF    0A.3
0ABA:  BCF    03.6
0ABB:  CALL   131
0ABC:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:  0000 "); 
0ABD:  MOVLW  85
0ABE:  BSF    03.6
0ABF:  MOVWF  0D
0AC0:  MOVLW  00
0AC1:  MOVWF  0F
0AC2:  BCF    0A.3
0AC3:  BCF    03.6
0AC4:  CALL   453
0AC5:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0AC6:  MOVLW  01
0AC7:  BSF    03.6
0AC8:  MOVWF  50
0AC9:  MOVWF  51
0ACA:  BCF    0A.3
0ACB:  BCF    03.6
0ACC:  CALL   405
0ACD:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "        _    "); 
0ACE:  MOVLW  8C
0ACF:  BSF    03.6
0AD0:  MOVWF  0D
0AD1:  MOVLW  00
0AD2:  MOVWF  0F
0AD3:  BCF    0A.3
0AD4:  BCF    03.6
0AD5:  CALL   453
0AD6:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0AD7:  BTFSS  5F.3
0AD8:  GOTO   377
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0AD9:  BSF    03.5
0ADA:  BSF    06.2
0ADB:  BCF    03.5
0ADC:  BTFSC  06.2
0ADD:  GOTO   303
....................       { 
....................           
....................          NUM++; 
0ADE:  BSF    03.6
0ADF:  INCF   4B,F
....................          NUM = NUM % 4; 
0AE0:  MOVLW  03
0AE1:  ANDWF  4B,F
....................          LCD_GOTOXY (5 + NUM, 1); 
0AE2:  MOVLW  05
0AE3:  ADDWF  4B,W
0AE4:  MOVWF  4C
0AE5:  MOVWF  50
0AE6:  MOVLW  01
0AE7:  MOVWF  51
0AE8:  BCF    0A.3
0AE9:  BCF    03.6
0AEA:  CALL   405
0AEB:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    "); 
0AEC:  MOVLW  93
0AED:  BSF    03.6
0AEE:  MOVWF  0D
0AEF:  MOVLW  00
0AF0:  MOVWF  0F
0AF1:  BCF    0A.3
0AF2:  BCF    03.6
0AF3:  CALL   453
0AF4:  BSF    0A.3
....................          DELAY_MS (300);  
0AF5:  MOVLW  02
0AF6:  BSF    03.6
0AF7:  MOVWF  4C
0AF8:  MOVLW  96
0AF9:  MOVWF  50
0AFA:  BCF    0A.3
0AFB:  BCF    03.6
0AFC:  CALL   131
0AFD:  BSF    0A.3
0AFE:  BSF    03.6
0AFF:  DECFSZ 4C,F
0B00:  GOTO   2F8
....................       } 
0B01:  GOTO   375
0B02:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0B03:  BSF    03.5
0B04:  BSF    06.3
0B05:  BCF    03.5
0B06:  BTFSC  06.3
0B07:  GOTO   376
....................       { 
....................          ID_GATEWAY[NUM]++; 
0B08:  MOVLW  7B
0B09:  BSF    03.6
0B0A:  ADDWF  4B,W
0B0B:  MOVWF  04
0B0C:  BCF    03.7
0B0D:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0B0E:  MOVLW  7B
0B0F:  ADDWF  4B,W
0B10:  MOVWF  78
0B11:  CLRF   7A
0B12:  BTFSC  03.0
0B13:  INCF   7A,F
0B14:  MOVF   78,W
0B15:  MOVWF  4C
0B16:  MOVF   7A,W
0B17:  MOVWF  4D
0B18:  MOVLW  7B
0B19:  ADDWF  4B,W
0B1A:  MOVWF  04
0B1B:  BCF    03.7
0B1C:  MOVF   00,W
0B1D:  MOVWF  4F
0B1E:  MOVLW  0A
0B1F:  MOVWF  50
*
0B34:  MOVF   77,W
0B35:  MOVWF  4E
0B36:  MOVF   4C,W
0B37:  MOVWF  04
0B38:  BCF    03.7
0B39:  BTFSC  4D.0
0B3A:  BSF    03.7
0B3B:  MOVF   4E,W
0B3C:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR3); 
0B3D:  MOVLW  7B
0B3E:  ADDWF  4B,W
0B3F:  MOVWF  04
0B40:  BCF    03.7
0B41:  MOVF   00,W
0B42:  MOVWF  4C
0B43:  CLRF   50
0B44:  CLRF   4F
0B45:  CLRF   4E
0B46:  MOVF   4C,W
0B47:  MOVWF  4D
0B48:  MOVLW  0A
0B49:  MOVWF  51
0B4A:  CLRF   53
0B4B:  MOVLW  EC
0B4C:  MOVWF  52
0B4D:  BCF    0A.3
0B4E:  BCF    03.6
0B4F:  CALL   541
0B50:  BSF    0A.3
....................          LCD_GOTOXY (9 + NUM, 2); 
0B51:  MOVLW  09
0B52:  BSF    03.6
0B53:  ADDWF  4B,W
0B54:  MOVWF  4C
0B55:  MOVWF  50
0B56:  MOVLW  02
0B57:  MOVWF  51
0B58:  BCF    0A.3
0B59:  BCF    03.6
0B5A:  CALL   405
0B5B:  BSF    0A.3
....................          DELAY_MS (10); 
0B5C:  MOVLW  0A
0B5D:  BSF    03.6
0B5E:  MOVWF  50
0B5F:  BCF    0A.3
0B60:  BCF    03.6
0B61:  CALL   131
0B62:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR3); 
0B63:  MOVLW  EC
0B64:  MOVWF  04
0B65:  BCF    03.7
0B66:  BCF    0A.3
0B67:  CALL   661
0B68:  BSF    0A.3
....................          DELAY_MS (300); 
0B69:  MOVLW  02
0B6A:  BSF    03.6
0B6B:  MOVWF  4C
0B6C:  MOVLW  96
0B6D:  MOVWF  50
0B6E:  BCF    0A.3
0B6F:  BCF    03.6
0B70:  CALL   131
0B71:  BSF    0A.3
0B72:  BSF    03.6
0B73:  DECFSZ 4C,F
0B74:  GOTO   36C
0B75:  BCF    03.6
....................       } 
0B76:  GOTO   2D7
....................    } 
....................  
....................    FOR (NUM = 0; NUM < 4; NUM++) 
0B77:  BSF    03.6
0B78:  CLRF   4B
0B79:  MOVF   4B,W
0B7A:  SUBLW  03
0B7B:  BTFSS  03.0
0B7C:  GOTO   3A6
....................    { 
....................       ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR3); 
0B7D:  MOVLW  7B
0B7E:  ADDWF  4B,W
0B7F:  MOVWF  04
0B80:  BCF    03.7
0B81:  MOVF   00,W
0B82:  MOVWF  4C
0B83:  CLRF   50
0B84:  CLRF   4F
0B85:  CLRF   4E
0B86:  MOVF   4C,W
0B87:  MOVWF  4D
0B88:  MOVLW  0A
0B89:  MOVWF  51
0B8A:  CLRF   53
0B8B:  MOVLW  EC
0B8C:  MOVWF  52
0B8D:  BCF    0A.3
0B8E:  BCF    03.6
0B8F:  CALL   541
0B90:  BSF    0A.3
....................       DELAY_MS (1); 
0B91:  MOVLW  01
0B92:  BSF    03.6
0B93:  MOVWF  50
0B94:  BCF    0A.3
0B95:  BCF    03.6
0B96:  CALL   131
0B97:  BSF    0A.3
....................       STRCAT (ID_GW, TEMP_CHAR3); 
0B98:  BSF    03.6
0B99:  CLRF   4E
0B9A:  MOVLW  6E
0B9B:  MOVWF  4D
0B9C:  CLRF   50
0B9D:  MOVLW  EC
0B9E:  MOVWF  4F
0B9F:  BCF    0A.3
0BA0:  BCF    03.6
0BA1:  CALL   6B9
0BA2:  BSF    0A.3
0BA3:  BSF    03.6
0BA4:  INCF   4B,F
0BA5:  GOTO   379
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
010A:  BCF    03.5
010B:  BCF    03.6
010C:  BCF    5F.1
....................    TT_FUN = 0; 
010D:  BCF    5F.2
....................    TT_STT = 0; 
010E:  BCF    5F.3
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   3A7
0805:  ADDLW  04
0806:  GOTO   3AA
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   3A7
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0975:  GOTO   3A7
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A7D:  GOTO   3A7
....................  
....................       CASE 3: 
....................       NHAPID_GW (); 
....................       BREAK; 
*
0BA6:  BCF    03.6
....................    } 
0BA7:  BCF    0A.3
0BA8:  BCF    0A.4
0BA9:  GOTO   779 (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
06F7:  BSF    5F.2
....................    LCD_GOTOXY (1, 1) ; 
06F8:  MOVLW  01
06F9:  BSF    03.6
06FA:  MOVWF  50
06FB:  MOVWF  51
06FC:  BCF    03.6
06FD:  CALL   405
....................    DELAY_MS (10); 
06FE:  MOVLW  0A
06FF:  BSF    03.6
0700:  MOVWF  50
0701:  BCF    03.6
0702:  CALL   131
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0703:  MOVLW  98
0704:  BSF    03.6
0705:  MOVWF  0D
0706:  MOVLW  00
0707:  MOVWF  0F
0708:  BCF    03.6
0709:  CALL   453
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
070A:  MOVLW  01
070B:  BSF    03.6
070C:  MOVWF  50
070D:  MOVLW  02
070E:  MOVWF  51
070F:  BCF    03.6
0710:  CALL   405
....................    DELAY_MS (10); 
0711:  MOVLW  0A
0712:  BSF    03.6
0713:  MOVWF  50
0714:  BCF    03.6
0715:  CALL   131
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0716:  MOVLW  A0
0717:  BSF    03.6
0718:  MOVWF  0D
0719:  MOVLW  00
071A:  MOVWF  0F
071B:  BCF    03.6
071C:  CALL   453
....................  
....................    WHILE (TT_FUN) 
071D:  BTFSS  5F.2
071E:  GOTO   775
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
071F:  BSF    03.5
0720:  BSF    06.2
0721:  BCF    03.5
0722:  BTFSC  06.2
0723:  GOTO   774
....................       { 
....................          CONFIG_FUN ++; 
0724:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0725:  MOVLW  03
0726:  ANDWF  38,F
....................          DELAY_MS (300); 
0727:  MOVLW  02
0728:  BSF    03.6
0729:  MOVWF  4B
072A:  MOVLW  96
072B:  MOVWF  50
072C:  BCF    03.6
072D:  CALL   131
072E:  BSF    03.6
072F:  DECFSZ 4B,F
0730:  GOTO   72A
....................  
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0731:  MOVLW  06
0732:  MOVWF  50
0733:  MOVLW  02
0734:  MOVWF  51
0735:  BCF    03.6
0736:  CALL   405
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0737:  BSF    03.6
0738:  CLRF   50
0739:  CLRF   4F
073A:  CLRF   4E
073B:  BCF    03.6
073C:  MOVF   38,W
073D:  BSF    03.6
073E:  MOVWF  4D
073F:  MOVLW  0A
0740:  MOVWF  51
0741:  CLRF   53
0742:  MOVLW  75
0743:  MOVWF  52
0744:  BCF    03.6
0745:  CALL   541
....................          DELAY_MS (10); 
0746:  MOVLW  0A
0747:  BSF    03.6
0748:  MOVWF  50
0749:  BCF    03.6
074A:  CALL   131
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
074B:  MOVLW  75
074C:  MOVWF  04
074D:  BCF    03.7
074E:  CALL   661
....................  
....................          SWITCH (CONFIG_FUN) 
074F:  MOVF   38,W
0750:  ADDLW  FC
0751:  BTFSC  03.0
0752:  GOTO   774
0753:  ADDLW  04
0754:  GOTO   77D
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID         "); 
0755:  MOVLW  A8
0756:  BSF    03.6
0757:  MOVWF  0D
0758:  MOVLW  00
0759:  MOVWF  0F
075A:  BCF    03.6
075B:  CALL   453
....................             BREAK; 
075C:  GOTO   774
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - DEVICES    "); 
075D:  MOVLW  B0
075E:  BSF    03.6
075F:  MOVWF  0D
0760:  MOVLW  00
0761:  MOVWF  0F
0762:  BCF    03.6
0763:  CALL   453
....................             BREAK; 
0764:  GOTO   774
....................              
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, " - SENSORS    "); 
0765:  MOVLW  B8
0766:  BSF    03.6
0767:  MOVWF  0D
0768:  MOVLW  00
0769:  MOVWF  0F
076A:  BCF    03.6
076B:  CALL   453
....................             BREAK; 
076C:  GOTO   774
....................              
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, " - ID - GW:    "); 
076D:  MOVLW  C0
076E:  BSF    03.6
076F:  MOVWF  0D
0770:  MOVLW  00
0771:  MOVWF  0F
0772:  BCF    03.6
0773:  CALL   453
....................             BREAK; 
....................          } 
....................       } 
0774:  GOTO   71D
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0775:  BTFSC  5F.1
0776:  GOTO   77A
....................    { 
....................       SELLECT_FUN (); 
0777:  BSF    0A.3
0778:  GOTO   000
0779:  BCF    0A.3
....................    } 
077A:  BSF    0A.3
077B:  BCF    0A.4
077C:  GOTO   6D9 (RETURN)
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    * TEMP_CHAR2 = '\0'; 
*
0BF8:  CLRF   7A
0BF9:  MOVLW  E8
0BFA:  MOVWF  04
0BFB:  BCF    03.7
0BFC:  BTFSC  7A.0
0BFD:  BSF    03.7
0BFE:  CLRF   00
....................    * TT_DEVICE_CHAR = '\0'; 
0BFF:  CLRF   7A
0C00:  MOVLW  62
0C01:  MOVWF  04
0C02:  BCF    03.7
0C03:  BTFSC  7A.0
0C04:  BSF    03.7
0C05:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
0C06:  BSF    03.6
0C07:  CLRF   4C
0C08:  MOVF   4C,W
0C09:  SUBLW  07
0C0A:  BTFSS  03.0
0C0B:  GOTO   43B
....................    { 
....................       IF (TT_DEVICE[I]) 
0C0C:  MOVF   4C,W
0C0D:  MOVWF  4D
0C0E:  CLRF   4F
0C0F:  MOVLW  60
0C10:  MOVWF  4E
0C11:  BCF    0A.3
0C12:  BCF    03.6
0C13:  CALL   67E
0C14:  BSF    0A.3
0C15:  BTFSS  78.0
0C16:  GOTO   438
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
0C17:  BSF    03.6
0C18:  CLRF   50
0C19:  CLRF   4F
0C1A:  CLRF   4E
0C1B:  MOVF   4C,W
0C1C:  MOVWF  4D
0C1D:  MOVLW  0A
0C1E:  MOVWF  51
0C1F:  CLRF   53
0C20:  MOVLW  E8
0C21:  MOVWF  52
0C22:  BCF    0A.3
0C23:  BCF    03.6
0C24:  CALL   541
0C25:  BSF    0A.3
....................          DELAY_MS (1); 
0C26:  MOVLW  01
0C27:  BSF    03.6
0C28:  MOVWF  50
0C29:  BCF    0A.3
0C2A:  BCF    03.6
0C2B:  CALL   131
0C2C:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0C2D:  BSF    03.6
0C2E:  CLRF   4E
0C2F:  MOVLW  62
0C30:  MOVWF  4D
0C31:  CLRF   50
0C32:  MOVLW  E8
0C33:  MOVWF  4F
0C34:  BCF    0A.3
0C35:  BCF    03.6
0C36:  CALL   6B9
0C37:  BSF    0A.3
....................       } 
0C38:  BSF    03.6
0C39:  INCF   4C,F
0C3A:  GOTO   408
....................    } 
....................  
....................    // PACKAGE_CONFIG[6] = TT_DEVICE_CHAR; 
.................... } 
....................  
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    * TEMP_CHAR2 = '\0'; 
0C3B:  CLRF   7A
0C3C:  MOVLW  E8
0C3D:  MOVWF  04
0C3E:  BCF    03.7
0C3F:  BTFSC  7A.0
0C40:  BSF    03.7
0C41:  CLRF   00
....................    * TEMP_CHAR3 = '\0'; 
0C42:  CLRF   7A
0C43:  MOVLW  EC
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  BTFSC  7A.0
0C47:  BSF    03.7
0C48:  CLRF   00
....................    FOR (INT J = 0; J < 5; J++) 
0C49:  CLRF   4C
0C4A:  MOVF   4C,W
0C4B:  SUBLW  04
0C4C:  BTFSS  03.0
0C4D:  GOTO   47D
....................    { 
....................       IF (TT_SENSOR[J]) 
0C4E:  MOVF   4C,W
0C4F:  MOVWF  4D
0C50:  CLRF   4F
0C51:  MOVLW  61
0C52:  MOVWF  4E
0C53:  BCF    0A.3
0C54:  BCF    03.6
0C55:  CALL   67E
0C56:  BSF    0A.3
0C57:  BTFSS  78.0
0C58:  GOTO   47A
....................       { 
....................          ITOA (J, 10, TEMP_CHAR2); 
0C59:  BSF    03.6
0C5A:  CLRF   50
0C5B:  CLRF   4F
0C5C:  CLRF   4E
0C5D:  MOVF   4C,W
0C5E:  MOVWF  4D
0C5F:  MOVLW  0A
0C60:  MOVWF  51
0C61:  CLRF   53
0C62:  MOVLW  E8
0C63:  MOVWF  52
0C64:  BCF    0A.3
0C65:  BCF    03.6
0C66:  CALL   541
0C67:  BSF    0A.3
....................          DELAY_MS (1); 
0C68:  MOVLW  01
0C69:  BSF    03.6
0C6A:  MOVWF  50
0C6B:  BCF    0A.3
0C6C:  BCF    03.6
0C6D:  CALL   131
0C6E:  BSF    0A.3
....................          STRCAT (TEMP_CHAR3, TEMP_CHAR2); 
0C6F:  BSF    03.6
0C70:  CLRF   4E
0C71:  MOVLW  EC
0C72:  MOVWF  4D
0C73:  CLRF   50
0C74:  MOVLW  E8
0C75:  MOVWF  4F
0C76:  BCF    0A.3
0C77:  BCF    03.6
0C78:  CALL   6B9
0C79:  BSF    0A.3
....................       } 
0C7A:  BSF    03.6
0C7B:  INCF   4C,F
0C7C:  GOTO   44A
....................    } 
....................  
....................    //PACKAGE_CONFIG[7] = TEMP_CHAR3; 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0BB2:  BCF    5F.2
....................    TT_STT = 0; 
0BB3:  BCF    5F.3
....................    PACKAGE_CONFIG[1] = ID_GW; 
0BB4:  BSF    03.5
0BB5:  CLRF   59
0BB6:  MOVLW  6E
0BB7:  MOVWF  58
....................    DELAY_MS (2); 
0BB8:  MOVLW  02
0BB9:  BCF    03.5
0BBA:  BSF    03.6
0BBB:  MOVWF  50
0BBC:  BCF    0A.3
0BBD:  BCF    03.6
0BBE:  CALL   131
0BBF:  BSF    0A.3
....................    PACKAGE_CONFIG[2] = ID_; 
0BC0:  BSF    03.5
0BC1:  CLRF   5B
0BC2:  MOVLW  6A
0BC3:  MOVWF  5A
....................    DELAY_MS (2); 
0BC4:  MOVLW  02
0BC5:  BCF    03.5
0BC6:  BSF    03.6
0BC7:  MOVWF  50
0BC8:  BCF    0A.3
0BC9:  BCF    03.6
0BCA:  CALL   131
0BCB:  BSF    0A.3
....................    TT_DEVICE_CHAR = ""; 
0BCC:  BSF    03.6
0BCD:  CLRF   4C
0BCE:  CLRF   4D
0BCF:  MOVLW  62
0BD0:  MOVWF  04
0BD1:  BCF    03.7
0BD2:  MOVF   4C,W
0BD3:  ADDWF  04,F
0BD4:  MOVF   4D,W
0BD5:  BCF    0A.3
0BD6:  BCF    03.6
0BD7:  CALL   064
0BD8:  BSF    0A.3
0BD9:  MOVWF  00
0BDA:  IORLW  00
0BDB:  BTFSC  03.2
0BDC:  GOTO   3E2
0BDD:  BSF    03.6
0BDE:  INCF   4D,F
0BDF:  INCF   4C,F
0BE0:  GOTO   3CF
0BE1:  BCF    03.6
....................    TT_SENSOR_CHAR = ""; 
0BE2:  BSF    03.6
0BE3:  CLRF   4C
0BE4:  CLRF   4D
0BE5:  MOVLW  66
0BE6:  MOVWF  04
0BE7:  BCF    03.7
0BE8:  MOVF   4C,W
0BE9:  ADDWF  04,F
0BEA:  MOVF   4D,W
0BEB:  BCF    0A.3
0BEC:  BCF    03.6
0BED:  CALL   064
0BEE:  BSF    0A.3
0BEF:  MOVWF  00
0BF0:  IORLW  00
0BF1:  BTFSC  03.2
0BF2:  GOTO   3F8
0BF3:  BSF    03.6
0BF4:  INCF   4D,F
0BF5:  INCF   4C,F
0BF6:  GOTO   3E5
0BF7:  BCF    03.6
....................    XULYDEVICE_CF (); 
....................    XULYSENSOR_CF (); 
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
*
0C7D:  BSF    03.5
0C7E:  BCF    03.6
0C7F:  CLRF   61
0C80:  MOVLW  62
0C81:  MOVWF  60
....................    DELAY_MS (2); 
0C82:  MOVLW  02
0C83:  BCF    03.5
0C84:  BSF    03.6
0C85:  MOVWF  50
0C86:  BCF    0A.3
0C87:  BCF    03.6
0C88:  CALL   131
0C89:  BSF    0A.3
....................    PACKAGE_CONFIG[6] = TEMP_CHAR3; 
0C8A:  BSF    03.5
0C8B:  CLRF   63
0C8C:  MOVLW  EC
0C8D:  MOVWF  62
....................    //TINH DO DAI --> 
....................    LEN_PACKAGES = 0; 
0C8E:  BCF    03.5
0C8F:  BSF    03.6
0C90:  CLRF   43
....................    PACKAGE_CONFIG[3] = "12"; //DO DAI CUA LENGHT C  DAI = 2 
0C91:  MOVLW  31
0C92:  BSF    03.5
0C93:  BCF    03.6
0C94:  MOVWF  5C
0C95:  MOVLW  32
0C96:  MOVWF  5D
....................    FOR (INT J = 0; J < 9; J++) 
0C97:  BCF    03.5
0C98:  BSF    03.6
0C99:  CLRF   4B
0C9A:  MOVF   4B,W
0C9B:  SUBLW  08
0C9C:  BTFSS  03.0
0C9D:  GOTO   4CE
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
0C9E:  BCF    03.0
0C9F:  RLF    4B,W
0CA0:  ADDLW  D6
0CA1:  MOVWF  04
0CA2:  BCF    03.7
0CA3:  INCF   04,F
0CA4:  MOVF   00,W
0CA5:  MOVWF  4D
0CA6:  DECF   04,F
0CA7:  MOVF   00,W
0CA8:  MOVWF  4C
0CA9:  MOVF   4D,W
0CAA:  MOVWF  4F
0CAB:  MOVF   4C,W
0CAC:  MOVWF  4E
*
0CCA:  MOVF   78,W
0CCB:  ADDWF  43,F
0CCC:  INCF   4B,F
0CCD:  GOTO   49A
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+6; //7 @ 
0CCE:  MOVLW  06
0CCF:  ADDWF  43,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0CD0:  CLRF   50
0CD1:  CLRF   4F
0CD2:  CLRF   4E
0CD3:  MOVF   43,W
0CD4:  MOVWF  4D
0CD5:  MOVLW  0A
0CD6:  MOVWF  51
0CD7:  CLRF   53
0CD8:  MOVLW  75
0CD9:  MOVWF  52
0CDA:  BCF    0A.3
0CDB:  BCF    03.6
0CDC:  CALL   541
0CDD:  BSF    0A.3
....................    PACKAGE_CONFIG[3] = TEMP_CHAR; 
0CDE:  BSF    03.5
0CDF:  CLRF   5D
0CE0:  MOVLW  75
0CE1:  MOVWF  5C
....................     
....................    FOR ( J = 0; J < 8; J++) 
0CE2:  BCF    03.5
0CE3:  BSF    03.6
0CE4:  CLRF   4B
0CE5:  MOVF   4B,W
0CE6:  SUBLW  07
0CE7:  BTFSS  03.0
0CE8:  GOTO   503
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0CE9:  BCF    03.0
0CEA:  RLF    4B,W
0CEB:  ADDLW  D6
0CEC:  MOVWF  04
0CED:  BCF    03.7
0CEE:  INCF   04,F
0CEF:  MOVF   00,W
0CF0:  MOVWF  4D
0CF1:  DECF   04,F
0CF2:  MOVF   00,W
0CF3:  MOVWF  4C
0CF4:  MOVWF  04
0CF5:  BCF    03.7
0CF6:  BTFSC  4D.0
0CF7:  BSF    03.7
0CF8:  BCF    0A.3
0CF9:  BCF    03.6
0CFA:  CALL   785
0CFB:  BSF    0A.3
....................       PRINTF ("@"); 
0CFC:  MOVLW  40
0CFD:  BTFSS  0C.4
0CFE:  GOTO   4FD
0CFF:  MOVWF  19
0D00:  BSF    03.6
0D01:  INCF   4B,F
0D02:  GOTO   4E5
....................    } 
....................  
....................    /* 
....................    LCD_GOTOXY (1, 1) ; 
....................    DELAY_MS (10); 
....................    FOR (J = 0; J < 9; J++) 
....................    { 
....................       PRINTF (LCD_PUTC, PACKAGE_CONFIG[J]); 
....................    } 
....................    */ 
....................  
....................    LCD_GOTOXY (1, 1) ; 
0D03:  MOVLW  01
0D04:  MOVWF  50
0D05:  MOVWF  51
0D06:  BCF    0A.3
0D07:  BCF    03.6
0D08:  CALL   405
0D09:  BSF    0A.3
....................    DELAY_MS (10); 
0D0A:  MOVLW  0A
0D0B:  BSF    03.6
0D0C:  MOVWF  50
0D0D:  BCF    0A.3
0D0E:  BCF    03.6
0D0F:  CALL   131
0D10:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0D11:  MOVLW  C8
0D12:  BSF    03.6
0D13:  MOVWF  0D
0D14:  MOVLW  00
0D15:  MOVWF  0F
0D16:  BCF    0A.3
0D17:  BCF    03.6
0D18:  CALL   453
0D19:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0D1A:  MOVLW  01
0D1B:  BSF    03.6
0D1C:  MOVWF  50
0D1D:  MOVLW  02
0D1E:  MOVWF  51
0D1F:  BCF    0A.3
0D20:  BCF    03.6
0D21:  CALL   405
0D22:  BSF    0A.3
....................    DELAY_MS (10); 
0D23:  MOVLW  0A
0D24:  BSF    03.6
0D25:  MOVWF  50
0D26:  BCF    0A.3
0D27:  BCF    03.6
0D28:  CALL   131
0D29:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0D2A:  MOVLW  D2
0D2B:  BSF    03.6
0D2C:  MOVWF  0D
0D2D:  MOVLW  00
0D2E:  MOVWF  0F
0D2F:  BCF    0A.3
0D30:  BCF    03.6
0D31:  CALL   453
0D32:  BSF    0A.3
....................    PACKAGE_NHIETDO[1] = ID_; 
0D33:  BSF    03.5
0D34:  CLRF   23
0D35:  MOVLW  6A
0D36:  MOVWF  22
....................    TT_CONFIG_DONE = 0; 
0D37:  BCF    03.5
0D38:  BCF    5F.1
0D39:  BSF    0A.3
0D3A:  BCF    0A.4
0D3B:  GOTO   6DE (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID QUET_PHIM() 
*
00DC:  BSF    03.5
00DD:  BSF    03.6
00DE:  CLRF   16
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00DF:  BCF    03.6
00E0:  BSF    06.1
00E1:  BCF    03.5
00E2:  BTFSC  06.1
00E3:  GOTO   0FB
....................    { 
....................       IF (TMR1IF) 
00E4:  BTFSS  0C.0
00E5:  GOTO   0F6
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00E6:  BSF    03.5
00E7:  BCF    08.2
00E8:  MOVLW  04
00E9:  BCF    03.5
00EA:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00EB:  BCF    0C.0
00EC:  CLRF   0E
00ED:  MOVLW  0B
00EE:  MOVWF  0F
00EF:  MOVLW  DC
00F0:  MOVWF  0E
00F1:  BSF    03.5
00F2:  BSF    03.6
00F3:  INCF   16,F
00F4:  BCF    03.5
00F5:  BCF    03.6
....................       } 
00F6:  BSF    03.5
00F7:  BSF    03.6
00F8:  GOTO   0DF
00F9:  BCF    03.5
00FA:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00FB:  BSF    03.5
00FC:  BSF    03.6
00FD:  MOVF   16,W
00FE:  SUBLW  14
00FF:  BTFSC  03.0
0100:  GOTO   10A
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0101:  MOVLW  01
0102:  BCF    03.5
0103:  BCF    03.6
0104:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0105:  BSF    5F.1
....................       TT_FUN = 0; 
0106:  BCF    5F.2
....................    } 
0107:  GOTO   10F
0108:  BSF    03.5
0109:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
010F:  BCF    0B.1
0110:  BCF    0A.3
0111:  BCF    0A.4
0112:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTU[VT] = GETCH (); 
0113:  MOVLW  3C
0114:  ADDWF  5A,W
0115:  MOVWF  04
0116:  BCF    03.7
0117:  BTFSS  0C.5
0118:  GOTO   117
0119:  MOVF   1A,W
011A:  MOVWF  00
....................  
....................     IF (KYTU[VT] == '.') 
011B:  MOVLW  3C
011C:  ADDWF  5A,W
011D:  MOVWF  04
011E:  BCF    03.7
011F:  MOVF   00,W
0120:  SUBLW  2E
0121:  BTFSS  03.2
0122:  GOTO   12C
....................     { 
....................        KYTU[VT] = '\0'; 
0123:  MOVLW  3C
0124:  ADDWF  5A,W
0125:  MOVWF  04
0126:  BCF    03.7
0127:  CLRF   00
....................        VT = 0; 
0128:  CLRF   5A
....................        TTNHAN = 1; 
0129:  MOVLW  01
012A:  MOVWF  5B
....................     } 
012B:  GOTO   12D
....................  
....................     ELSE 
....................     VT++; 
012C:  INCF   5A,F
012D:  BCF    0C.5
012E:  BCF    0A.3
012F:  BCF    0A.4
0130:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07BB:  MOVLW  01
07BC:  BSF    03.6
07BD:  MOVWF  50
07BE:  MOVWF  51
07BF:  BCF    03.6
07C0:  CALL   405
....................     DELAY_MS (10); 
07C1:  MOVLW  0A
07C2:  BSF    03.6
07C3:  MOVWF  50
07C4:  BCF    03.6
07C5:  CALL   131
....................     PRINTF (LCD_PUTC, KYTU); 
07C6:  MOVLW  3C
07C7:  MOVWF  04
07C8:  BCF    03.7
07C9:  CALL   661
....................     DELAY_MS (1); 
07CA:  MOVLW  01
07CB:  BSF    03.6
07CC:  MOVWF  50
07CD:  BCF    03.6
07CE:  CALL   131
07CF:  BSF    0A.3
07D0:  BCF    0A.4
07D1:  GOTO   75F (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
02B1:  BSF    03.6
02B2:  RLF    4B,W
02B3:  MOVWF  77
02B4:  RLF    77,F
02B5:  MOVLW  FC
02B6:  ANDWF  77,F
02B7:  BCF    03.6
02B8:  MOVF   1F,W
02B9:  ANDLW  C3
02BA:  IORWF  77,W
02BB:  MOVWF  1F
....................     KQADC = 0; 
02BC:  CLRF   33
02BD:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
02BE:  BSF    03.6
02BF:  CLRF   4C
02C0:  MOVF   4C,W
02C1:  SUBLW  63
02C2:  BTFSS  03.0
02C3:  GOTO   2D8
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
02C4:  BCF    03.6
02C5:  BSF    1F.1
02C6:  BTFSC  1F.1
02C7:  GOTO   2C6
02C8:  BSF    03.5
02C9:  MOVF   1E,W
02CA:  BCF    03.5
02CB:  ADDWF  32,F
02CC:  MOVF   1E,W
02CD:  BTFSC  03.0
02CE:  INCFSZ 1E,W
02CF:  ADDWF  33,F
....................        DELAY_MS (1); 
02D0:  MOVLW  01
02D1:  BSF    03.6
02D2:  MOVWF  50
02D3:  BCF    03.6
02D4:  CALL   131
02D5:  BSF    03.6
02D6:  INCF   4C,F
02D7:  GOTO   2C0
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
02D8:  BCF    03.6
02D9:  MOVF   33,W
02DA:  BSF    03.6
02DB:  MOVWF  4E
02DC:  BCF    03.6
02DD:  MOVF   32,W
02DE:  BSF    03.6
02DF:  MOVWF  4D
*
02FC:  MOVF   7A,W
02FD:  MOVWF  50
02FE:  MOVF   79,W
02FF:  MOVWF  4F
0300:  MOVF   78,W
0301:  MOVWF  4E
0302:  MOVF   77,W
0303:  MOVWF  4D
0304:  MOVLW  9A
0305:  MOVWF  54
0306:  MOVLW  99
0307:  MOVWF  53
0308:  MOVLW  4C
0309:  MOVWF  52
030A:  MOVLW  86
030B:  MOVWF  51
*
03D5:  MOVF   7A,W
03D6:  MOVWF  50
03D7:  MOVF   79,W
03D8:  MOVWF  4F
03D9:  MOVF   78,W
03DA:  MOVWF  4E
03DB:  MOVF   77,W
03DC:  MOVWF  4D
*
03FB:  MOVF   79,W
03FC:  BCF    03.6
03FD:  MOVWF  33
03FE:  MOVF   78,W
03FF:  MOVWF  32
....................     RETURN KQADC; 
0400:  MOVF   32,W
0401:  MOVWF  78
0402:  BSF    0A.3
0403:  BCF    0A.4
0404:  GOTO   6D1 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07A3:  BSF    03.6
07A4:  CLRF   4B
07A5:  MOVF   4B,W
07A6:  SUBLW  1E
07A7:  BTFSS  03.0
07A8:  GOTO   7B7
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07A9:  BSF    03.5
07AA:  BCF    03.6
07AB:  BCF    08.1
07AC:  MOVLW  02
07AD:  BCF    03.5
07AE:  XORWF  08,F
....................        DELAY_MS (100); 
07AF:  MOVLW  64
07B0:  BSF    03.6
07B1:  MOVWF  50
07B2:  BCF    03.6
07B3:  CALL   131
07B4:  BSF    03.6
07B5:  INCF   4B,F
07B6:  GOTO   7A5
....................     } 
07B7:  BCF    03.6
07B8:  BSF    0A.3
07B9:  BCF    0A.4
07BA:  GOTO   6E3 (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
0D3C:  MOVF   03,W
0D3D:  ANDLW  1F
0D3E:  MOVWF  03
0D3F:  BSF    03.5
0D40:  BSF    03.6
0D41:  BSF    07.3
0D42:  MOVLW  08
0D43:  BCF    03.6
0D44:  MOVWF  19
0D45:  MOVLW  02
0D46:  MOVWF  1A
0D47:  MOVLW  A6
0D48:  MOVWF  18
0D49:  MOVLW  90
0D4A:  BCF    03.5
0D4B:  MOVWF  18
0D4C:  MOVLW  FF
0D4D:  MOVWF  31
0D4E:  CLRF   38
0D4F:  CLRF   39
0D50:  CLRF   3A
0D51:  CLRF   3B
0D52:  CLRF   5A
0D53:  CLRF   5B
0D54:  BCF    5F.0
0D55:  BCF    5F.1
0D56:  BCF    5F.2
0D57:  BCF    5F.3
0D58:  BSF    03.6
0D59:  CLRF   43
0D5A:  BSF    03.5
0D5B:  MOVF   09,W
0D5C:  ANDLW  C0
0D5D:  MOVWF  09
0D5E:  BCF    03.6
0D5F:  BCF    1F.4
0D60:  BCF    1F.5
0D61:  MOVLW  00
0D62:  BSF    03.6
0D63:  MOVWF  08
0D64:  BCF    03.5
0D65:  CLRF   07
0D66:  CLRF   08
0D67:  CLRF   09
0D68:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0E8F:  MOVLW  00
0E90:  BSF    03.5
0E91:  BCF    03.6
0E92:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0E93:  MOVLW  FF
0E94:  MOVWF  06
....................     SET_TRIS_E (0); 
0E95:  BCF    09.0
0E96:  BCF    09.1
0E97:  BCF    09.2
0E98:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0E99:  MOVLW  80
0E9A:  MOVWF  07
0E9B:  BCF    03.5
0E9C:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0E9D:  BSF    1F.6
0E9E:  BCF    1F.7
0E9F:  BSF    03.5
0EA0:  BSF    1F.7
0EA1:  BCF    03.5
0EA2:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0EA3:  BSF    03.5
0EA4:  BSF    03.6
0EA5:  MOVF   09,W
0EA6:  ANDLW  C0
0EA7:  MOVWF  09
0EA8:  BCF    03.6
0EA9:  BCF    1F.4
0EAA:  BCF    1F.5
0EAB:  MOVLW  01
0EAC:  BSF    03.6
0EAD:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0EAE:  BCF    03.5
0EAF:  BCF    03.6
0EB0:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0EB1:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0EB2:  BSF    0B.4
0EB3:  BSF    03.5
0EB4:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0EB5:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0EB6:  MOVLW  C0
0EB7:  BCF    03.5
0EB8:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0EB9:  MOVLW  35
0EBA:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0EBB:  CLRF   0E
0EBC:  MOVLW  0B
0EBD:  MOVWF  0F
0EBE:  MOVLW  DC
0EBF:  MOVWF  0E
....................     TMR1IF = 0; 
0EC0:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0EC1:  BCF    0A.3
0EC2:  GOTO   24B
0EC3:  BSF    0A.3
....................     ID_NODE = 0; 
0EC4:  CLRF   39
....................     TT_CONFIG = 0; 
0EC5:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0EC6:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0EC7:  BSF    03.5
0EC8:  CLRF   08
0EC9:  BCF    03.5
0ECA:  CLRF   08
....................     TTNHAN = 0;     
0ECB:  CLRF   5B
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0ECC:  BSF    03.6
0ECD:  CLRF   4B
0ECE:  BCF    0A.3
0ECF:  BCF    03.6
0ED0:  GOTO   2B1
0ED1:  BSF    0A.3
0ED2:  CLRF   35
0ED3:  MOVF   78,W
0ED4:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0ED5:  BTFSS  5F.0
0ED6:  GOTO   6DB
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0ED7:  BCF    0A.3
0ED8:  GOTO   6F7
0ED9:  BSF    0A.3
....................        } 
0EDA:  GOTO   782
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0EDB:  BTFSS  5F.1
0EDC:  GOTO   6DF
....................        { 
....................           CONFIG_DONE (); 
0EDD:  GOTO   3B2
....................        } 
0EDE:  GOTO   782
....................  
....................         
....................        ELSE 
....................        { 
....................  
....................           WHILE ( ! TT_CONFIG) 
0EDF:  BTFSC  5F.0
0EE0:  GOTO   782
....................           { 
....................              CHUONG_TRINH_CON (); 
0EE1:  BCF    0A.3
0EE2:  GOTO   7A3
0EE3:  BSF    0A.3
....................  
....................              IF (AN0 > 26) 
0EE4:  MOVF   35,F
0EE5:  BTFSS  03.2
0EE6:  GOTO   6EB
0EE7:  MOVF   34,W
0EE8:  SUBLW  1A
0EE9:  BTFSC  03.0
0EEA:  GOTO   750
....................              { 
....................                 ITOA (AN0, 10, NHIETDO1); 
0EEB:  BSF    03.6
0EEC:  CLRF   50
0EED:  CLRF   4F
0EEE:  BCF    03.6
0EEF:  MOVF   35,W
0EF0:  BSF    03.6
0EF1:  MOVWF  4E
0EF2:  BCF    03.6
0EF3:  MOVF   34,W
0EF4:  BSF    03.6
0EF5:  MOVWF  4D
0EF6:  MOVLW  0A
0EF7:  MOVWF  51
0EF8:  MOVLW  01
0EF9:  MOVWF  53
0EFA:  MOVLW  44
0EFB:  MOVWF  52
0EFC:  BCF    0A.3
0EFD:  BCF    03.6
0EFE:  CALL   541
0EFF:  BSF    0A.3
....................                 PACKAGE_NHIETDO[4] = NHIETDO1; 
0F00:  MOVLW  01
0F01:  BSF    03.5
0F02:  MOVWF  29
0F03:  MOVLW  44
0F04:  MOVWF  28
....................                 ITOA (AN1, 10, NHIETDO2); 
0F05:  BCF    03.5
0F06:  BSF    03.6
0F07:  CLRF   50
0F08:  CLRF   4F
0F09:  BCF    03.6
0F0A:  MOVF   37,W
0F0B:  BSF    03.6
0F0C:  MOVWF  4E
0F0D:  BCF    03.6
0F0E:  MOVF   36,W
0F0F:  BSF    03.6
0F10:  MOVWF  4D
0F11:  MOVLW  0A
0F12:  MOVWF  51
0F13:  MOVLW  01
0F14:  MOVWF  53
0F15:  MOVLW  47
0F16:  MOVWF  52
0F17:  BCF    0A.3
0F18:  BCF    03.6
0F19:  CALL   541
0F1A:  BSF    0A.3
....................                 PACKAGE_NHIETDO[5] = NHIETDO2; 
0F1B:  MOVLW  01
0F1C:  BSF    03.5
0F1D:  MOVWF  2B
0F1E:  MOVLW  47
0F1F:  MOVWF  2A
....................                  
....................                 FOR (INT I = 0; I < 8; I++) 
0F20:  BCF    03.5
0F21:  BSF    03.6
0F22:  CLRF   4A
0F23:  MOVF   4A,W
0F24:  SUBLW  07
0F25:  BTFSS  03.0
0F26:  GOTO   744
....................                 { 
....................                    PRINTF (PACKAGE_NHIETDO[I]); 
0F27:  BCF    03.0
0F28:  RLF    4A,W
0F29:  ADDLW  A0
0F2A:  MOVWF  04
0F2B:  BCF    03.7
0F2C:  INCF   04,F
0F2D:  MOVF   00,W
0F2E:  MOVWF  4C
0F2F:  DECF   04,F
0F30:  MOVF   00,W
0F31:  MOVWF  4B
0F32:  MOVWF  04
0F33:  BCF    03.7
0F34:  BTFSC  4C.0
0F35:  BSF    03.7
0F36:  BCF    0A.3
0F37:  BCF    03.6
0F38:  CALL   785
0F39:  BSF    0A.3
....................                    DELAY_MS (1); 
0F3A:  MOVLW  01
0F3B:  BSF    03.6
0F3C:  MOVWF  50
0F3D:  BCF    0A.3
0F3E:  BCF    03.6
0F3F:  CALL   131
0F40:  BSF    0A.3
0F41:  BSF    03.6
0F42:  INCF   4A,F
0F43:  GOTO   723
....................                 } 
....................  
....................                  
....................                 DELAY_MS (1000); 
0F44:  MOVLW  04
0F45:  MOVWF  4B
0F46:  MOVLW  FA
0F47:  MOVWF  50
0F48:  BCF    0A.3
0F49:  BCF    03.6
0F4A:  CALL   131
0F4B:  BSF    0A.3
0F4C:  BSF    03.6
0F4D:  DECFSZ 4B,F
0F4E:  GOTO   746
0F4F:  BCF    03.6
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
0F50:  DECFSZ 5B,W
0F51:  GOTO   781
....................              { 
....................                 TTNHAN = 0; 
0F52:  CLRF   5B
....................                 //TEMP_CHAR = 'K'; 
....................                 ID_NODE_NHAN = KYTU[1] - 48; 
0F53:  MOVLW  30
0F54:  SUBWF  3D,W
0F55:  MOVWF  5C
....................                 ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
0F56:  MOVLW  30
0F57:  SUBWF  3E,W
0F58:  ADDLW  40
0F59:  MOVWF  5D
....................                 TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
0F5A:  MOVLW  30
0F5B:  SUBWF  3F,W
0F5C:  MOVWF  5E
....................                 XUATLCD (); 
0F5D:  BCF    0A.3
0F5E:  GOTO   7BB
0F5F:  BSF    0A.3
....................                  
....................                 IF (ID_NODE_NHAN == ID_NODE) 
0F60:  MOVF   39,W
0F61:  SUBWF  5C,W
0F62:  BTFSS  03.2
0F63:  GOTO   781
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0F64:  MOVF   5E,F
0F65:  BTFSS  03.2
0F66:  GOTO   769
0F67:  MOVLW  00
0F68:  GOTO   76A
0F69:  MOVLW  01
0F6A:  MOVWF  77
0F6B:  MOVF   5D,W
0F6C:  BSF    03.6
0F6D:  MOVWF  4C
0F6E:  MOVF   77,W
0F6F:  MOVWF  4D
0F70:  CLRF   4F
0F71:  CLRF   4E
0F72:  BCF    0A.3
0F73:  BCF    03.6
0F74:  CALL   697
0F75:  BSF    0A.3
0F76:  MOVF   5D,W
0F77:  BSF    03.6
0F78:  MOVWF  4C
0F79:  CLRF   4D
0F7A:  CLRF   4F
0F7B:  MOVLW  80
0F7C:  MOVWF  4E
0F7D:  BCF    0A.3
0F7E:  BCF    03.6
0F7F:  CALL   697
0F80:  BSF    0A.3
....................                 } 
....................              } 
0F81:  GOTO   6DF
....................           } 
....................        } 
0F82:  GOTO   6CC
....................     } 
....................  } 
....................  
0F83:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
