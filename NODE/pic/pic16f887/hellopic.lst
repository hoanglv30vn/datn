CCS PCM C Compiler, Version 5.015, 5967               20-Oct-21 01:22

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3465 words (42%)
                           Largest free fragment is 2048
               RAM used:   206 (56%) at main() level
                           246 (67%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   3F6
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0B6
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0E5
....................  
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  2A
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  40
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 00,00
0072:  DATA C4,22
0073:  DATA D6,24
0074:  DATA C3,22
0075:  DATA 3A,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA D3,22
007C:  DATA CE,29
007D:  DATA 4F,29
007E:  DATA 3A,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 00,01
0084:  DATA C3,27
0085:  DATA 4E,23
0086:  DATA C9,23
0087:  DATA 3A,10
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 20,10
008C:  DATA 00,01
008D:  DATA C3,20
008E:  DATA D3,22
008F:  DATA 3A,10
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 00,01
0096:  DATA 2D,10
0097:  DATA 49,22
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 20,00
009B:  DATA 2D,10
009C:  DATA C4,22
009D:  DATA D6,24
009E:  DATA C3,22
009F:  DATA 53,00
00A0:  DATA 2D,10
00A1:  DATA D3,22
00A2:  DATA CE,29
00A3:  DATA 4F,29
00A4:  DATA 53,00
00A5:  DATA 2D,10
00A6:  DATA D2,22
00A7:  DATA D3,22
00A8:  DATA 54,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 20,22
00AE:  DATA 4F,27
00AF:  DATA 45,00
00B0:  DATA C3,27
00B1:  DATA 4E,23
00B2:  DATA C9,23
00B3:  DATA 20,22
00B4:  DATA 4F,27
00B5:  DATA 45,00
*
02B2:  MOVLW  8E
02B3:  MOVWF  77
02B4:  MOVF   40,W
02B5:  MOVWF  78
02B6:  MOVF   3F,W
02B7:  MOVWF  79
02B8:  CLRF   7A
02B9:  MOVF   78,F
02BA:  BTFSS  03.2
02BB:  GOTO   2C6
02BC:  MOVF   79,W
02BD:  MOVWF  78
02BE:  CLRF   79
02BF:  MOVLW  08
02C0:  SUBWF  77,F
02C1:  MOVF   78,F
02C2:  BTFSS  03.2
02C3:  GOTO   2C6
02C4:  CLRF   77
02C5:  GOTO   2CE
02C6:  BCF    03.0
02C7:  BTFSC  78.7
02C8:  GOTO   2CD
02C9:  RLF    79,F
02CA:  RLF    78,F
02CB:  DECF   77,F
02CC:  GOTO   2C6
02CD:  BCF    78.7
*
02DE:  MOVF   3F,W
02DF:  BTFSC  03.2
02E0:  GOTO   3A3
02E1:  MOVWF  4B
02E2:  MOVF   43,W
02E3:  BTFSC  03.2
02E4:  GOTO   3A3
02E5:  SUBWF  4B,F
02E6:  BTFSS  03.0
02E7:  GOTO   2ED
02E8:  MOVLW  7F
02E9:  ADDWF  4B,F
02EA:  BTFSC  03.0
02EB:  GOTO   3A3
02EC:  GOTO   2F3
02ED:  MOVLW  81
02EE:  SUBWF  4B,F
02EF:  BTFSS  03.0
02F0:  GOTO   3A3
02F1:  BTFSC  03.2
02F2:  GOTO   3A3
02F3:  MOVF   4B,W
02F4:  MOVWF  77
02F5:  CLRF   78
02F6:  CLRF   79
02F7:  CLRF   7A
02F8:  CLRF   4A
02F9:  MOVF   40,W
02FA:  MOVWF  49
02FB:  BSF    49.7
02FC:  MOVF   41,W
02FD:  MOVWF  48
02FE:  MOVF   42,W
02FF:  MOVWF  47
0300:  MOVLW  19
0301:  MOVWF  4B
0302:  MOVF   46,W
0303:  SUBWF  47,F
0304:  BTFSC  03.0
0305:  GOTO   316
0306:  MOVLW  01
0307:  SUBWF  48,F
0308:  BTFSC  03.0
0309:  GOTO   316
030A:  SUBWF  49,F
030B:  BTFSC  03.0
030C:  GOTO   316
030D:  SUBWF  4A,F
030E:  BTFSC  03.0
030F:  GOTO   316
0310:  INCF   4A,F
0311:  INCF   49,F
0312:  INCF   48,F
0313:  MOVF   46,W
0314:  ADDWF  47,F
0315:  GOTO   348
0316:  MOVF   45,W
0317:  SUBWF  48,F
0318:  BTFSC  03.0
0319:  GOTO   331
031A:  MOVLW  01
031B:  SUBWF  49,F
031C:  BTFSC  03.0
031D:  GOTO   331
031E:  SUBWF  4A,F
031F:  BTFSC  03.0
0320:  GOTO   331
0321:  INCF   4A,F
0322:  INCF   49,F
0323:  MOVF   45,W
0324:  ADDWF  48,F
0325:  MOVF   46,W
0326:  ADDWF  47,F
0327:  BTFSS  03.0
0328:  GOTO   348
0329:  INCF   48,F
032A:  BTFSS  03.2
032B:  GOTO   348
032C:  INCF   49,F
032D:  BTFSS  03.2
032E:  GOTO   348
032F:  INCF   4A,F
0330:  GOTO   348
0331:  MOVF   44,W
0332:  IORLW  80
0333:  SUBWF  49,F
0334:  BTFSC  03.0
0335:  GOTO   347
0336:  MOVLW  01
0337:  SUBWF  4A,F
0338:  BTFSC  03.0
0339:  GOTO   347
033A:  INCF   4A,F
033B:  MOVF   44,W
033C:  IORLW  80
033D:  ADDWF  49,F
033E:  MOVF   45,W
033F:  ADDWF  48,F
0340:  BTFSS  03.0
0341:  GOTO   325
0342:  INCF   49,F
0343:  BTFSS  03.2
0344:  GOTO   325
0345:  INCF   4A,F
0346:  GOTO   325
0347:  BSF    7A.0
0348:  DECFSZ 4B,F
0349:  GOTO   34B
034A:  GOTO   356
034B:  BCF    03.0
034C:  RLF    47,F
034D:  RLF    48,F
034E:  RLF    49,F
034F:  RLF    4A,F
0350:  BCF    03.0
0351:  RLF    7A,F
0352:  RLF    79,F
0353:  RLF    78,F
0354:  RLF    4C,F
0355:  GOTO   302
0356:  BTFSS  4C.0
0357:  GOTO   35E
0358:  BCF    03.0
0359:  RRF    78,F
035A:  RRF    79,F
035B:  RRF    7A,F
035C:  RRF    4C,F
035D:  GOTO   361
035E:  DECF   77,F
035F:  BTFSC  03.2
0360:  GOTO   3A3
0361:  BTFSC  4C.7
0362:  GOTO   38A
0363:  BCF    03.0
0364:  RLF    47,F
0365:  RLF    48,F
0366:  RLF    49,F
0367:  RLF    4A,F
0368:  MOVF   46,W
0369:  SUBWF  47,F
036A:  BTFSC  03.0
036B:  GOTO   376
036C:  MOVLW  01
036D:  SUBWF  48,F
036E:  BTFSC  03.0
036F:  GOTO   376
0370:  SUBWF  49,F
0371:  BTFSC  03.0
0372:  GOTO   376
0373:  SUBWF  4A,F
0374:  BTFSS  03.0
0375:  GOTO   399
0376:  MOVF   45,W
0377:  SUBWF  48,F
0378:  BTFSC  03.0
0379:  GOTO   381
037A:  MOVLW  01
037B:  SUBWF  49,F
037C:  BTFSC  03.0
037D:  GOTO   381
037E:  SUBWF  4A,F
037F:  BTFSS  03.0
0380:  GOTO   399
0381:  MOVF   44,W
0382:  IORLW  80
0383:  SUBWF  49,F
0384:  BTFSC  03.0
0385:  GOTO   38A
0386:  MOVLW  01
0387:  SUBWF  4A,F
0388:  BTFSS  03.0
0389:  GOTO   399
038A:  INCF   7A,F
038B:  BTFSS  03.2
038C:  GOTO   399
038D:  INCF   79,F
038E:  BTFSS  03.2
038F:  GOTO   399
0390:  INCF   78,F
0391:  BTFSS  03.2
0392:  GOTO   399
0393:  INCF   77,F
0394:  BTFSC  03.2
0395:  GOTO   3A3
0396:  RRF    78,F
0397:  RRF    79,F
0398:  RRF    7A,F
0399:  MOVF   40,W
039A:  MOVWF  4B
039B:  MOVF   44,W
039C:  XORWF  4B,F
039D:  BTFSS  4B.7
039E:  GOTO   3A1
039F:  BSF    78.7
03A0:  GOTO   3A7
03A1:  BCF    78.7
03A2:  GOTO   3A7
03A3:  CLRF   77
03A4:  CLRF   78
03A5:  CLRF   79
03A6:  CLRF   7A
*
03AF:  MOVLW  8E
03B0:  MOVWF  77
03B1:  MOVF   3F,W
03B2:  SUBWF  77,F
03B3:  MOVF   40,W
03B4:  MOVWF  79
03B5:  MOVF   41,W
03B6:  MOVWF  78
03B7:  BSF    79.7
03B8:  MOVF   77,F
03B9:  BTFSC  03.2
03BA:  GOTO   3C6
03BB:  BCF    03.0
03BC:  MOVF   79,F
03BD:  BTFSS  03.2
03BE:  GOTO   3C2
03BF:  MOVF   78,F
03C0:  BTFSC  03.2
03C1:  GOTO   3C6
03C2:  RRF    79,F
03C3:  RRF    78,F
03C4:  DECFSZ 77,F
03C5:  GOTO   3BB
03C6:  BTFSS  40.7
03C7:  GOTO   3CD
03C8:  COMF   78,F
03C9:  COMF   79,F
03CA:  INCF   78,F
03CB:  BTFSC  03.2
03CC:  INCF   79,F
*
0425:  MOVF   0B,W
0426:  BSF    03.6
0427:  MOVWF  3E
0428:  BCF    03.6
0429:  BCF    0B.7
042A:  BSF    03.5
042B:  BSF    03.6
042C:  BSF    0C.7
042D:  BSF    0C.0
042E:  NOP
042F:  NOP
0430:  BCF    03.5
0431:  BTFSS  3E.7
0432:  GOTO   436
0433:  BCF    03.6
0434:  BSF    0B.7
0435:  BSF    03.6
0436:  MOVF   0C,W
0437:  ANDLW  7F
0438:  BTFSC  03.2
0439:  GOTO   473
043A:  MOVWF  3E
043B:  MOVF   0D,W
043C:  MOVWF  3F
043D:  MOVF   0F,W
043E:  MOVWF  40
043F:  MOVF   3E,W
0440:  MOVWF  41
0441:  BCF    03.6
0442:  CALL   3EB
0443:  BSF    03.6
0444:  MOVF   3F,W
0445:  MOVWF  0D
0446:  MOVF   40,W
0447:  MOVWF  0F
0448:  BCF    03.6
0449:  MOVF   0B,W
044A:  BSF    03.6
044B:  MOVWF  41
044C:  BCF    03.6
044D:  BCF    0B.7
044E:  BSF    03.5
044F:  BSF    03.6
0450:  BSF    0C.7
0451:  BSF    0C.0
0452:  NOP
0453:  NOP
0454:  BCF    03.5
0455:  BTFSS  41.7
0456:  GOTO   45A
0457:  BCF    03.6
0458:  BSF    0B.7
0459:  BSF    03.6
045A:  RLF    0C,W
045B:  RLF    0E,W
045C:  ANDLW  7F
045D:  BTFSC  03.2
045E:  GOTO   473
045F:  MOVWF  3E
0460:  MOVF   0D,W
0461:  MOVWF  3F
0462:  MOVF   0F,W
0463:  MOVWF  40
0464:  MOVF   3E,W
0465:  MOVWF  41
0466:  BCF    03.6
0467:  CALL   3EB
0468:  BSF    03.6
0469:  MOVF   3F,W
046A:  MOVWF  0D
046B:  MOVF   40,W
046C:  MOVWF  0F
046D:  INCF   0D,F
046E:  BTFSC  03.2
046F:  INCF   0F,F
0470:  BCF    03.6
0471:  GOTO   425
0472:  BSF    03.6
0473:  BCF    03.6
0474:  RETURN
0475:  BTFSC  03.1
0476:  GOTO   47A
0477:  MOVLW  5E
0478:  MOVWF  04
0479:  BSF    03.7
047A:  BSF    03.6
047B:  MOVF   59,W
047C:  XORWF  5D,W
047D:  ANDLW  80
047E:  MOVWF  63
047F:  BTFSS  59.7
0480:  GOTO   48C
0481:  COMF   56,F
0482:  COMF   57,F
0483:  COMF   58,F
0484:  COMF   59,F
0485:  INCF   56,F
0486:  BTFSC  03.2
0487:  INCF   57,F
0488:  BTFSC  03.2
0489:  INCF   58,F
048A:  BTFSC  03.2
048B:  INCF   59,F
048C:  BTFSS  5D.7
048D:  GOTO   499
048E:  COMF   5A,F
048F:  COMF   5B,F
0490:  COMF   5C,F
0491:  COMF   5D,F
0492:  INCF   5A,F
0493:  BTFSC  03.2
0494:  INCF   5B,F
0495:  BTFSC  03.2
0496:  INCF   5C,F
0497:  BTFSC  03.2
0498:  INCF   5D,F
0499:  CLRF   77
049A:  CLRF   78
049B:  CLRF   79
049C:  CLRF   7A
049D:  CLRF   5E
049E:  CLRF   5F
049F:  CLRF   60
04A0:  CLRF   61
04A1:  MOVF   5D,W
04A2:  IORWF  5C,W
04A3:  IORWF  5B,W
04A4:  IORWF  5A,W
04A5:  BTFSC  03.2
04A6:  GOTO   4D7
04A7:  MOVLW  20
04A8:  MOVWF  62
04A9:  BCF    03.0
04AA:  RLF    56,F
04AB:  RLF    57,F
04AC:  RLF    58,F
04AD:  RLF    59,F
04AE:  RLF    5E,F
04AF:  RLF    5F,F
04B0:  RLF    60,F
04B1:  RLF    61,F
04B2:  MOVF   5D,W
04B3:  SUBWF  61,W
04B4:  BTFSS  03.2
04B5:  GOTO   4C0
04B6:  MOVF   5C,W
04B7:  SUBWF  60,W
04B8:  BTFSS  03.2
04B9:  GOTO   4C0
04BA:  MOVF   5B,W
04BB:  SUBWF  5F,W
04BC:  BTFSS  03.2
04BD:  GOTO   4C0
04BE:  MOVF   5A,W
04BF:  SUBWF  5E,W
04C0:  BTFSS  03.0
04C1:  GOTO   4D1
04C2:  MOVF   5A,W
04C3:  SUBWF  5E,F
04C4:  MOVF   5B,W
04C5:  BTFSS  03.0
04C6:  INCFSZ 5B,W
04C7:  SUBWF  5F,F
04C8:  MOVF   5C,W
04C9:  BTFSS  03.0
04CA:  INCFSZ 5C,W
04CB:  SUBWF  60,F
04CC:  MOVF   5D,W
04CD:  BTFSS  03.0
04CE:  INCFSZ 5D,W
04CF:  SUBWF  61,F
04D0:  BSF    03.0
04D1:  RLF    77,F
04D2:  RLF    78,F
04D3:  RLF    79,F
04D4:  RLF    7A,F
04D5:  DECFSZ 62,F
04D6:  GOTO   4A9
04D7:  BTFSS  63.7
04D8:  GOTO   4E4
04D9:  COMF   77,F
04DA:  COMF   78,F
04DB:  COMF   79,F
04DC:  COMF   7A,F
04DD:  INCF   77,F
04DE:  BTFSC  03.2
04DF:  INCF   78,F
04E0:  BTFSC  03.2
04E1:  INCF   79,F
04E2:  BTFSC  03.2
04E3:  INCF   7A,F
04E4:  MOVF   5E,W
04E5:  MOVWF  00
04E6:  INCF   04,F
04E7:  MOVF   5F,W
04E8:  MOVWF  00
04E9:  INCF   04,F
04EA:  MOVF   60,W
04EB:  MOVWF  00
04EC:  INCF   04,F
04ED:  MOVF   61,W
04EE:  MOVWF  00
04EF:  BCF    03.6
04F0:  RETURN
*
050A:  MOVLW  20
050B:  MOVWF  5A
050C:  CLRF   56
050D:  CLRF   57
050E:  CLRF   58
050F:  CLRF   59
0510:  MOVF   51,W
0511:  MOVWF  7A
0512:  MOVF   50,W
0513:  MOVWF  79
0514:  MOVF   4F,W
0515:  MOVWF  78
0516:  MOVF   4E,W
0517:  MOVWF  77
0518:  BCF    03.0
0519:  BTFSS  77.0
051A:  GOTO   529
051B:  MOVF   52,W
051C:  ADDWF  56,F
051D:  MOVF   53,W
051E:  BTFSC  03.0
051F:  INCFSZ 53,W
0520:  ADDWF  57,F
0521:  MOVF   54,W
0522:  BTFSC  03.0
0523:  INCFSZ 54,W
0524:  ADDWF  58,F
0525:  MOVF   55,W
0526:  BTFSC  03.0
0527:  INCFSZ 55,W
0528:  ADDWF  59,F
0529:  RRF    59,F
052A:  RRF    58,F
052B:  RRF    57,F
052C:  RRF    56,F
052D:  RRF    7A,F
052E:  RRF    79,F
052F:  RRF    78,F
0530:  RRF    77,F
0531:  DECFSZ 5A,F
0532:  GOTO   518
*
0611:  MOVF   00,F
0612:  BTFSC  03.2
0613:  GOTO   62D
0614:  BSF    03.6
0615:  CLRF   3E
0616:  MOVF   04,W
0617:  MOVWF  3D
0618:  BCF    3E.0
0619:  BTFSC  03.7
061A:  BSF    3E.0
061B:  MOVF   00,W
061C:  MOVWF  41
061D:  BCF    03.6
061E:  CALL   3EB
061F:  BSF    03.6
0620:  MOVF   3D,W
0621:  MOVWF  04
0622:  BCF    03.7
0623:  BTFSC  3E.0
0624:  BSF    03.7
0625:  INCF   04,F
0626:  BTFSS  03.2
0627:  GOTO   62B
0628:  BCF    03.6
0629:  INCF   05,F
062A:  BSF    03.6
062B:  BCF    03.6
062C:  GOTO   611
062D:  RETURN
062E:  BSF    03.6
062F:  MOVF   3F,W
0630:  ANDLW  07
0631:  MOVWF  77
0632:  RRF    3F,W
0633:  MOVWF  78
0634:  RRF    78,F
0635:  RRF    78,F
0636:  MOVLW  1F
0637:  ANDWF  78,F
0638:  MOVF   78,W
0639:  ADDWF  40,W
063A:  MOVWF  04
063B:  BCF    03.7
063C:  BTFSC  41.0
063D:  BSF    03.7
063E:  MOVF   00,W
063F:  MOVWF  78
0640:  INCF   77,F
0641:  GOTO   643
0642:  RRF    78,F
0643:  DECFSZ 77,F
0644:  GOTO   642
0645:  BCF    03.6
0646:  RETURN
0647:  BSF    03.6
0648:  MOVF   3E,W
0649:  ANDLW  07
064A:  MOVWF  77
064B:  RRF    3E,W
064C:  MOVWF  78
064D:  RRF    78,F
064E:  RRF    78,F
064F:  MOVLW  1F
0650:  ANDWF  78,F
0651:  MOVF   78,W
0652:  ADDWF  40,W
0653:  MOVWF  04
0654:  BCF    03.7
0655:  BTFSC  41.0
0656:  BSF    03.7
0657:  CLRF   78
0658:  INCF   78,F
0659:  INCF   77,F
065A:  GOTO   65C
065B:  RLF    78,F
065C:  DECFSZ 77,F
065D:  GOTO   65B
065E:  MOVF   3F,F
065F:  BTFSC  03.2
0660:  GOTO   664
0661:  MOVF   78,W
0662:  IORWF  00,F
0663:  GOTO   667
0664:  COMF   78,F
0665:  MOVF   78,W
0666:  ANDWF  00,F
0667:  BCF    03.6
0668:  RETURN
*
06EF:  BCF    0A.0
06F0:  BSF    0A.1
06F1:  BSF    0A.2
06F2:  ADDWF  02,F
06F3:  GOTO   6C7
06F4:  GOTO   6CF
06F5:  GOTO   6D7
06F6:  GOTO   6DF
*
0735:  MOVF   00,F
0736:  BTFSC  03.2
0737:  GOTO   752
0738:  BSF    03.6
0739:  CLRF   41
073A:  MOVF   04,W
073B:  MOVWF  40
073C:  BCF    41.0
073D:  BTFSC  03.7
073E:  BSF    41.0
073F:  MOVF   00,W
0740:  BCF    03.6
0741:  BTFSS  0C.4
0742:  GOTO   741
0743:  MOVWF  19
0744:  BSF    03.6
0745:  MOVF   40,W
0746:  MOVWF  04
0747:  BCF    03.7
0748:  BTFSC  41.0
0749:  BSF    03.7
074A:  INCF   04,F
074B:  BTFSS  03.2
074C:  GOTO   750
074D:  BCF    03.6
074E:  INCF   05,F
074F:  BSF    03.6
0750:  BCF    03.6
0751:  GOTO   735
0752:  RETURN
*
0A83:  BCF    0A.0
0A84:  BSF    0A.1
0A85:  BCF    0A.2
0A86:  ADDWF  02,F
0A87:  GOTO   007
0A88:  GOTO   06E
0A89:  GOTO   176
0A8A:  GOTO   27E
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
06F7:  BSF    03.6
06F8:  MOVF   40,W
06F9:  MOVWF  44
06FA:  MOVF   3F,W
06FB:  MOVWF  43
06FC:  MOVF   44,W
06FD:  MOVWF  7A
06FE:  MOVF   43,W
06FF:  MOVWF  04
0700:  BCF    03.7
0701:  BTFSC  7A.0
0702:  BSF    03.7
0703:  MOVF   00,F
0704:  BTFSC  03.2
0705:  GOTO   70A
0706:  INCF   43,F
0707:  BTFSC  03.2
0708:  INCF   44,F
0709:  GOTO   6FC
....................    while(*s2 != '\0') 
070A:  MOVF   42,W
070B:  MOVWF  7A
070C:  MOVF   41,W
070D:  MOVWF  04
070E:  BCF    03.7
070F:  BTFSC  7A.0
0710:  BSF    03.7
0711:  MOVF   00,F
0712:  BTFSC  03.2
0713:  GOTO   729
....................    { 
....................       *s = *s2; 
0714:  MOVF   41,W
0715:  MOVWF  04
0716:  BCF    03.7
0717:  BTFSC  42.0
0718:  BSF    03.7
0719:  MOVF   00,W
071A:  MOVWF  47
071B:  MOVF   43,W
071C:  MOVWF  04
071D:  BCF    03.7
071E:  BTFSC  44.0
071F:  BSF    03.7
0720:  MOVF   47,W
0721:  MOVWF  00
....................       ++s; 
0722:  INCF   43,F
0723:  BTFSC  03.2
0724:  INCF   44,F
....................       ++s2; 
0725:  INCF   41,F
0726:  BTFSC  03.2
0727:  INCF   42,F
0728:  GOTO   70A
....................    } 
....................  
....................    *s = '\0'; 
0729:  MOVF   43,W
072A:  MOVWF  04
072B:  BCF    03.7
072C:  BTFSC  44.0
072D:  BSF    03.7
072E:  CLRF   00
....................    return(s1); 
072F:  MOVF   3F,W
0730:  MOVWF  78
0731:  MOVF   40,W
0732:  MOVWF  79
0733:  BCF    03.6
0734:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0C22:  BCF    03.6
0C23:  CLRF   2B
0C24:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04F1:  BSF    03.6
04F2:  CLRF   49
04F3:  CLRF   48
04F4:  CLRF   47
04F5:  MOVLW  01
04F6:  MOVWF  46
04F7:  CLRF   4B
04F8:  CLRF   4C
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04F9:  BTFSS  42.7
04FA:  GOTO   53B
....................          sign=1;        // Check for negative number 
04FB:  MOVLW  01
04FC:  MOVWF  4B
....................          num*=-1; 
04FD:  MOVF   42,W
04FE:  MOVWF  51
04FF:  MOVF   41,W
0500:  MOVWF  50
0501:  MOVF   40,W
0502:  MOVWF  4F
0503:  MOVF   3F,W
0504:  MOVWF  4E
0505:  MOVLW  FF
0506:  MOVWF  55
0507:  MOVWF  54
0508:  MOVWF  53
0509:  MOVWF  52
*
0533:  MOVF   7A,W
0534:  MOVWF  42
0535:  MOVF   79,W
0536:  MOVWF  41
0537:  MOVF   78,W
0538:  MOVWF  40
0539:  MOVF   77,W
053A:  MOVWF  3F
....................      } 
....................  
....................      while(temp>0) { 
053B:  MOVF   46,F
053C:  BTFSS  03.2
053D:  GOTO   547
053E:  MOVF   47,F
053F:  BTFSS  03.2
0540:  GOTO   547
0541:  MOVF   48,F
0542:  BTFSS  03.2
0543:  GOTO   547
0544:  MOVF   49,F
0545:  BTFSC  03.2
0546:  GOTO   5C3
....................          temp=(num/base); 
0547:  BCF    03.1
0548:  MOVF   42,W
0549:  MOVWF  59
054A:  MOVF   41,W
054B:  MOVWF  58
054C:  MOVF   40,W
054D:  MOVWF  57
054E:  MOVF   3F,W
054F:  MOVWF  56
0550:  CLRF   5D
0551:  CLRF   5C
0552:  CLRF   5B
0553:  MOVF   43,W
0554:  MOVWF  5A
0555:  BCF    03.6
0556:  CALL   475
0557:  MOVF   7A,W
0558:  BSF    03.6
0559:  MOVWF  49
055A:  MOVF   79,W
055B:  MOVWF  48
055C:  MOVF   78,W
055D:  MOVWF  47
055E:  MOVF   77,W
055F:  MOVWF  46
....................          s[cnt]=(num%base)+'0';    // Conversion 
0560:  MOVF   4C,W
0561:  ADDWF  44,W
0562:  MOVWF  78
0563:  MOVF   45,W
0564:  MOVWF  7A
0565:  BTFSC  03.0
0566:  INCF   7A,F
0567:  MOVF   78,W
0568:  MOVWF  4E
0569:  MOVF   7A,W
056A:  MOVWF  4F
056B:  CLRF   51
056C:  MOVF   04,W
056D:  MOVWF  50
056E:  BCF    51.0
056F:  BTFSC  03.7
0570:  BSF    51.0
0571:  BSF    03.1
0572:  MOVLW  52
0573:  MOVWF  04
0574:  BSF    03.7
0575:  MOVF   42,W
0576:  MOVWF  59
0577:  MOVF   41,W
0578:  MOVWF  58
0579:  MOVF   40,W
057A:  MOVWF  57
057B:  MOVF   3F,W
057C:  MOVWF  56
057D:  CLRF   5D
057E:  CLRF   5C
057F:  CLRF   5B
0580:  MOVF   43,W
0581:  MOVWF  5A
0582:  BCF    03.6
0583:  CALL   475
0584:  BSF    03.6
0585:  MOVF   50,W
0586:  MOVWF  04
0587:  BCF    03.7
0588:  BTFSC  51.0
0589:  BSF    03.7
058A:  MOVLW  30
058B:  ADDWF  52,W
058C:  MOVWF  77
058D:  MOVF   53,W
058E:  MOVWF  78
058F:  MOVLW  00
0590:  BTFSC  03.0
0591:  MOVLW  01
0592:  ADDWF  78,F
0593:  MOVF   54,W
0594:  MOVWF  79
0595:  MOVLW  00
0596:  BTFSC  03.0
0597:  MOVLW  01
0598:  ADDWF  79,F
0599:  MOVF   55,W
059A:  MOVWF  7A
059B:  MOVLW  00
059C:  BTFSC  03.0
059D:  MOVLW  01
059E:  ADDWF  7A,F
059F:  MOVF   4E,W
05A0:  MOVWF  04
05A1:  BCF    03.7
05A2:  BTFSC  4F.0
05A3:  BSF    03.7
05A4:  MOVF   77,W
05A5:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
05A6:  MOVF   4C,W
05A7:  ADDWF  44,W
05A8:  MOVWF  04
05A9:  BCF    03.7
05AA:  BTFSC  45.0
05AB:  BSF    03.7
05AC:  MOVF   00,W
05AD:  SUBLW  39
05AE:  BTFSC  03.0
05AF:  GOTO   5B9
....................             s[cnt]+=0x7; 
05B0:  MOVF   4C,W
05B1:  ADDWF  44,W
05B2:  MOVWF  04
05B3:  BCF    03.7
05B4:  BTFSC  45.0
05B5:  BSF    03.7
05B6:  MOVLW  07
05B7:  ADDWF  00,W
05B8:  MOVWF  00
....................  
....................          cnt++; 
05B9:  INCF   4C,F
....................          num=temp; 
05BA:  MOVF   49,W
05BB:  MOVWF  42
05BC:  MOVF   48,W
05BD:  MOVWF  41
05BE:  MOVF   47,W
05BF:  MOVWF  40
05C0:  MOVF   46,W
05C1:  MOVWF  3F
05C2:  GOTO   53B
....................      } 
....................  
....................      if(sign==1) { 
05C3:  DECFSZ 4B,W
05C4:  GOTO   5CE
....................          s[cnt]=0x2D;      // Negative sign 
05C5:  MOVF   4C,W
05C6:  ADDWF  44,W
05C7:  MOVWF  04
05C8:  BCF    03.7
05C9:  BTFSC  45.0
05CA:  BSF    03.7
05CB:  MOVLW  2D
05CC:  MOVWF  00
....................          cnt++; 
05CD:  INCF   4C,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
05CE:  CLRF   4A
05CF:  BCF    03.0
05D0:  RRF    4C,W
05D1:  SUBWF  4A,W
05D2:  BTFSC  03.0
05D3:  GOTO   604
....................  
....................          c=s[i]; 
05D4:  MOVF   4A,W
05D5:  ADDWF  44,W
05D6:  MOVWF  04
05D7:  BCF    03.7
05D8:  BTFSC  45.0
05D9:  BSF    03.7
05DA:  MOVF   00,W
05DB:  MOVWF  4D
....................          s[i]=s[cnt-i-1];        // Reverse the number 
05DC:  MOVF   4A,W
05DD:  ADDWF  44,W
05DE:  MOVWF  78
05DF:  MOVF   45,W
05E0:  MOVWF  7A
05E1:  BTFSC  03.0
05E2:  INCF   7A,F
05E3:  MOVF   78,W
05E4:  MOVWF  4E
05E5:  MOVF   7A,W
05E6:  MOVWF  4F
05E7:  MOVF   4A,W
05E8:  SUBWF  4C,W
05E9:  ADDLW  FF
05EA:  ADDWF  44,W
05EB:  MOVWF  04
05EC:  BCF    03.7
05ED:  BTFSC  45.0
05EE:  BSF    03.7
05EF:  MOVF   00,W
05F0:  MOVWF  50
05F1:  MOVF   4E,W
05F2:  MOVWF  04
05F3:  BCF    03.7
05F4:  BTFSC  4F.0
05F5:  BSF    03.7
05F6:  MOVF   50,W
05F7:  MOVWF  00
....................          s[cnt-i-1]=c; 
05F8:  MOVF   4A,W
05F9:  SUBWF  4C,W
05FA:  ADDLW  FF
05FB:  ADDWF  44,W
05FC:  MOVWF  04
05FD:  BCF    03.7
05FE:  BTFSC  45.0
05FF:  BSF    03.7
0600:  MOVF   4D,W
0601:  MOVWF  00
0602:  INCF   4A,F
0603:  GOTO   5CF
....................      } 
....................      s[cnt]='\0';     // End the string 
0604:  MOVF   4C,W
0605:  ADDWF  44,W
0606:  MOVWF  04
0607:  BCF    03.7
0608:  BTFSC  45.0
0609:  BSF    03.7
060A:  CLRF   00
....................      return s; 
060B:  MOVF   44,W
060C:  MOVWF  78
060D:  MOVF   45,W
060E:  MOVWF  79
060F:  BCF    03.6
0610:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... //#INCLUDE <CONFIG_NODE.C> 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0103:  MOVLW  42
0104:  MOVWF  04
0105:  BSF    03.7
0106:  MOVF   00,W
0107:  BTFSC  03.2
0108:  GOTO   116
0109:  MOVLW  06
010A:  MOVWF  78
010B:  CLRF   77
010C:  DECFSZ 77,F
010D:  GOTO   10C
010E:  DECFSZ 78,F
010F:  GOTO   10B
0110:  MOVLW  7B
0111:  MOVWF  77
0112:  DECFSZ 77,F
0113:  GOTO   112
0114:  DECFSZ 00,F
0115:  GOTO   109
0116:  RETURN
....................  
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
....................  
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01AA:  BSF    07.0
....................    output_float(LCD_DATA5); 
01AB:  BSF    07.1
....................    output_float(LCD_DATA6); 
01AC:  BSF    07.2
....................    output_float(LCD_DATA7); 
01AD:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01AE:  BCF    03.5
01AF:  BSF    09.2
01B0:  BSF    03.5
01B1:  BCF    09.2
....................    delay_cycles(1); 
01B2:  NOP
....................    lcd_output_enable(1); 
01B3:  BCF    03.5
01B4:  BSF    09.0
01B5:  BSF    03.5
01B6:  BCF    09.0
....................    delay_cycles(1); 
01B7:  NOP
....................    high = lcd_read_nibble(); 
01B8:  BCF    03.5
01B9:  CALL   15F
01BA:  MOVF   78,W
01BB:  BSF    03.6
01BC:  MOVWF  49
....................        
....................    lcd_output_enable(0); 
01BD:  BCF    03.6
01BE:  BCF    09.0
01BF:  BSF    03.5
01C0:  BCF    09.0
....................    delay_cycles(1); 
01C1:  NOP
....................    lcd_output_enable(1); 
01C2:  BCF    03.5
01C3:  BSF    09.0
01C4:  BSF    03.5
01C5:  BCF    09.0
....................    delay_us(1); 
01C6:  GOTO   1C7
01C7:  GOTO   1C8
01C8:  NOP
....................    low = lcd_read_nibble(); 
01C9:  BCF    03.5
01CA:  CALL   15F
01CB:  MOVF   78,W
01CC:  BSF    03.6
01CD:  MOVWF  48
....................        
....................    lcd_output_enable(0); 
01CE:  BCF    03.6
01CF:  BCF    09.0
01D0:  BSF    03.5
01D1:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01D2:  BCF    03.5
01D3:  BCF    31.0
01D4:  MOVF   31,W
01D5:  BSF    03.5
01D6:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01D7:  BCF    03.5
01D8:  BCF    31.1
01D9:  MOVF   31,W
01DA:  BSF    03.5
01DB:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01DC:  BCF    03.5
01DD:  BCF    31.2
01DE:  MOVF   31,W
01DF:  BSF    03.5
01E0:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01E1:  BCF    03.5
01E2:  BCF    31.3
01E3:  MOVF   31,W
01E4:  BSF    03.5
01E5:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01E6:  BCF    03.5
01E7:  BSF    03.6
01E8:  SWAPF  49,W
01E9:  MOVWF  77
01EA:  MOVLW  F0
01EB:  ANDWF  77,F
01EC:  MOVF   77,W
01ED:  IORWF  48,W
01EE:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
015F:  BSF    03.6
0160:  CLRF   4A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0161:  BCF    03.6
0162:  BSF    31.0
0163:  MOVF   31,W
0164:  BSF    03.5
0165:  MOVWF  07
0166:  MOVLW  00
0167:  BCF    03.5
0168:  BTFSC  07.0
0169:  MOVLW  01
016A:  BSF    03.6
016B:  IORWF  4A,F
....................    n |= input(LCD_DATA5) << 1; 
016C:  BCF    03.6
016D:  BSF    31.1
016E:  MOVF   31,W
016F:  BSF    03.5
0170:  MOVWF  07
0171:  MOVLW  00
0172:  BCF    03.5
0173:  BTFSC  07.1
0174:  MOVLW  01
0175:  MOVWF  77
0176:  BCF    03.0
0177:  RLF    77,F
0178:  MOVF   77,W
0179:  BSF    03.6
017A:  IORWF  4A,F
....................    n |= input(LCD_DATA6) << 2; 
017B:  BCF    03.6
017C:  BSF    31.2
017D:  MOVF   31,W
017E:  BSF    03.5
017F:  MOVWF  07
0180:  MOVLW  00
0181:  BCF    03.5
0182:  BTFSC  07.2
0183:  MOVLW  01
0184:  MOVWF  77
0185:  RLF    77,F
0186:  RLF    77,F
0187:  MOVLW  FC
0188:  ANDWF  77,F
0189:  MOVF   77,W
018A:  BSF    03.6
018B:  IORWF  4A,F
....................    n |= input(LCD_DATA7) << 3; 
018C:  BCF    03.6
018D:  BSF    31.3
018E:  MOVF   31,W
018F:  BSF    03.5
0190:  MOVWF  07
0191:  MOVLW  00
0192:  BCF    03.5
0193:  BTFSC  07.3
0194:  MOVLW  01
0195:  MOVWF  77
0196:  RLF    77,F
0197:  RLF    77,F
0198:  RLF    77,F
0199:  MOVLW  F8
019A:  ANDWF  77,F
019B:  MOVF   77,W
019C:  BSF    03.6
019D:  IORWF  4A,F
....................     
....................    return(n); 
019E:  MOVF   4A,W
019F:  MOVWF  78
....................   #else 
01A0:  BCF    03.6
01A1:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0117:  BSF    03.6
0118:  BTFSC  49.0
0119:  GOTO   11E
011A:  BCF    03.6
011B:  BCF    07.0
011C:  GOTO   120
011D:  BSF    03.6
011E:  BCF    03.6
011F:  BSF    07.0
0120:  BCF    31.0
0121:  MOVF   31,W
0122:  BSF    03.5
0123:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0124:  BCF    03.5
0125:  BSF    03.6
0126:  BTFSC  49.1
0127:  GOTO   12C
0128:  BCF    03.6
0129:  BCF    07.1
012A:  GOTO   12E
012B:  BSF    03.6
012C:  BCF    03.6
012D:  BSF    07.1
012E:  BCF    31.1
012F:  MOVF   31,W
0130:  BSF    03.5
0131:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0132:  BCF    03.5
0133:  BSF    03.6
0134:  BTFSC  49.2
0135:  GOTO   13A
0136:  BCF    03.6
0137:  BCF    07.2
0138:  GOTO   13C
0139:  BSF    03.6
013A:  BCF    03.6
013B:  BSF    07.2
013C:  BCF    31.2
013D:  MOVF   31,W
013E:  BSF    03.5
013F:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0140:  BCF    03.5
0141:  BSF    03.6
0142:  BTFSC  49.3
0143:  GOTO   148
0144:  BCF    03.6
0145:  BCF    07.3
0146:  GOTO   14A
0147:  BSF    03.6
0148:  BCF    03.6
0149:  BSF    07.3
014A:  BCF    31.3
014B:  MOVF   31,W
014C:  BSF    03.5
014D:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
014E:  NOP
....................    lcd_output_enable(1); 
014F:  BCF    03.5
0150:  BSF    09.0
0151:  BSF    03.5
0152:  BCF    09.0
....................    delay_us(2); 
0153:  MOVLW  02
0154:  MOVWF  77
0155:  DECFSZ 77,F
0156:  GOTO   155
0157:  GOTO   158
0158:  NOP
....................    lcd_output_enable(0); 
0159:  BCF    03.5
015A:  BCF    09.0
015B:  BSF    03.5
015C:  BCF    09.0
015D:  BCF    03.5
015E:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01A2:  BSF    03.5
01A3:  BCF    09.0
....................    lcd_rs_tris(); 
01A4:  BCF    09.1
....................    lcd_rw_tris(); 
01A5:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01A6:  BCF    03.5
01A7:  BCF    09.1
01A8:  BSF    03.5
01A9:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01EF:  MOVF   78,W
01F0:  MOVWF  48
01F1:  BTFSS  48.7
01F2:  GOTO   1F6
01F3:  BSF    03.5
01F4:  BCF    03.6
01F5:  GOTO   1AA
....................    lcd_output_rs(address); 
01F6:  MOVF   46,F
01F7:  BTFSS  03.2
01F8:  GOTO   1FD
01F9:  BCF    03.6
01FA:  BCF    09.1
01FB:  GOTO   1FF
01FC:  BSF    03.6
01FD:  BCF    03.6
01FE:  BSF    09.1
01FF:  BSF    03.5
0200:  BCF    09.1
....................    delay_cycles(1); 
0201:  NOP
....................    lcd_output_rw(0); 
0202:  BCF    03.5
0203:  BCF    09.2
0204:  BSF    03.5
0205:  BCF    09.2
....................    delay_cycles(1); 
0206:  NOP
....................    lcd_output_enable(0); 
0207:  BCF    03.5
0208:  BCF    09.0
0209:  BSF    03.5
020A:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
020B:  BCF    03.5
020C:  BSF    03.6
020D:  SWAPF  47,W
020E:  MOVWF  48
020F:  MOVLW  0F
0210:  ANDWF  48,F
0211:  MOVF   48,W
0212:  MOVWF  49
0213:  BCF    03.6
0214:  CALL   117
....................    lcd_send_nibble(n & 0xf); 
0215:  BSF    03.6
0216:  MOVF   47,W
0217:  ANDLW  0F
0218:  MOVWF  48
0219:  MOVWF  49
021A:  BCF    03.6
021B:  CALL   117
021C:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
021D:  MOVLW  28
021E:  BSF    03.6
021F:  MOVWF  3E
0220:  MOVLW  0C
0221:  MOVWF  3F
0222:  MOVLW  01
0223:  MOVWF  40
0224:  MOVLW  06
0225:  MOVWF  41
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0226:  BCF    03.6
0227:  BCF    09.0
0228:  BSF    03.5
0229:  BCF    09.0
....................    lcd_output_rs(0); 
022A:  BCF    03.5
022B:  BCF    09.1
022C:  BSF    03.5
022D:  BCF    09.1
....................    lcd_output_rw(0); 
022E:  BCF    03.5
022F:  BCF    09.2
0230:  BSF    03.5
0231:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0232:  BCF    03.5
0233:  BCF    31.0
0234:  MOVF   31,W
0235:  BSF    03.5
0236:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0237:  BCF    03.5
0238:  BCF    31.1
0239:  MOVF   31,W
023A:  BSF    03.5
023B:  MOVWF  07
....................    output_drive(LCD_DATA6); 
023C:  BCF    03.5
023D:  BCF    31.2
023E:  MOVF   31,W
023F:  BSF    03.5
0240:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0241:  BCF    03.5
0242:  BCF    31.3
0243:  MOVF   31,W
0244:  BSF    03.5
0245:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0246:  BCF    09.0
....................    lcd_rs_tris(); 
0247:  BCF    09.1
....................    lcd_rw_tris(); 
0248:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0249:  MOVLW  0F
024A:  BCF    03.5
024B:  BSF    03.6
024C:  MOVWF  42
024D:  BCF    03.6
024E:  CALL   103
....................    for(i=1;i<=3;++i) 
024F:  MOVLW  01
0250:  BSF    03.6
0251:  MOVWF  3D
0252:  MOVF   3D,W
0253:  SUBLW  03
0254:  BTFSS  03.0
0255:  GOTO   262
....................    { 
....................        lcd_send_nibble(3); 
0256:  MOVLW  03
0257:  MOVWF  49
0258:  BCF    03.6
0259:  CALL   117
....................        delay_ms(5); 
025A:  MOVLW  05
025B:  BSF    03.6
025C:  MOVWF  42
025D:  BCF    03.6
025E:  CALL   103
025F:  BSF    03.6
0260:  INCF   3D,F
0261:  GOTO   252
....................    } 
....................     
....................    lcd_send_nibble(2); 
0262:  MOVLW  02
0263:  MOVWF  49
0264:  BCF    03.6
0265:  CALL   117
....................    delay_ms(5); 
0266:  MOVLW  05
0267:  BSF    03.6
0268:  MOVWF  42
0269:  BCF    03.6
026A:  CALL   103
....................    for(i=0;i<=3;++i) 
026B:  BSF    03.6
026C:  CLRF   3D
026D:  MOVF   3D,W
026E:  SUBLW  03
026F:  BTFSS  03.0
0270:  GOTO   27F
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0271:  MOVLW  3E
0272:  ADDWF  3D,W
0273:  MOVWF  04
0274:  BSF    03.7
0275:  MOVF   00,W
0276:  MOVWF  42
0277:  CLRF   46
0278:  MOVF   42,W
0279:  MOVWF  47
027A:  BCF    03.6
027B:  CALL   1A2
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
027C:  BSF    03.6
027D:  INCF   3D,F
027E:  GOTO   26D
027F:  BCF    03.6
0280:  BSF    0A.3
0281:  BCF    0A.4
0282:  GOTO   54A (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
03D7:  BSF    03.6
03D8:  DECFSZ 43,W
03D9:  GOTO   3DB
03DA:  GOTO   3DE
....................       address=LCD_LINE_TWO; 
03DB:  MOVLW  40
03DC:  MOVWF  44
03DD:  GOTO   3DF
....................    else 
....................       address=0; 
03DE:  CLRF   44
....................       
....................    address+=x-1; 
03DF:  MOVLW  01
03E0:  SUBWF  42,W
03E1:  ADDWF  44,F
....................    lcd_send_byte(0,0x80|address); 
03E2:  MOVF   44,W
03E3:  IORLW  80
03E4:  MOVWF  45
03E5:  CLRF   46
03E6:  MOVF   45,W
03E7:  MOVWF  47
03E8:  BCF    03.6
03E9:  CALL   1A2
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03EA:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03EB:  BSF    03.6
03EC:  MOVF   41,W
03ED:  XORLW  07
03EE:  BCF    03.6
03EF:  BTFSC  03.2
03F0:  GOTO   3FB
03F1:  XORLW  0B
03F2:  BTFSC  03.2
03F3:  GOTO   402
03F4:  XORLW  06
03F5:  BTFSC  03.2
03F6:  GOTO   40E
03F7:  XORLW  02
03F8:  BTFSC  03.2
03F9:  GOTO   416
03FA:  GOTO   41D
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03FB:  MOVLW  01
03FC:  BSF    03.6
03FD:  MOVWF  42
03FE:  MOVWF  43
03FF:  BCF    03.6
0400:  CALL   3D7
0401:  GOTO   424
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0402:  BSF    03.6
0403:  CLRF   46
0404:  MOVLW  01
0405:  MOVWF  47
0406:  BCF    03.6
0407:  CALL   1A2
....................                      delay_ms(2); 
0408:  MOVLW  02
0409:  BSF    03.6
040A:  MOVWF  42
040B:  BCF    03.6
040C:  CALL   103
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
040D:  GOTO   424
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
040E:  MOVLW  01
040F:  BSF    03.6
0410:  MOVWF  42
0411:  MOVLW  02
0412:  MOVWF  43
0413:  BCF    03.6
0414:  CALL   3D7
0415:  GOTO   424
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0416:  BSF    03.6
0417:  CLRF   46
0418:  MOVLW  10
0419:  MOVWF  47
041A:  BCF    03.6
041B:  CALL   1A2
041C:  GOTO   424
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
041D:  MOVLW  01
041E:  BSF    03.6
041F:  MOVWF  46
0420:  MOVF   41,W
0421:  MOVWF  47
0422:  BCF    03.6
0423:  CALL   1A2
....................      #endif 
....................    } 
0424:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 1, 1, 0, 1, 1}; 
*
0C25:  MOVLW  DE
0C26:  MOVWF  60
.................... INT1 TT_SENSOR[8]={1, 0, 1, 1, 0, 0, 0, 0}; 
0C27:  MOVLW  0D
0C28:  MOVWF  61
.................... CHAR *TT_DEVICE_CHAR[]=" "; 
0C29:  MOVLW  20
0C2A:  MOVWF  64
0C2B:  CLRF   65
0C2C:  CLRF   63
0C2D:  MOVLW  64
0C2E:  MOVWF  62
.................... CHAR *TT_SENSOR_CHAR[]=" "; 
0C2F:  MOVLW  20
0C30:  MOVWF  68
0C31:  CLRF   69
0C32:  CLRF   67
0C33:  MOVLW  68
0C34:  MOVWF  66
.................... CHAR *PACKAGE_NHIETDO[]={"S","ID", "S_S" ,"LENGHT","NHIETDO","CHECKSUM","#"}; 
0C35:  MOVLW  53
0C36:  BSF    03.5
0C37:  MOVWF  2E
0C38:  CLRF   2F
0C39:  MOVLW  49
0C3A:  MOVWF  30
0C3B:  MOVLW  44
0C3C:  MOVWF  31
0C3D:  CLRF   32
0C3E:  MOVLW  53
0C3F:  MOVWF  33
0C40:  MOVLW  5F
0C41:  MOVWF  34
0C42:  MOVLW  53
0C43:  MOVWF  35
0C44:  CLRF   36
0C45:  MOVLW  4C
0C46:  MOVWF  37
0C47:  MOVLW  45
0C48:  MOVWF  38
0C49:  MOVLW  4E
0C4A:  MOVWF  39
0C4B:  MOVLW  47
0C4C:  MOVWF  3A
0C4D:  MOVLW  48
0C4E:  MOVWF  3B
0C4F:  MOVLW  54
0C50:  MOVWF  3C
0C51:  CLRF   3D
0C52:  MOVLW  4E
0C53:  MOVWF  3E
0C54:  MOVLW  48
0C55:  MOVWF  3F
0C56:  MOVLW  49
0C57:  MOVWF  40
0C58:  MOVLW  45
0C59:  MOVWF  41
0C5A:  MOVLW  54
0C5B:  MOVWF  42
0C5C:  MOVLW  44
0C5D:  MOVWF  43
0C5E:  MOVLW  4F
0C5F:  MOVWF  44
0C60:  CLRF   45
0C61:  MOVLW  43
0C62:  MOVWF  46
0C63:  MOVLW  48
0C64:  MOVWF  47
0C65:  MOVLW  45
0C66:  MOVWF  48
0C67:  MOVLW  43
0C68:  MOVWF  49
0C69:  MOVLW  4B
0C6A:  MOVWF  4A
0C6B:  MOVLW  53
0C6C:  MOVWF  4B
0C6D:  MOVLW  55
0C6E:  MOVWF  4C
0C6F:  MOVLW  4D
0C70:  MOVWF  4D
0C71:  CLRF   4E
0C72:  MOVLW  23
0C73:  MOVWF  4F
0C74:  CLRF   50
0C75:  CLRF   21
0C76:  MOVLW  AE
0C77:  MOVWF  20
0C78:  CLRF   23
0C79:  MOVLW  B0
0C7A:  MOVWF  22
0C7B:  CLRF   25
0C7C:  MOVLW  B3
0C7D:  MOVWF  24
0C7E:  CLRF   27
0C7F:  MOVLW  B7
0C80:  MOVWF  26
0C81:  CLRF   29
0C82:  MOVLW  BE
0C83:  MOVWF  28
0C84:  CLRF   2B
0C85:  MOVLW  C6
0C86:  MOVWF  2A
0C87:  CLRF   2D
0C88:  MOVLW  CF
0C89:  MOVWF  2C
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE1234","SENSOR1234","#"}; 
0C8A:  MOVLW  53
0C8B:  BCF    03.5
0C8C:  BSF    03.6
0C8D:  MOVWF  10
0C8E:  CLRF   11
0C8F:  MOVLW  49
0C90:  MOVWF  12
0C91:  MOVLW  44
0C92:  MOVWF  13
0C93:  CLRF   14
0C94:  MOVLW  43
0C95:  MOVWF  15
0C96:  MOVLW  5F
0C97:  MOVWF  16
0C98:  MOVLW  46
0C99:  MOVWF  17
0C9A:  CLRF   18
0C9B:  MOVLW  4C
0C9C:  MOVWF  19
0C9D:  MOVLW  45
0C9E:  MOVWF  1A
0C9F:  MOVLW  4E
0CA0:  MOVWF  1B
0CA1:  MOVLW  47
0CA2:  MOVWF  1C
0CA3:  MOVLW  48
0CA4:  MOVWF  1D
0CA5:  MOVLW  54
0CA6:  MOVWF  1E
0CA7:  CLRF   1F
0CA8:  MOVLW  49
0CA9:  MOVWF  20
0CAA:  MOVLW  44
0CAB:  MOVWF  21
0CAC:  MOVLW  5F
0CAD:  MOVWF  22
0CAE:  CLRF   23
0CAF:  MOVLW  44
0CB0:  MOVWF  24
0CB1:  MOVLW  45
0CB2:  MOVWF  25
0CB3:  MOVLW  56
0CB4:  MOVWF  26
0CB5:  MOVLW  49
0CB6:  MOVWF  27
0CB7:  MOVLW  43
0CB8:  MOVWF  28
0CB9:  MOVLW  45
0CBA:  MOVWF  29
0CBB:  MOVLW  31
0CBC:  MOVWF  2A
0CBD:  MOVLW  32
0CBE:  MOVWF  2B
0CBF:  MOVLW  33
0CC0:  MOVWF  2C
0CC1:  MOVLW  34
0CC2:  MOVWF  2D
0CC3:  CLRF   2E
0CC4:  MOVLW  53
0CC5:  MOVWF  2F
0CC6:  MOVLW  45
0CC7:  MOVWF  30
0CC8:  MOVLW  4E
0CC9:  MOVWF  31
0CCA:  MOVLW  53
0CCB:  MOVWF  32
0CCC:  MOVLW  4F
0CCD:  MOVWF  33
0CCE:  MOVLW  52
0CCF:  MOVWF  34
0CD0:  MOVLW  31
0CD1:  MOVWF  35
0CD2:  MOVLW  32
0CD3:  MOVWF  36
0CD4:  MOVLW  33
0CD5:  MOVWF  37
0CD6:  MOVLW  34
0CD7:  MOVWF  38
0CD8:  CLRF   39
0CD9:  MOVLW  23
0CDA:  MOVWF  3A
0CDB:  CLRF   3B
0CDC:  MOVLW  01
0CDD:  BSF    03.5
0CDE:  BCF    03.6
0CDF:  MOVWF  52
0CE0:  MOVLW  10
0CE1:  MOVWF  51
0CE2:  MOVLW  01
0CE3:  MOVWF  54
0CE4:  MOVLW  12
0CE5:  MOVWF  53
0CE6:  MOVLW  01
0CE7:  MOVWF  56
0CE8:  MOVLW  15
0CE9:  MOVWF  55
0CEA:  MOVLW  01
0CEB:  MOVWF  58
0CEC:  MOVLW  19
0CED:  MOVWF  57
0CEE:  MOVLW  01
0CEF:  MOVWF  5A
0CF0:  MOVLW  20
0CF1:  MOVWF  59
0CF2:  MOVLW  01
0CF3:  MOVWF  5C
0CF4:  MOVLW  24
0CF5:  MOVWF  5B
0CF6:  MOVLW  01
0CF7:  MOVWF  5E
0CF8:  MOVLW  2F
0CF9:  MOVWF  5D
0CFA:  MOVLW  01
0CFB:  MOVWF  60
0CFC:  MOVLW  3A
0CFD:  MOVWF  5F
.................... CHAR NHIETDO1[]="27"; 
0CFE:  MOVLW  32
0CFF:  BCF    03.5
0D00:  MOVWF  6A
0D01:  MOVLW  37
0D02:  MOVWF  6B
0D03:  CLRF   6C
.................... CHAR NHIETDO2[]="27"; 
0D04:  MOVLW  32
0D05:  MOVWF  6D
0D06:  MOVLW  37
0D07:  MOVWF  6E
0D08:  CLRF   6F
.................... CHAR ID_[]="0"; 
0D09:  MOVLW  30
0D0A:  MOVWF  70
0D0B:  CLRF   71
.................... CHAR *TEMP_CHAR[]="0"; 
0D0C:  MOVWF  74
0D0D:  CLRF   75
0D0E:  CLRF   73
0D0F:  MOVLW  74
0D10:  MOVWF  72
.................... CHAR *TEMP_CHAR2[]="0"; 
0D11:  MOVLW  30
0D12:  MOVWF  7D
0D13:  CLRF   7E
0D14:  CLRF   7C
0D15:  MOVLW  7D
0D16:  MOVWF  7B
....................    
.................... //--------------------------------------------------------------------// 
....................  
....................  
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    5F.1
....................    TT_STT = 1; 
0808:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  42
080C:  MOVLW  02
080D:  MOVWF  43
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   3D7
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  42
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   103
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   425
0821:  BSF    0A.3
....................    WHILE (TT_STT) 
0822:  BTFSS  5F.3
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  3D
0831:  MOVLW  96
0832:  MOVWF  42
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   103
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 3D,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   42
083B:  CLRF   41
083C:  CLRF   40
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  3F
0841:  MOVLW  0A
0842:  MOVWF  43
0843:  CLRF   45
0844:  MOVLW  70
0845:  MOVWF  44
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   4F1
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  42
084D:  MOVLW  02
084E:  MOVWF  43
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   3D7
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  42
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   103
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  70
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   611
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  42
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   103
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    5F.1
....................    TT_STT = 1; 
086F:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  42
0873:  MOVLW  02
0874:  MOVWF  43
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   3D7
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  42
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   103
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:         "); 
0880:  MOVLW  72
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   425
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  5F.3
088A:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11A
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  3D
0898:  MOVLW  96
0899:  MOVWF  42
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   103
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 3D,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   42
08A2:  CLRF   41
08A3:  CLRF   40
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  3F
08A8:  MOVLW  0A
08A9:  MOVWF  43
08AA:  CLRF   45
08AB:  MOVLW  72
08AC:  MOVWF  44
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   4F1
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  42
08B4:  MOVLW  02
08B5:  MOVWF  43
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   3D7
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  42
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   103
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  72
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   611
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  42
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   103
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
08CE:  MOVLW  20
08CF:  BSF    03.6
08D0:  MOVWF  41
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   3EB
08D4:  BSF    0A.3
08D5:  MOVLW  3A
08D6:  BSF    03.6
08D7:  MOVWF  41
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   3EB
08DB:  BSF    0A.3
08DC:  MOVLW  20
08DD:  BSF    03.6
08DE:  MOVWF  41
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   3EB
08E2:  BSF    0A.3
....................          DELAY_MS (1); 
08E3:  MOVLW  01
08E4:  BSF    03.6
08E5:  MOVWF  42
08E6:  BCF    0A.3
08E7:  BCF    03.6
08E8:  CALL   103
08E9:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EA:  MOVF   3A,W
08EB:  BSF    03.6
08EC:  MOVWF  3F
08ED:  CLRF   41
08EE:  MOVLW  60
08EF:  MOVWF  40
08F0:  BCF    0A.3
08F1:  BCF    03.6
08F2:  CALL   62E
08F3:  BSF    0A.3
08F4:  MOVLW  00
08F5:  BTFSC  78.0
08F6:  MOVLW  01
08F7:  BSF    03.6
08F8:  MOVWF  3D
08F9:  CLRF   42
08FA:  CLRF   41
08FB:  CLRF   40
08FC:  MOVF   3D,W
08FD:  MOVWF  3F
08FE:  MOVLW  0A
08FF:  MOVWF  43
0900:  CLRF   45
0901:  MOVLW  72
0902:  MOVWF  44
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   4F1
0906:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0907:  MOVLW  72
0908:  MOVWF  04
0909:  BCF    03.7
090A:  BCF    0A.3
090B:  CALL   611
090C:  BSF    0A.3
....................          DELAY_MS (1); 
090D:  MOVLW  01
090E:  BSF    03.6
090F:  MOVWF  42
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   103
0913:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0914:  BSF    03.5
0915:  BCF    08.0
0916:  MOVLW  01
0917:  BCF    03.5
0918:  XORWF  08,F
....................       } 
0919:  GOTO   174
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091A:  BSF    03.5
091B:  BSF    06.3
091C:  BCF    03.5
091D:  BTFSC  06.3
091E:  GOTO   174
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
091F:  MOVF   3A,W
0920:  BSF    03.6
0921:  MOVWF  3F
0922:  CLRF   41
0923:  MOVLW  60
0924:  MOVWF  40
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   62E
0928:  BSF    0A.3
0929:  MOVLW  00
092A:  BTFSS  78.0
092B:  MOVLW  01
092C:  BSF    03.6
092D:  MOVWF  3D
092E:  BCF    03.6
092F:  MOVF   3A,W
0930:  BSF    03.6
0931:  MOVWF  3E
0932:  MOVF   3D,W
0933:  MOVWF  3F
0934:  CLRF   41
0935:  MOVLW  60
0936:  MOVWF  40
0937:  BCF    0A.3
0938:  BCF    03.6
0939:  CALL   647
093A:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
093B:  MOVLW  0D
093C:  BSF    03.6
093D:  MOVWF  42
093E:  MOVLW  02
093F:  MOVWF  43
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   3D7
0943:  BSF    0A.3
....................          DELAY_MS (300); 
0944:  MOVLW  02
0945:  BSF    03.6
0946:  MOVWF  3D
0947:  MOVLW  96
0948:  MOVWF  42
0949:  BCF    0A.3
094A:  BCF    03.6
094B:  CALL   103
094C:  BSF    0A.3
094D:  BSF    03.6
094E:  DECFSZ 3D,F
094F:  GOTO   147
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0950:  BCF    03.6
0951:  MOVF   3A,W
0952:  BSF    03.6
0953:  MOVWF  3F
0954:  CLRF   41
0955:  MOVLW  60
0956:  MOVWF  40
0957:  BCF    0A.3
0958:  BCF    03.6
0959:  CALL   62E
095A:  BSF    0A.3
095B:  MOVLW  00
095C:  BTFSC  78.0
095D:  MOVLW  01
095E:  BSF    03.6
095F:  MOVWF  3D
0960:  CLRF   42
0961:  CLRF   41
0962:  CLRF   40
0963:  MOVF   3D,W
0964:  MOVWF  3F
0965:  MOVLW  0A
0966:  MOVWF  43
0967:  CLRF   45
0968:  MOVLW  72
0969:  MOVWF  44
096A:  BCF    0A.3
096B:  BCF    03.6
096C:  CALL   4F1
096D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
096E:  MOVLW  72
096F:  MOVWF  04
0970:  BCF    03.7
0971:  BCF    0A.3
0972:  CALL   611
0973:  BSF    0A.3
....................       } 
0974:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0976:  BCF    5F.1
....................    TT_STT = 1; 
0977:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0978:  MOVLW  01
0979:  BSF    03.6
097A:  MOVWF  42
097B:  MOVLW  02
097C:  MOVWF  43
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   3D7
0980:  BSF    0A.3
....................    DELAY_MS (10); 
0981:  MOVLW  0A
0982:  BSF    03.6
0983:  MOVWF  42
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   103
0987:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
0988:  MOVLW  7B
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  MOVLW  00
098C:  MOVWF  0F
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   425
0990:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0991:  BTFSS  5F.3
0992:  GOTO   27D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0993:  BSF    03.5
0994:  BSF    06.2
0995:  BCF    03.5
0996:  BTFSC  06.2
0997:  GOTO   222
....................       { 
....................          STT_SENSOR ++; 
0998:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0999:  MOVF   3B,W
099A:  SUBLW  03
099B:  BTFSS  03.0
099C:  CLRF   3B
....................          DELAY_MS (300); 
099D:  MOVLW  02
099E:  BSF    03.6
099F:  MOVWF  3D
09A0:  MOVLW  96
09A1:  MOVWF  42
09A2:  BCF    0A.3
09A3:  BCF    03.6
09A4:  CALL   103
09A5:  BSF    0A.3
09A6:  BSF    03.6
09A7:  DECFSZ 3D,F
09A8:  GOTO   1A0
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09A9:  CLRF   42
09AA:  CLRF   41
09AB:  CLRF   40
09AC:  BCF    03.6
09AD:  MOVF   3B,W
09AE:  BSF    03.6
09AF:  MOVWF  3F
09B0:  MOVLW  0A
09B1:  MOVWF  43
09B2:  CLRF   45
09B3:  MOVLW  72
09B4:  MOVWF  44
09B5:  BCF    0A.3
09B6:  BCF    03.6
09B7:  CALL   4F1
09B8:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09B9:  MOVLW  09
09BA:  BSF    03.6
09BB:  MOVWF  42
09BC:  MOVLW  02
09BD:  MOVWF  43
09BE:  BCF    0A.3
09BF:  BCF    03.6
09C0:  CALL   3D7
09C1:  BSF    0A.3
....................          DELAY_MS (10); 
09C2:  MOVLW  0A
09C3:  BSF    03.6
09C4:  MOVWF  42
09C5:  BCF    0A.3
09C6:  BCF    03.6
09C7:  CALL   103
09C8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09C9:  MOVLW  72
09CA:  MOVWF  04
09CB:  BCF    03.7
09CC:  BCF    0A.3
09CD:  CALL   611
09CE:  BSF    0A.3
....................          DELAY_MS (1); 
09CF:  MOVLW  01
09D0:  BSF    03.6
09D1:  MOVWF  42
09D2:  BCF    0A.3
09D3:  BCF    03.6
09D4:  CALL   103
09D5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
09D6:  MOVLW  20
09D7:  BSF    03.6
09D8:  MOVWF  41
09D9:  BCF    0A.3
09DA:  BCF    03.6
09DB:  CALL   3EB
09DC:  BSF    0A.3
09DD:  MOVLW  3A
09DE:  BSF    03.6
09DF:  MOVWF  41
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   3EB
09E3:  BSF    0A.3
09E4:  MOVLW  20
09E5:  BSF    03.6
09E6:  MOVWF  41
09E7:  BCF    0A.3
09E8:  BCF    03.6
09E9:  CALL   3EB
09EA:  BSF    0A.3
....................          DELAY_MS (1); 
09EB:  MOVLW  01
09EC:  BSF    03.6
09ED:  MOVWF  42
09EE:  BCF    0A.3
09EF:  BCF    03.6
09F0:  CALL   103
09F1:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F2:  MOVF   3B,W
09F3:  BSF    03.6
09F4:  MOVWF  3F
09F5:  CLRF   41
09F6:  MOVLW  61
09F7:  MOVWF  40
09F8:  BCF    0A.3
09F9:  BCF    03.6
09FA:  CALL   62E
09FB:  BSF    0A.3
09FC:  MOVLW  00
09FD:  BTFSC  78.0
09FE:  MOVLW  01
09FF:  BSF    03.6
0A00:  MOVWF  3D
0A01:  CLRF   42
0A02:  CLRF   41
0A03:  CLRF   40
0A04:  MOVF   3D,W
0A05:  MOVWF  3F
0A06:  MOVLW  0A
0A07:  MOVWF  43
0A08:  CLRF   45
0A09:  MOVLW  72
0A0A:  MOVWF  44
0A0B:  BCF    0A.3
0A0C:  BCF    03.6
0A0D:  CALL   4F1
0A0E:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A0F:  MOVLW  72
0A10:  MOVWF  04
0A11:  BCF    03.7
0A12:  BCF    0A.3
0A13:  CALL   611
0A14:  BSF    0A.3
....................          DELAY_MS (1); 
0A15:  MOVLW  01
0A16:  BSF    03.6
0A17:  MOVWF  42
0A18:  BCF    0A.3
0A19:  BCF    03.6
0A1A:  CALL   103
0A1B:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A1C:  BSF    03.5
0A1D:  BCF    08.0
0A1E:  MOVLW  01
0A1F:  BCF    03.5
0A20:  XORWF  08,F
....................       } 
0A21:  GOTO   27C
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A22:  BSF    03.5
0A23:  BSF    06.3
0A24:  BCF    03.5
0A25:  BTFSC  06.3
0A26:  GOTO   27C
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A27:  MOVF   3B,W
0A28:  BSF    03.6
0A29:  MOVWF  3F
0A2A:  CLRF   41
0A2B:  MOVLW  61
0A2C:  MOVWF  40
0A2D:  BCF    0A.3
0A2E:  BCF    03.6
0A2F:  CALL   62E
0A30:  BSF    0A.3
0A31:  MOVLW  00
0A32:  BTFSS  78.0
0A33:  MOVLW  01
0A34:  BSF    03.6
0A35:  MOVWF  3D
0A36:  BCF    03.6
0A37:  MOVF   3B,W
0A38:  BSF    03.6
0A39:  MOVWF  3E
0A3A:  MOVF   3D,W
0A3B:  MOVWF  3F
0A3C:  CLRF   41
0A3D:  MOVLW  61
0A3E:  MOVWF  40
0A3F:  BCF    0A.3
0A40:  BCF    03.6
0A41:  CALL   647
0A42:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0A43:  MOVLW  0D
0A44:  BSF    03.6
0A45:  MOVWF  42
0A46:  MOVLW  02
0A47:  MOVWF  43
0A48:  BCF    0A.3
0A49:  BCF    03.6
0A4A:  CALL   3D7
0A4B:  BSF    0A.3
....................          DELAY_MS (300); 
0A4C:  MOVLW  02
0A4D:  BSF    03.6
0A4E:  MOVWF  3D
0A4F:  MOVLW  96
0A50:  MOVWF  42
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   103
0A54:  BSF    0A.3
0A55:  BSF    03.6
0A56:  DECFSZ 3D,F
0A57:  GOTO   24F
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A58:  BCF    03.6
0A59:  MOVF   3B,W
0A5A:  BSF    03.6
0A5B:  MOVWF  3F
0A5C:  CLRF   41
0A5D:  MOVLW  61
0A5E:  MOVWF  40
0A5F:  BCF    0A.3
0A60:  BCF    03.6
0A61:  CALL   62E
0A62:  BSF    0A.3
0A63:  MOVLW  00
0A64:  BTFSC  78.0
0A65:  MOVLW  01
0A66:  BSF    03.6
0A67:  MOVWF  3D
0A68:  CLRF   42
0A69:  CLRF   41
0A6A:  CLRF   40
0A6B:  MOVF   3D,W
0A6C:  MOVWF  3F
0A6D:  MOVLW  0A
0A6E:  MOVWF  43
0A6F:  CLRF   45
0A70:  MOVLW  72
0A71:  MOVWF  44
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   4F1
0A75:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A76:  MOVLW  72
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  BCF    0A.3
0A7A:  CALL   611
0A7B:  BSF    0A.3
....................       } 
0A7C:  GOTO   191
....................  
....................    } 
.................... } 
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0A7E:  BCF    5F.1
....................    ID_NODE = 0; 
0A7F:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00DD:  BCF    03.6
00DE:  BCF    5F.1
....................    TT_FUN = 0; 
00DF:  BCF    5F.2
....................    TT_STT = 0; 
00E0:  BCF    5F.3
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   280
0805:  ADDLW  04
0806:  GOTO   283
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   280
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0975:  GOTO   280
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0A7D:  GOTO   280
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
0A80:  BCF    0A.3
0A81:  BCF    0A.4
0A82:  GOTO   6EB (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0669:  BSF    5F.2
....................    LCD_GOTOXY (1, 1) ; 
066A:  MOVLW  01
066B:  BSF    03.6
066C:  MOVWF  42
066D:  MOVWF  43
066E:  BCF    03.6
066F:  CALL   3D7
....................    DELAY_MS (10); 
0670:  MOVLW  0A
0671:  BSF    03.6
0672:  MOVWF  42
0673:  BCF    03.6
0674:  CALL   103
....................    PRINTF (LCD_PUTC, "CONFIG:         "); 
0675:  MOVLW  84
0676:  BSF    03.6
0677:  MOVWF  0D
0678:  MOVLW  00
0679:  MOVWF  0F
067A:  BCF    03.6
067B:  CALL   425
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
067C:  MOVLW  01
067D:  BSF    03.6
067E:  MOVWF  42
067F:  MOVLW  02
0680:  MOVWF  43
0681:  BCF    03.6
0682:  CALL   3D7
....................    DELAY_MS (10); 
0683:  MOVLW  0A
0684:  BSF    03.6
0685:  MOVWF  42
0686:  BCF    03.6
0687:  CALL   103
....................    PRINTF (LCD_PUTC, "CASE:           "); 
0688:  MOVLW  8D
0689:  BSF    03.6
068A:  MOVWF  0D
068B:  MOVLW  00
068C:  MOVWF  0F
068D:  BCF    03.6
068E:  CALL   425
....................  
....................    WHILE (TT_FUN) 
068F:  BTFSS  5F.2
0690:  GOTO   6E7
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0691:  BSF    03.5
0692:  BSF    06.2
0693:  BCF    03.5
0694:  BTFSC  06.2
0695:  GOTO   6E6
....................       { 
....................          CONFIG_FUN ++;          
0696:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
0697:  MOVLW  03
0698:  ANDWF  38,F
....................          DELAY_MS (300);          
0699:  MOVLW  02
069A:  BSF    03.6
069B:  MOVWF  3D
069C:  MOVLW  96
069D:  MOVWF  42
069E:  BCF    03.6
069F:  CALL   103
06A0:  BSF    03.6
06A1:  DECFSZ 3D,F
06A2:  GOTO   69C
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
06A3:  MOVLW  06
06A4:  MOVWF  42
06A5:  MOVLW  02
06A6:  MOVWF  43
06A7:  BCF    03.6
06A8:  CALL   3D7
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
06A9:  BSF    03.6
06AA:  CLRF   42
06AB:  CLRF   41
06AC:  CLRF   40
06AD:  BCF    03.6
06AE:  MOVF   38,W
06AF:  BSF    03.6
06B0:  MOVWF  3F
06B1:  MOVLW  0A
06B2:  MOVWF  43
06B3:  CLRF   45
06B4:  MOVLW  72
06B5:  MOVWF  44
06B6:  BCF    03.6
06B7:  CALL   4F1
....................          DELAY_MS (10); 
06B8:  MOVLW  0A
06B9:  BSF    03.6
06BA:  MOVWF  42
06BB:  BCF    03.6
06BC:  CALL   103
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06BD:  MOVLW  72
06BE:  MOVWF  04
06BF:  BCF    03.7
06C0:  CALL   611
....................          SWITCH (CONFIG_FUN) 
06C1:  MOVF   38,W
06C2:  ADDLW  FC
06C3:  BTFSC  03.0
06C4:  GOTO   6E6
06C5:  ADDLW  04
06C6:  GOTO   6EF
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, "- ID     "); 
06C7:  MOVLW  96
06C8:  BSF    03.6
06C9:  MOVWF  0D
06CA:  MOVLW  00
06CB:  MOVWF  0F
06CC:  BCF    03.6
06CD:  CALL   425
....................             BREAK;       
06CE:  GOTO   6E6
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, "- DEVICES"); 
06CF:  MOVLW  9B
06D0:  BSF    03.6
06D1:  MOVWF  0D
06D2:  MOVLW  00
06D3:  MOVWF  0F
06D4:  BCF    03.6
06D5:  CALL   425
....................             BREAK; 
06D6:  GOTO   6E6
....................        
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, "- SENSORS"); 
06D7:  MOVLW  A0
06D8:  BSF    03.6
06D9:  MOVWF  0D
06DA:  MOVLW  00
06DB:  MOVWF  0F
06DC:  BCF    03.6
06DD:  CALL   425
....................             BREAK; 
06DE:  GOTO   6E6
....................        
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, "- RESET  "); 
06DF:  MOVLW  A5
06E0:  BSF    03.6
06E1:  MOVWF  0D
06E2:  MOVLW  00
06E3:  MOVWF  0F
06E4:  BCF    03.6
06E5:  CALL   425
....................             BREAK;  
....................          } 
....................       } 
06E6:  GOTO   68F
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
06E7:  BTFSC  5F.1
06E8:  GOTO   6EC
....................    { 
....................       SELLECT_FUN (); 
06E9:  BSF    0A.3
06EA:  GOTO   000
06EB:  BCF    0A.3
....................    } 
06EC:  BSF    0A.3
06ED:  BCF    0A.4
06EE:  GOTO   560 (RETURN)
....................  
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    *TEMP_CHAR2 = '\0'; 
*
0AB9:  CLRF   7A
0ABA:  MOVLW  7B
0ABB:  MOVWF  04
0ABC:  BCF    03.7
0ABD:  BTFSC  7A.0
0ABE:  BSF    03.7
0ABF:  CLRF   00
....................    *TT_DEVICE_CHAR = '\0'; 
0AC0:  CLRF   7A
0AC1:  MOVLW  62
0AC2:  MOVWF  04
0AC3:  BCF    03.7
0AC4:  BTFSC  7A.0
0AC5:  BSF    03.7
0AC6:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
0AC7:  BSF    03.6
0AC8:  CLRF   3E
0AC9:  MOVF   3E,W
0ACA:  SUBLW  07
0ACB:  BTFSS  03.0
0ACC:  GOTO   2FC
....................    { 
....................       IF (TT_DEVICE[I]) 
0ACD:  MOVF   3E,W
0ACE:  MOVWF  3F
0ACF:  CLRF   41
0AD0:  MOVLW  60
0AD1:  MOVWF  40
0AD2:  BCF    0A.3
0AD3:  BCF    03.6
0AD4:  CALL   62E
0AD5:  BSF    0A.3
0AD6:  BTFSS  78.0
0AD7:  GOTO   2F9
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
0AD8:  BSF    03.6
0AD9:  CLRF   42
0ADA:  CLRF   41
0ADB:  CLRF   40
0ADC:  MOVF   3E,W
0ADD:  MOVWF  3F
0ADE:  MOVLW  0A
0ADF:  MOVWF  43
0AE0:  CLRF   45
0AE1:  MOVLW  7B
0AE2:  MOVWF  44
0AE3:  BCF    0A.3
0AE4:  BCF    03.6
0AE5:  CALL   4F1
0AE6:  BSF    0A.3
....................          DELAY_MS (1); 
0AE7:  MOVLW  01
0AE8:  BSF    03.6
0AE9:  MOVWF  42
0AEA:  BCF    0A.3
0AEB:  BCF    03.6
0AEC:  CALL   103
0AED:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0AEE:  BSF    03.6
0AEF:  CLRF   40
0AF0:  MOVLW  62
0AF1:  MOVWF  3F
0AF2:  CLRF   42
0AF3:  MOVLW  7B
0AF4:  MOVWF  41
0AF5:  BCF    0A.3
0AF6:  BCF    03.6
0AF7:  CALL   6F7
0AF8:  BSF    0A.3
....................       } 
0AF9:  BSF    03.6
0AFA:  INCF   3E,F
0AFB:  GOTO   2C9
....................    } 
....................    TEMP_CHAR2 = "*"; 
0AFC:  CLRF   3F
0AFD:  CLRF   40
0AFE:  MOVLW  7B
0AFF:  MOVWF  04
0B00:  BCF    03.7
0B01:  MOVF   3F,W
0B02:  ADDWF  04,F
0B03:  MOVF   40,W
0B04:  BCF    0A.3
0B05:  BCF    03.6
0B06:  CALL   058
0B07:  BSF    0A.3
0B08:  MOVWF  00
0B09:  IORLW  00
0B0A:  BTFSC  03.2
0B0B:  GOTO   311
0B0C:  BSF    03.6
0B0D:  INCF   40,F
0B0E:  INCF   3F,F
0B0F:  GOTO   2FE
0B10:  BCF    03.6
....................    DELAY_MS (1); 
0B11:  MOVLW  01
0B12:  BSF    03.6
0B13:  MOVWF  42
0B14:  BCF    0A.3
0B15:  BCF    03.6
0B16:  CALL   103
0B17:  BSF    0A.3
....................    STRCAT (TT_DEVICE_CHAR, TEMP_CHAR2); 
0B18:  BSF    03.6
0B19:  CLRF   40
0B1A:  MOVLW  62
0B1B:  MOVWF  3F
0B1C:  CLRF   42
0B1D:  MOVLW  7B
0B1E:  MOVWF  41
0B1F:  BCF    0A.3
0B20:  BCF    03.6
0B21:  CALL   6F7
0B22:  BSF    0A.3
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR;      
0B23:  BSF    03.5
0B24:  CLRF   5C
0B25:  MOVLW  62
0B26:  MOVWF  5B
.................... } 
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    *TEMP_CHAR2 = '\0'; 
0B27:  CLRF   7A
0B28:  MOVLW  7B
0B29:  MOVWF  04
0B2A:  BCF    03.7
0B2B:  BTFSC  7A.0
0B2C:  BSF    03.7
0B2D:  CLRF   00
....................    *TEMP_CHAR = '\0';   
0B2E:  CLRF   7A
0B2F:  MOVLW  72
0B30:  MOVWF  04
0B31:  BCF    03.7
0B32:  BTFSC  7A.0
0B33:  BSF    03.7
0B34:  CLRF   00
....................    FOR (INT J = 0; J < 8; J++) 
0B35:  BCF    03.5
0B36:  BSF    03.6
0B37:  CLRF   3E
0B38:  MOVF   3E,W
0B39:  SUBLW  07
0B3A:  BTFSS  03.0
0B3B:  GOTO   36B
....................    { 
....................       IF (TT_SENSOR[J]) 
0B3C:  MOVF   3E,W
0B3D:  MOVWF  3F
0B3E:  CLRF   41
0B3F:  MOVLW  61
0B40:  MOVWF  40
0B41:  BCF    0A.3
0B42:  BCF    03.6
0B43:  CALL   62E
0B44:  BSF    0A.3
0B45:  BTFSS  78.0
0B46:  GOTO   368
....................       { 
....................          ITOA (J, 10, TEMP_CHAR2); 
0B47:  BSF    03.6
0B48:  CLRF   42
0B49:  CLRF   41
0B4A:  CLRF   40
0B4B:  MOVF   3E,W
0B4C:  MOVWF  3F
0B4D:  MOVLW  0A
0B4E:  MOVWF  43
0B4F:  CLRF   45
0B50:  MOVLW  7B
0B51:  MOVWF  44
0B52:  BCF    0A.3
0B53:  BCF    03.6
0B54:  CALL   4F1
0B55:  BSF    0A.3
....................          DELAY_MS (1); 
0B56:  MOVLW  01
0B57:  BSF    03.6
0B58:  MOVWF  42
0B59:  BCF    0A.3
0B5A:  BCF    03.6
0B5B:  CALL   103
0B5C:  BSF    0A.3
....................          STRCAT (TEMP_CHAR, TEMP_CHAR2);         
0B5D:  BSF    03.6
0B5E:  CLRF   40
0B5F:  MOVLW  72
0B60:  MOVWF  3F
0B61:  CLRF   42
0B62:  MOVLW  7B
0B63:  MOVWF  41
0B64:  BCF    0A.3
0B65:  BCF    03.6
0B66:  CALL   6F7
0B67:  BSF    0A.3
....................       } 
0B68:  BSF    03.6
0B69:  INCF   3E,F
0B6A:  GOTO   338
....................    } 
....................     
....................    TEMP_CHAR2 = "@"; 
0B6B:  CLRF   3F
0B6C:  CLRF   40
0B6D:  MOVLW  7B
0B6E:  MOVWF  04
0B6F:  BCF    03.7
0B70:  MOVF   3F,W
0B71:  ADDWF  04,F
0B72:  MOVF   40,W
0B73:  BCF    0A.3
0B74:  BCF    03.6
0B75:  CALL   05E
0B76:  BSF    0A.3
0B77:  MOVWF  00
0B78:  IORLW  00
0B79:  BTFSC  03.2
0B7A:  GOTO   380
0B7B:  BSF    03.6
0B7C:  INCF   40,F
0B7D:  INCF   3F,F
0B7E:  GOTO   36D
0B7F:  BCF    03.6
....................    DELAY_MS (1); 
0B80:  MOVLW  01
0B81:  BSF    03.6
0B82:  MOVWF  42
0B83:  BCF    0A.3
0B84:  BCF    03.6
0B85:  CALL   103
0B86:  BSF    0A.3
....................    STRCAT (TEMP_CHAR, TEMP_CHAR2); 
0B87:  BSF    03.6
0B88:  CLRF   40
0B89:  MOVLW  72
0B8A:  MOVWF  3F
0B8B:  CLRF   42
0B8C:  MOVLW  7B
0B8D:  MOVWF  41
0B8E:  BCF    0A.3
0B8F:  BCF    03.6
0B90:  CALL   6F7
0B91:  BSF    0A.3
....................    PACKAGE_CONFIG[6] = TEMP_CHAR;  
0B92:  BSF    03.5
0B93:  CLRF   5E
0B94:  MOVLW  72
0B95:  MOVWF  5D
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0A8B:  BCF    5F.2
....................    TT_STT = 0; 
0A8C:  BCF    5F.3
....................    TT_DEVICE_CHAR = ""; 
0A8D:  BSF    03.6
0A8E:  CLRF   3E
0A8F:  CLRF   3F
0A90:  MOVLW  62
0A91:  MOVWF  04
0A92:  BCF    03.7
0A93:  MOVF   3E,W
0A94:  ADDWF  04,F
0A95:  MOVF   3F,W
0A96:  BCF    0A.3
0A97:  BCF    03.6
0A98:  CALL   064
0A99:  BSF    0A.3
0A9A:  MOVWF  00
0A9B:  IORLW  00
0A9C:  BTFSC  03.2
0A9D:  GOTO   2A3
0A9E:  BSF    03.6
0A9F:  INCF   3F,F
0AA0:  INCF   3E,F
0AA1:  GOTO   290
0AA2:  BCF    03.6
....................    TT_SENSOR_CHAR = "";    
0AA3:  BSF    03.6
0AA4:  CLRF   3E
0AA5:  CLRF   3F
0AA6:  MOVLW  66
0AA7:  MOVWF  04
0AA8:  BCF    03.7
0AA9:  MOVF   3E,W
0AAA:  ADDWF  04,F
0AAB:  MOVF   3F,W
0AAC:  BCF    0A.3
0AAD:  BCF    03.6
0AAE:  CALL   064
0AAF:  BSF    0A.3
0AB0:  MOVWF  00
0AB1:  IORLW  00
0AB2:  BTFSC  03.2
0AB3:  GOTO   2B9
0AB4:  BSF    03.6
0AB5:  INCF   3F,F
0AB6:  INCF   3E,F
0AB7:  GOTO   2A6
0AB8:  BCF    03.6
....................    XULYDEVICE_CF(); 
....................    XULYSENSOR_CF(); 
....................    PACKAGE_CONFIG[1] = ID_; 
*
0B96:  CLRF   54
0B97:  MOVLW  70
0B98:  MOVWF  53
....................    FOR (INT J = 0; J < 8; J++) 
0B99:  BCF    03.5
0B9A:  BSF    03.6
0B9B:  CLRF   3D
0B9C:  MOVF   3D,W
0B9D:  SUBLW  07
0B9E:  BTFSS  03.0
0B9F:  GOTO   3BD
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0BA0:  BCF    03.0
0BA1:  RLF    3D,W
0BA2:  ADDLW  D1
0BA3:  MOVWF  04
0BA4:  BCF    03.7
0BA5:  INCF   04,F
0BA6:  MOVF   00,W
0BA7:  MOVWF  3F
0BA8:  DECF   04,F
0BA9:  MOVF   00,W
0BAA:  MOVWF  3E
0BAB:  MOVWF  04
0BAC:  BCF    03.7
0BAD:  BTFSC  3F.0
0BAE:  BSF    03.7
0BAF:  BCF    0A.3
0BB0:  BCF    03.6
0BB1:  CALL   735
0BB2:  BSF    0A.3
....................       DELAY_MS (1); 
0BB3:  MOVLW  01
0BB4:  BSF    03.6
0BB5:  MOVWF  42
0BB6:  BCF    0A.3
0BB7:  BCF    03.6
0BB8:  CALL   103
0BB9:  BSF    0A.3
0BBA:  BSF    03.6
0BBB:  INCF   3D,F
0BBC:  GOTO   39C
....................    } 
....................  
....................    LCD_GOTOXY (1, 1) ; 
0BBD:  MOVLW  01
0BBE:  MOVWF  42
0BBF:  MOVWF  43
0BC0:  BCF    0A.3
0BC1:  BCF    03.6
0BC2:  CALL   3D7
0BC3:  BSF    0A.3
....................    DELAY_MS (10); 
0BC4:  MOVLW  0A
0BC5:  BSF    03.6
0BC6:  MOVWF  42
0BC7:  BCF    0A.3
0BC8:  BCF    03.6
0BC9:  CALL   103
0BCA:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE"); 
0BCB:  MOVLW  AA
0BCC:  BSF    03.6
0BCD:  MOVWF  0D
0BCE:  MOVLW  00
0BCF:  MOVWF  0F
0BD0:  BCF    0A.3
0BD1:  BCF    03.6
0BD2:  CALL   425
0BD3:  BSF    0A.3
....................  
....................    LCD_GOTOXY (1, 2) ; 
0BD4:  MOVLW  01
0BD5:  BSF    03.6
0BD6:  MOVWF  42
0BD7:  MOVLW  02
0BD8:  MOVWF  43
0BD9:  BCF    0A.3
0BDA:  BCF    03.6
0BDB:  CALL   3D7
0BDC:  BSF    0A.3
....................    DELAY_MS (10); 
0BDD:  MOVLW  0A
0BDE:  BSF    03.6
0BDF:  MOVWF  42
0BE0:  BCF    0A.3
0BE1:  BCF    03.6
0BE2:  CALL   103
0BE3:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE");    
0BE4:  MOVLW  B0
0BE5:  BSF    03.6
0BE6:  MOVWF  0D
0BE7:  MOVLW  00
0BE8:  MOVWF  0F
0BE9:  BCF    0A.3
0BEA:  BCF    03.6
0BEB:  CALL   425
0BEC:  BSF    0A.3
....................    PACKAGE_NHIETDO[1] = ID_; 
0BED:  BSF    03.5
0BEE:  CLRF   23
0BEF:  MOVLW  70
0BF0:  MOVWF  22
....................    TT_CONFIG_DONE = 0; 
0BF1:  BCF    03.5
0BF2:  BCF    5F.1
0BF3:  BSF    0A.3
0BF4:  BCF    0A.4
0BF5:  GOTO   565 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID QUET_PHIM() 
*
00B6:  BSF    03.6
00B7:  CLRF   64
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00B8:  BSF    03.5
00B9:  BCF    03.6
00BA:  BSF    06.1
00BB:  BCF    03.5
00BC:  BTFSC  06.1
00BD:  GOTO   0D1
....................    { 
....................       IF (TMR1IF) 
00BE:  BTFSS  0C.0
00BF:  GOTO   0CE
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00C0:  BSF    03.5
00C1:  BCF    08.2
00C2:  MOVLW  04
00C3:  BCF    03.5
00C4:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00C5:  BCF    0C.0
00C6:  CLRF   0E
00C7:  MOVLW  0B
00C8:  MOVWF  0F
00C9:  MOVLW  DC
00CA:  MOVWF  0E
00CB:  BSF    03.6
00CC:  INCF   64,F
00CD:  BCF    03.6
....................       } 
00CE:  BSF    03.6
00CF:  GOTO   0B8
00D0:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00D1:  BSF    03.6
00D2:  MOVF   64,W
00D3:  SUBLW  14
00D4:  BTFSC  03.0
00D5:  GOTO   0DD
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00D6:  MOVLW  01
00D7:  BCF    03.6
00D8:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00D9:  BSF    5F.1
....................       TT_FUN = 0; 
00DA:  BCF    5F.2
....................    } 
00DB:  GOTO   0E1
00DC:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
00E1:  BCF    0B.1
00E2:  BCF    0A.3
00E3:  BCF    0A.4
00E4:  GOTO   031
....................  #INT_RDA 
....................  
....................  VOID NGAT() 
....................  { 
....................     KYTU[VT] = GETCH (); 
00E5:  MOVLW  3C
00E6:  ADDWF  5A,W
00E7:  MOVWF  04
00E8:  BCF    03.7
00E9:  BTFSS  0C.5
00EA:  GOTO   0E9
00EB:  MOVF   1A,W
00EC:  MOVWF  00
....................  
....................     IF (KYTU[VT] == '.') 
00ED:  MOVLW  3C
00EE:  ADDWF  5A,W
00EF:  MOVWF  04
00F0:  BCF    03.7
00F1:  MOVF   00,W
00F2:  SUBLW  2E
00F3:  BTFSS  03.2
00F4:  GOTO   0FE
....................     { 
....................        KYTU[VT] = '\0'; 
00F5:  MOVLW  3C
00F6:  ADDWF  5A,W
00F7:  MOVWF  04
00F8:  BCF    03.7
00F9:  CLRF   00
....................        VT = 0; 
00FA:  CLRF   5A
....................        TTNHAN = 1; 
00FB:  MOVLW  01
00FC:  MOVWF  5B
....................     } 
00FD:  GOTO   0FF
....................  
....................     ELSE 
....................     VT++; 
00FE:  INCF   5A,F
00FF:  BCF    0C.5
0100:  BCF    0A.3
0101:  BCF    0A.4
0102:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
076B:  MOVLW  01
076C:  BSF    03.6
076D:  MOVWF  42
076E:  MOVWF  43
076F:  BCF    03.6
0770:  CALL   3D7
....................     DELAY_MS (10); 
0771:  MOVLW  0A
0772:  BSF    03.6
0773:  MOVWF  42
0774:  BCF    03.6
0775:  CALL   103
....................     PRINTF (LCD_PUTC, KYTU); 
0776:  MOVLW  3C
0777:  MOVWF  04
0778:  BCF    03.7
0779:  CALL   611
....................     DELAY_MS (1); 
077A:  MOVLW  01
077B:  BSF    03.6
077C:  MOVWF  42
077D:  BCF    03.6
077E:  CALL   103
077F:  BSF    0A.3
0780:  BCF    0A.4
0781:  GOTO   5E2 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
0283:  BSF    03.6
0284:  RLF    3D,W
0285:  MOVWF  77
0286:  RLF    77,F
0287:  MOVLW  FC
0288:  ANDWF  77,F
0289:  BCF    03.6
028A:  MOVF   1F,W
028B:  ANDLW  C3
028C:  IORWF  77,W
028D:  MOVWF  1F
....................     KQADC = 0; 
028E:  CLRF   33
028F:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0290:  BSF    03.6
0291:  CLRF   3E
0292:  MOVF   3E,W
0293:  SUBLW  63
0294:  BTFSS  03.0
0295:  GOTO   2AA
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0296:  BCF    03.6
0297:  BSF    1F.1
0298:  BTFSC  1F.1
0299:  GOTO   298
029A:  BSF    03.5
029B:  MOVF   1E,W
029C:  BCF    03.5
029D:  ADDWF  32,F
029E:  MOVF   1E,W
029F:  BTFSC  03.0
02A0:  INCFSZ 1E,W
02A1:  ADDWF  33,F
....................        DELAY_MS (1); 
02A2:  MOVLW  01
02A3:  BSF    03.6
02A4:  MOVWF  42
02A5:  BCF    03.6
02A6:  CALL   103
02A7:  BSF    03.6
02A8:  INCF   3E,F
02A9:  GOTO   292
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
02AA:  BCF    03.6
02AB:  MOVF   33,W
02AC:  BSF    03.6
02AD:  MOVWF  40
02AE:  BCF    03.6
02AF:  MOVF   32,W
02B0:  BSF    03.6
02B1:  MOVWF  3F
*
02CE:  MOVF   7A,W
02CF:  MOVWF  42
02D0:  MOVF   79,W
02D1:  MOVWF  41
02D2:  MOVF   78,W
02D3:  MOVWF  40
02D4:  MOVF   77,W
02D5:  MOVWF  3F
02D6:  MOVLW  9A
02D7:  MOVWF  46
02D8:  MOVLW  99
02D9:  MOVWF  45
02DA:  MOVLW  4C
02DB:  MOVWF  44
02DC:  MOVLW  86
02DD:  MOVWF  43
*
03A7:  MOVF   7A,W
03A8:  MOVWF  42
03A9:  MOVF   79,W
03AA:  MOVWF  41
03AB:  MOVF   78,W
03AC:  MOVWF  40
03AD:  MOVF   77,W
03AE:  MOVWF  3F
*
03CD:  MOVF   79,W
03CE:  BCF    03.6
03CF:  MOVWF  33
03D0:  MOVF   78,W
03D1:  MOVWF  32
....................     RETURN KQADC; 
03D2:  MOVF   32,W
03D3:  MOVWF  78
03D4:  BSF    0A.3
03D5:  BCF    0A.4
03D6:  GOTO   558 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON  () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0753:  BSF    03.6
0754:  CLRF   3D
0755:  MOVF   3D,W
0756:  SUBLW  1E
0757:  BTFSS  03.0
0758:  GOTO   767
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
0759:  BSF    03.5
075A:  BCF    03.6
075B:  BCF    08.1
075C:  MOVLW  02
075D:  BCF    03.5
075E:  XORWF  08,F
....................        DELAY_MS (100); 
075F:  MOVLW  64
0760:  BSF    03.6
0761:  MOVWF  42
0762:  BCF    03.6
0763:  CALL   103
0764:  BSF    03.6
0765:  INCF   3D,F
0766:  GOTO   755
....................     } 
0767:  BCF    03.6
0768:  BSF    0A.3
0769:  BCF    0A.4
076A:  GOTO   56A (RETURN)
....................  } 
....................  
....................  VOID MAIN () 
*
0BF6:  MOVF   03,W
0BF7:  ANDLW  1F
0BF8:  MOVWF  03
0BF9:  BSF    03.5
0BFA:  BSF    03.6
0BFB:  BSF    07.3
0BFC:  MOVLW  08
0BFD:  BCF    03.6
0BFE:  MOVWF  19
0BFF:  MOVLW  02
0C00:  MOVWF  1A
0C01:  MOVLW  A6
0C02:  MOVWF  18
0C03:  MOVLW  90
0C04:  BCF    03.5
0C05:  MOVWF  18
0C06:  MOVLW  FF
0C07:  MOVWF  31
0C08:  CLRF   38
0C09:  CLRF   39
0C0A:  CLRF   3A
0C0B:  CLRF   3B
0C0C:  CLRF   5A
0C0D:  CLRF   5B
0C0E:  BCF    5F.0
0C0F:  BCF    5F.1
0C10:  BCF    5F.2
0C11:  BCF    5F.3
0C12:  BSF    03.5
0C13:  BSF    03.6
0C14:  MOVF   09,W
0C15:  ANDLW  C0
0C16:  MOVWF  09
0C17:  BCF    03.6
0C18:  BCF    1F.4
0C19:  BCF    1F.5
0C1A:  MOVLW  00
0C1B:  BSF    03.6
0C1C:  MOVWF  08
0C1D:  BCF    03.5
0C1E:  CLRF   07
0C1F:  CLRF   08
0C20:  CLRF   09
0C21:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0D17:  MOVLW  00
0D18:  BSF    03.5
0D19:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0D1A:  MOVLW  FF
0D1B:  MOVWF  06
....................     SET_TRIS_E (0); 
0D1C:  BCF    09.0
0D1D:  BCF    09.1
0D1E:  BCF    09.2
0D1F:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0D20:  MOVLW  80
0D21:  MOVWF  07
0D22:  BCF    03.5
0D23:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0D24:  BSF    1F.6
0D25:  BCF    1F.7
0D26:  BSF    03.5
0D27:  BSF    1F.7
0D28:  BCF    03.5
0D29:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0D2A:  BSF    03.5
0D2B:  BSF    03.6
0D2C:  MOVF   09,W
0D2D:  ANDLW  C0
0D2E:  MOVWF  09
0D2F:  BCF    03.6
0D30:  BCF    1F.4
0D31:  BCF    1F.5
0D32:  MOVLW  01
0D33:  BSF    03.6
0D34:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0D35:  BCF    03.5
0D36:  BCF    03.6
0D37:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0D38:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0D39:  BSF    0B.4
0D3A:  BSF    03.5
0D3B:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0D3C:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0D3D:  MOVLW  C0
0D3E:  BCF    03.5
0D3F:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0D40:  MOVLW  35
0D41:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0D42:  CLRF   0E
0D43:  MOVLW  0B
0D44:  MOVWF  0F
0D45:  MOVLW  DC
0D46:  MOVWF  0E
....................     TMR1IF = 0; 
0D47:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0D48:  BCF    0A.3
0D49:  GOTO   21D
0D4A:  BSF    0A.3
....................     ID_NODE = 0; 
0D4B:  CLRF   39
....................     TT_CONFIG = 0; 
0D4C:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0D4D:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0D4E:  BSF    03.5
0D4F:  CLRF   08
0D50:  BCF    03.5
0D51:  CLRF   08
....................     TTNHAN = 0; 
0D52:  CLRF   5B
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0D53:  BSF    03.6
0D54:  CLRF   3D
0D55:  BCF    0A.3
0D56:  BCF    03.6
0D57:  GOTO   283
0D58:  BSF    0A.3
0D59:  CLRF   35
0D5A:  MOVF   78,W
0D5B:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0D5C:  BTFSS  5F.0
0D5D:  GOTO   562
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0D5E:  BCF    0A.3
0D5F:  GOTO   669
0D60:  BSF    0A.3
....................        } 
0D61:  GOTO   605
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0D62:  BTFSS  5F.1
0D63:  GOTO   566
....................        { 
....................           CONFIG_DONE (); 
0D64:  GOTO   28B
....................        } 
0D65:  GOTO   605
....................  
....................         
....................        ELSE 
....................        {                    
....................             WHILE(!TT_CONFIG) 
0D66:  BTFSC  5F.0
0D67:  GOTO   605
....................             { 
....................                 CHUONG_TRINH_CON (); 
0D68:  BCF    0A.3
0D69:  GOTO   753
0D6A:  BSF    0A.3
....................                 IF (AN0 > 26) 
0D6B:  MOVF   35,F
0D6C:  BTFSS  03.2
0D6D:  GOTO   572
0D6E:  MOVF   34,W
0D6F:  SUBLW  1A
0D70:  BTFSC  03.0
0D71:  GOTO   5D3
....................                 { 
....................                    ITOA (AN0, 10, NHIETDO1); 
0D72:  BSF    03.6
0D73:  CLRF   42
0D74:  CLRF   41
0D75:  BCF    03.6
0D76:  MOVF   35,W
0D77:  BSF    03.6
0D78:  MOVWF  40
0D79:  BCF    03.6
0D7A:  MOVF   34,W
0D7B:  BSF    03.6
0D7C:  MOVWF  3F
0D7D:  MOVLW  0A
0D7E:  MOVWF  43
0D7F:  CLRF   45
0D80:  MOVLW  6A
0D81:  MOVWF  44
0D82:  BCF    0A.3
0D83:  BCF    03.6
0D84:  CALL   4F1
0D85:  BSF    0A.3
....................                    PACKAGE_NHIETDO[4] = NHIETDO1; 
0D86:  BSF    03.5
0D87:  CLRF   29
0D88:  MOVLW  6A
0D89:  MOVWF  28
....................                    ITOA (AN1, 10, NHIETDO2); 
0D8A:  BCF    03.5
0D8B:  BSF    03.6
0D8C:  CLRF   42
0D8D:  CLRF   41
0D8E:  BCF    03.6
0D8F:  MOVF   37,W
0D90:  BSF    03.6
0D91:  MOVWF  40
0D92:  BCF    03.6
0D93:  MOVF   36,W
0D94:  BSF    03.6
0D95:  MOVWF  3F
0D96:  MOVLW  0A
0D97:  MOVWF  43
0D98:  CLRF   45
0D99:  MOVLW  6D
0D9A:  MOVWF  44
0D9B:  BCF    0A.3
0D9C:  BCF    03.6
0D9D:  CALL   4F1
0D9E:  BSF    0A.3
....................                    PACKAGE_NHIETDO[5] = NHIETDO2; 
0D9F:  BSF    03.5
0DA0:  CLRF   2B
0DA1:  MOVLW  6D
0DA2:  MOVWF  2A
....................                     
....................                    FOR (INT I = 0; I < 8; I++) 
0DA3:  BCF    03.5
0DA4:  BSF    03.6
0DA5:  CLRF   3C
0DA6:  MOVF   3C,W
0DA7:  SUBLW  07
0DA8:  BTFSS  03.0
0DA9:  GOTO   5C7
....................                    { 
....................                       PRINTF (PACKAGE_NHIETDO[I]); 
0DAA:  BCF    03.0
0DAB:  RLF    3C,W
0DAC:  ADDLW  A0
0DAD:  MOVWF  04
0DAE:  BCF    03.7
0DAF:  INCF   04,F
0DB0:  MOVF   00,W
0DB1:  MOVWF  3E
0DB2:  DECF   04,F
0DB3:  MOVF   00,W
0DB4:  MOVWF  3D
0DB5:  MOVWF  04
0DB6:  BCF    03.7
0DB7:  BTFSC  3E.0
0DB8:  BSF    03.7
0DB9:  BCF    0A.3
0DBA:  BCF    03.6
0DBB:  CALL   735
0DBC:  BSF    0A.3
....................                       DELAY_MS (1); 
0DBD:  MOVLW  01
0DBE:  BSF    03.6
0DBF:  MOVWF  42
0DC0:  BCF    0A.3
0DC1:  BCF    03.6
0DC2:  CALL   103
0DC3:  BSF    0A.3
0DC4:  BSF    03.6
0DC5:  INCF   3C,F
0DC6:  GOTO   5A6
....................                    } 
....................        
....................                    DELAY_MS (1000); 
0DC7:  MOVLW  04
0DC8:  MOVWF  3D
0DC9:  MOVLW  FA
0DCA:  MOVWF  42
0DCB:  BCF    0A.3
0DCC:  BCF    03.6
0DCD:  CALL   103
0DCE:  BSF    0A.3
0DCF:  BSF    03.6
0DD0:  DECFSZ 3D,F
0DD1:  GOTO   5C9
0DD2:  BCF    03.6
....................                 } 
....................        
....................                 IF (TTNHAN == 1) 
0DD3:  DECFSZ 5B,W
0DD4:  GOTO   604
....................                 {              
....................                    TTNHAN = 0; 
0DD5:  CLRF   5B
....................                    //TEMP_CHAR = 'K'; 
....................                    ID_NODE_NHAN = KYTU[1] - 48; 
0DD6:  MOVLW  30
0DD7:  SUBWF  3D,W
0DD8:  MOVWF  5C
....................                    ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
0DD9:  MOVLW  30
0DDA:  SUBWF  3E,W
0DDB:  ADDLW  40
0DDC:  MOVWF  5D
....................                    TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D  (D0 = 64) 
0DDD:  MOVLW  30
0DDE:  SUBWF  3F,W
0DDF:  MOVWF  5E
....................                    XUATLCD (); 
0DE0:  BCF    0A.3
0DE1:  GOTO   76B
0DE2:  BSF    0A.3
....................        
....................                    IF (ID_NODE_NHAN == ID_NODE) 
0DE3:  MOVF   39,W
0DE4:  SUBWF  5C,W
0DE5:  BTFSS  03.2
0DE6:  GOTO   604
....................                    { 
....................                       OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0DE7:  MOVF   5E,F
0DE8:  BTFSS  03.2
0DE9:  GOTO   5EC
0DEA:  MOVLW  00
0DEB:  GOTO   5ED
0DEC:  MOVLW  01
0DED:  MOVWF  77
0DEE:  MOVF   5D,W
0DEF:  BSF    03.6
0DF0:  MOVWF  3E
0DF1:  MOVF   77,W
0DF2:  MOVWF  3F
0DF3:  CLRF   41
0DF4:  CLRF   40
0DF5:  BCF    0A.3
0DF6:  BCF    03.6
0DF7:  CALL   647
0DF8:  BSF    0A.3
0DF9:  MOVF   5D,W
0DFA:  BSF    03.6
0DFB:  MOVWF  3E
0DFC:  CLRF   3F
0DFD:  CLRF   41
0DFE:  MOVLW  80
0DFF:  MOVWF  40
0E00:  BCF    0A.3
0E01:  BCF    03.6
0E02:  CALL   647
0E03:  BSF    0A.3
....................                    } 
....................                 }           
0E04:  GOTO   566
....................               
....................             } 
....................        } 
0E05:  GOTO   553
....................     } 
....................  } 
....................  
0E06:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
