CCS PCM C Compiler, Version 5.015, 5967               17-Oct-21 00:45

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3303 words (40%)
                           Largest free fragment is 2048
               RAM used:   196 (53%) at main() level
                           236 (64%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   3DB
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   07E
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0AD
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  00
005D:  BCF    0A.0
005E:  BCF    0A.1
005F:  BCF    0A.2
0060:  ADDWF  02,F
0061:  RETLW  2A
0062:  RETLW  00
0063:  BCF    0A.0
0064:  BCF    0A.1
0065:  BCF    0A.2
0066:  ADDWF  02,F
0067:  RETLW  40
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 00,00
006C:  DATA C4,22
006D:  DATA D6,24
006E:  DATA C3,22
006F:  DATA 3A,10
0070:  DATA 00,01
0071:  DATA D3,22
0072:  DATA CE,29
0073:  DATA 4F,29
0074:  DATA 3A,10
0075:  DATA 00,01
0076:  DATA C3,27
0077:  DATA 4E,23
0078:  DATA C9,23
0079:  DATA 00,01
007A:  DATA C3,20
007B:  DATA D3,22
007C:  DATA 3A,10
007D:  DATA 00,00
*
027A:  MOVLW  8E
027B:  MOVWF  77
027C:  MOVF   38,W
027D:  MOVWF  78
027E:  MOVF   37,W
027F:  MOVWF  79
0280:  CLRF   7A
0281:  MOVF   78,F
0282:  BTFSS  03.2
0283:  GOTO   28E
0284:  MOVF   79,W
0285:  MOVWF  78
0286:  CLRF   79
0287:  MOVLW  08
0288:  SUBWF  77,F
0289:  MOVF   78,F
028A:  BTFSS  03.2
028B:  GOTO   28E
028C:  CLRF   77
028D:  GOTO   296
028E:  BCF    03.0
028F:  BTFSC  78.7
0290:  GOTO   295
0291:  RLF    79,F
0292:  RLF    78,F
0293:  DECF   77,F
0294:  GOTO   28E
0295:  BCF    78.7
*
02A6:  MOVF   37,W
02A7:  BTFSC  03.2
02A8:  GOTO   36B
02A9:  MOVWF  43
02AA:  MOVF   3B,W
02AB:  BTFSC  03.2
02AC:  GOTO   36B
02AD:  SUBWF  43,F
02AE:  BTFSS  03.0
02AF:  GOTO   2B5
02B0:  MOVLW  7F
02B1:  ADDWF  43,F
02B2:  BTFSC  03.0
02B3:  GOTO   36B
02B4:  GOTO   2BB
02B5:  MOVLW  81
02B6:  SUBWF  43,F
02B7:  BTFSS  03.0
02B8:  GOTO   36B
02B9:  BTFSC  03.2
02BA:  GOTO   36B
02BB:  MOVF   43,W
02BC:  MOVWF  77
02BD:  CLRF   78
02BE:  CLRF   79
02BF:  CLRF   7A
02C0:  CLRF   42
02C1:  MOVF   38,W
02C2:  MOVWF  41
02C3:  BSF    41.7
02C4:  MOVF   39,W
02C5:  MOVWF  40
02C6:  MOVF   3A,W
02C7:  MOVWF  3F
02C8:  MOVLW  19
02C9:  MOVWF  43
02CA:  MOVF   3E,W
02CB:  SUBWF  3F,F
02CC:  BTFSC  03.0
02CD:  GOTO   2DE
02CE:  MOVLW  01
02CF:  SUBWF  40,F
02D0:  BTFSC  03.0
02D1:  GOTO   2DE
02D2:  SUBWF  41,F
02D3:  BTFSC  03.0
02D4:  GOTO   2DE
02D5:  SUBWF  42,F
02D6:  BTFSC  03.0
02D7:  GOTO   2DE
02D8:  INCF   42,F
02D9:  INCF   41,F
02DA:  INCF   40,F
02DB:  MOVF   3E,W
02DC:  ADDWF  3F,F
02DD:  GOTO   310
02DE:  MOVF   3D,W
02DF:  SUBWF  40,F
02E0:  BTFSC  03.0
02E1:  GOTO   2F9
02E2:  MOVLW  01
02E3:  SUBWF  41,F
02E4:  BTFSC  03.0
02E5:  GOTO   2F9
02E6:  SUBWF  42,F
02E7:  BTFSC  03.0
02E8:  GOTO   2F9
02E9:  INCF   42,F
02EA:  INCF   41,F
02EB:  MOVF   3D,W
02EC:  ADDWF  40,F
02ED:  MOVF   3E,W
02EE:  ADDWF  3F,F
02EF:  BTFSS  03.0
02F0:  GOTO   310
02F1:  INCF   40,F
02F2:  BTFSS  03.2
02F3:  GOTO   310
02F4:  INCF   41,F
02F5:  BTFSS  03.2
02F6:  GOTO   310
02F7:  INCF   42,F
02F8:  GOTO   310
02F9:  MOVF   3C,W
02FA:  IORLW  80
02FB:  SUBWF  41,F
02FC:  BTFSC  03.0
02FD:  GOTO   30F
02FE:  MOVLW  01
02FF:  SUBWF  42,F
0300:  BTFSC  03.0
0301:  GOTO   30F
0302:  INCF   42,F
0303:  MOVF   3C,W
0304:  IORLW  80
0305:  ADDWF  41,F
0306:  MOVF   3D,W
0307:  ADDWF  40,F
0308:  BTFSS  03.0
0309:  GOTO   2ED
030A:  INCF   41,F
030B:  BTFSS  03.2
030C:  GOTO   2ED
030D:  INCF   42,F
030E:  GOTO   2ED
030F:  BSF    7A.0
0310:  DECFSZ 43,F
0311:  GOTO   313
0312:  GOTO   31E
0313:  BCF    03.0
0314:  RLF    3F,F
0315:  RLF    40,F
0316:  RLF    41,F
0317:  RLF    42,F
0318:  BCF    03.0
0319:  RLF    7A,F
031A:  RLF    79,F
031B:  RLF    78,F
031C:  RLF    44,F
031D:  GOTO   2CA
031E:  BTFSS  44.0
031F:  GOTO   326
0320:  BCF    03.0
0321:  RRF    78,F
0322:  RRF    79,F
0323:  RRF    7A,F
0324:  RRF    44,F
0325:  GOTO   329
0326:  DECF   77,F
0327:  BTFSC  03.2
0328:  GOTO   36B
0329:  BTFSC  44.7
032A:  GOTO   352
032B:  BCF    03.0
032C:  RLF    3F,F
032D:  RLF    40,F
032E:  RLF    41,F
032F:  RLF    42,F
0330:  MOVF   3E,W
0331:  SUBWF  3F,F
0332:  BTFSC  03.0
0333:  GOTO   33E
0334:  MOVLW  01
0335:  SUBWF  40,F
0336:  BTFSC  03.0
0337:  GOTO   33E
0338:  SUBWF  41,F
0339:  BTFSC  03.0
033A:  GOTO   33E
033B:  SUBWF  42,F
033C:  BTFSS  03.0
033D:  GOTO   361
033E:  MOVF   3D,W
033F:  SUBWF  40,F
0340:  BTFSC  03.0
0341:  GOTO   349
0342:  MOVLW  01
0343:  SUBWF  41,F
0344:  BTFSC  03.0
0345:  GOTO   349
0346:  SUBWF  42,F
0347:  BTFSS  03.0
0348:  GOTO   361
0349:  MOVF   3C,W
034A:  IORLW  80
034B:  SUBWF  41,F
034C:  BTFSC  03.0
034D:  GOTO   352
034E:  MOVLW  01
034F:  SUBWF  42,F
0350:  BTFSS  03.0
0351:  GOTO   361
0352:  INCF   7A,F
0353:  BTFSS  03.2
0354:  GOTO   361
0355:  INCF   79,F
0356:  BTFSS  03.2
0357:  GOTO   361
0358:  INCF   78,F
0359:  BTFSS  03.2
035A:  GOTO   361
035B:  INCF   77,F
035C:  BTFSC  03.2
035D:  GOTO   36B
035E:  RRF    78,F
035F:  RRF    79,F
0360:  RRF    7A,F
0361:  MOVF   38,W
0362:  MOVWF  43
0363:  MOVF   3C,W
0364:  XORWF  43,F
0365:  BTFSS  43.7
0366:  GOTO   369
0367:  BSF    78.7
0368:  GOTO   36F
0369:  BCF    78.7
036A:  GOTO   36F
036B:  CLRF   77
036C:  CLRF   78
036D:  CLRF   79
036E:  CLRF   7A
*
0377:  MOVLW  8E
0378:  MOVWF  77
0379:  MOVF   37,W
037A:  SUBWF  77,F
037B:  MOVF   38,W
037C:  MOVWF  79
037D:  MOVF   39,W
037E:  MOVWF  78
037F:  BSF    79.7
0380:  MOVF   77,F
0381:  BTFSC  03.2
0382:  GOTO   38E
0383:  BCF    03.0
0384:  MOVF   79,F
0385:  BTFSS  03.2
0386:  GOTO   38A
0387:  MOVF   78,F
0388:  BTFSC  03.2
0389:  GOTO   38E
038A:  RRF    79,F
038B:  RRF    78,F
038C:  DECFSZ 77,F
038D:  GOTO   383
038E:  BTFSS  38.7
038F:  GOTO   395
0390:  COMF   78,F
0391:  COMF   79,F
0392:  INCF   78,F
0393:  BTFSC  03.2
0394:  INCF   79,F
*
03ED:  MOVF   0B,W
03EE:  BSF    03.6
03EF:  MOVWF  35
03F0:  BCF    03.6
03F1:  BCF    0B.7
03F2:  BSF    03.5
03F3:  BSF    03.6
03F4:  BSF    0C.7
03F5:  BSF    0C.0
03F6:  NOP
03F7:  NOP
03F8:  BCF    03.5
03F9:  BTFSS  35.7
03FA:  GOTO   3FE
03FB:  BCF    03.6
03FC:  BSF    0B.7
03FD:  BSF    03.6
03FE:  MOVF   0C,W
03FF:  ANDLW  7F
0400:  BTFSC  03.2
0401:  GOTO   43B
0402:  MOVWF  35
0403:  MOVF   0D,W
0404:  MOVWF  36
0405:  MOVF   0F,W
0406:  MOVWF  37
0407:  MOVF   35,W
0408:  MOVWF  39
0409:  BCF    03.6
040A:  CALL   3B3
040B:  BSF    03.6
040C:  MOVF   36,W
040D:  MOVWF  0D
040E:  MOVF   37,W
040F:  MOVWF  0F
0410:  BCF    03.6
0411:  MOVF   0B,W
0412:  BSF    03.6
0413:  MOVWF  38
0414:  BCF    03.6
0415:  BCF    0B.7
0416:  BSF    03.5
0417:  BSF    03.6
0418:  BSF    0C.7
0419:  BSF    0C.0
041A:  NOP
041B:  NOP
041C:  BCF    03.5
041D:  BTFSS  38.7
041E:  GOTO   422
041F:  BCF    03.6
0420:  BSF    0B.7
0421:  BSF    03.6
0422:  RLF    0C,W
0423:  RLF    0E,W
0424:  ANDLW  7F
0425:  BTFSC  03.2
0426:  GOTO   43B
0427:  MOVWF  35
0428:  MOVF   0D,W
0429:  MOVWF  36
042A:  MOVF   0F,W
042B:  MOVWF  37
042C:  MOVF   35,W
042D:  MOVWF  39
042E:  BCF    03.6
042F:  CALL   3B3
0430:  BSF    03.6
0431:  MOVF   36,W
0432:  MOVWF  0D
0433:  MOVF   37,W
0434:  MOVWF  0F
0435:  INCF   0D,F
0436:  BTFSC  03.2
0437:  INCF   0F,F
0438:  BCF    03.6
0439:  GOTO   3ED
043A:  BSF    03.6
043B:  BCF    03.6
043C:  RETURN
043D:  BTFSC  03.1
043E:  GOTO   442
043F:  MOVLW  56
0440:  MOVWF  04
0441:  BSF    03.7
0442:  BSF    03.6
0443:  MOVF   51,W
0444:  XORWF  55,W
0445:  ANDLW  80
0446:  MOVWF  5B
0447:  BTFSS  51.7
0448:  GOTO   454
0449:  COMF   4E,F
044A:  COMF   4F,F
044B:  COMF   50,F
044C:  COMF   51,F
044D:  INCF   4E,F
044E:  BTFSC  03.2
044F:  INCF   4F,F
0450:  BTFSC  03.2
0451:  INCF   50,F
0452:  BTFSC  03.2
0453:  INCF   51,F
0454:  BTFSS  55.7
0455:  GOTO   461
0456:  COMF   52,F
0457:  COMF   53,F
0458:  COMF   54,F
0459:  COMF   55,F
045A:  INCF   52,F
045B:  BTFSC  03.2
045C:  INCF   53,F
045D:  BTFSC  03.2
045E:  INCF   54,F
045F:  BTFSC  03.2
0460:  INCF   55,F
0461:  CLRF   77
0462:  CLRF   78
0463:  CLRF   79
0464:  CLRF   7A
0465:  CLRF   56
0466:  CLRF   57
0467:  CLRF   58
0468:  CLRF   59
0469:  MOVF   55,W
046A:  IORWF  54,W
046B:  IORWF  53,W
046C:  IORWF  52,W
046D:  BTFSC  03.2
046E:  GOTO   49F
046F:  MOVLW  20
0470:  MOVWF  5A
0471:  BCF    03.0
0472:  RLF    4E,F
0473:  RLF    4F,F
0474:  RLF    50,F
0475:  RLF    51,F
0476:  RLF    56,F
0477:  RLF    57,F
0478:  RLF    58,F
0479:  RLF    59,F
047A:  MOVF   55,W
047B:  SUBWF  59,W
047C:  BTFSS  03.2
047D:  GOTO   488
047E:  MOVF   54,W
047F:  SUBWF  58,W
0480:  BTFSS  03.2
0481:  GOTO   488
0482:  MOVF   53,W
0483:  SUBWF  57,W
0484:  BTFSS  03.2
0485:  GOTO   488
0486:  MOVF   52,W
0487:  SUBWF  56,W
0488:  BTFSS  03.0
0489:  GOTO   499
048A:  MOVF   52,W
048B:  SUBWF  56,F
048C:  MOVF   53,W
048D:  BTFSS  03.0
048E:  INCFSZ 53,W
048F:  SUBWF  57,F
0490:  MOVF   54,W
0491:  BTFSS  03.0
0492:  INCFSZ 54,W
0493:  SUBWF  58,F
0494:  MOVF   55,W
0495:  BTFSS  03.0
0496:  INCFSZ 55,W
0497:  SUBWF  59,F
0498:  BSF    03.0
0499:  RLF    77,F
049A:  RLF    78,F
049B:  RLF    79,F
049C:  RLF    7A,F
049D:  DECFSZ 5A,F
049E:  GOTO   471
049F:  BTFSS  5B.7
04A0:  GOTO   4AC
04A1:  COMF   77,F
04A2:  COMF   78,F
04A3:  COMF   79,F
04A4:  COMF   7A,F
04A5:  INCF   77,F
04A6:  BTFSC  03.2
04A7:  INCF   78,F
04A8:  BTFSC  03.2
04A9:  INCF   79,F
04AA:  BTFSC  03.2
04AB:  INCF   7A,F
04AC:  MOVF   56,W
04AD:  MOVWF  00
04AE:  INCF   04,F
04AF:  MOVF   57,W
04B0:  MOVWF  00
04B1:  INCF   04,F
04B2:  MOVF   58,W
04B3:  MOVWF  00
04B4:  INCF   04,F
04B5:  MOVF   59,W
04B6:  MOVWF  00
04B7:  BCF    03.6
04B8:  RETURN
*
04D2:  MOVLW  20
04D3:  MOVWF  52
04D4:  CLRF   4E
04D5:  CLRF   4F
04D6:  CLRF   50
04D7:  CLRF   51
04D8:  MOVF   49,W
04D9:  MOVWF  7A
04DA:  MOVF   48,W
04DB:  MOVWF  79
04DC:  MOVF   47,W
04DD:  MOVWF  78
04DE:  MOVF   46,W
04DF:  MOVWF  77
04E0:  BCF    03.0
04E1:  BTFSS  77.0
04E2:  GOTO   4F1
04E3:  MOVF   4A,W
04E4:  ADDWF  4E,F
04E5:  MOVF   4B,W
04E6:  BTFSC  03.0
04E7:  INCFSZ 4B,W
04E8:  ADDWF  4F,F
04E9:  MOVF   4C,W
04EA:  BTFSC  03.0
04EB:  INCFSZ 4C,W
04EC:  ADDWF  50,F
04ED:  MOVF   4D,W
04EE:  BTFSC  03.0
04EF:  INCFSZ 4D,W
04F0:  ADDWF  51,F
04F1:  RRF    51,F
04F2:  RRF    50,F
04F3:  RRF    4F,F
04F4:  RRF    4E,F
04F5:  RRF    7A,F
04F6:  RRF    79,F
04F7:  RRF    78,F
04F8:  RRF    77,F
04F9:  DECFSZ 52,F
04FA:  GOTO   4E0
*
05D9:  MOVF   00,F
05DA:  BTFSC  03.2
05DB:  GOTO   5F5
05DC:  BSF    03.6
05DD:  CLRF   38
05DE:  MOVF   04,W
05DF:  MOVWF  37
05E0:  BCF    38.0
05E1:  BTFSC  03.7
05E2:  BSF    38.0
05E3:  MOVF   00,W
05E4:  MOVWF  39
05E5:  BCF    03.6
05E6:  CALL   3B3
05E7:  BSF    03.6
05E8:  MOVF   37,W
05E9:  MOVWF  04
05EA:  BCF    03.7
05EB:  BTFSC  38.0
05EC:  BSF    03.7
05ED:  INCF   04,F
05EE:  BTFSS  03.2
05EF:  GOTO   5F3
05F0:  BCF    03.6
05F1:  INCF   05,F
05F2:  BSF    03.6
05F3:  BCF    03.6
05F4:  GOTO   5D9
05F5:  RETURN
05F6:  BSF    03.6
05F7:  MOVF   37,W
05F8:  ANDLW  07
05F9:  MOVWF  77
05FA:  RRF    37,W
05FB:  MOVWF  78
05FC:  RRF    78,F
05FD:  RRF    78,F
05FE:  MOVLW  1F
05FF:  ANDWF  78,F
0600:  MOVF   78,W
0601:  ADDWF  38,W
0602:  MOVWF  04
0603:  BCF    03.7
0604:  BTFSC  39.0
0605:  BSF    03.7
0606:  MOVF   00,W
0607:  MOVWF  78
0608:  INCF   77,F
0609:  GOTO   60B
060A:  RRF    78,F
060B:  DECFSZ 77,F
060C:  GOTO   60A
060D:  BCF    03.6
060E:  RETURN
060F:  BSF    03.6
0610:  MOVF   36,W
0611:  ANDLW  07
0612:  MOVWF  77
0613:  RRF    36,W
0614:  MOVWF  78
0615:  RRF    78,F
0616:  RRF    78,F
0617:  MOVLW  1F
0618:  ANDWF  78,F
0619:  MOVF   78,W
061A:  ADDWF  38,W
061B:  MOVWF  04
061C:  BCF    03.7
061D:  BTFSC  39.0
061E:  BSF    03.7
061F:  CLRF   78
0620:  INCF   78,F
0621:  INCF   77,F
0622:  GOTO   624
0623:  RLF    78,F
0624:  DECFSZ 77,F
0625:  GOTO   623
0626:  MOVF   37,F
0627:  BTFSC  03.2
0628:  GOTO   62C
0629:  MOVF   78,W
062A:  IORWF  00,F
062B:  GOTO   62F
062C:  COMF   78,F
062D:  MOVF   78,W
062E:  ANDWF  00,F
062F:  BCF    03.6
0630:  RETURN
*
06D0:  MOVF   00,F
06D1:  BTFSC  03.2
06D2:  GOTO   6ED
06D3:  BSF    03.6
06D4:  CLRF   3A
06D5:  MOVF   04,W
06D6:  MOVWF  39
06D7:  BCF    3A.0
06D8:  BTFSC  03.7
06D9:  BSF    3A.0
06DA:  MOVF   00,W
06DB:  BCF    03.6
06DC:  BTFSS  0C.4
06DD:  GOTO   6DC
06DE:  MOVWF  19
06DF:  BSF    03.6
06E0:  MOVF   39,W
06E1:  MOVWF  04
06E2:  BCF    03.7
06E3:  BTFSC  3A.0
06E4:  BSF    03.7
06E5:  INCF   04,F
06E6:  BTFSS  03.2
06E7:  GOTO   6EB
06E8:  BCF    03.6
06E9:  INCF   05,F
06EA:  BSF    03.6
06EB:  BCF    03.6
06EC:  GOTO   6D0
06ED:  RETURN
*
0A83:  BCF    0A.0
0A84:  BSF    0A.1
0A85:  BCF    0A.2
0A86:  ADDWF  02,F
0A87:  GOTO   007
0A88:  GOTO   06E
0A89:  GOTO   176
0A8A:  GOTO   27E
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0692:  BSF    03.6
0693:  MOVF   38,W
0694:  MOVWF  3C
0695:  MOVF   37,W
0696:  MOVWF  3B
0697:  MOVF   3C,W
0698:  MOVWF  7A
0699:  MOVF   3B,W
069A:  MOVWF  04
069B:  BCF    03.7
069C:  BTFSC  7A.0
069D:  BSF    03.7
069E:  MOVF   00,F
069F:  BTFSC  03.2
06A0:  GOTO   6A5
06A1:  INCF   3B,F
06A2:  BTFSC  03.2
06A3:  INCF   3C,F
06A4:  GOTO   697
....................    while(*s2 != '\0') 
06A5:  MOVF   3A,W
06A6:  MOVWF  7A
06A7:  MOVF   39,W
06A8:  MOVWF  04
06A9:  BCF    03.7
06AA:  BTFSC  7A.0
06AB:  BSF    03.7
06AC:  MOVF   00,F
06AD:  BTFSC  03.2
06AE:  GOTO   6C4
....................    { 
....................       *s = *s2; 
06AF:  MOVF   39,W
06B0:  MOVWF  04
06B1:  BCF    03.7
06B2:  BTFSC  3A.0
06B3:  BSF    03.7
06B4:  MOVF   00,W
06B5:  MOVWF  3F
06B6:  MOVF   3B,W
06B7:  MOVWF  04
06B8:  BCF    03.7
06B9:  BTFSC  3C.0
06BA:  BSF    03.7
06BB:  MOVF   3F,W
06BC:  MOVWF  00
....................       ++s; 
06BD:  INCF   3B,F
06BE:  BTFSC  03.2
06BF:  INCF   3C,F
....................       ++s2; 
06C0:  INCF   39,F
06C1:  BTFSC  03.2
06C2:  INCF   3A,F
06C3:  GOTO   6A5
....................    } 
....................  
....................    *s = '\0'; 
06C4:  MOVF   3B,W
06C5:  MOVWF  04
06C6:  BCF    03.7
06C7:  BTFSC  3C.0
06C8:  BSF    03.7
06C9:  CLRF   00
....................    return(s1); 
06CA:  MOVF   37,W
06CB:  MOVWF  78
06CC:  MOVF   38,W
06CD:  MOVWF  79
06CE:  BCF    03.6
06CF:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0C07:  BCF    03.6
0C08:  CLRF   2B
0C09:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
04B9:  BSF    03.6
04BA:  CLRF   41
04BB:  CLRF   40
04BC:  CLRF   3F
04BD:  MOVLW  01
04BE:  MOVWF  3E
04BF:  CLRF   43
04C0:  CLRF   44
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
04C1:  BTFSS  3A.7
04C2:  GOTO   503
....................          sign=1;        // Check for negative number 
04C3:  MOVLW  01
04C4:  MOVWF  43
....................          num*=-1; 
04C5:  MOVF   3A,W
04C6:  MOVWF  49
04C7:  MOVF   39,W
04C8:  MOVWF  48
04C9:  MOVF   38,W
04CA:  MOVWF  47
04CB:  MOVF   37,W
04CC:  MOVWF  46
04CD:  MOVLW  FF
04CE:  MOVWF  4D
04CF:  MOVWF  4C
04D0:  MOVWF  4B
04D1:  MOVWF  4A
*
04FB:  MOVF   7A,W
04FC:  MOVWF  3A
04FD:  MOVF   79,W
04FE:  MOVWF  39
04FF:  MOVF   78,W
0500:  MOVWF  38
0501:  MOVF   77,W
0502:  MOVWF  37
....................      } 
....................  
....................      while(temp>0) { 
0503:  MOVF   3E,F
0504:  BTFSS  03.2
0505:  GOTO   50F
0506:  MOVF   3F,F
0507:  BTFSS  03.2
0508:  GOTO   50F
0509:  MOVF   40,F
050A:  BTFSS  03.2
050B:  GOTO   50F
050C:  MOVF   41,F
050D:  BTFSC  03.2
050E:  GOTO   58B
....................          temp=(num/base); 
050F:  BCF    03.1
0510:  MOVF   3A,W
0511:  MOVWF  51
0512:  MOVF   39,W
0513:  MOVWF  50
0514:  MOVF   38,W
0515:  MOVWF  4F
0516:  MOVF   37,W
0517:  MOVWF  4E
0518:  CLRF   55
0519:  CLRF   54
051A:  CLRF   53
051B:  MOVF   3B,W
051C:  MOVWF  52
051D:  BCF    03.6
051E:  CALL   43D
051F:  MOVF   7A,W
0520:  BSF    03.6
0521:  MOVWF  41
0522:  MOVF   79,W
0523:  MOVWF  40
0524:  MOVF   78,W
0525:  MOVWF  3F
0526:  MOVF   77,W
0527:  MOVWF  3E
....................          s[cnt]=(num%base)+'0';    // Conversion 
0528:  MOVF   44,W
0529:  ADDWF  3C,W
052A:  MOVWF  78
052B:  MOVF   3D,W
052C:  MOVWF  7A
052D:  BTFSC  03.0
052E:  INCF   7A,F
052F:  MOVF   78,W
0530:  MOVWF  46
0531:  MOVF   7A,W
0532:  MOVWF  47
0533:  CLRF   49
0534:  MOVF   04,W
0535:  MOVWF  48
0536:  BCF    49.0
0537:  BTFSC  03.7
0538:  BSF    49.0
0539:  BSF    03.1
053A:  MOVLW  4A
053B:  MOVWF  04
053C:  BSF    03.7
053D:  MOVF   3A,W
053E:  MOVWF  51
053F:  MOVF   39,W
0540:  MOVWF  50
0541:  MOVF   38,W
0542:  MOVWF  4F
0543:  MOVF   37,W
0544:  MOVWF  4E
0545:  CLRF   55
0546:  CLRF   54
0547:  CLRF   53
0548:  MOVF   3B,W
0549:  MOVWF  52
054A:  BCF    03.6
054B:  CALL   43D
054C:  BSF    03.6
054D:  MOVF   48,W
054E:  MOVWF  04
054F:  BCF    03.7
0550:  BTFSC  49.0
0551:  BSF    03.7
0552:  MOVLW  30
0553:  ADDWF  4A,W
0554:  MOVWF  77
0555:  MOVF   4B,W
0556:  MOVWF  78
0557:  MOVLW  00
0558:  BTFSC  03.0
0559:  MOVLW  01
055A:  ADDWF  78,F
055B:  MOVF   4C,W
055C:  MOVWF  79
055D:  MOVLW  00
055E:  BTFSC  03.0
055F:  MOVLW  01
0560:  ADDWF  79,F
0561:  MOVF   4D,W
0562:  MOVWF  7A
0563:  MOVLW  00
0564:  BTFSC  03.0
0565:  MOVLW  01
0566:  ADDWF  7A,F
0567:  MOVF   46,W
0568:  MOVWF  04
0569:  BCF    03.7
056A:  BTFSC  47.0
056B:  BSF    03.7
056C:  MOVF   77,W
056D:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
056E:  MOVF   44,W
056F:  ADDWF  3C,W
0570:  MOVWF  04
0571:  BCF    03.7
0572:  BTFSC  3D.0
0573:  BSF    03.7
0574:  MOVF   00,W
0575:  SUBLW  39
0576:  BTFSC  03.0
0577:  GOTO   581
....................             s[cnt]+=0x7; 
0578:  MOVF   44,W
0579:  ADDWF  3C,W
057A:  MOVWF  04
057B:  BCF    03.7
057C:  BTFSC  3D.0
057D:  BSF    03.7
057E:  MOVLW  07
057F:  ADDWF  00,W
0580:  MOVWF  00
....................  
....................          cnt++; 
0581:  INCF   44,F
....................          num=temp; 
0582:  MOVF   41,W
0583:  MOVWF  3A
0584:  MOVF   40,W
0585:  MOVWF  39
0586:  MOVF   3F,W
0587:  MOVWF  38
0588:  MOVF   3E,W
0589:  MOVWF  37
058A:  GOTO   503
....................      } 
....................  
....................      if(sign==1) { 
058B:  DECFSZ 43,W
058C:  GOTO   596
....................          s[cnt]=0x2D;      // Negative sign 
058D:  MOVF   44,W
058E:  ADDWF  3C,W
058F:  MOVWF  04
0590:  BCF    03.7
0591:  BTFSC  3D.0
0592:  BSF    03.7
0593:  MOVLW  2D
0594:  MOVWF  00
....................          cnt++; 
0595:  INCF   44,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0596:  CLRF   42
0597:  BCF    03.0
0598:  RRF    44,W
0599:  SUBWF  42,W
059A:  BTFSC  03.0
059B:  GOTO   5CC
....................  
....................          c=s[i]; 
059C:  MOVF   42,W
059D:  ADDWF  3C,W
059E:  MOVWF  04
059F:  BCF    03.7
05A0:  BTFSC  3D.0
05A1:  BSF    03.7
05A2:  MOVF   00,W
05A3:  MOVWF  45
....................          s[i]=s[cnt-i-1];        // Reverse the number 
05A4:  MOVF   42,W
05A5:  ADDWF  3C,W
05A6:  MOVWF  78
05A7:  MOVF   3D,W
05A8:  MOVWF  7A
05A9:  BTFSC  03.0
05AA:  INCF   7A,F
05AB:  MOVF   78,W
05AC:  MOVWF  46
05AD:  MOVF   7A,W
05AE:  MOVWF  47
05AF:  MOVF   42,W
05B0:  SUBWF  44,W
05B1:  ADDLW  FF
05B2:  ADDWF  3C,W
05B3:  MOVWF  04
05B4:  BCF    03.7
05B5:  BTFSC  3D.0
05B6:  BSF    03.7
05B7:  MOVF   00,W
05B8:  MOVWF  48
05B9:  MOVF   46,W
05BA:  MOVWF  04
05BB:  BCF    03.7
05BC:  BTFSC  47.0
05BD:  BSF    03.7
05BE:  MOVF   48,W
05BF:  MOVWF  00
....................          s[cnt-i-1]=c; 
05C0:  MOVF   42,W
05C1:  SUBWF  44,W
05C2:  ADDLW  FF
05C3:  ADDWF  3C,W
05C4:  MOVWF  04
05C5:  BCF    03.7
05C6:  BTFSC  3D.0
05C7:  BSF    03.7
05C8:  MOVF   45,W
05C9:  MOVWF  00
05CA:  INCF   42,F
05CB:  GOTO   597
....................      } 
....................      s[cnt]='\0';     // End the string 
05CC:  MOVF   44,W
05CD:  ADDWF  3C,W
05CE:  MOVWF  04
05CF:  BCF    03.7
05D0:  BTFSC  3D.0
05D1:  BSF    03.7
05D2:  CLRF   00
....................      return s; 
05D3:  MOVF   3C,W
05D4:  MOVWF  78
05D5:  MOVF   3D,W
05D6:  MOVWF  79
05D7:  BCF    03.6
05D8:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... //#INCLUDE <TV_LCD.C> 
.................... /* 
.................... INT ATOI(CONST CHAR *S) : STING --> S? NGUY?N 
.................... LONG ATOL(CONST CHAR *S) : STRING --> S? NGUY?N D?I 
.................... FLOAT ATOF(CONST CHAR *S) : STRING --> S? THUC 
.................... */ 
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
00CB:  MOVLW  3A
00CC:  MOVWF  04
00CD:  BSF    03.7
00CE:  MOVF   00,W
00CF:  BTFSC  03.2
00D0:  GOTO   0DE
00D1:  MOVLW  06
00D2:  MOVWF  78
00D3:  CLRF   77
00D4:  DECFSZ 77,F
00D5:  GOTO   0D4
00D6:  DECFSZ 78,F
00D7:  GOTO   0D3
00D8:  MOVLW  7B
00D9:  MOVWF  77
00DA:  DECFSZ 77,F
00DB:  GOTO   0DA
00DC:  DECFSZ 00,F
00DD:  GOTO   0D1
00DE:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2                               
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0172:  BSF    07.0
....................    output_float(LCD_DATA5); 
0173:  BSF    07.1
....................    output_float(LCD_DATA6); 
0174:  BSF    07.2
....................    output_float(LCD_DATA7); 
0175:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0176:  BCF    03.5
0177:  BSF    09.2
0178:  BSF    03.5
0179:  BCF    09.2
....................    delay_cycles(1); 
017A:  NOP
....................    lcd_output_enable(1); 
017B:  BCF    03.5
017C:  BSF    09.0
017D:  BSF    03.5
017E:  BCF    09.0
....................    delay_cycles(1); 
017F:  NOP
....................    high = lcd_read_nibble(); 
0180:  BCF    03.5
0181:  CALL   127
0182:  MOVF   78,W
0183:  BSF    03.6
0184:  MOVWF  41
....................        
....................    lcd_output_enable(0); 
0185:  BCF    03.6
0186:  BCF    09.0
0187:  BSF    03.5
0188:  BCF    09.0
....................    delay_cycles(1); 
0189:  NOP
....................    lcd_output_enable(1); 
018A:  BCF    03.5
018B:  BSF    09.0
018C:  BSF    03.5
018D:  BCF    09.0
....................    delay_us(1); 
018E:  GOTO   18F
018F:  GOTO   190
0190:  NOP
....................    low = lcd_read_nibble(); 
0191:  BCF    03.5
0192:  CALL   127
0193:  MOVF   78,W
0194:  BSF    03.6
0195:  MOVWF  40
....................        
....................    lcd_output_enable(0); 
0196:  BCF    03.6
0197:  BCF    09.0
0198:  BSF    03.5
0199:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
019A:  BCF    03.5
019B:  BCF    31.0
019C:  MOVF   31,W
019D:  BSF    03.5
019E:  MOVWF  07
....................    output_drive(LCD_DATA5); 
019F:  BCF    03.5
01A0:  BCF    31.1
01A1:  MOVF   31,W
01A2:  BSF    03.5
01A3:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01A4:  BCF    03.5
01A5:  BCF    31.2
01A6:  MOVF   31,W
01A7:  BSF    03.5
01A8:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01A9:  BCF    03.5
01AA:  BCF    31.3
01AB:  MOVF   31,W
01AC:  BSF    03.5
01AD:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01AE:  BCF    03.5
01AF:  BSF    03.6
01B0:  SWAPF  41,W
01B1:  MOVWF  77
01B2:  MOVLW  F0
01B3:  ANDWF  77,F
01B4:  MOVF   77,W
01B5:  IORWF  40,W
01B6:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0127:  BSF    03.6
0128:  CLRF   42
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0129:  BCF    03.6
012A:  BSF    31.0
012B:  MOVF   31,W
012C:  BSF    03.5
012D:  MOVWF  07
012E:  MOVLW  00
012F:  BCF    03.5
0130:  BTFSC  07.0
0131:  MOVLW  01
0132:  BSF    03.6
0133:  IORWF  42,F
....................    n |= input(LCD_DATA5) << 1; 
0134:  BCF    03.6
0135:  BSF    31.1
0136:  MOVF   31,W
0137:  BSF    03.5
0138:  MOVWF  07
0139:  MOVLW  00
013A:  BCF    03.5
013B:  BTFSC  07.1
013C:  MOVLW  01
013D:  MOVWF  77
013E:  BCF    03.0
013F:  RLF    77,F
0140:  MOVF   77,W
0141:  BSF    03.6
0142:  IORWF  42,F
....................    n |= input(LCD_DATA6) << 2; 
0143:  BCF    03.6
0144:  BSF    31.2
0145:  MOVF   31,W
0146:  BSF    03.5
0147:  MOVWF  07
0148:  MOVLW  00
0149:  BCF    03.5
014A:  BTFSC  07.2
014B:  MOVLW  01
014C:  MOVWF  77
014D:  RLF    77,F
014E:  RLF    77,F
014F:  MOVLW  FC
0150:  ANDWF  77,F
0151:  MOVF   77,W
0152:  BSF    03.6
0153:  IORWF  42,F
....................    n |= input(LCD_DATA7) << 3; 
0154:  BCF    03.6
0155:  BSF    31.3
0156:  MOVF   31,W
0157:  BSF    03.5
0158:  MOVWF  07
0159:  MOVLW  00
015A:  BCF    03.5
015B:  BTFSC  07.3
015C:  MOVLW  01
015D:  MOVWF  77
015E:  RLF    77,F
015F:  RLF    77,F
0160:  RLF    77,F
0161:  MOVLW  F8
0162:  ANDWF  77,F
0163:  MOVF   77,W
0164:  BSF    03.6
0165:  IORWF  42,F
....................     
....................    return(n); 
0166:  MOVF   42,W
0167:  MOVWF  78
....................   #else 
0168:  BCF    03.6
0169:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
00DF:  BSF    03.6
00E0:  BTFSC  41.0
00E1:  GOTO   0E6
00E2:  BCF    03.6
00E3:  BCF    07.0
00E4:  GOTO   0E8
00E5:  BSF    03.6
00E6:  BCF    03.6
00E7:  BSF    07.0
00E8:  BCF    31.0
00E9:  MOVF   31,W
00EA:  BSF    03.5
00EB:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
00EC:  BCF    03.5
00ED:  BSF    03.6
00EE:  BTFSC  41.1
00EF:  GOTO   0F4
00F0:  BCF    03.6
00F1:  BCF    07.1
00F2:  GOTO   0F6
00F3:  BSF    03.6
00F4:  BCF    03.6
00F5:  BSF    07.1
00F6:  BCF    31.1
00F7:  MOVF   31,W
00F8:  BSF    03.5
00F9:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
00FA:  BCF    03.5
00FB:  BSF    03.6
00FC:  BTFSC  41.2
00FD:  GOTO   102
00FE:  BCF    03.6
00FF:  BCF    07.2
0100:  GOTO   104
0101:  BSF    03.6
0102:  BCF    03.6
0103:  BSF    07.2
0104:  BCF    31.2
0105:  MOVF   31,W
0106:  BSF    03.5
0107:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0108:  BCF    03.5
0109:  BSF    03.6
010A:  BTFSC  41.3
010B:  GOTO   110
010C:  BCF    03.6
010D:  BCF    07.3
010E:  GOTO   112
010F:  BSF    03.6
0110:  BCF    03.6
0111:  BSF    07.3
0112:  BCF    31.3
0113:  MOVF   31,W
0114:  BSF    03.5
0115:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0116:  NOP
....................    lcd_output_enable(1); 
0117:  BCF    03.5
0118:  BSF    09.0
0119:  BSF    03.5
011A:  BCF    09.0
....................    delay_us(2); 
011B:  MOVLW  02
011C:  MOVWF  77
011D:  DECFSZ 77,F
011E:  GOTO   11D
011F:  GOTO   120
0120:  NOP
....................    lcd_output_enable(0); 
0121:  BCF    03.5
0122:  BCF    09.0
0123:  BSF    03.5
0124:  BCF    09.0
0125:  BCF    03.5
0126:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
016A:  BSF    03.5
016B:  BCF    09.0
....................    lcd_rs_tris(); 
016C:  BCF    09.1
....................    lcd_rw_tris(); 
016D:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
016E:  BCF    03.5
016F:  BCF    09.1
0170:  BSF    03.5
0171:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01B7:  MOVF   78,W
01B8:  MOVWF  40
01B9:  BTFSS  40.7
01BA:  GOTO   1BE
01BB:  BSF    03.5
01BC:  BCF    03.6
01BD:  GOTO   172
....................    lcd_output_rs(address); 
01BE:  MOVF   3E,F
01BF:  BTFSS  03.2
01C0:  GOTO   1C5
01C1:  BCF    03.6
01C2:  BCF    09.1
01C3:  GOTO   1C7
01C4:  BSF    03.6
01C5:  BCF    03.6
01C6:  BSF    09.1
01C7:  BSF    03.5
01C8:  BCF    09.1
....................    delay_cycles(1); 
01C9:  NOP
....................    lcd_output_rw(0); 
01CA:  BCF    03.5
01CB:  BCF    09.2
01CC:  BSF    03.5
01CD:  BCF    09.2
....................    delay_cycles(1); 
01CE:  NOP
....................    lcd_output_enable(0); 
01CF:  BCF    03.5
01D0:  BCF    09.0
01D1:  BSF    03.5
01D2:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
01D3:  BCF    03.5
01D4:  BSF    03.6
01D5:  SWAPF  3F,W
01D6:  MOVWF  40
01D7:  MOVLW  0F
01D8:  ANDWF  40,F
01D9:  MOVF   40,W
01DA:  MOVWF  41
01DB:  BCF    03.6
01DC:  CALL   0DF
....................    lcd_send_nibble(n & 0xf); 
01DD:  BSF    03.6
01DE:  MOVF   3F,W
01DF:  ANDLW  0F
01E0:  MOVWF  40
01E1:  MOVWF  41
01E2:  BCF    03.6
01E3:  CALL   0DF
01E4:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
01E5:  MOVLW  28
01E6:  BSF    03.6
01E7:  MOVWF  36
01E8:  MOVLW  0C
01E9:  MOVWF  37
01EA:  MOVLW  01
01EB:  MOVWF  38
01EC:  MOVLW  06
01ED:  MOVWF  39
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
01EE:  BCF    03.6
01EF:  BCF    09.0
01F0:  BSF    03.5
01F1:  BCF    09.0
....................    lcd_output_rs(0); 
01F2:  BCF    03.5
01F3:  BCF    09.1
01F4:  BSF    03.5
01F5:  BCF    09.1
....................    lcd_output_rw(0); 
01F6:  BCF    03.5
01F7:  BCF    09.2
01F8:  BSF    03.5
01F9:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01FA:  BCF    03.5
01FB:  BCF    31.0
01FC:  MOVF   31,W
01FD:  BSF    03.5
01FE:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01FF:  BCF    03.5
0200:  BCF    31.1
0201:  MOVF   31,W
0202:  BSF    03.5
0203:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0204:  BCF    03.5
0205:  BCF    31.2
0206:  MOVF   31,W
0207:  BSF    03.5
0208:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0209:  BCF    03.5
020A:  BCF    31.3
020B:  MOVF   31,W
020C:  BSF    03.5
020D:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
020E:  BCF    09.0
....................    lcd_rs_tris(); 
020F:  BCF    09.1
....................    lcd_rw_tris(); 
0210:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0211:  MOVLW  0F
0212:  BCF    03.5
0213:  BSF    03.6
0214:  MOVWF  3A
0215:  BCF    03.6
0216:  CALL   0CB
....................    for(i=1;i<=3;++i) 
0217:  MOVLW  01
0218:  BSF    03.6
0219:  MOVWF  35
021A:  MOVF   35,W
021B:  SUBLW  03
021C:  BTFSS  03.0
021D:  GOTO   22A
....................    { 
....................        lcd_send_nibble(3); 
021E:  MOVLW  03
021F:  MOVWF  41
0220:  BCF    03.6
0221:  CALL   0DF
....................        delay_ms(5); 
0222:  MOVLW  05
0223:  BSF    03.6
0224:  MOVWF  3A
0225:  BCF    03.6
0226:  CALL   0CB
0227:  BSF    03.6
0228:  INCF   35,F
0229:  GOTO   21A
....................    } 
....................     
....................    lcd_send_nibble(2); 
022A:  MOVLW  02
022B:  MOVWF  41
022C:  BCF    03.6
022D:  CALL   0DF
....................    delay_ms(5); 
022E:  MOVLW  05
022F:  BSF    03.6
0230:  MOVWF  3A
0231:  BCF    03.6
0232:  CALL   0CB
....................    for(i=0;i<=3;++i) 
0233:  BSF    03.6
0234:  CLRF   35
0235:  MOVF   35,W
0236:  SUBLW  03
0237:  BTFSS  03.0
0238:  GOTO   247
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0239:  MOVLW  36
023A:  ADDWF  35,W
023B:  MOVWF  04
023C:  BSF    03.7
023D:  MOVF   00,W
023E:  MOVWF  3A
023F:  CLRF   3E
0240:  MOVF   3A,W
0241:  MOVWF  3F
0242:  BCF    03.6
0243:  CALL   16A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0244:  BSF    03.6
0245:  INCF   35,F
0246:  GOTO   235
0247:  BCF    03.6
0248:  BSF    0A.3
0249:  BCF    0A.4
024A:  GOTO   516 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
039F:  BSF    03.6
03A0:  DECFSZ 3B,W
03A1:  GOTO   3A3
03A2:  GOTO   3A6
....................       address=LCD_LINE_TWO; 
03A3:  MOVLW  40
03A4:  MOVWF  3C
03A5:  GOTO   3A7
....................    else 
....................       address=0; 
03A6:  CLRF   3C
....................       
....................    address+=x-1; 
03A7:  MOVLW  01
03A8:  SUBWF  3A,W
03A9:  ADDWF  3C,F
....................    lcd_send_byte(0,0x80|address); 
03AA:  MOVF   3C,W
03AB:  IORLW  80
03AC:  MOVWF  3D
03AD:  CLRF   3E
03AE:  MOVF   3D,W
03AF:  MOVWF  3F
03B0:  BCF    03.6
03B1:  CALL   16A
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03B2:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03B3:  BSF    03.6
03B4:  MOVF   39,W
03B5:  XORLW  07
03B6:  BCF    03.6
03B7:  BTFSC  03.2
03B8:  GOTO   3C3
03B9:  XORLW  0B
03BA:  BTFSC  03.2
03BB:  GOTO   3CA
03BC:  XORLW  06
03BD:  BTFSC  03.2
03BE:  GOTO   3D6
03BF:  XORLW  02
03C0:  BTFSC  03.2
03C1:  GOTO   3DE
03C2:  GOTO   3E5
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03C3:  MOVLW  01
03C4:  BSF    03.6
03C5:  MOVWF  3A
03C6:  MOVWF  3B
03C7:  BCF    03.6
03C8:  CALL   39F
03C9:  GOTO   3EC
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03CA:  BSF    03.6
03CB:  CLRF   3E
03CC:  MOVLW  01
03CD:  MOVWF  3F
03CE:  BCF    03.6
03CF:  CALL   16A
....................                      delay_ms(2); 
03D0:  MOVLW  02
03D1:  BSF    03.6
03D2:  MOVWF  3A
03D3:  BCF    03.6
03D4:  CALL   0CB
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03D5:  GOTO   3EC
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03D6:  MOVLW  01
03D7:  BSF    03.6
03D8:  MOVWF  3A
03D9:  MOVLW  02
03DA:  MOVWF  3B
03DB:  BCF    03.6
03DC:  CALL   39F
03DD:  GOTO   3EC
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03DE:  BSF    03.6
03DF:  CLRF   3E
03E0:  MOVLW  10
03E1:  MOVWF  3F
03E2:  BCF    03.6
03E3:  CALL   16A
03E4:  GOTO   3EC
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03E5:  MOVLW  01
03E6:  BSF    03.6
03E7:  MOVWF  3E
03E8:  MOVF   39,W
03E9:  MOVWF  3F
03EA:  BCF    03.6
03EB:  CALL   16A
....................      #endif 
....................    } 
03EC:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 KYTU[30], VT=0,TTNHAN=0;  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
....................  
.................... INT1 TT_CONFIG=0, TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
*
0C0A:  CLRF   60
.................... INT1 TT_SENSOR[8]={0, 0, 0, 0, 0, 0, 0, 0}; 
0C0B:  CLRF   61
.................... CHAR TT_DEVICE_CHAR[]=" "; 
0C0C:  MOVLW  20
0C0D:  MOVWF  62
0C0E:  CLRF   63
.................... CHAR TT_SENSOR_CHAR[]=" "; 
0C0F:  MOVWF  64
0C10:  CLRF   65
....................  
.................... CHAR *PACKAGE[]={"S","ID", "S_S" ,"LENGHT","DATA1", "DATA2","CHECKSUM","#"}; 
0C11:  MOVLW  53
0C12:  BSF    03.5
0C13:  MOVWF  20
0C14:  CLRF   21
0C15:  MOVLW  49
0C16:  MOVWF  22
0C17:  MOVLW  44
0C18:  MOVWF  23
0C19:  CLRF   24
0C1A:  MOVLW  53
0C1B:  MOVWF  25
0C1C:  MOVLW  5F
0C1D:  MOVWF  26
0C1E:  MOVLW  53
0C1F:  MOVWF  27
0C20:  CLRF   28
0C21:  MOVLW  4C
0C22:  MOVWF  29
0C23:  MOVLW  45
0C24:  MOVWF  2A
0C25:  MOVLW  4E
0C26:  MOVWF  2B
0C27:  MOVLW  47
0C28:  MOVWF  2C
0C29:  MOVLW  48
0C2A:  MOVWF  2D
0C2B:  MOVLW  54
0C2C:  MOVWF  2E
0C2D:  CLRF   2F
0C2E:  MOVLW  44
0C2F:  MOVWF  30
0C30:  MOVLW  41
0C31:  MOVWF  31
0C32:  MOVLW  54
0C33:  MOVWF  32
0C34:  MOVLW  41
0C35:  MOVWF  33
0C36:  MOVLW  31
0C37:  MOVWF  34
0C38:  CLRF   35
0C39:  MOVLW  44
0C3A:  MOVWF  36
0C3B:  MOVLW  41
0C3C:  MOVWF  37
0C3D:  MOVLW  54
0C3E:  MOVWF  38
0C3F:  MOVLW  41
0C40:  MOVWF  39
0C41:  MOVLW  32
0C42:  MOVWF  3A
0C43:  CLRF   3B
0C44:  MOVLW  43
0C45:  MOVWF  3C
0C46:  MOVLW  48
0C47:  MOVWF  3D
0C48:  MOVLW  45
0C49:  MOVWF  3E
0C4A:  MOVLW  43
0C4B:  MOVWF  3F
0C4C:  MOVLW  4B
0C4D:  MOVWF  40
0C4E:  MOVLW  53
0C4F:  MOVWF  41
0C50:  MOVLW  55
0C51:  MOVWF  42
0C52:  MOVLW  4D
0C53:  MOVWF  43
0C54:  CLRF   44
0C55:  MOVLW  23
0C56:  MOVWF  45
0C57:  CLRF   46
0C58:  BCF    03.5
0C59:  CLRF   67
0C5A:  MOVLW  A0
0C5B:  MOVWF  66
0C5C:  CLRF   69
0C5D:  MOVLW  A2
0C5E:  MOVWF  68
0C5F:  CLRF   6B
0C60:  MOVLW  A5
0C61:  MOVWF  6A
0C62:  CLRF   6D
0C63:  MOVLW  A9
0C64:  MOVWF  6C
0C65:  CLRF   6F
0C66:  MOVLW  B0
0C67:  MOVWF  6E
0C68:  CLRF   71
0C69:  MOVLW  B6
0C6A:  MOVWF  70
0C6B:  CLRF   73
0C6C:  MOVLW  BC
0C6D:  MOVWF  72
0C6E:  CLRF   75
0C6F:  MOVLW  C5
0C70:  MOVWF  74
.................... CHAR *PACKAGE_CONFIG[]={"S","ID", "C_F" ,"LENGHT","ID_", "DEVICE","SENSOR","#"}; 
0C71:  MOVLW  53
0C72:  BSF    03.6
0C73:  MOVWF  10
0C74:  CLRF   11
0C75:  MOVLW  49
0C76:  MOVWF  12
0C77:  MOVLW  44
0C78:  MOVWF  13
0C79:  CLRF   14
0C7A:  MOVLW  43
0C7B:  MOVWF  15
0C7C:  MOVLW  5F
0C7D:  MOVWF  16
0C7E:  MOVLW  46
0C7F:  MOVWF  17
0C80:  CLRF   18
0C81:  MOVLW  4C
0C82:  MOVWF  19
0C83:  MOVLW  45
0C84:  MOVWF  1A
0C85:  MOVLW  4E
0C86:  MOVWF  1B
0C87:  MOVLW  47
0C88:  MOVWF  1C
0C89:  MOVLW  48
0C8A:  MOVWF  1D
0C8B:  MOVLW  54
0C8C:  MOVWF  1E
0C8D:  CLRF   1F
0C8E:  MOVLW  49
0C8F:  MOVWF  20
0C90:  MOVLW  44
0C91:  MOVWF  21
0C92:  MOVLW  5F
0C93:  MOVWF  22
0C94:  CLRF   23
0C95:  MOVLW  44
0C96:  MOVWF  24
0C97:  MOVLW  45
0C98:  MOVWF  25
0C99:  MOVLW  56
0C9A:  MOVWF  26
0C9B:  MOVLW  49
0C9C:  MOVWF  27
0C9D:  MOVLW  43
0C9E:  MOVWF  28
0C9F:  MOVLW  45
0CA0:  MOVWF  29
0CA1:  CLRF   2A
0CA2:  MOVLW  53
0CA3:  MOVWF  2B
0CA4:  MOVLW  45
0CA5:  MOVWF  2C
0CA6:  MOVLW  4E
0CA7:  MOVWF  2D
0CA8:  MOVLW  53
0CA9:  MOVWF  2E
0CAA:  MOVLW  4F
0CAB:  MOVWF  2F
0CAC:  MOVLW  52
0CAD:  MOVWF  30
0CAE:  CLRF   31
0CAF:  MOVLW  23
0CB0:  MOVWF  32
0CB1:  CLRF   33
0CB2:  MOVLW  01
0CB3:  BSF    03.5
0CB4:  BCF    03.6
0CB5:  MOVWF  48
0CB6:  MOVLW  10
0CB7:  MOVWF  47
0CB8:  MOVLW  01
0CB9:  MOVWF  4A
0CBA:  MOVLW  12
0CBB:  MOVWF  49
0CBC:  MOVLW  01
0CBD:  MOVWF  4C
0CBE:  MOVLW  15
0CBF:  MOVWF  4B
0CC0:  MOVLW  01
0CC1:  MOVWF  4E
0CC2:  MOVLW  19
0CC3:  MOVWF  4D
0CC4:  MOVLW  01
0CC5:  MOVWF  50
0CC6:  MOVLW  20
0CC7:  MOVWF  4F
0CC8:  MOVLW  01
0CC9:  MOVWF  52
0CCA:  MOVLW  24
0CCB:  MOVWF  51
0CCC:  MOVLW  01
0CCD:  MOVWF  54
0CCE:  MOVLW  2B
0CCF:  MOVWF  53
0CD0:  MOVLW  01
0CD1:  MOVWF  56
0CD2:  MOVLW  32
0CD3:  MOVWF  55
.................... CHAR NHIETDO1[]="27"; 
0CD4:  MOVWF  7B
0CD5:  MOVLW  37
0CD6:  MOVWF  7C
0CD7:  CLRF   7D
.................... CHAR NHIETDO2[]="27"; 
0CD8:  MOVLW  32
0CD9:  MOVWF  57
0CDA:  MOVLW  37
0CDB:  MOVWF  58
0CDC:  CLRF   59
.................... CHAR ID_[]="0"; 
0CDD:  MOVLW  30
0CDE:  MOVWF  5A
0CDF:  CLRF   5B
.................... CHAR TEMP_CHAR[]="0"; 
0CE0:  MOVWF  5C
0CE1:  CLRF   5D
.................... CHAR TEMP_CHAR2[]="0"; 
0CE2:  MOVWF  5E
0CE3:  CLRF   5F
....................    
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    5F.1
....................    TT_STT = 1; 
0808:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  3A
080C:  MOVLW  02
080D:  MOVWF  3B
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   39F
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  3A
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   0CB
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID: "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   3ED
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  5F.3
0823:  GOTO   06D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   06C
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  35
0831:  MOVLW  96
0832:  MOVWF  3A
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   0CB
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 35,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   3A
083B:  CLRF   39
083C:  CLRF   38
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  37
0841:  MOVLW  0A
0842:  MOVWF  3B
0843:  CLRF   3D
0844:  MOVLW  DA
0845:  MOVWF  3C
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   4B9
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  3A
084D:  MOVLW  02
084E:  MOVWF  3B
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   39F
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  3A
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   0CB
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  DA
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BCF    0A.3
085E:  CALL   5D9
085F:  BSF    0A.3
....................          DELAY_MS (1); 
0860:  MOVLW  01
0861:  BSF    03.6
0862:  MOVWF  3A
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   0CB
0866:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0867:  BSF    03.5
0868:  BCF    08.0
0869:  MOVLW  01
086A:  BCF    03.5
086B:  XORWF  08,F
....................       } 
086C:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
086E:  BCF    5F.1
....................    TT_STT = 1; 
086F:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0870:  MOVLW  01
0871:  BSF    03.6
0872:  MOVWF  3A
0873:  MOVLW  02
0874:  MOVWF  3B
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   39F
0878:  BSF    0A.3
....................    DELAY_MS (10); 
0879:  MOVLW  0A
087A:  BSF    03.6
087B:  MOVWF  3A
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   0CB
087F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE: "); 
0880:  MOVLW  6C
0881:  BSF    03.6
0882:  MOVWF  0D
0883:  MOVLW  00
0884:  MOVWF  0F
0885:  BCF    0A.3
0886:  BCF    03.6
0887:  CALL   3ED
0888:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0889:  BTFSS  5F.3
088A:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
088B:  BSF    03.5
088C:  BSF    06.2
088D:  BCF    03.5
088E:  BTFSC  06.2
088F:  GOTO   11A
....................       { 
....................          STT_DEVICE ++; 
0890:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
0891:  MOVF   3A,W
0892:  SUBLW  07
0893:  BTFSS  03.0
0894:  CLRF   3A
....................          DELAY_MS (300); 
0895:  MOVLW  02
0896:  BSF    03.6
0897:  MOVWF  35
0898:  MOVLW  96
0899:  MOVWF  3A
089A:  BCF    0A.3
089B:  BCF    03.6
089C:  CALL   0CB
089D:  BSF    0A.3
089E:  BSF    03.6
089F:  DECFSZ 35,F
08A0:  GOTO   098
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08A1:  CLRF   3A
08A2:  CLRF   39
08A3:  CLRF   38
08A4:  BCF    03.6
08A5:  MOVF   3A,W
08A6:  BSF    03.6
08A7:  MOVWF  37
08A8:  MOVLW  0A
08A9:  MOVWF  3B
08AA:  CLRF   3D
08AB:  MOVLW  DC
08AC:  MOVWF  3C
08AD:  BCF    0A.3
08AE:  BCF    03.6
08AF:  CALL   4B9
08B0:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08B1:  MOVLW  09
08B2:  BSF    03.6
08B3:  MOVWF  3A
08B4:  MOVLW  02
08B5:  MOVWF  3B
08B6:  BCF    0A.3
08B7:  BCF    03.6
08B8:  CALL   39F
08B9:  BSF    0A.3
....................          DELAY_MS (10); 
08BA:  MOVLW  0A
08BB:  BSF    03.6
08BC:  MOVWF  3A
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   0CB
08C0:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08C1:  MOVLW  DC
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BCF    0A.3
08C5:  CALL   5D9
08C6:  BSF    0A.3
....................          DELAY_MS (1); 
08C7:  MOVLW  01
08C8:  BSF    03.6
08C9:  MOVWF  3A
08CA:  BCF    0A.3
08CB:  BCF    03.6
08CC:  CALL   0CB
08CD:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ":  "); 
08CE:  MOVLW  3A
08CF:  BSF    03.6
08D0:  MOVWF  39
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   3B3
08D4:  BSF    0A.3
08D5:  MOVLW  20
08D6:  BSF    03.6
08D7:  MOVWF  39
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   3B3
08DB:  BSF    0A.3
08DC:  MOVLW  20
08DD:  BSF    03.6
08DE:  MOVWF  39
08DF:  BCF    0A.3
08E0:  BCF    03.6
08E1:  CALL   3B3
08E2:  BSF    0A.3
....................          DELAY_MS (1); 
08E3:  MOVLW  01
08E4:  BSF    03.6
08E5:  MOVWF  3A
08E6:  BCF    0A.3
08E7:  BCF    03.6
08E8:  CALL   0CB
08E9:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
08EA:  MOVF   3A,W
08EB:  BSF    03.6
08EC:  MOVWF  37
08ED:  CLRF   39
08EE:  MOVLW  60
08EF:  MOVWF  38
08F0:  BCF    0A.3
08F1:  BCF    03.6
08F2:  CALL   5F6
08F3:  BSF    0A.3
08F4:  MOVLW  00
08F5:  BTFSC  78.0
08F6:  MOVLW  01
08F7:  BSF    03.6
08F8:  MOVWF  35
08F9:  CLRF   3A
08FA:  CLRF   39
08FB:  CLRF   38
08FC:  MOVF   35,W
08FD:  MOVWF  37
08FE:  MOVLW  0A
08FF:  MOVWF  3B
0900:  CLRF   3D
0901:  MOVLW  DC
0902:  MOVWF  3C
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   4B9
0906:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0907:  MOVLW  DC
0908:  MOVWF  04
0909:  BCF    03.7
090A:  BCF    0A.3
090B:  CALL   5D9
090C:  BSF    0A.3
....................          DELAY_MS (1); 
090D:  MOVLW  01
090E:  BSF    03.6
090F:  MOVWF  3A
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   0CB
0913:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0914:  BSF    03.5
0915:  BCF    08.0
0916:  MOVLW  01
0917:  BCF    03.5
0918:  XORWF  08,F
....................       } 
0919:  GOTO   174
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
091A:  BSF    03.5
091B:  BSF    06.3
091C:  BCF    03.5
091D:  BTFSC  06.3
091E:  GOTO   174
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
091F:  MOVF   3A,W
0920:  BSF    03.6
0921:  MOVWF  37
0922:  CLRF   39
0923:  MOVLW  60
0924:  MOVWF  38
0925:  BCF    0A.3
0926:  BCF    03.6
0927:  CALL   5F6
0928:  BSF    0A.3
0929:  MOVLW  00
092A:  BTFSS  78.0
092B:  MOVLW  01
092C:  BSF    03.6
092D:  MOVWF  35
092E:  BCF    03.6
092F:  MOVF   3A,W
0930:  BSF    03.6
0931:  MOVWF  36
0932:  MOVF   35,W
0933:  MOVWF  37
0934:  CLRF   39
0935:  MOVLW  60
0936:  MOVWF  38
0937:  BCF    0A.3
0938:  BCF    03.6
0939:  CALL   60F
093A:  BSF    0A.3
....................          LCD_GOTOXY (12, 2) ; 
093B:  MOVLW  0C
093C:  BSF    03.6
093D:  MOVWF  3A
093E:  MOVLW  02
093F:  MOVWF  3B
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   39F
0943:  BSF    0A.3
....................          DELAY_MS (300); 
0944:  MOVLW  02
0945:  BSF    03.6
0946:  MOVWF  35
0947:  MOVLW  96
0948:  MOVWF  3A
0949:  BCF    0A.3
094A:  BCF    03.6
094B:  CALL   0CB
094C:  BSF    0A.3
094D:  BSF    03.6
094E:  DECFSZ 35,F
094F:  GOTO   147
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0950:  BCF    03.6
0951:  MOVF   3A,W
0952:  BSF    03.6
0953:  MOVWF  37
0954:  CLRF   39
0955:  MOVLW  60
0956:  MOVWF  38
0957:  BCF    0A.3
0958:  BCF    03.6
0959:  CALL   5F6
095A:  BSF    0A.3
095B:  MOVLW  00
095C:  BTFSC  78.0
095D:  MOVLW  01
095E:  BSF    03.6
095F:  MOVWF  35
0960:  CLRF   3A
0961:  CLRF   39
0962:  CLRF   38
0963:  MOVF   35,W
0964:  MOVWF  37
0965:  MOVLW  0A
0966:  MOVWF  3B
0967:  CLRF   3D
0968:  MOVLW  DC
0969:  MOVWF  3C
096A:  BCF    0A.3
096B:  BCF    03.6
096C:  CALL   4B9
096D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
096E:  MOVLW  DC
096F:  MOVWF  04
0970:  BCF    03.7
0971:  BCF    0A.3
0972:  CALL   5D9
0973:  BSF    0A.3
....................       } 
0974:  GOTO   089
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0976:  BCF    5F.1
....................    TT_STT = 1; 
0977:  BSF    5F.3
....................    LCD_GOTOXY (1, 2) ; 
0978:  MOVLW  01
0979:  BSF    03.6
097A:  MOVWF  3A
097B:  MOVLW  02
097C:  MOVWF  3B
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   39F
0980:  BSF    0A.3
....................    DELAY_MS (10); 
0981:  MOVLW  0A
0982:  BSF    03.6
0983:  MOVWF  3A
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   0CB
0987:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR: "); 
0988:  MOVLW  71
0989:  BSF    03.6
098A:  MOVWF  0D
098B:  MOVLW  00
098C:  MOVWF  0F
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   3ED
0990:  BSF    0A.3
....................    WHILE (TT_STT) 
0991:  BTFSS  5F.3
0992:  GOTO   27D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0993:  BSF    03.5
0994:  BSF    06.2
0995:  BCF    03.5
0996:  BTFSC  06.2
0997:  GOTO   222
....................       { 
....................          STT_SENSOR ++; 
0998:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0999:  MOVF   3B,W
099A:  SUBLW  03
099B:  BTFSS  03.0
099C:  CLRF   3B
....................          DELAY_MS (300); 
099D:  MOVLW  02
099E:  BSF    03.6
099F:  MOVWF  35
09A0:  MOVLW  96
09A1:  MOVWF  3A
09A2:  BCF    0A.3
09A3:  BCF    03.6
09A4:  CALL   0CB
09A5:  BSF    0A.3
09A6:  BSF    03.6
09A7:  DECFSZ 35,F
09A8:  GOTO   1A0
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
09A9:  CLRF   3A
09AA:  CLRF   39
09AB:  CLRF   38
09AC:  BCF    03.6
09AD:  MOVF   3B,W
09AE:  BSF    03.6
09AF:  MOVWF  37
09B0:  MOVLW  0A
09B1:  MOVWF  3B
09B2:  CLRF   3D
09B3:  MOVLW  DC
09B4:  MOVWF  3C
09B5:  BCF    0A.3
09B6:  BCF    03.6
09B7:  CALL   4B9
09B8:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
09B9:  MOVLW  09
09BA:  BSF    03.6
09BB:  MOVWF  3A
09BC:  MOVLW  02
09BD:  MOVWF  3B
09BE:  BCF    0A.3
09BF:  BCF    03.6
09C0:  CALL   39F
09C1:  BSF    0A.3
....................          DELAY_MS (10); 
09C2:  MOVLW  0A
09C3:  BSF    03.6
09C4:  MOVWF  3A
09C5:  BCF    0A.3
09C6:  BCF    03.6
09C7:  CALL   0CB
09C8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09C9:  MOVLW  DC
09CA:  MOVWF  04
09CB:  BCF    03.7
09CC:  BCF    0A.3
09CD:  CALL   5D9
09CE:  BSF    0A.3
....................          DELAY_MS (1); 
09CF:  MOVLW  01
09D0:  BSF    03.6
09D1:  MOVWF  3A
09D2:  BCF    0A.3
09D3:  BCF    03.6
09D4:  CALL   0CB
09D5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ":  "); 
09D6:  MOVLW  3A
09D7:  BSF    03.6
09D8:  MOVWF  39
09D9:  BCF    0A.3
09DA:  BCF    03.6
09DB:  CALL   3B3
09DC:  BSF    0A.3
09DD:  MOVLW  20
09DE:  BSF    03.6
09DF:  MOVWF  39
09E0:  BCF    0A.3
09E1:  BCF    03.6
09E2:  CALL   3B3
09E3:  BSF    0A.3
09E4:  MOVLW  20
09E5:  BSF    03.6
09E6:  MOVWF  39
09E7:  BCF    0A.3
09E8:  BCF    03.6
09E9:  CALL   3B3
09EA:  BSF    0A.3
....................          DELAY_MS (1); 
09EB:  MOVLW  01
09EC:  BSF    03.6
09ED:  MOVWF  3A
09EE:  BCF    0A.3
09EF:  BCF    03.6
09F0:  CALL   0CB
09F1:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
09F2:  MOVF   3B,W
09F3:  BSF    03.6
09F4:  MOVWF  37
09F5:  CLRF   39
09F6:  MOVLW  61
09F7:  MOVWF  38
09F8:  BCF    0A.3
09F9:  BCF    03.6
09FA:  CALL   5F6
09FB:  BSF    0A.3
09FC:  MOVLW  00
09FD:  BTFSC  78.0
09FE:  MOVLW  01
09FF:  BSF    03.6
0A00:  MOVWF  35
0A01:  CLRF   3A
0A02:  CLRF   39
0A03:  CLRF   38
0A04:  MOVF   35,W
0A05:  MOVWF  37
0A06:  MOVLW  0A
0A07:  MOVWF  3B
0A08:  CLRF   3D
0A09:  MOVLW  DC
0A0A:  MOVWF  3C
0A0B:  BCF    0A.3
0A0C:  BCF    03.6
0A0D:  CALL   4B9
0A0E:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A0F:  MOVLW  DC
0A10:  MOVWF  04
0A11:  BCF    03.7
0A12:  BCF    0A.3
0A13:  CALL   5D9
0A14:  BSF    0A.3
....................          DELAY_MS (1); 
0A15:  MOVLW  01
0A16:  BSF    03.6
0A17:  MOVWF  3A
0A18:  BCF    0A.3
0A19:  BCF    03.6
0A1A:  CALL   0CB
0A1B:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0A1C:  BSF    03.5
0A1D:  BCF    08.0
0A1E:  MOVLW  01
0A1F:  BCF    03.5
0A20:  XORWF  08,F
....................       }    
0A21:  GOTO   27C
....................       ELSE IF (!INPUT (BT3_PIN)) 
0A22:  BSF    03.5
0A23:  BSF    06.3
0A24:  BCF    03.5
0A25:  BTFSC  06.3
0A26:  GOTO   27C
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0A27:  MOVF   3B,W
0A28:  BSF    03.6
0A29:  MOVWF  37
0A2A:  CLRF   39
0A2B:  MOVLW  61
0A2C:  MOVWF  38
0A2D:  BCF    0A.3
0A2E:  BCF    03.6
0A2F:  CALL   5F6
0A30:  BSF    0A.3
0A31:  MOVLW  00
0A32:  BTFSS  78.0
0A33:  MOVLW  01
0A34:  BSF    03.6
0A35:  MOVWF  35
0A36:  BCF    03.6
0A37:  MOVF   3B,W
0A38:  BSF    03.6
0A39:  MOVWF  36
0A3A:  MOVF   35,W
0A3B:  MOVWF  37
0A3C:  CLRF   39
0A3D:  MOVLW  61
0A3E:  MOVWF  38
0A3F:  BCF    0A.3
0A40:  BCF    03.6
0A41:  CALL   60F
0A42:  BSF    0A.3
....................          LCD_GOTOXY (12, 2) ; 
0A43:  MOVLW  0C
0A44:  BSF    03.6
0A45:  MOVWF  3A
0A46:  MOVLW  02
0A47:  MOVWF  3B
0A48:  BCF    0A.3
0A49:  BCF    03.6
0A4A:  CALL   39F
0A4B:  BSF    0A.3
....................          DELAY_MS (300); 
0A4C:  MOVLW  02
0A4D:  BSF    03.6
0A4E:  MOVWF  35
0A4F:  MOVLW  96
0A50:  MOVWF  3A
0A51:  BCF    0A.3
0A52:  BCF    03.6
0A53:  CALL   0CB
0A54:  BSF    0A.3
0A55:  BSF    03.6
0A56:  DECFSZ 35,F
0A57:  GOTO   24F
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A58:  BCF    03.6
0A59:  MOVF   3B,W
0A5A:  BSF    03.6
0A5B:  MOVWF  37
0A5C:  CLRF   39
0A5D:  MOVLW  61
0A5E:  MOVWF  38
0A5F:  BCF    0A.3
0A60:  BCF    03.6
0A61:  CALL   5F6
0A62:  BSF    0A.3
0A63:  MOVLW  00
0A64:  BTFSC  78.0
0A65:  MOVLW  01
0A66:  BSF    03.6
0A67:  MOVWF  35
0A68:  CLRF   3A
0A69:  CLRF   39
0A6A:  CLRF   38
0A6B:  MOVF   35,W
0A6C:  MOVWF  37
0A6D:  MOVLW  0A
0A6E:  MOVWF  3B
0A6F:  CLRF   3D
0A70:  MOVLW  DC
0A71:  MOVWF  3C
0A72:  BCF    0A.3
0A73:  BCF    03.6
0A74:  CALL   4B9
0A75:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A76:  MOVLW  DC
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  BCF    0A.3
0A7A:  CALL   5D9
0A7B:  BSF    0A.3
....................       }   
0A7C:  GOTO   191
....................        
....................    } 
.................... } 
....................  
....................  
.................... VOID RESET_CONFIG() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0A7E:  BCF    5F.1
....................    ID_NODE = 0; 
0A7F:  CLRF   39
....................    //TT_SENSOR = {0, 0, 0, 0, 0, 0, 0, 0}; 
....................    //TT_DEVICE = {0, 0, 0, 0, 0, 0, 0, 0}; 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00A5:  BCF    03.6
00A6:  BCF    5F.1
....................    TT_FUN = 0; 
00A7:  BCF    5F.2
....................    TT_STT = 0; 
00A8:  BCF    5F.3
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    5F.1
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   280
0805:  ADDLW  04
0806:  GOTO   283
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
086D:  GOTO   280
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
0975:  GOTO   280
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR ();       
....................       BREAK; 
*
0A7D:  GOTO   280
....................  
....................       CASE 3: 
....................       RESET_CONFIG (); 
....................       BREAK; 
....................    } 
*
0A80:  BCF    0A.3
0A81:  BCF    0A.4
0A82:  GOTO   68E (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0631:  BSF    5F.2
....................    LCD_GOTOXY (1, 1) ; 
0632:  MOVLW  01
0633:  BSF    03.6
0634:  MOVWF  3A
0635:  MOVWF  3B
0636:  BCF    03.6
0637:  CALL   39F
....................    DELAY_MS (10); 
0638:  MOVLW  0A
0639:  BSF    03.6
063A:  MOVWF  3A
063B:  BCF    03.6
063C:  CALL   0CB
....................    PRINTF (LCD_PUTC, "CONFIG"); 
063D:  MOVLW  76
063E:  BSF    03.6
063F:  MOVWF  0D
0640:  MOVLW  00
0641:  MOVWF  0F
0642:  BCF    03.6
0643:  CALL   3ED
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0644:  MOVLW  01
0645:  BSF    03.6
0646:  MOVWF  3A
0647:  MOVLW  02
0648:  MOVWF  3B
0649:  BCF    03.6
064A:  CALL   39F
....................    DELAY_MS (10); 
064B:  MOVLW  0A
064C:  BSF    03.6
064D:  MOVWF  3A
064E:  BCF    03.6
064F:  CALL   0CB
....................    PRINTF (LCD_PUTC, "CASE: "); 
0650:  MOVLW  7A
0651:  BSF    03.6
0652:  MOVWF  0D
0653:  MOVLW  00
0654:  MOVWF  0F
0655:  BCF    03.6
0656:  CALL   3ED
....................  
....................    WHILE (TT_FUN) 
0657:  BTFSS  5F.2
0658:  GOTO   68C
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0659:  BSF    03.5
065A:  BSF    06.2
065B:  BCF    03.5
065C:  BTFSC  06.2
065D:  GOTO   68B
....................       { 
....................          CONFIG_FUN ++; 
065E:  INCF   38,F
....................          IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
065F:  MOVF   38,W
0660:  SUBLW  03
0661:  BTFSS  03.0
0662:  CLRF   38
....................          DELAY_MS (300); 
0663:  MOVLW  02
0664:  BSF    03.6
0665:  MOVWF  35
0666:  MOVLW  96
0667:  MOVWF  3A
0668:  BCF    03.6
0669:  CALL   0CB
066A:  BSF    03.6
066B:  DECFSZ 35,F
066C:  GOTO   666
....................           
....................          //HIEN THI 
....................          LCD_GOTOXY (9, 2) ; 
066D:  MOVLW  09
066E:  MOVWF  3A
066F:  MOVLW  02
0670:  MOVWF  3B
0671:  BCF    03.6
0672:  CALL   39F
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0673:  BSF    03.6
0674:  CLRF   3A
0675:  CLRF   39
0676:  CLRF   38
0677:  BCF    03.6
0678:  MOVF   38,W
0679:  BSF    03.6
067A:  MOVWF  37
067B:  MOVLW  0A
067C:  MOVWF  3B
067D:  CLRF   3D
067E:  MOVLW  DC
067F:  MOVWF  3C
0680:  BCF    03.6
0681:  CALL   4B9
....................          DELAY_MS (10); 
0682:  MOVLW  0A
0683:  BSF    03.6
0684:  MOVWF  3A
0685:  BCF    03.6
0686:  CALL   0CB
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0687:  MOVLW  DC
0688:  MOVWF  04
0689:  BCF    03.7
068A:  CALL   5D9
....................       } 
068B:  GOTO   657
....................    } 
....................    ////// 
....................    SELLECT_FUN (); 
068C:  BSF    0A.3
068D:  GOTO   000
068E:  BCF    0A.3
068F:  BSF    0A.3
0690:  BCF    0A.4
0691:  GOTO   52C (RETURN)
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0A8B:  BCF    5F.2
....................    TT_STT = 0; 
0A8C:  BCF    5F.3
....................    TT_DEVICE_CHAR = ""; 
0A8D:  BSF    03.6
0A8E:  CLRF   37
0A8F:  CLRF   38
0A90:  MOVLW  62
0A91:  MOVWF  04
0A92:  BCF    03.7
0A93:  MOVF   37,W
0A94:  ADDWF  04,F
0A95:  MOVF   38,W
0A96:  BCF    0A.3
0A97:  BCF    03.6
0A98:  CALL   058
0A99:  BSF    0A.3
0A9A:  MOVWF  00
0A9B:  IORLW  00
0A9C:  BTFSC  03.2
0A9D:  GOTO   2A3
0A9E:  BSF    03.6
0A9F:  INCF   38,F
0AA0:  INCF   37,F
0AA1:  GOTO   290
0AA2:  BCF    03.6
....................    TT_SENSOR_CHAR = "";   
0AA3:  BSF    03.6
0AA4:  CLRF   37
0AA5:  CLRF   38
0AA6:  MOVLW  64
0AA7:  MOVWF  04
0AA8:  BCF    03.7
0AA9:  MOVF   37,W
0AAA:  ADDWF  04,F
0AAB:  MOVF   38,W
0AAC:  BCF    0A.3
0AAD:  BCF    03.6
0AAE:  CALL   058
0AAF:  BSF    0A.3
0AB0:  MOVWF  00
0AB1:  IORLW  00
0AB2:  BTFSC  03.2
0AB3:  GOTO   2B9
0AB4:  BSF    03.6
0AB5:  INCF   38,F
0AB6:  INCF   37,F
0AB7:  GOTO   2A6
0AB8:  BCF    03.6
....................     
....................    TEMP_CHAR = "";     
0AB9:  BSF    03.6
0ABA:  CLRF   37
0ABB:  CLRF   38
0ABC:  MOVLW  DC
0ABD:  MOVWF  04
0ABE:  BCF    03.7
0ABF:  MOVF   37,W
0AC0:  ADDWF  04,F
0AC1:  MOVF   38,W
0AC2:  BCF    0A.3
0AC3:  BCF    03.6
0AC4:  CALL   058
0AC5:  BSF    0A.3
0AC6:  MOVWF  00
0AC7:  IORLW  00
0AC8:  BTFSC  03.2
0AC9:  GOTO   2CF
0ACA:  BSF    03.6
0ACB:  INCF   38,F
0ACC:  INCF   37,F
0ACD:  GOTO   2BC
0ACE:  BCF    03.6
....................    FOR (INT I = 0; I < 8; I++) 
0ACF:  BSF    03.6
0AD0:  CLRF   35
0AD1:  MOVF   35,W
0AD2:  SUBLW  07
0AD3:  BTFSS  03.0
0AD4:  GOTO   304
....................    { 
....................       IF (TT_DEVICE[I]) 
0AD5:  MOVF   35,W
0AD6:  MOVWF  37
0AD7:  CLRF   39
0AD8:  MOVLW  60
0AD9:  MOVWF  38
0ADA:  BCF    0A.3
0ADB:  BCF    03.6
0ADC:  CALL   5F6
0ADD:  BSF    0A.3
0ADE:  BTFSS  78.0
0ADF:  GOTO   301
....................       { 
....................          ITOA (I, 10, TEMP_CHAR); 
0AE0:  BSF    03.6
0AE1:  CLRF   3A
0AE2:  CLRF   39
0AE3:  CLRF   38
0AE4:  MOVF   35,W
0AE5:  MOVWF  37
0AE6:  MOVLW  0A
0AE7:  MOVWF  3B
0AE8:  CLRF   3D
0AE9:  MOVLW  DC
0AEA:  MOVWF  3C
0AEB:  BCF    0A.3
0AEC:  BCF    03.6
0AED:  CALL   4B9
0AEE:  BSF    0A.3
....................          DELAY_MS (1);          
0AEF:  MOVLW  01
0AF0:  BSF    03.6
0AF1:  MOVWF  3A
0AF2:  BCF    0A.3
0AF3:  BCF    03.6
0AF4:  CALL   0CB
0AF5:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
0AF6:  BSF    03.6
0AF7:  CLRF   38
0AF8:  MOVLW  62
0AF9:  MOVWF  37
0AFA:  CLRF   3A
0AFB:  MOVLW  DC
0AFC:  MOVWF  39
0AFD:  BCF    0A.3
0AFE:  BCF    03.6
0AFF:  CALL   692
0B00:  BSF    0A.3
....................       } 
0B01:  BSF    03.6
0B02:  INCF   35,F
0B03:  GOTO   2D1
....................    } 
....................  
....................    TEMP_CHAR = "*"; 
0B04:  CLRF   37
0B05:  CLRF   38
0B06:  MOVLW  DC
0B07:  MOVWF  04
0B08:  BCF    03.7
0B09:  MOVF   37,W
0B0A:  ADDWF  04,F
0B0B:  MOVF   38,W
0B0C:  BCF    0A.3
0B0D:  BCF    03.6
0B0E:  CALL   05D
0B0F:  BSF    0A.3
0B10:  MOVWF  00
0B11:  IORLW  00
0B12:  BTFSC  03.2
0B13:  GOTO   319
0B14:  BSF    03.6
0B15:  INCF   38,F
0B16:  INCF   37,F
0B17:  GOTO   306
0B18:  BCF    03.6
....................    STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
0B19:  BSF    03.6
0B1A:  CLRF   38
0B1B:  MOVLW  62
0B1C:  MOVWF  37
0B1D:  CLRF   3A
0B1E:  MOVLW  DC
0B1F:  MOVWF  39
0B20:  BCF    0A.3
0B21:  BCF    03.6
0B22:  CALL   692
0B23:  BSF    0A.3
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR;    
0B24:  BSF    03.5
0B25:  CLRF   52
0B26:  MOVLW  62
0B27:  MOVWF  51
....................  
....................     
....................     
....................   
....................    TEMP_CHAR2 = "";    
0B28:  BCF    03.5
0B29:  BSF    03.6
0B2A:  CLRF   37
0B2B:  CLRF   38
0B2C:  MOVLW  DE
0B2D:  MOVWF  04
0B2E:  BCF    03.7
0B2F:  MOVF   37,W
0B30:  ADDWF  04,F
0B31:  MOVF   38,W
0B32:  BCF    0A.3
0B33:  BCF    03.6
0B34:  CALL   058
0B35:  BSF    0A.3
0B36:  MOVWF  00
0B37:  IORLW  00
0B38:  BTFSC  03.2
0B39:  GOTO   33F
0B3A:  BSF    03.6
0B3B:  INCF   38,F
0B3C:  INCF   37,F
0B3D:  GOTO   32C
0B3E:  BCF    03.6
....................    //SENSOR 
....................    FOR ( I = 0; I < 8; I++) 
0B3F:  BSF    03.6
0B40:  CLRF   35
0B41:  MOVF   35,W
0B42:  SUBLW  07
0B43:  BTFSS  03.0
0B44:  GOTO   374
....................    { 
....................       IF (TT_SENSOR[I]) 
0B45:  MOVF   35,W
0B46:  MOVWF  37
0B47:  CLRF   39
0B48:  MOVLW  61
0B49:  MOVWF  38
0B4A:  BCF    0A.3
0B4B:  BCF    03.6
0B4C:  CALL   5F6
0B4D:  BSF    0A.3
0B4E:  BTFSS  78.0
0B4F:  GOTO   371
....................       { 
....................          ITOA (I, 10, TEMP_CHAR2); 
0B50:  BSF    03.6
0B51:  CLRF   3A
0B52:  CLRF   39
0B53:  CLRF   38
0B54:  MOVF   35,W
0B55:  MOVWF  37
0B56:  MOVLW  0A
0B57:  MOVWF  3B
0B58:  CLRF   3D
0B59:  MOVLW  DE
0B5A:  MOVWF  3C
0B5B:  BCF    0A.3
0B5C:  BCF    03.6
0B5D:  CALL   4B9
0B5E:  BSF    0A.3
....................          DELAY_MS (1);          
0B5F:  MOVLW  01
0B60:  BSF    03.6
0B61:  MOVWF  3A
0B62:  BCF    0A.3
0B63:  BCF    03.6
0B64:  CALL   0CB
0B65:  BSF    0A.3
....................          STRCAT (TT_SENSOR_CHAR, TEMP_CHAR2); 
0B66:  BSF    03.6
0B67:  CLRF   38
0B68:  MOVLW  64
0B69:  MOVWF  37
0B6A:  CLRF   3A
0B6B:  MOVLW  DE
0B6C:  MOVWF  39
0B6D:  BCF    0A.3
0B6E:  BCF    03.6
0B6F:  CALL   692
0B70:  BSF    0A.3
....................       } 
0B71:  BSF    03.6
0B72:  INCF   35,F
0B73:  GOTO   341
....................    } 
....................  
....................    TEMP_CHAR2 = "@"; 
0B74:  CLRF   37
0B75:  CLRF   38
0B76:  MOVLW  DE
0B77:  MOVWF  04
0B78:  BCF    03.7
0B79:  MOVF   37,W
0B7A:  ADDWF  04,F
0B7B:  MOVF   38,W
0B7C:  BCF    0A.3
0B7D:  BCF    03.6
0B7E:  CALL   063
0B7F:  BSF    0A.3
0B80:  MOVWF  00
0B81:  IORLW  00
0B82:  BTFSC  03.2
0B83:  GOTO   389
0B84:  BSF    03.6
0B85:  INCF   38,F
0B86:  INCF   37,F
0B87:  GOTO   376
0B88:  BCF    03.6
....................    STRCAT (TT_SENSOR_CHAR, TEMP_CHAR2); 
0B89:  BSF    03.6
0B8A:  CLRF   38
0B8B:  MOVLW  64
0B8C:  MOVWF  37
0B8D:  CLRF   3A
0B8E:  MOVLW  DE
0B8F:  MOVWF  39
0B90:  BCF    0A.3
0B91:  BCF    03.6
0B92:  CALL   692
0B93:  BSF    0A.3
....................    PACKAGE_CONFIG[6] = TEMP_CHAR2; 
0B94:  BSF    03.5
0B95:  CLRF   54
0B96:  MOVLW  DE
0B97:  MOVWF  53
....................     
....................     
....................    //ID 
....................    PACKAGE_CONFIG[1] = ID_; 
0B98:  CLRF   4A
0B99:  MOVLW  DA
0B9A:  MOVWF  49
....................     
....................    FOR (INT J = 0; J < 8; J++) 
0B9B:  BCF    03.5
0B9C:  BSF    03.6
0B9D:  CLRF   36
0B9E:  MOVF   36,W
0B9F:  SUBLW  07
0BA0:  BTFSS  03.0
0BA1:  GOTO   3BF
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0BA2:  BCF    03.0
0BA3:  RLF    36,W
0BA4:  ADDLW  C7
0BA5:  MOVWF  04
0BA6:  BCF    03.7
0BA7:  INCF   04,F
0BA8:  MOVF   00,W
0BA9:  MOVWF  38
0BAA:  DECF   04,F
0BAB:  MOVF   00,W
0BAC:  MOVWF  37
0BAD:  MOVWF  04
0BAE:  BCF    03.7
0BAF:  BTFSC  38.0
0BB0:  BSF    03.7
0BB1:  BCF    0A.3
0BB2:  BCF    03.6
0BB3:  CALL   6D0
0BB4:  BSF    0A.3
....................       DELAY_MS (1); 
0BB5:  MOVLW  01
0BB6:  BSF    03.6
0BB7:  MOVWF  3A
0BB8:  BCF    0A.3
0BB9:  BCF    03.6
0BBA:  CALL   0CB
0BBB:  BSF    0A.3
0BBC:  BSF    03.6
0BBD:  INCF   36,F
0BBE:  GOTO   39E
....................    } 
....................  
....................    LCD_GOTOXY (1, 2) ; 
0BBF:  MOVLW  01
0BC0:  MOVWF  3A
0BC1:  MOVLW  02
0BC2:  MOVWF  3B
0BC3:  BCF    0A.3
0BC4:  BCF    03.6
0BC5:  CALL   39F
0BC6:  BSF    0A.3
....................    DELAY_MS (10); 
0BC7:  MOVLW  0A
0BC8:  BSF    03.6
0BC9:  MOVWF  3A
0BCA:  BCF    0A.3
0BCB:  BCF    03.6
0BCC:  CALL   0CB
0BCD:  BSF    0A.3
....................    PRINTF (LCD_PUTC, TT_DEVICE_CHAR); 
0BCE:  MOVLW  62
0BCF:  MOVWF  04
0BD0:  BCF    03.7
0BD1:  BCF    0A.3
0BD2:  CALL   5D9
0BD3:  BSF    0A.3
....................    PACKAGE[1] = ID_; 
0BD4:  CLRF   69
0BD5:  MOVLW  DA
0BD6:  MOVWF  68
....................    TT_CONFIG_DONE = 0; 
0BD7:  BCF    5F.1
0BD8:  BSF    0A.3
0BD9:  BCF    0A.4
0BDA:  GOTO   530 (RETURN)
.................... } 
....................  
.................... VOID QUET_PHIM() 
*
007E:  BSF    03.6
007F:  CLRF   5C
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
0080:  BSF    03.5
0081:  BCF    03.6
0082:  BSF    06.1
0083:  BCF    03.5
0084:  BTFSC  06.1
0085:  GOTO   099
....................    { 
....................       IF (TMR1IF)       
0086:  BTFSS  0C.0
0087:  GOTO   096
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
0088:  BSF    03.5
0089:  BCF    08.2
008A:  MOVLW  04
008B:  BCF    03.5
008C:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
008D:  BCF    0C.0
008E:  CLRF   0E
008F:  MOVLW  0B
0090:  MOVWF  0F
0091:  MOVLW  DC
0092:  MOVWF  0E
0093:  BSF    03.6
0094:  INCF   5C,F
0095:  BCF    03.6
....................       } 
0096:  BSF    03.6
0097:  GOTO   080
0098:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 30) 
0099:  BSF    03.6
009A:  MOVF   5C,W
009B:  SUBLW  1E
009C:  BTFSC  03.0
009D:  GOTO   0A5
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
009E:  MOVLW  01
009F:  BCF    03.6
00A0:  XORWF  5F,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00A1:  BSF    5F.1
....................       TT_FUN = 0; 
00A2:  BCF    5F.2
....................    } 
00A3:  GOTO   0A9
00A4:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    }   
.................... } 
....................  
.................... #INT_EXT 
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
....................  
*
00A9:  BCF    0B.1
00AA:  BCF    0A.3
00AB:  BCF    0A.4
00AC:  GOTO   031
.................... #INT_RDA 
.................... VOID NGAT() 
.................... {    
....................    KYTU[VT] = GETCH (); 
00AD:  MOVLW  3C
00AE:  ADDWF  5A,W
00AF:  MOVWF  04
00B0:  BCF    03.7
00B1:  BTFSS  0C.5
00B2:  GOTO   0B1
00B3:  MOVF   1A,W
00B4:  MOVWF  00
....................    IF (KYTU[VT] == '.') 
00B5:  MOVLW  3C
00B6:  ADDWF  5A,W
00B7:  MOVWF  04
00B8:  BCF    03.7
00B9:  MOVF   00,W
00BA:  SUBLW  2E
00BB:  BTFSS  03.2
00BC:  GOTO   0C6
....................    { 
....................       KYTU[VT] = '\0'; 
00BD:  MOVLW  3C
00BE:  ADDWF  5A,W
00BF:  MOVWF  04
00C0:  BCF    03.7
00C1:  CLRF   00
....................       VT = 0; 
00C2:  CLRF   5A
....................       TTNHAN = 1; 
00C3:  MOVLW  01
00C4:  MOVWF  5B
....................    } 
00C5:  GOTO   0C7
....................    ELSE 
....................    VT++; 
00C6:  INCF   5A,F
00C7:  BCF    0C.5
00C8:  BCF    0A.3
00C9:  BCF    0A.4
00CA:  GOTO   031
.................... } 
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
0706:  MOVLW  01
0707:  BSF    03.6
0708:  MOVWF  3A
0709:  MOVWF  3B
070A:  BCF    03.6
070B:  CALL   39F
....................     DELAY_MS (10); 
070C:  MOVLW  0A
070D:  BSF    03.6
070E:  MOVWF  3A
070F:  BCF    03.6
0710:  CALL   0CB
....................     PRINTF (LCD_PUTC, KYTU); 
0711:  MOVLW  3C
0712:  MOVWF  04
0713:  BCF    03.7
0714:  CALL   5D9
....................     DELAY_MS (1); 
0715:  MOVLW  01
0716:  BSF    03.6
0717:  MOVWF  3A
0718:  BCF    03.6
0719:  CALL   0CB
071A:  BSF    0A.3
071B:  BCF    0A.4
071C:  GOTO   5A6 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
*
024B:  BSF    03.6
024C:  RLF    35,W
024D:  MOVWF  77
024E:  RLF    77,F
024F:  MOVLW  FC
0250:  ANDWF  77,F
0251:  BCF    03.6
0252:  MOVF   1F,W
0253:  ANDLW  C3
0254:  IORWF  77,W
0255:  MOVWF  1F
....................     KQADC = 0; 
0256:  CLRF   33
0257:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0258:  BSF    03.6
0259:  CLRF   36
025A:  MOVF   36,W
025B:  SUBLW  63
025C:  BTFSS  03.0
025D:  GOTO   272
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
025E:  BCF    03.6
025F:  BSF    1F.1
0260:  BTFSC  1F.1
0261:  GOTO   260
0262:  BSF    03.5
0263:  MOVF   1E,W
0264:  BCF    03.5
0265:  ADDWF  32,F
0266:  MOVF   1E,W
0267:  BTFSC  03.0
0268:  INCFSZ 1E,W
0269:  ADDWF  33,F
....................        DELAY_MS (1); 
026A:  MOVLW  01
026B:  BSF    03.6
026C:  MOVWF  3A
026D:  BCF    03.6
026E:  CALL   0CB
026F:  BSF    03.6
0270:  INCF   36,F
0271:  GOTO   25A
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0272:  BCF    03.6
0273:  MOVF   33,W
0274:  BSF    03.6
0275:  MOVWF  38
0276:  BCF    03.6
0277:  MOVF   32,W
0278:  BSF    03.6
0279:  MOVWF  37
*
0296:  MOVF   7A,W
0297:  MOVWF  3A
0298:  MOVF   79,W
0299:  MOVWF  39
029A:  MOVF   78,W
029B:  MOVWF  38
029C:  MOVF   77,W
029D:  MOVWF  37
029E:  MOVLW  9A
029F:  MOVWF  3E
02A0:  MOVLW  99
02A1:  MOVWF  3D
02A2:  MOVLW  4C
02A3:  MOVWF  3C
02A4:  MOVLW  86
02A5:  MOVWF  3B
*
036F:  MOVF   7A,W
0370:  MOVWF  3A
0371:  MOVF   79,W
0372:  MOVWF  39
0373:  MOVF   78,W
0374:  MOVWF  38
0375:  MOVF   77,W
0376:  MOVWF  37
*
0395:  MOVF   79,W
0396:  BCF    03.6
0397:  MOVWF  33
0398:  MOVF   78,W
0399:  MOVWF  32
....................     RETURN KQADC; 
039A:  MOVF   32,W
039B:  MOVWF  78
039C:  BSF    0A.3
039D:  BCF    0A.4
039E:  GOTO   524 (RETURN)
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
06EE:  BSF    03.6
06EF:  CLRF   35
06F0:  MOVF   35,W
06F1:  SUBLW  1E
06F2:  BTFSS  03.0
06F3:  GOTO   702
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
06F4:  BSF    03.5
06F5:  BCF    03.6
06F6:  BCF    08.1
06F7:  MOVLW  02
06F8:  BCF    03.5
06F9:  XORWF  08,F
....................        DELAY_MS (100); 
06FA:  MOVLW  64
06FB:  BSF    03.6
06FC:  MOVWF  3A
06FD:  BCF    03.6
06FE:  CALL   0CB
06FF:  BSF    03.6
0700:  INCF   35,F
0701:  GOTO   6F0
....................     } 
0702:  BCF    03.6
0703:  BSF    0A.3
0704:  BCF    0A.4
0705:  GOTO   532 (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0BDB:  MOVF   03,W
0BDC:  ANDLW  1F
0BDD:  MOVWF  03
0BDE:  BSF    03.5
0BDF:  BSF    03.6
0BE0:  BSF    07.3
0BE1:  MOVLW  08
0BE2:  BCF    03.6
0BE3:  MOVWF  19
0BE4:  MOVLW  02
0BE5:  MOVWF  1A
0BE6:  MOVLW  A6
0BE7:  MOVWF  18
0BE8:  MOVLW  90
0BE9:  BCF    03.5
0BEA:  MOVWF  18
0BEB:  MOVLW  FF
0BEC:  MOVWF  31
0BED:  CLRF   38
0BEE:  CLRF   39
0BEF:  CLRF   3A
0BF0:  CLRF   3B
0BF1:  CLRF   5A
0BF2:  CLRF   5B
0BF3:  BCF    5F.0
0BF4:  BCF    5F.1
0BF5:  BCF    5F.2
0BF6:  BCF    5F.3
0BF7:  BSF    03.5
0BF8:  BSF    03.6
0BF9:  MOVF   09,W
0BFA:  ANDLW  C0
0BFB:  MOVWF  09
0BFC:  BCF    03.6
0BFD:  BCF    1F.4
0BFE:  BCF    1F.5
0BFF:  MOVLW  00
0C00:  BSF    03.6
0C01:  MOVWF  08
0C02:  BCF    03.5
0C03:  CLRF   07
0C04:  CLRF   08
0C05:  CLRF   09
0C06:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0CE4:  MOVLW  00
0CE5:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0CE6:  MOVLW  FF
0CE7:  MOVWF  06
....................     SET_TRIS_E (0); 
0CE8:  BCF    09.0
0CE9:  BCF    09.1
0CEA:  BCF    09.2
0CEB:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0CEC:  MOVLW  80
0CED:  MOVWF  07
0CEE:  BCF    03.5
0CEF:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0CF0:  BSF    1F.6
0CF1:  BCF    1F.7
0CF2:  BSF    03.5
0CF3:  BSF    1F.7
0CF4:  BCF    03.5
0CF5:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0CF6:  BSF    03.5
0CF7:  BSF    03.6
0CF8:  MOVF   09,W
0CF9:  ANDLW  C0
0CFA:  MOVWF  09
0CFB:  BCF    03.6
0CFC:  BCF    1F.4
0CFD:  BCF    1F.5
0CFE:  MOVLW  01
0CFF:  BSF    03.6
0D00:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0D01:  BCF    03.5
0D02:  BCF    03.6
0D03:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0D04:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0D05:  BSF    0B.4
0D06:  BSF    03.5
0D07:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0D08:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0D09:  MOVLW  C0
0D0A:  BCF    03.5
0D0B:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8) ; 
0D0C:  MOVLW  35
0D0D:  MOVWF  10
....................     //SET_TIMER1 (0) ; 
....................     SET_TIMER1 (3036) ; 
0D0E:  CLRF   0E
0D0F:  MOVLW  0B
0D10:  MOVWF  0F
0D11:  MOVLW  DC
0D12:  MOVWF  0E
....................     TMR1IF = 0; 
0D13:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0D14:  BCF    0A.3
0D15:  GOTO   1E5
0D16:  BSF    0A.3
....................     ID_NODE = 0; 
0D17:  CLRF   39
....................     TT_CONFIG = 0; 
0D18:  BCF    5F.0
....................     TT_CONFIG_DONE = 0; 
0D19:  BCF    5F.1
....................     OUTPUT_D (0X00); 
0D1A:  BSF    03.5
0D1B:  CLRF   08
0D1C:  BCF    03.5
0D1D:  CLRF   08
....................     TTNHAN = 0; 
0D1E:  CLRF   5B
....................               
....................                 
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        AN0 = ADC_READ (0) ; 
0D1F:  BSF    03.6
0D20:  CLRF   35
0D21:  BCF    0A.3
0D22:  BCF    03.6
0D23:  GOTO   24B
0D24:  BSF    0A.3
0D25:  CLRF   35
0D26:  MOVF   78,W
0D27:  MOVWF  34
....................  
....................        IF (TT_CONFIG) 
0D28:  BTFSS  5F.0
0D29:  GOTO   52E
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0D2A:  BCF    0A.3
0D2B:  GOTO   631
0D2C:  BSF    0A.3
....................        } 
0D2D:  GOTO   530
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0D2E:  BTFSC  5F.1
....................        { 
....................           CONFIG_DONE () ; 
0D2F:  GOTO   28B
....................        } 
....................  
....................        CHUONG_TRINH_CON (); 
0D30:  BCF    0A.3
0D31:  GOTO   6EE
0D32:  BSF    0A.3
....................  
....................        IF (AN0 > 26) 
0D33:  MOVF   35,F
0D34:  BTFSS  03.2
0D35:  GOTO   53A
0D36:  MOVF   34,W
0D37:  SUBLW  1A
0D38:  BTFSC  03.0
0D39:  GOTO   597
....................        { 
....................           ITOA (AN0, 10, NHIETDO1); 
0D3A:  BSF    03.6
0D3B:  CLRF   3A
0D3C:  CLRF   39
0D3D:  BCF    03.6
0D3E:  MOVF   35,W
0D3F:  BSF    03.6
0D40:  MOVWF  38
0D41:  BCF    03.6
0D42:  MOVF   34,W
0D43:  BSF    03.6
0D44:  MOVWF  37
0D45:  MOVLW  0A
0D46:  MOVWF  3B
0D47:  CLRF   3D
0D48:  MOVLW  7B
0D49:  MOVWF  3C
0D4A:  BCF    0A.3
0D4B:  BCF    03.6
0D4C:  CALL   4B9
0D4D:  BSF    0A.3
....................           PACKAGE[4] = NHIETDO1; 
0D4E:  CLRF   6F
0D4F:  MOVLW  7B
0D50:  MOVWF  6E
....................           ITOA (AN1, 10, NHIETDO2); 
0D51:  BSF    03.6
0D52:  CLRF   3A
0D53:  CLRF   39
0D54:  BCF    03.6
0D55:  MOVF   37,W
0D56:  BSF    03.6
0D57:  MOVWF  38
0D58:  BCF    03.6
0D59:  MOVF   36,W
0D5A:  BSF    03.6
0D5B:  MOVWF  37
0D5C:  MOVLW  0A
0D5D:  MOVWF  3B
0D5E:  CLRF   3D
0D5F:  MOVLW  D7
0D60:  MOVWF  3C
0D61:  BCF    0A.3
0D62:  BCF    03.6
0D63:  CALL   4B9
0D64:  BSF    0A.3
....................           PACKAGE[5] = NHIETDO2; 
0D65:  CLRF   71
0D66:  MOVLW  D7
0D67:  MOVWF  70
....................            
....................           FOR (INT I = 0; I < 8; I++) 
0D68:  BSF    03.6
0D69:  CLRF   34
0D6A:  MOVF   34,W
0D6B:  SUBLW  07
0D6C:  BTFSS  03.0
0D6D:  GOTO   58B
....................           { 
....................              PRINTF (PACKAGE[I]); 
0D6E:  BCF    03.0
0D6F:  RLF    34,W
0D70:  ADDLW  66
0D71:  MOVWF  04
0D72:  BCF    03.7
0D73:  INCF   04,F
0D74:  MOVF   00,W
0D75:  MOVWF  36
0D76:  DECF   04,F
0D77:  MOVF   00,W
0D78:  MOVWF  35
0D79:  MOVWF  04
0D7A:  BCF    03.7
0D7B:  BTFSC  36.0
0D7C:  BSF    03.7
0D7D:  BCF    0A.3
0D7E:  BCF    03.6
0D7F:  CALL   6D0
0D80:  BSF    0A.3
....................              DELAY_MS (1); 
0D81:  MOVLW  01
0D82:  BSF    03.6
0D83:  MOVWF  3A
0D84:  BCF    0A.3
0D85:  BCF    03.6
0D86:  CALL   0CB
0D87:  BSF    0A.3
0D88:  BSF    03.6
0D89:  INCF   34,F
0D8A:  GOTO   56A
....................           } 
....................  
....................           DELAY_MS (1000); 
0D8B:  MOVLW  04
0D8C:  MOVWF  35
0D8D:  MOVLW  FA
0D8E:  MOVWF  3A
0D8F:  BCF    0A.3
0D90:  BCF    03.6
0D91:  CALL   0CB
0D92:  BSF    0A.3
0D93:  BSF    03.6
0D94:  DECFSZ 35,F
0D95:  GOTO   58D
0D96:  BCF    03.6
....................        } 
....................  
....................        IF (TTNHAN == 1) 
0D97:  DECFSZ 5B,W
0D98:  GOTO   5C8
....................        { 
....................            
....................           TTNHAN = 0; 
0D99:  CLRF   5B
....................           //TEMP_CHAR = 'K'; 
....................           ID_NODE_NHAN = KYTU[1]-48; 
0D9A:  MOVLW  30
0D9B:  SUBWF  3D,W
0D9C:  MOVWF  5C
....................           ID_DEVICE_NHAN =KYTU[2]-48 + 64; 
0D9D:  MOVLW  30
0D9E:  SUBWF  3E,W
0D9F:  ADDLW  40
0DA0:  MOVWF  5D
....................           TT_DEVICE_NHAN = KYTU[3]-48;// -48 ASCII --> S?. +64 -->PORT_D (D0=64) 
0DA1:  MOVLW  30
0DA2:  SUBWF  3F,W
0DA3:  MOVWF  5E
....................           XUATLCD ();                 
0DA4:  BCF    0A.3
0DA5:  GOTO   706
0DA6:  BSF    0A.3
....................           IF(ID_NODE_NHAN == ID_NODE) 
0DA7:  MOVF   39,W
0DA8:  SUBWF  5C,W
0DA9:  BTFSS  03.2
0DAA:  GOTO   5C8
....................           { 
....................                OUTPUT_BIT (ID_DEVICE_NHAN,TT_DEVICE_NHAN);  
0DAB:  MOVF   5E,F
0DAC:  BTFSS  03.2
0DAD:  GOTO   5B0
0DAE:  MOVLW  00
0DAF:  GOTO   5B1
0DB0:  MOVLW  01
0DB1:  MOVWF  77
0DB2:  MOVF   5D,W
0DB3:  BSF    03.6
0DB4:  MOVWF  36
0DB5:  MOVF   77,W
0DB6:  MOVWF  37
0DB7:  CLRF   39
0DB8:  CLRF   38
0DB9:  BCF    0A.3
0DBA:  BCF    03.6
0DBB:  CALL   60F
0DBC:  BSF    0A.3
0DBD:  MOVF   5D,W
0DBE:  BSF    03.6
0DBF:  MOVWF  36
0DC0:  CLRF   37
0DC1:  CLRF   39
0DC2:  MOVLW  80
0DC3:  MOVWF  38
0DC4:  BCF    0A.3
0DC5:  BCF    03.6
0DC6:  CALL   60F
0DC7:  BSF    0A.3
....................           } 
....................  
....................        } 
0DC8:  GOTO   51F
....................     } 
....................  } 
....................  
0DC9:  SLEEP
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
